
(function(l, r) { if (!l || l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (self.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(self.document);
var app = (function () {
    'use strict';

    function noop$2() { }
    const identity$3 = x => x;
    function assign$1(tar, src) {
        // @ts-ignore
        for (const k in src)
            tar[k] = src[k];
        return tar;
    }
    function add_location(element, file, line, column, char) {
        element.__svelte_meta = {
            loc: { file, line, column, char }
        };
    }
    function run(fn) {
        return fn();
    }
    function blank_object() {
        return Object.create(null);
    }
    function run_all(fns) {
        fns.forEach(run);
    }
    function is_function(thing) {
        return typeof thing === 'function';
    }
    function safe_not_equal(a, b) {
        return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');
    }
    function is_empty(obj) {
        return Object.keys(obj).length === 0;
    }
    function validate_store(store, name) {
        if (store != null && typeof store.subscribe !== 'function') {
            throw new Error(`'${name}' is not a store with a 'subscribe' method`);
        }
    }
    function subscribe(store, ...callbacks) {
        if (store == null) {
            return noop$2;
        }
        const unsub = store.subscribe(...callbacks);
        return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
    }
    function component_subscribe(component, store, callback) {
        component.$$.on_destroy.push(subscribe(store, callback));
    }
    function create_slot(definition, ctx, $$scope, fn) {
        if (definition) {
            const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
            return definition[0](slot_ctx);
        }
    }
    function get_slot_context(definition, ctx, $$scope, fn) {
        return definition[1] && fn
            ? assign$1($$scope.ctx.slice(), definition[1](fn(ctx)))
            : $$scope.ctx;
    }
    function get_slot_changes(definition, $$scope, dirty, fn) {
        if (definition[2] && fn) {
            const lets = definition[2](fn(dirty));
            if ($$scope.dirty === undefined) {
                return lets;
            }
            if (typeof lets === 'object') {
                const merged = [];
                const len = Math.max($$scope.dirty.length, lets.length);
                for (let i = 0; i < len; i += 1) {
                    merged[i] = $$scope.dirty[i] | lets[i];
                }
                return merged;
            }
            return $$scope.dirty | lets;
        }
        return $$scope.dirty;
    }
    function update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {
        if (slot_changes) {
            const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
            slot.p(slot_context, slot_changes);
        }
    }
    function get_all_dirty_from_scope($$scope) {
        if ($$scope.ctx.length > 32) {
            const dirty = [];
            const length = $$scope.ctx.length / 32;
            for (let i = 0; i < length; i++) {
                dirty[i] = -1;
            }
            return dirty;
        }
        return -1;
    }
    function exclude_internal_props(props) {
        const result = {};
        for (const k in props)
            if (k[0] !== '$')
                result[k] = props[k];
        return result;
    }
    function compute_rest_props(props, keys) {
        const rest = {};
        keys = new Set(keys);
        for (const k in props)
            if (!keys.has(k) && k[0] !== '$')
                rest[k] = props[k];
        return rest;
    }
    function null_to_empty(value) {
        return value == null ? '' : value;
    }
    function set_store_value(store, ret, value) {
        store.set(value);
        return ret;
    }
    function action_destroyer(action_result) {
        return action_result && is_function(action_result.destroy) ? action_result.destroy : noop$2;
    }

    const is_client = typeof window !== 'undefined';
    let now$3 = is_client
        ? () => window.performance.now()
        : () => Date.now();
    let raf$1 = is_client ? cb => requestAnimationFrame(cb) : noop$2;

    const tasks = new Set();
    function run_tasks(now) {
        tasks.forEach(task => {
            if (!task.c(now)) {
                tasks.delete(task);
                task.f();
            }
        });
        if (tasks.size !== 0)
            raf$1(run_tasks);
    }
    /**
     * Creates a new task that runs on each raf frame
     * until it returns a falsy value or is aborted
     */
    function loop(callback) {
        let task;
        if (tasks.size === 0)
            raf$1(run_tasks);
        return {
            promise: new Promise(fulfill => {
                tasks.add(task = { c: callback, f: fulfill });
            }),
            abort() {
                tasks.delete(task);
            }
        };
    }
    function append$1(target, node) {
        target.appendChild(node);
    }
    function get_root_for_style(node) {
        if (!node)
            return document;
        const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;
        if (root && root.host) {
            return root;
        }
        return node.ownerDocument;
    }
    function append_empty_stylesheet(node) {
        const style_element = element('style');
        append_stylesheet(get_root_for_style(node), style_element);
        return style_element.sheet;
    }
    function append_stylesheet(node, style) {
        append$1(node.head || node, style);
        return style.sheet;
    }
    function insert(target, node, anchor) {
        target.insertBefore(node, anchor || null);
    }
    function detach(node) {
        if (node.parentNode) {
            node.parentNode.removeChild(node);
        }
    }
    function destroy_each(iterations, detaching) {
        for (let i = 0; i < iterations.length; i += 1) {
            if (iterations[i])
                iterations[i].d(detaching);
        }
    }
    function element(name) {
        return document.createElement(name);
    }
    function svg_element(name) {
        return document.createElementNS('http://www.w3.org/2000/svg', name);
    }
    function text(data) {
        return document.createTextNode(data);
    }
    function space() {
        return text(' ');
    }
    function empty$1() {
        return text('');
    }
    function listen(node, event, handler, options) {
        node.addEventListener(event, handler, options);
        return () => node.removeEventListener(event, handler, options);
    }
    function attr(node, attribute, value) {
        if (value == null)
            node.removeAttribute(attribute);
        else if (node.getAttribute(attribute) !== value)
            node.setAttribute(attribute, value);
    }
    function set_attributes(node, attributes) {
        // @ts-ignore
        const descriptors = Object.getOwnPropertyDescriptors(node.__proto__);
        for (const key in attributes) {
            if (attributes[key] == null) {
                node.removeAttribute(key);
            }
            else if (key === 'style') {
                node.style.cssText = attributes[key];
            }
            else if (key === '__value') {
                node.value = node[key] = attributes[key];
            }
            else if (descriptors[key] && descriptors[key].set) {
                node[key] = attributes[key];
            }
            else {
                attr(node, key, attributes[key]);
            }
        }
    }
    function children$1(element) {
        return Array.from(element.childNodes);
    }
    function set_style(node, key, value, important) {
        if (value === null) {
            node.style.removeProperty(key);
        }
        else {
            node.style.setProperty(key, value, important ? 'important' : '');
        }
    }
    function custom_event(type, detail, { bubbles = false, cancelable = false } = {}) {
        const e = document.createEvent('CustomEvent');
        e.initCustomEvent(type, bubbles, cancelable, detail);
        return e;
    }

    // we need to store the information for multiple documents because a Svelte application could also contain iframes
    // https://github.com/sveltejs/svelte/issues/3624
    const managed_styles = new Map();
    let active = 0;
    // https://github.com/darkskyapp/string-hash/blob/master/index.js
    function hash$2(str) {
        let hash = 5381;
        let i = str.length;
        while (i--)
            hash = ((hash << 5) - hash) ^ str.charCodeAt(i);
        return hash >>> 0;
    }
    function create_style_information(doc, node) {
        const info = { stylesheet: append_empty_stylesheet(node), rules: {} };
        managed_styles.set(doc, info);
        return info;
    }
    function create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {
        const step = 16.666 / duration;
        let keyframes = '{\n';
        for (let p = 0; p <= 1; p += step) {
            const t = a + (b - a) * ease(p);
            keyframes += p * 100 + `%{${fn(t, 1 - t)}}\n`;
        }
        const rule = keyframes + `100% {${fn(b, 1 - b)}}\n}`;
        const name = `__svelte_${hash$2(rule)}_${uid}`;
        const doc = get_root_for_style(node);
        const { stylesheet, rules } = managed_styles.get(doc) || create_style_information(doc, node);
        if (!rules[name]) {
            rules[name] = true;
            stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);
        }
        const animation = node.style.animation || '';
        node.style.animation = `${animation ? `${animation}, ` : ''}${name} ${duration}ms linear ${delay}ms 1 both`;
        active += 1;
        return name;
    }
    function delete_rule(node, name) {
        const previous = (node.style.animation || '').split(', ');
        const next = previous.filter(name
            ? anim => anim.indexOf(name) < 0 // remove specific animation
            : anim => anim.indexOf('__svelte') === -1 // remove all Svelte animations
        );
        const deleted = previous.length - next.length;
        if (deleted) {
            node.style.animation = next.join(', ');
            active -= deleted;
            if (!active)
                clear_rules();
        }
    }
    function clear_rules() {
        raf$1(() => {
            if (active)
                return;
            managed_styles.forEach(info => {
                const { ownerNode } = info.stylesheet;
                // there is no ownerNode if it runs on jsdom.
                if (ownerNode)
                    detach(ownerNode);
            });
            managed_styles.clear();
        });
    }

    let current_component;
    function set_current_component(component) {
        current_component = component;
    }
    function get_current_component() {
        if (!current_component)
            throw new Error('Function called outside component initialization');
        return current_component;
    }
    /**
     * The `onMount` function schedules a callback to run as soon as the component has been mounted to the DOM.
     * It must be called during the component's initialisation (but doesn't need to live *inside* the component;
     * it can be called from an external module).
     *
     * `onMount` does not run inside a [server-side component](/docs#run-time-server-side-component-api).
     *
     * https://svelte.dev/docs#run-time-svelte-onmount
     */
    function onMount(fn) {
        get_current_component().$$.on_mount.push(fn);
    }
    /**
     * Schedules a callback to run immediately after the component has been updated.
     *
     * The first time the callback runs will be after the initial `onMount`
     */
    function afterUpdate(fn) {
        get_current_component().$$.after_update.push(fn);
    }
    /**
     * Schedules a callback to run immediately before the component is unmounted.
     *
     * Out of `onMount`, `beforeUpdate`, `afterUpdate` and `onDestroy`, this is the
     * only one that runs inside a server-side component.
     *
     * https://svelte.dev/docs#run-time-svelte-ondestroy
     */
    function onDestroy(fn) {
        get_current_component().$$.on_destroy.push(fn);
    }
    /**
     * Creates an event dispatcher that can be used to dispatch [component events](/docs#template-syntax-component-directives-on-eventname).
     * Event dispatchers are functions that can take two arguments: `name` and `detail`.
     *
     * Component events created with `createEventDispatcher` create a
     * [CustomEvent](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent).
     * These events do not [bubble](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/Events#Event_bubbling_and_capture).
     * The `detail` argument corresponds to the [CustomEvent.detail](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/detail)
     * property and can contain any type of data.
     *
     * https://svelte.dev/docs#run-time-svelte-createeventdispatcher
     */
    function createEventDispatcher() {
        const component = get_current_component();
        return (type, detail, { cancelable = false } = {}) => {
            const callbacks = component.$$.callbacks[type];
            if (callbacks) {
                // TODO are there situations where events could be dispatched
                // in a server (non-DOM) environment?
                const event = custom_event(type, detail, { cancelable });
                callbacks.slice().forEach(fn => {
                    fn.call(component, event);
                });
                return !event.defaultPrevented;
            }
            return true;
        };
    }

    const dirty_components = [];
    const binding_callbacks = [];
    const render_callbacks = [];
    const flush_callbacks = [];
    const resolved_promise = Promise.resolve();
    let update_scheduled = false;
    function schedule_update() {
        if (!update_scheduled) {
            update_scheduled = true;
            resolved_promise.then(flush);
        }
    }
    function add_render_callback(fn) {
        render_callbacks.push(fn);
    }
    // flush() calls callbacks in this order:
    // 1. All beforeUpdate callbacks, in order: parents before children
    // 2. All bind:this callbacks, in reverse order: children before parents.
    // 3. All afterUpdate callbacks, in order: parents before children. EXCEPT
    //    for afterUpdates called during the initial onMount, which are called in
    //    reverse order: children before parents.
    // Since callbacks might update component values, which could trigger another
    // call to flush(), the following steps guard against this:
    // 1. During beforeUpdate, any updated components will be added to the
    //    dirty_components array and will cause a reentrant call to flush(). Because
    //    the flush index is kept outside the function, the reentrant call will pick
    //    up where the earlier call left off and go through all dirty components. The
    //    current_component value is saved and restored so that the reentrant call will
    //    not interfere with the "parent" flush() call.
    // 2. bind:this callbacks cannot trigger new flush() calls.
    // 3. During afterUpdate, any updated components will NOT have their afterUpdate
    //    callback called a second time; the seen_callbacks set, outside the flush()
    //    function, guarantees this behavior.
    const seen_callbacks = new Set();
    let flushidx = 0; // Do *not* move this inside the flush() function
    function flush() {
        const saved_component = current_component;
        do {
            // first, call beforeUpdate functions
            // and update components
            while (flushidx < dirty_components.length) {
                const component = dirty_components[flushidx];
                flushidx++;
                set_current_component(component);
                update$1(component.$$);
            }
            set_current_component(null);
            dirty_components.length = 0;
            flushidx = 0;
            while (binding_callbacks.length)
                binding_callbacks.pop()();
            // then, once components are updated, call
            // afterUpdate functions. This may cause
            // subsequent updates...
            for (let i = 0; i < render_callbacks.length; i += 1) {
                const callback = render_callbacks[i];
                if (!seen_callbacks.has(callback)) {
                    // ...so guard against infinite loops
                    seen_callbacks.add(callback);
                    callback();
                }
            }
            render_callbacks.length = 0;
        } while (dirty_components.length);
        while (flush_callbacks.length) {
            flush_callbacks.pop()();
        }
        update_scheduled = false;
        seen_callbacks.clear();
        set_current_component(saved_component);
    }
    function update$1($$) {
        if ($$.fragment !== null) {
            $$.update();
            run_all($$.before_update);
            const dirty = $$.dirty;
            $$.dirty = [-1];
            $$.fragment && $$.fragment.p($$.ctx, dirty);
            $$.after_update.forEach(add_render_callback);
        }
    }

    let promise;
    function wait() {
        if (!promise) {
            promise = Promise.resolve();
            promise.then(() => {
                promise = null;
            });
        }
        return promise;
    }
    function dispatch(node, direction, kind) {
        node.dispatchEvent(custom_event(`${direction ? 'intro' : 'outro'}${kind}`));
    }
    const outroing = new Set();
    let outros;
    function group_outros() {
        outros = {
            r: 0,
            c: [],
            p: outros // parent group
        };
    }
    function check_outros() {
        if (!outros.r) {
            run_all(outros.c);
        }
        outros = outros.p;
    }
    function transition_in(block, local) {
        if (block && block.i) {
            outroing.delete(block);
            block.i(local);
        }
    }
    function transition_out(block, local, detach, callback) {
        if (block && block.o) {
            if (outroing.has(block))
                return;
            outroing.add(block);
            outros.c.push(() => {
                outroing.delete(block);
                if (callback) {
                    if (detach)
                        block.d(1);
                    callback();
                }
            });
            block.o(local);
        }
        else if (callback) {
            callback();
        }
    }
    const null_transition = { duration: 0 };
    function create_in_transition(node, fn, params) {
        let config = fn(node, params);
        let running = false;
        let animation_name;
        let task;
        let uid = 0;
        function cleanup() {
            if (animation_name)
                delete_rule(node, animation_name);
        }
        function go() {
            const { delay = 0, duration = 300, easing = identity$3, tick = noop$2, css } = config || null_transition;
            if (css)
                animation_name = create_rule(node, 0, 1, duration, delay, easing, css, uid++);
            tick(0, 1);
            const start_time = now$3() + delay;
            const end_time = start_time + duration;
            if (task)
                task.abort();
            running = true;
            add_render_callback(() => dispatch(node, true, 'start'));
            task = loop(now => {
                if (running) {
                    if (now >= end_time) {
                        tick(1, 0);
                        dispatch(node, true, 'end');
                        cleanup();
                        return running = false;
                    }
                    if (now >= start_time) {
                        const t = easing((now - start_time) / duration);
                        tick(t, 1 - t);
                    }
                }
                return running;
            });
        }
        let started = false;
        return {
            start() {
                if (started)
                    return;
                started = true;
                delete_rule(node);
                if (is_function(config)) {
                    config = config();
                    wait().then(go);
                }
                else {
                    go();
                }
            },
            invalidate() {
                started = false;
            },
            end() {
                if (running) {
                    cleanup();
                    running = false;
                }
            }
        };
    }

    const globals = (typeof window !== 'undefined'
        ? window
        : typeof globalThis !== 'undefined'
            ? globalThis
            : global);

    function get_spread_update(levels, updates) {
        const update = {};
        const to_null_out = {};
        const accounted_for = { $$scope: 1 };
        let i = levels.length;
        while (i--) {
            const o = levels[i];
            const n = updates[i];
            if (n) {
                for (const key in o) {
                    if (!(key in n))
                        to_null_out[key] = 1;
                }
                for (const key in n) {
                    if (!accounted_for[key]) {
                        update[key] = n[key];
                        accounted_for[key] = 1;
                    }
                }
                levels[i] = n;
            }
            else {
                for (const key in o) {
                    accounted_for[key] = 1;
                }
            }
        }
        for (const key in to_null_out) {
            if (!(key in update))
                update[key] = undefined;
        }
        return update;
    }
    function create_component(block) {
        block && block.c();
    }
    function mount_component(component, target, anchor, customElement) {
        const { fragment, after_update } = component.$$;
        fragment && fragment.m(target, anchor);
        if (!customElement) {
            // onMount happens before the initial afterUpdate
            add_render_callback(() => {
                const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);
                // if the component was destroyed immediately
                // it will update the `$$.on_destroy` reference to `null`.
                // the destructured on_destroy may still reference to the old array
                if (component.$$.on_destroy) {
                    component.$$.on_destroy.push(...new_on_destroy);
                }
                else {
                    // Edge case - component was destroyed immediately,
                    // most likely as a result of a binding initialising
                    run_all(new_on_destroy);
                }
                component.$$.on_mount = [];
            });
        }
        after_update.forEach(add_render_callback);
    }
    function destroy_component(component, detaching) {
        const $$ = component.$$;
        if ($$.fragment !== null) {
            run_all($$.on_destroy);
            $$.fragment && $$.fragment.d(detaching);
            // TODO null out other refs, including component.$$ (but need to
            // preserve final state?)
            $$.on_destroy = $$.fragment = null;
            $$.ctx = [];
        }
    }
    function make_dirty(component, i) {
        if (component.$$.dirty[0] === -1) {
            dirty_components.push(component);
            schedule_update();
            component.$$.dirty.fill(0);
        }
        component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));
    }
    function init(component, options, instance, create_fragment, not_equal, props, append_styles, dirty = [-1]) {
        const parent_component = current_component;
        set_current_component(component);
        const $$ = component.$$ = {
            fragment: null,
            ctx: [],
            // state
            props,
            update: noop$2,
            not_equal,
            bound: blank_object(),
            // lifecycle
            on_mount: [],
            on_destroy: [],
            on_disconnect: [],
            before_update: [],
            after_update: [],
            context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
            // everything else
            callbacks: blank_object(),
            dirty,
            skip_bound: false,
            root: options.target || parent_component.$$.root
        };
        append_styles && append_styles($$.root);
        let ready = false;
        $$.ctx = instance
            ? instance(component, options.props || {}, (i, ret, ...rest) => {
                const value = rest.length ? rest[0] : ret;
                if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
                    if (!$$.skip_bound && $$.bound[i])
                        $$.bound[i](value);
                    if (ready)
                        make_dirty(component, i);
                }
                return ret;
            })
            : [];
        $$.update();
        ready = true;
        run_all($$.before_update);
        // `false` as a special case of no DOM component
        $$.fragment = create_fragment ? create_fragment($$.ctx) : false;
        if (options.target) {
            if (options.hydrate) {
                const nodes = children$1(options.target);
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment && $$.fragment.l(nodes);
                nodes.forEach(detach);
            }
            else {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment && $$.fragment.c();
            }
            if (options.intro)
                transition_in(component.$$.fragment);
            mount_component(component, options.target, options.anchor, options.customElement);
            flush();
        }
        set_current_component(parent_component);
    }
    /**
     * Base class for Svelte components. Used when dev=false.
     */
    class SvelteComponent {
        $destroy() {
            destroy_component(this, 1);
            this.$destroy = noop$2;
        }
        $on(type, callback) {
            if (!is_function(callback)) {
                return noop$2;
            }
            const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));
            callbacks.push(callback);
            return () => {
                const index = callbacks.indexOf(callback);
                if (index !== -1)
                    callbacks.splice(index, 1);
            };
        }
        $set($$props) {
            if (this.$$set && !is_empty($$props)) {
                this.$$.skip_bound = true;
                this.$$set($$props);
                this.$$.skip_bound = false;
            }
        }
    }

    function dispatch_dev(type, detail) {
        document.dispatchEvent(custom_event(type, Object.assign({ version: '3.53.1' }, detail), { bubbles: true }));
    }
    function append_dev(target, node) {
        dispatch_dev('SvelteDOMInsert', { target, node });
        append$1(target, node);
    }
    function insert_dev(target, node, anchor) {
        dispatch_dev('SvelteDOMInsert', { target, node, anchor });
        insert(target, node, anchor);
    }
    function detach_dev(node) {
        dispatch_dev('SvelteDOMRemove', { node });
        detach(node);
    }
    function listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation) {
        const modifiers = options === true ? ['capture'] : options ? Array.from(Object.keys(options)) : [];
        if (has_prevent_default)
            modifiers.push('preventDefault');
        if (has_stop_propagation)
            modifiers.push('stopPropagation');
        dispatch_dev('SvelteDOMAddEventListener', { node, event, handler, modifiers });
        const dispose = listen(node, event, handler, options);
        return () => {
            dispatch_dev('SvelteDOMRemoveEventListener', { node, event, handler, modifiers });
            dispose();
        };
    }
    function attr_dev(node, attribute, value) {
        attr(node, attribute, value);
        if (value == null)
            dispatch_dev('SvelteDOMRemoveAttribute', { node, attribute });
        else
            dispatch_dev('SvelteDOMSetAttribute', { node, attribute, value });
    }
    function prop_dev(node, property, value) {
        node[property] = value;
        dispatch_dev('SvelteDOMSetProperty', { node, property, value });
    }
    function set_data_dev(text, data) {
        data = '' + data;
        if (text.wholeText === data)
            return;
        dispatch_dev('SvelteDOMSetData', { node: text, data });
        text.data = data;
    }
    function validate_each_argument(arg) {
        if (typeof arg !== 'string' && !(arg && typeof arg === 'object' && 'length' in arg)) {
            let msg = '{#each} only iterates over array-like objects.';
            if (typeof Symbol === 'function' && arg && Symbol.iterator in arg) {
                msg += ' You can use a spread to convert this iterable into an array.';
            }
            throw new Error(msg);
        }
    }
    function validate_slots(name, slot, keys) {
        for (const slot_key of Object.keys(slot)) {
            if (!~keys.indexOf(slot_key)) {
                console.warn(`<${name}> received an unexpected slot "${slot_key}".`);
            }
        }
    }
    /**
     * Base class for Svelte components with some minor dev-enhancements. Used when dev=true.
     */
    class SvelteComponentDev extends SvelteComponent {
        constructor(options) {
            if (!options || (!options.target && !options.$$inline)) {
                throw new Error("'target' is a required option");
            }
            super();
        }
        $destroy() {
            super.$destroy();
            this.$destroy = () => {
                console.warn('Component was already destroyed'); // eslint-disable-line no-console
            };
        }
        $capture_state() { }
        $inject_state() { }
    }

    const subscriber_queue = [];
    /**
     * Creates a `Readable` store that allows reading by subscription.
     * @param value initial value
     * @param {StartStopNotifier}start start and stop notifications for subscriptions
     */
    function readable(value, start) {
        return {
            subscribe: writable(value, start).subscribe
        };
    }
    /**
     * Create a `Writable` store that allows both updating and reading by subscription.
     * @param {*=}value initial value
     * @param {StartStopNotifier=}start start and stop notifications for subscriptions
     */
    function writable(value, start = noop$2) {
        let stop;
        const subscribers = new Set();
        function set(new_value) {
            if (safe_not_equal(value, new_value)) {
                value = new_value;
                if (stop) { // store is ready
                    const run_queue = !subscriber_queue.length;
                    for (const subscriber of subscribers) {
                        subscriber[1]();
                        subscriber_queue.push(subscriber, value);
                    }
                    if (run_queue) {
                        for (let i = 0; i < subscriber_queue.length; i += 2) {
                            subscriber_queue[i][0](subscriber_queue[i + 1]);
                        }
                        subscriber_queue.length = 0;
                    }
                }
            }
        }
        function update(fn) {
            set(fn(value));
        }
        function subscribe(run, invalidate = noop$2) {
            const subscriber = [run, invalidate];
            subscribers.add(subscriber);
            if (subscribers.size === 1) {
                stop = start(set) || noop$2;
            }
            run(value);
            return () => {
                subscribers.delete(subscriber);
                if (subscribers.size === 0) {
                    stop();
                    stop = null;
                }
            };
        }
        return { set, update, subscribe };
    }
    function derived(stores, fn, initial_value) {
        const single = !Array.isArray(stores);
        const stores_array = single
            ? [stores]
            : stores;
        const auto = fn.length < 2;
        return readable(initial_value, (set) => {
            let inited = false;
            const values = [];
            let pending = 0;
            let cleanup = noop$2;
            const sync = () => {
                if (pending) {
                    return;
                }
                cleanup();
                const result = fn(single ? values[0] : values, set);
                if (auto) {
                    set(result);
                }
                else {
                    cleanup = is_function(result) ? result : noop$2;
                }
            };
            const unsubscribers = stores_array.map((store, i) => subscribe(store, (value) => {
                values[i] = value;
                pending &= ~(1 << i);
                if (inited) {
                    sync();
                }
            }, () => {
                pending |= (1 << i);
            }));
            inited = true;
            sync();
            return function stop() {
                run_all(unsubscribers);
                cleanup();
            };
        });
    }

    var dataSource = [
    	{
    		feature_id: 203,
    		year: 1979,
    		feature: "Regio",
    		feature_plural: "Regiones",
    		name: "Alpha Regio",
    		type: "Other",
    		origin: "Greek",
    		continent: "Europe",
    		clean_name: "Alpha ",
    		description: "First letter in Greek alphabet.",
    		bio: "Maxwell Montes, Alpha Regio, and Beta Regio are the three exceptions to the rule that the surface features of Venus are to be named for females: women or goddesses.",
    		search_term: "Alpha Regio",
    		diameter: "1,897.0",
    		center_lat: -25.5,
    		center_long: 0.3
    	},
    	{
    		feature_id: 721,
    		year: 1979,
    		feature: "Regio",
    		feature_plural: "Regiones",
    		name: "Beta Regio",
    		type: "Other",
    		origin: "Greek",
    		continent: "Europe",
    		clean_name: "Beta ",
    		description: "Second letter in Greek alphabet.",
    		bio: "Maxwell Montes, Alpha Regio, and Beta Regio are the three exceptions to the rule that the surface features of Venus are to be named for females: women or goddesses.",
    		search_term: "Beta Regio",
    		diameter: "2,869.0",
    		center_lat: 25.3,
    		center_long: 282.8
    	},
    	{
    		feature_id: 3766,
    		year: 1979,
    		feature: "Mons",
    		feature_plural: "Montes",
    		name: "Maxwell Montes",
    		type: "Other",
    		origin: "Great Britain",
    		continent: "Europe",
    		clean_name: "Maxwell ",
    		description: "James C.; British physicist (1831-1879).",
    		bio: "Maxwell Montes is named for James Clerk Maxwell whose work in mathematical physics predicted the existence of radio waves, which made radar, and thus the surface observations of Venus, possible. Maxwell Montes, Alpha Regio, and Beta Regio are the three exceptions to the rule that the surface features of Venus are to be named for females.",
    		search_term: "Maxwell Montes",
    		diameter: "797.0",
    		center_lat: 65.2,
    		center_long: 3.3
    	},
    	{
    		feature_id: 2384,
    		year: 1979,
    		feature: "Mons",
    		feature_plural: "Montes",
    		name: "Hathor Mons",
    		type: "Goddess",
    		origin: "Egypt",
    		continent: "Africa",
    		clean_name: "Hathor",
    		description: "Egyptian sky goddess.",
    		bio: "Hathor was a major goddess in ancient Egyptian religion who played a wide variety of roles. As a sky deity, she was the mother or consort of the sky god Horus and the sun god Ra, both of whom were connected with kingship, and thus she was the symbolic mother of their earthly representatives, the pharaohs. She was one of several goddesses who acted as the Eye of Ra, Ra's feminine counterpart, and in this form she had a vengeful aspect that protected him from his enemies.",
    		search_term: "Hathor",
    		diameter: "333.0",
    		center_lat: -38.7,
    		center_long: 324.7
    	},
    	{
    		feature_id: 2733,
    		year: 1979,
    		feature: "Terra",
    		feature_plural: "Terrae",
    		name: "Ishtar Terra",
    		type: "Goddess",
    		origin: "Babylon",
    		continent: "Asia",
    		clean_name: "Ishtar",
    		description: "Babylonian goddess of love.",
    		bio: "Inanna is an ancient Mesopotamian goddess of love, war, and fertility. She is also associated with beauty, sex, divine justice, and political power. She was originally worshiped in Sumer under the name \"Inanna\", and later by the Akkadians, Babylonians, and Assyrians under the name Ishtar (occasionally represented by the logogram 𒌋𒁯). She was associated with the planet Venus and her most prominent symbols included the lion and the eight-pointed star.",
    		search_term: "Ishtar",
    		diameter: "5,610.0",
    		center_lat: 70.4,
    		center_long: 27.5
    	},
    	{
    		feature_id: 3244,
    		year: 1979,
    		feature: "Planum",
    		feature_plural: "Plana",
    		name: "Lakshmi Planum",
    		type: "Goddess",
    		origin: "India",
    		continent: "Asia",
    		clean_name: "Lakshmi",
    		description: "Indian goddess of love and war.",
    		bio: "Lakshmi is one of the principal goddesses in Hinduism. She is the goddess of wealth, fortune, power, beauty, fertility and prosperity, and associated with Maya (\"Illusion\"). Along with Parvati and Saraswati, she forms the Tridevi of Hindu goddesses. Within the goddess-oriented Shaktism, Lakshmi is venerated as the prosperity aspect of the Mother goddess.",
    		search_term: "Lakshmi",
    		diameter: "2,345.0",
    		center_lat: 68.6,
    		center_long: 339.3
    	},
    	{
    		feature_id: 3808,
    		year: 1979,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Meitner",
    		type: "Famous Woman",
    		origin: "Austria",
    		continent: "Europe",
    		clean_name: "Meitner",
    		description: "Lise; Austrian physicist (1878-1968).",
    		bio: "Elise Meitner ( LEE-zə MYTE-nər, German: [ˈliːzə ˈmaɪtnɐ] ; 7 November 1878 – 27 October 1968) was an Austrian-Swedish physicist who was one of those responsible for the discovery of the element protactinium and nuclear fission. While working at the Kaiser Wilhelm Institute on radioactivity, she discovered the radioactive isotope protactinium-231 in 1917. In 1938, Meitner and her nephew, the physicist Otto Robert Frisch, discovered nuclear fission.",
    		search_term: "Lise Meitner",
    		diameter: "149.0",
    		center_lat: -55.6,
    		center_long: 321.6
    	},
    	{
    		feature_id: 5319,
    		year: 1979,
    		feature: "Patera",
    		feature_plural: "Paterae",
    		name: "Sappho Patera",
    		type: "Famous Woman",
    		origin: "Greek",
    		continent: "Europe",
    		clean_name: "Sappho",
    		description: "Lyric poet, Lesbos, Asia Minor (fl. between 580-160 B.C.).",
    		bio: "Sappho (; Greek: Σαπφώ Sapphō [sap.pʰɔ̌ː]; Aeolic Greek Ψάπφω Psápphō; c. 630 – c. 570 BC) was an Archaic Greek poet from Eresos or Mytilene on the island of Lesbos.",
    		search_term: "Sappho",
    		diameter: "225.0",
    		center_lat: 14.1,
    		center_long: 16.5
    	},
    	{
    		feature_id: 317,
    		year: 1979,
    		feature: "Terra",
    		feature_plural: "Terrae",
    		name: "Aphrodite Terra",
    		type: "Goddess",
    		origin: "Greek",
    		continent: "Europe",
    		clean_name: "Aphrodite",
    		description: "Greek goddess of love.",
    		bio: "Aphrodite is an ancient Greek goddess associated with love, lust, beauty, pleasure, passion, and procreation. She was syncretized with the Roman goddess Venus.",
    		search_term: "Aphrodite",
    		diameter: "10,000.0",
    		center_lat: -5.8,
    		center_long: 104.8
    	},
    	{
    		feature_id: 2024,
    		year: 1979,
    		feature: "Mons",
    		feature_plural: "Montes",
    		name: "Freyja Montes",
    		type: "Goddess",
    		origin: "Norse",
    		continent: "Europe",
    		clean_name: "Freyja",
    		description: "Norse, mother of Odin.",
    		bio: "In Norse paganism, Freyja (Old Norse \"(the) Lady\") is a goddess associated with love, beauty, fertility, sex, war, gold, and seiðr (magic for seeing and influencing the future). Freyja is the owner of the necklace Brísingamen, rides a chariot pulled by two cats, is accompanied by the boar Hildisvíni, and possesses a cloak of falcon feathers. By her husband Óðr, she is the mother of two daughters, Hnoss and Gersemi.",
    		search_term: "Freyja",
    		diameter: "579.0",
    		center_lat: 74.1,
    		center_long: 333.8
    	},
    	{
    		feature_id: 5014,
    		year: 1979,
    		feature: "Mons",
    		feature_plural: "Montes",
    		name: "Rhea Mons",
    		type: "Goddess",
    		origin: "Greek",
    		continent: "Europe",
    		clean_name: "Rhea",
    		description: "Greek Titaness.",
    		bio: "",
    		search_term: "",
    		diameter: "217.0",
    		center_lat: 32.4,
    		center_long: 282.2
    	},
    	{
    		feature_id: 5958,
    		year: 1979,
    		feature: "Mons",
    		feature_plural: "Montes",
    		name: "Theia Mons",
    		type: "Goddess",
    		origin: "Greek",
    		continent: "Europe",
    		clean_name: "Theia",
    		description: "Greek Titaness.",
    		bio: "In Greek mythology, Theia, also called Euryphaessa, \"wide-shining\", is one of the twelve Titans, the children of the earth goddess Gaia and the sky god Uranus. She is the Greek goddess of sight and vision, and by extension the goddess who endowed gold, silver and gems with their brilliance and intrinsic value.",
    		search_term: "Theia",
    		diameter: "226.0",
    		center_lat: 22.7,
    		center_long: 281
    	},
    	{
    		feature_id: 136,
    		year: 1979,
    		feature: "Mons",
    		feature_plural: "Montes",
    		name: "Akna Montes",
    		type: "Goddess",
    		origin: "Mayan",
    		continent: "North America",
    		clean_name: "Akna",
    		description: "Mayan goddess of birth.",
    		bio: "",
    		search_term: "",
    		diameter: "830.0",
    		center_lat: 68.9,
    		center_long: 318.2
    	},
    	{
    		feature_id: 1240,
    		year: 1982,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Cleopatra",
    		type: "Famous Woman",
    		origin: "Egypt",
    		continent: "Africa",
    		clean_name: "Cleopatra",
    		description: "Egyptian queen, notable for love affairs with Julius Caesar and Mark Anthony (69-30 B.C.).",
    		bio: "Cleopatra VII Philopator (Greek: Κλεοπάτρα Φιλοπάτωρ, 'Cleopatra the father-beloved'; 69 BC – 10 August 30 BC) was Queen of the Ptolemaic Kingdom of Egypt from 51 to 30 BC, and its last active ruler. Whereas myths about Cleopatra persist in popular media, important aspects of her career go largely unnoticed, such as her command of naval forces and administrative acts.",
    		search_term: "Cleopatra",
    		diameter: "105.0",
    		center_lat: 65.8,
    		center_long: 7.1
    	},
    	{
    		feature_id: 3133,
    		year: 1982,
    		feature: "Chasma",
    		feature_plural: "Chasmata",
    		name: "Kuanja Chasma",
    		type: "Goddess",
    		origin: "Mbundu",
    		continent: "Africa",
    		clean_name: "Kuanja",
    		description: "Mbundu goddess of the spirit of the hunt.",
    		bio: "",
    		search_term: "",
    		diameter: "890.0",
    		center_lat: -12,
    		center_long: 99.5
    	},
    	{
    		feature_id: 3550,
    		year: 1982,
    		feature: "Mons",
    		feature_plural: "Montes",
    		name: "Maat Mons",
    		type: "Goddess",
    		origin: "Egypt",
    		continent: "Africa",
    		clean_name: "Maat",
    		description: "Ancient Egyptian goddess of truth and justice.",
    		bio: "Maat or Maʽat (Egyptian: mꜣꜥt /ˈmuʀʕat/, Coptic: ⲙⲉⲓ) refers to the ancient Egyptian concepts of truth, balance, order, harmony, law, morality, and justice. Ma'at was also the goddess who personified these concepts, and regulated the stars, seasons, and the actions of mortals and the deities who had brought order from chaos at the moment of creation. Her ideological opposite was Isfet (Egyptian jzft), meaning injustice, chaos, violence or to do evil.",
    		search_term: "Maat",
    		diameter: "395.0",
    		center_lat: 0.5,
    		center_long: 194.6
    	},
    	{
    		feature_id: 5896,
    		year: 1982,
    		feature: "Mons",
    		feature_plural: "Montes",
    		name: "Tefnut Mons",
    		type: "Goddess",
    		origin: "Egypt",
    		continent: "Africa",
    		clean_name: "Tefnut",
    		description: "Ancient Egyptian goddess of dew or rain.",
    		bio: "Tefnut (Ancient Egyptian: tfn.t; Coptic: ⲧϥⲏⲛⲉ tfēne) is a deity of moisture, moist air, dew and rain in Ancient Egyptian religion. She is the sister and consort of the air god Shu and the mother of Geb and Nut. The name Tefnut has no certain etymology but it may be an onomatopoeia of the sound of spitting, as Atum spits her out in some versions of the creation myth.",
    		search_term: "Tefnut",
    		diameter: "182.0",
    		center_lat: -38.6,
    		center_long: 304
    	},
    	{
    		feature_id: 2276,
    		year: 1982,
    		feature: "Mons",
    		feature_plural: "Montes",
    		name: "Gula Mons",
    		type: "Goddess",
    		origin: "Babylon",
    		continent: "Asia",
    		clean_name: "Gula",
    		description: "Babylonian earth mother, creative force.",
    		bio: "",
    		search_term: "",
    		diameter: "276.0",
    		center_lat: 21.9,
    		center_long: 359.1
    	},
    	{
    		feature_id: 2447,
    		year: 1982,
    		feature: "Chasma",
    		feature_plural: "Chasmata",
    		name: "Heng-o Chasma",
    		type: "Goddess",
    		origin: "China",
    		continent: "Asia",
    		clean_name: "Heng-o",
    		description: "Chinese moon goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "734.0",
    		center_lat: 6.6,
    		center_long: 355.5
    	},
    	{
    		feature_id: 2697,
    		year: 1982,
    		feature: "Mons",
    		feature_plural: "Montes",
    		name: "Innini Mons",
    		type: "Goddess",
    		origin: "Babylon",
    		continent: "Asia",
    		clean_name: "Innini",
    		description: "Babylonian earth mother worshipped at Kish.",
    		bio: "",
    		search_term: "",
    		diameter: "339.0",
    		center_lat: -34.6,
    		center_long: 328.5
    	},
    	{
    		feature_id: 4531,
    		year: 1982,
    		feature: "Regio",
    		feature_plural: "Regiones",
    		name: "Ovda Regio",
    		type: "Goddess",
    		origin: "Mari",
    		continent: "Asia",
    		clean_name: "Ovda",
    		description: "Marijian; Titaness having supernatural power.",
    		bio: "",
    		search_term: "",
    		diameter: "5,280.0",
    		center_lat: -2.8,
    		center_long: 85.6
    	},
    	{
    		feature_id: 4538,
    		year: 1982,
    		feature: "Mons",
    		feature_plural: "Montes",
    		name: "Ozza Mons",
    		type: "Goddess",
    		origin: "Persian",
    		continent: "Asia",
    		clean_name: "Ozza",
    		description: "Persian goddess honored by the Koreishies.",
    		bio: "Al-ʻUzzā (Arabic: العزى al-ʻUzzā [al ʕuzzaː] or Old Arabic [al ʕuzzeː]) was one of the three chief goddesses of Arabian religion in pre-Islamic times and she was worshiped by the pre-Islamic Arabs along with al-Lāt and Manāt. A stone cube at Nakhla (near Mecca) was held sacred as part of her cult. She is mentioned in Qur'an 53:19 as being one of the goddesses who people worshiped.",
    		search_term: "Ozza",
    		diameter: "507.0",
    		center_lat: 4.5,
    		center_long: 201
    	},
    	{
    		feature_id: 4588,
    		year: 1982,
    		feature: "Chasma",
    		feature_plural: "Chasmata",
    		name: "Parga Chasmata",
    		type: "Goddess",
    		origin: "Siberia",
    		continent: "Asia",
    		clean_name: "Parga",
    		description: "Nenets (Samoyed) forest witch. (Feature extent expanded in 2001.)",
    		bio: "",
    		search_term: "",
    		diameter: "11,000.0",
    		center_lat: -20,
    		center_long: 255
    	},
    	{
    		feature_id: 5318,
    		year: 1982,
    		feature: "Mons",
    		feature_plural: "Montes",
    		name: "Sapas Mons",
    		type: "Goddess",
    		origin: "Phoenician",
    		continent: "Asia",
    		clean_name: "Sapas",
    		description: "Phoenician commerce, travel, and messenger goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "217.0",
    		center_lat: 8.5,
    		center_long: 188.3
    	},
    	{
    		feature_id: 6248,
    		year: 1982,
    		feature: "Mons",
    		feature_plural: "Montes",
    		name: "Ushas Mons",
    		type: "Goddess",
    		origin: "India",
    		continent: "Asia",
    		clean_name: "Ushas",
    		description: "Indian goddess of dawn.",
    		bio: "Ushas is a Vedic goddess of dawn in Hinduism. She is the life of all living creatures, the impeller of action and breath, the foe of chaos and confusion, the auspicious arouser of cosmic and moral order called the Ṛta in Hinduism. She is portrayed as a beautifully adorned young woman riding in a golden chariot or a hundred chariots, drawn by golden red horses or cows, on her path across the sky.",
    		search_term: "Ushas",
    		diameter: "413.0",
    		center_lat: -24.3,
    		center_long: 324.6
    	},
    	{
    		feature_id: 6252,
    		year: 1982,
    		feature: "Rupes",
    		feature_plural: "Rupēs",
    		name: "Ut Rupes",
    		type: "Goddess",
    		origin: "Turkmenistan",
    		continent: "Asia",
    		clean_name: "Ut",
    		description: "Siberian; Turco-Tatar goddess of the hearth fire.",
    		bio: "",
    		search_term: "",
    		diameter: "676.0",
    		center_lat: 55.3,
    		center_long: 321.9
    	},
    	{
    		feature_id: 6397,
    		year: 1982,
    		feature: "Chasma",
    		feature_plural: "Chasmata",
    		name: "Vir-ava Chasma",
    		type: "Goddess",
    		origin: "Mordvinian",
    		continent: "Asia",
    		clean_name: "Vir-ava",
    		description: "Mordvinian forest mother.",
    		bio: "",
    		search_term: "",
    		diameter: "1,700.0",
    		center_lat: -16.5,
    		center_long: 124
    	},
    	{
    		feature_id: 3258,
    		year: 1982,
    		feature: "Linea",
    		feature_plural: "Lineae",
    		name: "Lampedo Linea",
    		type: "Heroine",
    		origin: "Scythia",
    		continent: "Asia",
    		clean_name: "Lampedo",
    		description: "Scythian Amazon queen.",
    		bio: "Lampedo (Greek for \"burning torch\"; also Lampeto) is an Amazon queen mentioned in Roman historiography. She ruled with her sister Marpesia. The sisters called themselves daughters of Mars to put terror in the heart of their enemies to show they were incredible warriors to be feared.",
    		search_term: "Lampedo",
    		diameter: "800.0",
    		center_lat: 62.2,
    		center_long: 293
    	},
    	{
    		feature_id: 1267,
    		year: 1982,
    		feature: "Patera",
    		feature_plural: "Paterae",
    		name: "Colette Patera",
    		type: "Famous Woman",
    		origin: "France",
    		continent: "Europe",
    		clean_name: "Colette",
    		description: "Claudine; French novelist (1873-1954).",
    		bio: "Sidonie-Gabrielle Colette (French: [kɔ.lɛt]; 28 January 1873 – 3 August 1954), known mononymously as Colette, was a French author and woman of letters. She was also a mime, actress, and journalist. Colette is best known in the English-speaking world for her 1944 novella Gigi, which was the basis for the 1958 film and the 1973 stage production of the same name.",
    		search_term: "Colette",
    		diameter: "149.0",
    		center_lat: 66.3,
    		center_long: 322.8
    	},
    	{
    		feature_id: 295,
    		year: 1982,
    		feature: "Linea",
    		feature_plural: "Lineae",
    		name: "Antiope Linea",
    		type: "Goddess",
    		origin: "Greek",
    		continent: "Europe",
    		clean_name: "Antiope",
    		description: "Amazon awarded to Theseus.",
    		bio: "",
    		search_term: "",
    		diameter: "0.0",
    		center_lat: -40,
    		center_long: 350
    	},
    	{
    		feature_id: 400,
    		year: 1982,
    		feature: "Chasma",
    		feature_plural: "Chasmata",
    		name: "Artemis Chasma",
    		type: "Goddess",
    		origin: "Greek",
    		continent: "Europe",
    		clean_name: "Artemis",
    		description: "Greek goddess of hunt/moon.",
    		bio: "In ancient Greek mythology and religion, Artemis is the goddess of the hunt, the wilderness, wild animals, nature, vegetation, childbirth, care of children, and chastity. She was heavily identified with Selene, the Moon, and Hecate, another Moon goddess, and was thus regarded as one of the most prominent lunar deities in mythology, alongside the aforementioned two. She would often roam the forests of Greece, attended by her large entourage, mostly made up of nymphs, some mortals, and hunters.",
    		search_term: "Artemis",
    		diameter: "3,087.0",
    		center_lat: -41.2,
    		center_long: 138.5
    	},
    	{
    		feature_id: 437,
    		year: 1982,
    		feature: "Regio",
    		feature_plural: "Regiones",
    		name: "Asteria Regio",
    		type: "Goddess",
    		origin: "Greek",
    		continent: "Europe",
    		clean_name: "Asteria",
    		description: "Greek Titaness.",
    		bio: "",
    		search_term: "",
    		diameter: "1,131.0",
    		center_lat: 21.6,
    		center_long: 267.5
    	},
    	{
    		feature_id: 456,
    		year: 1982,
    		feature: "Regio",
    		feature_plural: "Regiones",
    		name: "Atla Regio",
    		type: "Goddess",
    		origin: "Norway",
    		continent: "Europe",
    		clean_name: "Atla",
    		description: "Norse giantess, mother of Heimdall.",
    		bio: "",
    		search_term: "",
    		diameter: "3,200.0",
    		center_lat: 9.2,
    		center_long: 200.1
    	},
    	{
    		feature_id: 673,
    		year: 1982,
    		feature: "Regio",
    		feature_plural: "Regiones",
    		name: "Bell Regio",
    		type: "Goddess",
    		origin: "Great Britain",
    		continent: "Europe",
    		clean_name: "Bell",
    		description: "English giantess.",
    		bio: "",
    		search_term: "",
    		diameter: "1,778.0",
    		center_lat: 32.8,
    		center_long: 51.4
    	},
    	{
    		feature_id: 1390,
    		year: 1982,
    		feature: "Chasma",
    		feature_plural: "Chasmata",
    		name: "Dali Chasma",
    		type: "Goddess",
    		origin: "Georgia",
    		continent: "Europe",
    		clean_name: "Dali",
    		description: "Georgian; goddess of hunt.",
    		bio: "",
    		search_term: "",
    		diameter: "2,077.0",
    		center_lat: -17.6,
    		center_long: 167
    	},
    	{
    		feature_id: 1512,
    		year: 1982,
    		feature: "Chasma",
    		feature_plural: "Chasmata",
    		name: "Devana Chasma",
    		type: "Goddess",
    		origin: "Czechoslovakia",
    		continent: "Europe",
    		clean_name: "Devana",
    		description: "Czechoslovakian goddess of hunting.",
    		bio: "Devana is the goddess of wild nature, forests, hunting and the moon worshiped by the Western Slavs. In the sources, she was first mentioned in the 15th century by Jan Długosz, who compared her to the Roman goddess Diana.",
    		search_term: "Devana",
    		diameter: "2,000.0",
    		center_lat: 22,
    		center_long: 283.5
    	},
    	{
    		feature_id: 1525,
    		year: 1982,
    		feature: "Chasma",
    		feature_plural: "Chasmata",
    		name: "Diana Chasma",
    		type: "Goddess",
    		origin: "Roman",
    		continent: "Europe",
    		clean_name: "Diana",
    		description: "Roman goddess of hunt/moon.",
    		bio: "",
    		search_term: "",
    		diameter: "938.0",
    		center_lat: -14.8,
    		center_long: 154.8
    	},
    	{
    		feature_id: 1747,
    		year: 1982,
    		feature: "Regio",
    		feature_plural: "Regiones",
    		name: "Eistla Regio",
    		type: "Goddess",
    		origin: "Norse",
    		continent: "Europe",
    		clean_name: "Eistla",
    		description: "Norse giantess.",
    		bio: "In Norse mythology, the Nine Mothers of Heimdallr are nine sisters who gave birth to the god Heimdallr. Eistla means obscure. Suggestions include 'the stormy one' (from eisa, meaning 'hurry'), to a potential a sea god (from eista 'testicles', in other words, 'the swollen, swelling ones'), and 'the glowing one' (from eisa 'glowing ash, fire').",
    		search_term: "Eistla",
    		diameter: "8,015.0",
    		center_lat: 10.5,
    		center_long: 21.5
    	},
    	{
    		feature_id: 2099,
    		year: 1982,
    		feature: "Chasma",
    		feature_plural: "Chasmata",
    		name: "Ganis Chasma",
    		type: "Goddess",
    		origin: "Sámi",
    		continent: "Europe",
    		clean_name: "Ganis",
    		description: "Western Sámi forest maiden.",
    		bio: "",
    		search_term: "",
    		diameter: "3,700.0",
    		center_lat: 18,
    		center_long: 189
    	},
    	{
    		feature_id: 2287,
    		year: 1982,
    		feature: "Linea",
    		feature_plural: "Lineae",
    		name: "Guor Linea",
    		type: "Goddess",
    		origin: "Iceland",
    		continent: "Europe",
    		clean_name: "Guor",
    		description: "Northern European Valkyrie.",
    		bio: "",
    		search_term: "",
    		diameter: "0.0",
    		center_lat: 20,
    		center_long: 0
    	},
    	{
    		feature_id: 2406,
    		year: 1982,
    		feature: "Chasma",
    		feature_plural: "Chasmata",
    		name: "Hecate Chasma",
    		type: "Goddess",
    		origin: "Greek",
    		continent: "Europe",
    		clean_name: "Hecate",
    		description: "Greek moon goddess.",
    		bio: "Hecate or Hekate is a goddess in ancient Greek religion and mythology, most often shown holding a pair of torches, a key, snakes, or accompanied by dogs, and in later periods depicted as three-formed or triple-bodied. She is variously associated with crossroads, entrance-ways, night, light, magic, witchcraft, the Moon, knowledge of herbs and poisonous plants, graves, ghosts, necromancy, and sorcery. Her earliest appearance in literature was in Hesiod's Theogony in the 8th century BCE as a goddess of great honour with domains in sky, earth, and sea.",
    		search_term: "Hecate",
    		diameter: "3,145.0",
    		center_lat: 18.2,
    		center_long: 254.3
    	},
    	{
    		feature_id: 2492,
    		year: 1982,
    		feature: "Rupes",
    		feature_plural: "Rupēs",
    		name: "Hestia Rupes",
    		type: "Goddess",
    		origin: "Greek",
    		continent: "Europe",
    		clean_name: "Hestia",
    		description: "Greek hearth goddess.",
    		bio: "In ancient Greek religion and mythology, Hestia is the virgin goddess of the hearth, the right ordering of domesticity, the family, the home, and the state. In myth, she is the firstborn child of the Titans Cronus and Rhea, and one of the Twelve Olympians. According to ancient Greek tradition, Hestia was along with four of her five siblings devoured by her own father Cronus as an infant due to his fear of being overthrown by one of his offspring, and was only freed when her youngest brother Zeus forced their father to disgorge the children he had eaten. Cronus and the rest of the Titans were cast down, and Hestia then became one of the Olympian gods, the new rulers of the cosmos, alongside her brothers and sisters.",
    		search_term: "Hestia",
    		diameter: "588.0",
    		center_lat: 6,
    		center_long: 71.1
    	},
    	{
    		feature_id: 2519,
    		year: 1982,
    		feature: "Linea",
    		feature_plural: "Lineae",
    		name: "Hippolyta Linea",
    		type: "Goddess",
    		origin: "Greek",
    		continent: "Europe",
    		clean_name: "Hippolyta",
    		description: "Amazon queen.",
    		bio: "In Classical Greek mythology, Hippolyta, or Hippolyte (; Greek: Ἱππολύτη Hippolytē) was a daughter of Ares and Otrera, queen of the Amazons, and a sister of Antiope and Melanippe. She wore her father Ares' zoster, the Greek word found in the Iliad and elsewhere meaning \"war belt.\" Some traditional English translations have preferred the more feminine-sounding \"girdle.\" Hippolyta figures prominently in the myths of both Heracles and Theseus. The myths about her are varied enough that they may therefore be about several different women.",
    		search_term: "Hippolyta",
    		diameter: "0.0",
    		center_lat: -42,
    		center_long: 345
    	},
    	{
    		feature_id: 2676,
    		year: 1982,
    		feature: "Regio",
    		feature_plural: "Regiones",
    		name: "Imdr Regio",
    		type: "Goddess",
    		origin: "Norse",
    		continent: "Europe",
    		clean_name: "Imdr",
    		description: "Norse giantess.",
    		bio: "In Norse mythology, the Nine Mothers of Heimdallr are nine sisters who gave birth to the god Heimdallr. Imdr is possibly related to íma 'wolf'.",
    		search_term: "Imdr",
    		diameter: "1,611.0",
    		center_lat: -43,
    		center_long: 212
    	},
    	{
    		feature_id: 2868,
    		year: 1982,
    		feature: "Chasma",
    		feature_plural: "Chasmata",
    		name: "Juno Chasma",
    		type: "Goddess",
    		origin: "Roman",
    		continent: "Europe",
    		clean_name: "Juno",
    		description: "Roman sky goddess; sister and consort of Jupiter.",
    		bio: "",
    		search_term: "",
    		diameter: "915.0",
    		center_lat: -30.5,
    		center_long: 111.1
    	},
    	{
    		feature_id: 2925,
    		year: 1982,
    		feature: "Linea",
    		feature_plural: "Lineae",
    		name: "Kara Linea",
    		type: "Goddess",
    		origin: "Iceland",
    		continent: "Europe",
    		clean_name: "Kara",
    		description: "Icelandic Valkryie.",
    		bio: "",
    		search_term: "",
    		diameter: "0.0",
    		center_lat: -44,
    		center_long: 306
    	},
    	{
    		feature_id: 3955,
    		year: 1982,
    		feature: "Linea",
    		feature_plural: "Lineae",
    		name: "Molpadia Linea",
    		type: "Goddess",
    		origin: "Greek",
    		continent: "Europe",
    		clean_name: "Molpadia",
    		description: "Amazon.",
    		bio: "Molpadia, an Amazon, was was a participant in the Attic War, where she witnessed her queen Antiope sustain heavy injuries. Antiope was hurt so seriously that she could not defend herself from Theseus and his retainers. Knowing this, Molpadia killed the queen with an arrow (some say spear), saving her from violation by the Athenian king. She was afterwards killed by Theseus, and her tomb was shown at Athens.",
    		search_term: "Molpadia",
    		diameter: "0.0",
    		center_lat: -48,
    		center_long: 355
    	},
    	{
    		feature_id: 4705,
    		year: 1982,
    		feature: "Regio",
    		feature_plural: "Regiones",
    		name: "Phoebe Regio",
    		type: "Goddess",
    		origin: "Greek",
    		continent: "Europe",
    		clean_name: "Phoebe",
    		description: "Greek Titaness.",
    		bio: "",
    		search_term: "",
    		diameter: "2,852.0",
    		center_lat: -6,
    		center_long: 282.8
    	},
    	{
    		feature_id: 5524,
    		year: 1982,
    		feature: "Mons",
    		feature_plural: "Montes",
    		name: "Sif Mons",
    		type: "Goddess",
    		origin: "Germany",
    		continent: "Europe",
    		clean_name: "Sif",
    		description: "Teutonic goddess; Thor's wife.",
    		bio: "In Norse mythology, Sif (Old Norse: [siv]) is a golden-haired goddess associated with earth. Sif is attested in the Poetic Edda, compiled in the 13th century from earlier traditional sources, and the Prose Edda, written in the 13th century by Snorri Sturluson, and in the poetry of skalds. In both the Poetic Edda and the Prose Edda, she is known for her golden hair and is married to the thunder god Thor.",
    		search_term: "Sif",
    		diameter: "200.0",
    		center_lat: 22,
    		center_long: 352.4
    	},
    	{
    		feature_id: 5909,
    		year: 1982,
    		feature: "Tessera",
    		feature_plural: "Tesserae",
    		name: "Tellus Tessera",
    		type: "Goddess",
    		origin: "Greek",
    		continent: "Europe",
    		clean_name: "Tellus",
    		description: "Greek Titaness",
    		bio: "",
    		search_term: "",
    		diameter: "2,329.0",
    		center_lat: 42.6,
    		center_long: 76.8
    	},
    	{
    		feature_id: 5938,
    		year: 1982,
    		feature: "Regio",
    		feature_plural: "Regiones",
    		name: "Tethus Regio",
    		type: "Goddess",
    		origin: "Greek",
    		continent: "Europe",
    		clean_name: "Tethus",
    		description: "Greek Titaness.",
    		bio: "",
    		search_term: "",
    		diameter: "0.0",
    		center_lat: 66,
    		center_long: 120
    	},
    	{
    		feature_id: 5961,
    		year: 1982,
    		feature: "Regio",
    		feature_plural: "Regiones",
    		name: "Themis Regio",
    		type: "Goddess",
    		origin: "Greek",
    		continent: "Europe",
    		clean_name: "Themis",
    		description: "Greek Titaness.",
    		bio: "In Greek mythology and religion, Themis (; Ancient Greek: Θέμις, romanized: Themis, lit. 'justice, law, custom') is one of the twelve Titan children of Gaia and Uranus, and the second wife of Zeus. She is the goddess and personification of justice, divine order, fairness, law, and custom, and her symbols include the Scales of Justice. She is also associated with oracles and prophecies, including the Oracle of Delphi.",
    		search_term: "Themis",
    		diameter: "1,811.0",
    		center_lat: -37.4,
    		center_long: 284.2
    	},
    	{
    		feature_id: 5970,
    		year: 1982,
    		feature: "Regio",
    		feature_plural: "Regiones",
    		name: "Thetis Regio",
    		type: "Goddess",
    		origin: "Greek",
    		continent: "Europe",
    		clean_name: "Thetis",
    		description: "Greek Titaness.",
    		bio: "Thetis (; Greek: Θέτις [tʰétis]), is a figure from Greek mythology with varying mythological roles. She mainly appears as a sea nymph, a goddess of water, or one of the 50 Nereids, daughters of the ancient sea god Nereus.When described as a Nereid in Classical myths, Thetis was the daughter of Nereus and Doris, and a granddaughter of Tethys with whom she sometimes shares characteristics. Often she seems to lead the Nereids as they attend to her tasks.",
    		search_term: "Thetis",
    		diameter: "2,801.0",
    		center_lat: -11.4,
    		center_long: 129.9
    	},
    	{
    		feature_id: 6198,
    		year: 1982,
    		feature: "Regio",
    		feature_plural: "Regiones",
    		name: "Ulfrun Regio",
    		type: "Goddess",
    		origin: "Norse",
    		continent: "Europe",
    		clean_name: "Ulfrun",
    		description: "Norse giantess.",
    		bio: "In Norse mythology, the Nine Mothers of Heimdallr are nine sisters who gave birth to the god Heimdallr. Ulfrun means 'Wolf rune' or 'wolf-woman'.",
    		search_term: "Ulfrun",
    		diameter: "3,954.0",
    		center_lat: 27,
    		center_long: 225
    	},
    	{
    		feature_id: 6368,
    		year: 1982,
    		feature: "Rupes",
    		feature_plural: "Rupēs",
    		name: "Vesta Rupes",
    		type: "Goddess",
    		origin: "Roman",
    		continent: "Europe",
    		clean_name: "Vesta",
    		description: "Roman hearth goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "788.0",
    		center_lat: 58.3,
    		center_long: 323.9
    	},
    	{
    		feature_id: 112,
    		year: 1982,
    		feature: "Planitia",
    		feature_plural: "Planitiae",
    		name: "Aino Planitia",
    		type: "Heroine",
    		origin: "Finland",
    		continent: "Europe",
    		clean_name: "Aino ",
    		description: "Finnish heroine who became water spirit.",
    		bio: "Aino (Finnish pronunciation: [ˈɑi̯no]) is a figure in the Finnish national epic Kalevala. It relates that she was the beautiful sister of Joukahainen. Her brother, having lost a singing contest to the storied Väinämöinen, promised Aino's \"hands and feet\" in marriage if Väinämöinen would save him from drowning in the swamp into which Joukahainen had been thrown.",
    		search_term: "Aino (mythology)",
    		diameter: "4,985.0",
    		center_lat: -40.5,
    		center_long: 94.5
    	},
    	{
    		feature_id: 447,
    		year: 1982,
    		feature: "Planitia",
    		feature_plural: "Planitiae",
    		name: "Atalanta Planitia",
    		type: "Heroine",
    		origin: "Greek",
    		continent: "Europe",
    		clean_name: "Atalanta ",
    		description: "Greek mythical heroine.",
    		bio: "Atalanta, meaning \"equal in weight\", is a heroine in Greek mythology. There are two versions of the huntress Atalanta: one from Arcadia, whose parents were Iasus and Clymene and who is primarily known from the tales of the Calydonian boar hunt and the Argonauts; and the other from Boeotia, who is the daughter of King Schoeneus and is primarily noted for her skill in the footrace.",
    		search_term: "Atalanta",
    		diameter: "2,050.0",
    		center_lat: 45.6,
    		center_long: 165.8
    	},
    	{
    		feature_id: 2273,
    		year: 1982,
    		feature: "Planitia",
    		feature_plural: "Planitiae",
    		name: "Guinevere Planitia",
    		type: "Heroine",
    		origin: "Great Britain",
    		continent: "Europe",
    		clean_name: "Guinevere ",
    		description: "British, wife of Arthur.",
    		bio: "Guinevere was, according to Arthurian legend, an early-medieval queen of Great Britain and the wife of King Arthur. First mentioned in popular literature in the early 12th century, nearly 700 years after the purported times of Arthur, Guinevere has since been portrayed as everything from a villainous and opportunistic traitor to a fatally flawed but noble and virtuous lady.",
    		search_term: "Guinevere",
    		diameter: "7,520.0",
    		center_lat: 21.9,
    		center_long: 325
    	},
    	{
    		feature_id: 2422,
    		year: 1982,
    		feature: "Planitia",
    		feature_plural: "Planitiae",
    		name: "Helen Planitia",
    		type: "Heroine",
    		origin: "Greek",
    		continent: "Europe",
    		clean_name: "Helen ",
    		description: "Greek; “the face that launched 1000 ships.”",
    		bio: "Helen of Troy was a figure in Greek mythology said to have been the most beautiful woman in the world. She was believed to have been the daughter of Zeus and Leda, and was the sister of Clytemnestra, Castor and Pollux, Philonoe, Phoebe and Timandra. She was married to King Menelaus of Sparta \"who became by her the father of Hermione, and, according to others, of Nicostratus also.\" The usual tradition is that after the goddess Aphrodite promised her to Paris in the Judgement of Paris, she was seduced by him and carried off to Troy.",
    		search_term: "Helen of Troy",
    		diameter: "4,360.0",
    		center_lat: -51.7,
    		center_long: 263.9
    	},
    	{
    		feature_id: 3306,
    		year: 1982,
    		feature: "Planitia",
    		feature_plural: "Planitiae",
    		name: "Lavinia Planitia",
    		type: "Heroine",
    		origin: "Roman",
    		continent: "Europe",
    		clean_name: "Lavinia ",
    		description: "Roman; wife of Aeneas.",
    		bio: "In Roman mythology, Lavinia is the daughter of Latinus and Amata, and the last wife of Aeneas. It has been proposed that the character was in part intended to represent Servilia Isaurica, Emperor Augustus's first fiancée. Lavinia, the only child of the king and \"ripe for marriage,\" had been courted by many men who hoped to become the king of Latium.",
    		search_term: "Lavinia",
    		diameter: "2,820.0",
    		center_lat: -47.3,
    		center_long: 347.5
    	},
    	{
    		feature_id: 3326,
    		year: 1982,
    		feature: "Planitia",
    		feature_plural: "Planitiae",
    		name: "Leda Planitia",
    		type: "Heroine",
    		origin: "Greek",
    		continent: "Europe",
    		clean_name: "Leda ",
    		description: "Mother of Helen, Castor.",
    		bio: "In Greek mythology, Leda (; Ancient Greek: Λήδα [lɛ͜ɛ́.d̪äː]) was an Aetolian princess who became a Spartan queen. According to Ovid, she was famed for her beautiful black hair and snowy skin. Her myth gave rise to the popular motif in Renaissance and later art of Leda and the Swan.",
    		search_term: "Leda (mythology)",
    		diameter: "2,890.0",
    		center_lat: 44,
    		center_long: 65.1
    	},
    	{
    		feature_id: 4303,
    		year: 1982,
    		feature: "Planitia",
    		feature_plural: "Planitiae",
    		name: "Niobe Planitia",
    		type: "Heroine",
    		origin: "Greek",
    		continent: "Europe",
    		clean_name: "Niobe ",
    		description: "Greek; her 12 children killed by Artemis and Apollo.",
    		bio: "In Greek mythology, Niobe was a daughter of Tantalus and of either Dione, the most frequently cited, or of Eurythemista or Euryanassa, the wife of Amphion and the sister of Pelops and Broteas. Her father was the ruler of a city located near Manisa in today's Aegean Turkey that was called \"Tantalis\" or \"the city of Tantalus\", or \"Sipylus\". The city was located at the foot of Mount Sipylus and its ruins were reported to be still visible at the beginning of the 1st century AD, although few traces remain today.",
    		search_term: "Niobe",
    		diameter: "5,008.0",
    		center_lat: 21,
    		center_long: 112.3
    	},
    	{
    		feature_id: 5233,
    		year: 1982,
    		feature: "Planitia",
    		feature_plural: "Planitiae",
    		name: "Rusalka Planitia",
    		type: "Heroine",
    		origin: "Russia",
    		continent: "Europe",
    		clean_name: "Rusalka ",
    		description: "Russian mermaid.",
    		bio: "In Slavic folklore, the rusalka is a typically feminine entity, often malicious toward mankind and frequently associated with water, with counterparts in other parts of Europe, such as the French Melusine and the Germanic Nixie. Rusalki appear in a variety of media in modern popular culture, particularly in Slavic language-speaking countries, where they frequently resemble the concept of the mermaid.",
    		search_term: "Rusalka",
    		diameter: "3,600.0",
    		center_lat: 3,
    		center_long: 170
    	},
    	{
    		feature_id: 3222,
    		year: 1982,
    		feature: "Terra",
    		feature_plural: "Terrae",
    		name: "Lada Terra",
    		type: "Goddess",
    		origin: "Slavic",
    		continent: "Multiple",
    		clean_name: "Lada",
    		description: "Slavic goddess of love.",
    		bio: "",
    		search_term: "",
    		diameter: "8,615.0",
    		center_lat: -62.5,
    		center_long: 20
    	},
    	{
    		feature_id: 4170,
    		year: 1982,
    		feature: "Planitia",
    		feature_plural: "Planitiae",
    		name: "Navka Planitia",
    		type: "Heroine",
    		origin: "Slavic",
    		continent: "Multiple",
    		clean_name: "Navka ",
    		description: "East-Slavic mermaid.",
    		bio: "Mavka is a type of female spirit in Ukrainian folklore and mythology. She is a long-haired figure, sometimes naked, who may be dangerous to young men.",
    		search_term: "Mavka",
    		diameter: "2,100.0",
    		center_lat: -8.1,
    		center_long: 317.6
    	},
    	{
    		feature_id: 5404,
    		year: 1982,
    		feature: "Planitia",
    		feature_plural: "Planitiae",
    		name: "Sedna Planitia",
    		type: "Heroine",
    		origin: "Inuit/Yupik",
    		continent: "Multiple",
    		clean_name: "Sedna ",
    		description: "Eskimo; her fingers became seals and whales.",
    		bio: "Sedna is the goddess of the sea and marine animals in Inuit mythology, also known as the Mother of the Sea or Mistress of the Sea. In one legend Sedna is a giant, the daughter of the creator-god Anguta, with a great hunger that causes her to attack her parents. Angered, Anguta takes her out to sea and throws her over the side of his kayak. As she clings to the sides, he chops off her fingers and she sinks to the underworld, becoming the ruler of the monsters of the deep. Her huge fingers become the seals, walruses, and whales hunted by the Inuit.",
    		search_term: "Sedna (mythology)",
    		diameter: "3,570.0",
    		center_lat: 42.7,
    		center_long: 340.7
    	},
    	{
    		feature_id: 5264,
    		year: 1982,
    		feature: "Patera",
    		feature_plural: "Paterae",
    		name: "Sacajawea Patera",
    		type: "Famous Woman",
    		origin: "Dakota",
    		continent: "North America",
    		clean_name: "Sacajawea",
    		description: "Shoshoni Indian woman who served as an interpreter for the Lewis and Clark expedition to the Pacific Northwest (1786-1812).",
    		bio: "Sacagawea ( sack-uh-juh-WE-uh or suh-COG-uh-way-uh; also spelled Sakakawea or Sacajawea; May c. 1788 – December 20, 1812 or April 9, 1884) was a Lemhi Shoshone woman who, in her teens, helped the Lewis and Clark Expedition in achieving their chartered mission objectives by exploring the Louisiana Territory. Sacagawea traveled with the expedition thousands of miles from North Dakota to the Pacific Ocean, helping to establish cultural contacts with Native American people and contributing to the expedition's knowledge of natural history in different regions. The National American Woman Suffrage Association of the early 20th century adopted her as a symbol of women's worth and independence, erecting several statues and plaques in her memory, and doing much to recount her accomplishments.",
    		search_term: "Sacagawea",
    		diameter: "233.0",
    		center_lat: 64.3,
    		center_long: 335.4
    	},
    	{
    		feature_id: 2765,
    		year: 1982,
    		feature: "Chasma",
    		feature_plural: "Chasmata",
    		name: "Ix Chel Chasma",
    		type: "Goddess",
    		origin: "Aztec",
    		continent: "North America",
    		clean_name: "Ix Chel",
    		description: "Aztec wife of the Sun god; probably moon goddess.",
    		bio: "Ixchel or Ix Chel is the 16th-century name of the aged jaguar Goddess of midwifery and medicine in ancient Maya culture.",
    		search_term: "Ix Chel",
    		diameter: "503.0",
    		center_lat: -10,
    		center_long: 73.4
    	},
    	{
    		feature_id: 4326,
    		year: 1982,
    		feature: "Mons",
    		feature_plural: "Montes",
    		name: "Nokomis Montes",
    		type: "Goddess",
    		origin: "Algonquin",
    		continent: "North America",
    		clean_name: "Nokomis",
    		description: "Algonquin (N. America) earth mother.",
    		bio: "Nokomis is the name of Nanabozho's grandmother in the Ojibwe traditional stories and was the name of Hiawatha's grandmother in Henry Wadsworth Longfellow's poem, The Song of Hiawatha, which is a re-telling of the Nanabozho stories. Nokomis is an important character in the poem.",
    		search_term: "Nokomis",
    		diameter: "486.0",
    		center_lat: 20,
    		center_long: 189
    	},
    	{
    		feature_id: 4901,
    		year: 1982,
    		feature: "Chasma",
    		feature_plural: "Chasmata",
    		name: "Quilla Chasma",
    		type: "Goddess",
    		origin: "Inca",
    		continent: "South America",
    		clean_name: "Quilla",
    		description: "Inca moon goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "973.0",
    		center_lat: -23.7,
    		center_long: 127.3
    	},
    	{
    		feature_id: 2385,
    		year: 1985,
    		feature: "Patera",
    		feature_plural: "Paterae",
    		name: "Hatshepsut Patera",
    		type: "Famous Woman",
    		origin: "Egypt",
    		continent: "Africa",
    		clean_name: "Hatshepsut",
    		description: "Egyptian pharaoh (1479 B.C.).",
    		bio: "Hatshepsut (; also Hatchepsut; Egyptian: ḥꜣt-špswt 'Foremost of Noble Ladies'; or Hatasu c. 1507–1458 BC) was the fifth pharaoh of the Eighteenth Dynasty of Egypt. She was the second historically confirmed female pharaoh, after Sobekneferu.",
    		search_term: "Hatshepsut",
    		diameter: "118.0",
    		center_lat: 28.1,
    		center_long: 64.5
    	},
    	{
    		feature_id: 173,
    		year: 1985,
    		feature: "Tholus",
    		feature_plural: "Tholi",
    		name: "Ale Tholus",
    		type: "Goddess",
    		origin: "Nigeria",
    		continent: "Africa",
    		clean_name: "Ale",
    		description: "Igbo (Nigeria) goddess who created Earth and vegetation.",
    		bio: "",
    		search_term: "",
    		diameter: "87.0",
    		center_lat: 68.2,
    		center_long: 247
    	},
    	{
    		feature_id: 632,
    		year: 1985,
    		feature: "Tholus",
    		feature_plural: "Tholi",
    		name: "Bast Tholus",
    		type: "Goddess",
    		origin: "Egypt",
    		continent: "Africa",
    		clean_name: "Bast",
    		description: "Egyptian goddess of joy.",
    		bio: "",
    		search_term: "",
    		diameter: "83.0",
    		center_lat: 57.8,
    		center_long: 130.3
    	},
    	{
    		feature_id: 1425,
    		year: 1985,
    		feature: "Chasma",
    		feature_plural: "Chasmata",
    		name: "Daura Chasma",
    		type: "Goddess",
    		origin: "Sudan",
    		continent: "Africa",
    		clean_name: "Daura",
    		description: "Hausa (W. Sudan) great huntress.",
    		bio: "Daurama or Magajiya Daurama (c. 9th century) was a ruler of the Hausa people who, as the Last Kabara of Daura, presided over the upheaval that saw a transference of power from the matriarchal royal system of the Hausa people. Oral traditions remember her as the founding \"queen grandmother\" of the Hausa empire started in the area we know today as the monarchies of northern Niger and Nigeria.",
    		search_term: "Daurama",
    		diameter: "729.0",
    		center_lat: 73.8,
    		center_long: 53.8
    	},
    	{
    		feature_id: 3867,
    		year: 1985,
    		feature: "Tessera",
    		feature_plural: "Tesserae",
    		name: "Meskhent Tessera",
    		type: "Goddess",
    		origin: "Egypt",
    		continent: "Africa",
    		clean_name: "Meskhent",
    		description: "Egyptian goddess of fortune.",
    		bio: "In ancient Egyptian mythology, Meskhenet, (also spelt Mesenet, Meskhent, and Meshkent) was the goddess of childbirth, and the creator of each child's Ka, a part of their soul, which she breathed into them at the moment of birth. She was worshipped from the earliest of times by Egyptians. In ancient Egypt, women delivered babies while squatting on a pair of bricks, known as \"birth bricks\", and Meskhenet was the goddess associated with this form of delivery.",
    		search_term: "Meskhent",
    		diameter: "1,056.0",
    		center_lat: 65.8,
    		center_long: 103.1
    	},
    	{
    		feature_id: 4520,
    		year: 1985,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Otau Corona",
    		type: "Goddess",
    		origin: "Nigeria",
    		continent: "Africa",
    		clean_name: "Otau",
    		description: "Bini (S. Nigeria) goddess of fertility.",
    		bio: "",
    		search_term: "",
    		diameter: "172.0",
    		center_lat: 67.8,
    		center_long: 298.7
    	},
    	{
    		feature_id: 4996,
    		year: 1985,
    		feature: "Mons",
    		feature_plural: "Montes",
    		name: "Renpet Mons",
    		type: "Goddess",
    		origin: "Egypt",
    		continent: "Africa",
    		clean_name: "Renpet",
    		description: "Egyptian goddess of springtime and youth.",
    		bio: "Renpet was, in the Egyptian language, the word for \"year\". Its hieroglyph was figuratively depicted in art as a woman wearing a palm shoot (symbolizing time) over her head. She was often referred to as the Mistress of Eternity and also personified fertility, youth and spring.",
    		search_term: "Renpet",
    		diameter: "138.0",
    		center_lat: 76,
    		center_long: 236.2
    	},
    	{
    		feature_id: 5415,
    		year: 1985,
    		feature: "Mons",
    		feature_plural: "Montes",
    		name: "Sekmet Mons",
    		type: "Goddess",
    		origin: "Egypt",
    		continent: "Africa",
    		clean_name: "Sekmet",
    		description: "Ancient Egyptian goddess of war and battle.",
    		bio: "In Egyptian mythology, Sekhmet, is a warrior goddess as well as goddess of healing. She is depicted as a lioness. Sekhmet is a solar deity, sometimes called the daughter of Ra and often associated with the goddesses Hathor and Bastet.",
    		search_term: "Sekmet",
    		diameter: "285.0",
    		center_lat: 44.5,
    		center_long: 240.5
    	},
    	{
    		feature_id: 2391,
    		year: 1985,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Hayashi",
    		type: "Famous Woman",
    		origin: "Japan",
    		continent: "Asia",
    		clean_name: "Hayashi",
    		description: "Fumiko; Japanese writer (1903-1951).",
    		bio: "Fumiko Hayashi (林芙美子, Hayashi Fumiko, December 31, 1903 – June 28, 1951) was a Japanese writer of novels, short stories and poetry, who is included in the feminist literature canon. Among her best-known works are Diary of a Vagabond, Late Chrysanthemum and Floating Clouds. Hayashi was born in Moji-ku, Kitakyūshū, Japan, and raised in abject poverty.",
    		search_term: "Fumiko Hayashi (author)",
    		diameter: "43.1",
    		center_lat: 53.8,
    		center_long: 243.9
    	},
    	{
    		feature_id: 2498,
    		year: 1985,
    		feature: "Patera",
    		feature_plural: "Paterae",
    		name: "Hiei Chu Patera",
    		type: "Famous Woman",
    		origin: "China",
    		continent: "Asia",
    		clean_name: "Hiei Chu",
    		description: "Chinese, converted silk worm product into thread and material (2698 B.C.).",
    		bio: "Leizu (Chinese: 嫘祖; pinyin: Léi Zǔ), also known as Xi Ling-shi (Chinese: 西陵氏, Wade–Giles Hsi Ling-shih), was a legendary Chinese empress and wife of the Yellow Emperor. According to tradition, she discovered sericulture, and invented the silk loom, in the 27th century BC. According to legend, Leizu discovered silkworms while having an afternoon tea, and a cocoon fell in her tea. It slowly unraveled and she was enchanted by it.",
    		search_term: "Leizu",
    		diameter: "139.0",
    		center_lat: 48.2,
    		center_long: 97.4
    	},
    	{
    		feature_id: 2778,
    		year: 1985,
    		feature: "Patera",
    		feature_plural: "Paterae",
    		name: "Izumi Patera",
    		type: "Famous Woman",
    		origin: "Japan",
    		continent: "Asia",
    		clean_name: "Izumi",
    		description: "Sikibu; Japanese writer (974-1036).",
    		bio: "Murasaki Shikibu (紫式部, English: 'Lady Murasaki'; c. 973 – c. 1014 or 1025) was a Japanese novelist, poet and lady-in-waiting at the Imperial court in the Heian period. She is best known as the author of The Tale of Genji, widely considered to be one of the world's first novels, written in Japanese between about 1000 and 1012. Murasaki Shikibu is a descriptive name; her personal name is unknown, but she may have been Fujiwara no Kaoriko (藤原香子), who was mentioned in a 1007 court diary as an imperial lady-in-waiting.",
    		search_term: "Murasaki Shikibu",
    		diameter: "74.0",
    		center_lat: 50,
    		center_long: 193.6
    	},
    	{
    		feature_id: 3006,
    		year: 1985,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Khatun",
    		type: "Famous Woman",
    		origin: "Turkey",
    		continent: "Asia",
    		clean_name: "Khatun",
    		description: "Mihri; Turkish poet (1456-1514).",
    		bio: "Mihri Hatun, also known as Lady Mihri and Mihri Khatun (born ca. 1460 – died 1506 AD; مهری خاتون), was an Ottoman poet. She was the daughter of a kadi (an Ottoman judge) and according to sources she spent most of her life in and near Amasya, in Anatolia.",
    		search_term: "Mihri Khatun",
    		diameter: "44.1",
    		center_lat: 40.3,
    		center_long: 87.2
    	},
    	{
    		feature_id: 4105,
    		year: 1985,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Nadira",
    		type: "Famous Woman",
    		origin: "Uzbekistan",
    		continent: "Asia",
    		clean_name: "Nadira",
    		description: "Uzbek poet (1791-1842).",
    		bio: "Mohlaroyim (Uzbek: Mohlaroyim, Моҳларойим; 1792–1842), most commonly known by her pen name Nodira, was an Uzbek poet and stateswoman. She functioned as regent of the Khanate of Kokand during the minority of her son from 1822. Nodira is generally regarded as one of the most outstanding Uzbek poets.",
    		search_term: "Nodira",
    		diameter: "31.4",
    		center_lat: 44.1,
    		center_long: 201.5
    	},
    	{
    		feature_id: 4970,
    		year: 1985,
    		feature: "Patera",
    		feature_plural: "Paterae",
    		name: "Razia Patera",
    		type: "Famous Woman",
    		origin: "India",
    		continent: "Asia",
    		clean_name: "Razia",
    		description: "Queen of Delhi Sultanate (India) (fl. 1236-1240).",
    		bio: "Raziyyat-Ud-Dunya Wa Ud-Din (Persian: سلطان رضیة الدنیا والدین) (died 15 October 1240, r. 1236–1240), popularly known as Razia Sultana, was a ruler of the Delhi Sultanate in the northern part of the Indian subcontinent. She was the first female Muslim ruler of the subcontinent, and the only female Muslim ruler of Delhi.",
    		search_term: "Razia Sultana",
    		diameter: "157.0",
    		center_lat: 46.2,
    		center_long: 197.8
    	},
    	{
    		feature_id: 6024,
    		year: 1985,
    		feature: "Patera",
    		feature_plural: "Paterae",
    		name: "Tipporah Patera",
    		type: "Famous Woman",
    		origin: "Hebrew",
    		continent: "Asia",
    		clean_name: "Tipporah",
    		description: "Hebrew medical scholar (1500 B.C.).",
    		bio: "",
    		search_term: "",
    		diameter: "99.0",
    		center_lat: 38.9,
    		center_long: 43
    	},
    	{
    		feature_id: 2686,
    		year: 1985,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Indira",
    		type: "First Name",
    		origin: "India",
    		continent: "Asia",
    		clean_name: "Indira",
    		description: "Hindu first name.",
    		bio: "",
    		search_term: "",
    		diameter: "16.6",
    		center_lat: 64.1,
    		center_long: 289.8
    	},
    	{
    		feature_id: 4947,
    		year: 1985,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Rani",
    		type: "First Name",
    		origin: "India",
    		continent: "Asia",
    		clean_name: "Rani",
    		description: "Hindu first name.",
    		bio: "",
    		search_term: "",
    		diameter: "10.7",
    		center_lat: 64.1,
    		center_long: 160.4
    	},
    	{
    		feature_id: 5238,
    		year: 1985,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Ruth",
    		type: "First Name",
    		origin: "Hebrew",
    		continent: "Asia",
    		clean_name: "Ruth",
    		description: "Hebrew first name.",
    		bio: "",
    		search_term: "",
    		diameter: "18.5",
    		center_lat: 43.3,
    		center_long: 19.9
    	},
    	{
    		feature_id: 191,
    		year: 1985,
    		feature: "Dorsum",
    		feature_plural: "Dorsa",
    		name: "Allat Dorsa",
    		type: "Goddess",
    		origin: "Arabian",
    		continent: "Asia",
    		clean_name: "Allat",
    		description: "Arab sky goddess.",
    		bio: "al-Lat is a pre-Islamic Arabian goddess worshipped under various associations throughout the entire Arabian Peninsula, including Mecca where she was worshipped alongside Manat and al-'Uzza as one of the daughters of Allah. The word Allat or Elat has been used to refer to various goddesses in the ancient Near East, including the goddess Asherah-Athirat.",
    		search_term: "Allat",
    		diameter: "750.0",
    		center_lat: 60,
    		center_long: 70
    	},
    	{
    		feature_id: 318,
    		year: 1985,
    		feature: "Mons",
    		feature_plural: "Montes",
    		name: "Api Mons",
    		type: "Goddess",
    		origin: "Scythia",
    		continent: "Asia",
    		clean_name: "Api",
    		description: "Scythian goddess of earth.",
    		bio: "",
    		search_term: "",
    		diameter: "190.0",
    		center_lat: 38.9,
    		center_long: 54.7
    	},
    	{
    		feature_id: 343,
    		year: 1985,
    		feature: "Chasma",
    		feature_plural: "Chasmata",
    		name: "Aranyani Chasma",
    		type: "Goddess",
    		origin: "India",
    		continent: "Asia",
    		clean_name: "Aranyani",
    		description: "Indian forest goddess.",
    		bio: "Aranyani is the goddess of forests and the wild animals that dwell within them in Hinduism. The Rigveda describes her as being elusive, fond of quiet glades in the jungle, and fearless of remote places. In the hymn, the supplicant entreats her to explain how she wanders so far from the fringe of civilisation without becoming afraid or lonely. She wears anklets with bells, and though seldom seen, she can be heard by the tinkling of her anklets. She is also described as a dancer.",
    		search_term: "Aranyani",
    		diameter: "718.0",
    		center_lat: 69.3,
    		center_long: 74.4
    	},
    	{
    		feature_id: 425,
    		year: 1985,
    		feature: "Tholus",
    		feature_plural: "Tholi",
    		name: "Ashtart Tholus",
    		type: "Goddess",
    		origin: "Phoenician",
    		continent: "Asia",
    		clean_name: "Ashtart",
    		description: "Phoenician goddess of love, fertility and war; personification of planet Venus.",
    		bio: "Astarte is the Hellenized form of the Ancient Near Eastern goddess Ashtart or Athtart (Northwest Semitic), a deity closely related to Ishtar (East Semitic), who was worshipped from the Bronze Age through classical antiquity. In various cultures Astarte was connected with some combination of the following spheres: war, sexuality, royal power, beauty, healing and especially hunting; however, known sources do not indicate she was a fertility goddess, contrary to opinions in early scholarship.",
    		search_term: "Ashtart",
    		diameter: "138.0",
    		center_lat: 48.7,
    		center_long: 247
    	},
    	{
    		feature_id: 685,
    		year: 1985,
    		feature: "Dorsum",
    		feature_plural: "Dorsa",
    		name: "Ben Dorsa",
    		type: "Goddess",
    		origin: "Vietnam",
    		continent: "Asia",
    		clean_name: "Ben",
    		description: "Vietnamese sky goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "628.0",
    		center_lat: 71.2,
    		center_long: 284.1
    	},
    	{
    		feature_id: 1680,
    		year: 1985,
    		feature: "Dorsum",
    		feature_plural: "Dorsa",
    		name: "Dyan-Mu Dorsa",
    		type: "Goddess",
    		origin: "China",
    		continent: "Asia",
    		clean_name: "Dyan-Mu",
    		description: "Chinese lightning goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "687.0",
    		center_lat: 78.2,
    		center_long: 31.9
    	},
    	{
    		feature_id: 2662,
    		year: 1985,
    		feature: "Fossa",
    		feature_plural: "Fossae",
    		name: "Ilbis Fossae",
    		type: "Goddess",
    		origin: "Yakutian",
    		continent: "Asia",
    		clean_name: "Ilbis",
    		description: "Yakutian (Siberia) goddess of bloodshed.",
    		bio: "",
    		search_term: "",
    		diameter: "512.0",
    		center_lat: 71.9,
    		center_long: 254.6
    	},
    	{
    		feature_id: 2971,
    		year: 1985,
    		feature: "Chasma",
    		feature_plural: "Chasmata",
    		name: "Kaygus Chasmata",
    		type: "Goddess",
    		origin: "Siberia",
    		continent: "Asia",
    		clean_name: "Kaygus",
    		description: "Ketian (Siberia) ruler of forest animals.",
    		bio: "",
    		search_term: "",
    		diameter: "503.0",
    		center_lat: 49.6,
    		center_long: 52.1
    	},
    	{
    		feature_id: 3101,
    		year: 1985,
    		feature: "Chasma",
    		feature_plural: "Chasmata",
    		name: "Kottravey Chasma",
    		type: "Goddess",
    		origin: "India",
    		continent: "Asia",
    		clean_name: "Kottravey",
    		description: "Dravidian (India) hunting goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "744.0",
    		center_lat: 30.5,
    		center_long: 77.9
    	},
    	{
    		feature_id: 3172,
    		year: 1985,
    		feature: "Tessera",
    		feature_plural: "Tesserae",
    		name: "Kutue Tessera",
    		type: "Goddess",
    		origin: "Siberia",
    		continent: "Asia",
    		clean_name: "Kutue",
    		description: "Ulchian (Siberia) folklore toad that brings happiness.",
    		bio: "",
    		search_term: "",
    		diameter: "653.0",
    		center_lat: 39.5,
    		center_long: 108.8
    	},
    	{
    		feature_id: 3645,
    		year: 1985,
    		feature: "Tessera",
    		feature_plural: "Tesserae",
    		name: "Manzan-Gurme Tesserae",
    		type: "Goddess",
    		origin: "Tibet",
    		continent: "Asia",
    		clean_name: "Manzan-Gurme",
    		description: "Ancestress who possesses the book of fate in Mongol, Tibetan, Buriat mythologies.",
    		bio: "",
    		search_term: "",
    		diameter: "1,354.0",
    		center_lat: 39,
    		center_long: 359.5
    	},
    	{
    		feature_id: 3927,
    		year: 1985,
    		feature: "Chasma",
    		feature_plural: "Chasmata",
    		name: "Misne Chasma",
    		type: "Goddess",
    		origin: "Siberia",
    		continent: "Asia",
    		clean_name: "Misne",
    		description: "Mansi (Siberia) forest maiden.",
    		bio: "",
    		search_term: "",
    		diameter: "610.0",
    		center_lat: 78.3,
    		center_long: 316.5
    	},
    	{
    		feature_id: 4052,
    		year: 1985,
    		feature: "Chasma",
    		feature_plural: "Chasmata",
    		name: "Mots Chasma",
    		type: "Goddess",
    		origin: "Caucasus",
    		continent: "Asia",
    		clean_name: "Mots",
    		description: "Avarian (Caucasus) moon goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "464.0",
    		center_lat: 51.9,
    		center_long: 56.1
    	},
    	{
    		feature_id: 5422,
    		year: 1985,
    		feature: "Tholus",
    		feature_plural: "Tholi",
    		name: "Semele Tholi",
    		type: "Goddess",
    		origin: "Phoenician",
    		continent: "Asia",
    		clean_name: "Semele",
    		description: "Frygian (Phoenician) Earth goddess.",
    		bio: "Semele (; Ancient Greek: Σεμέλη Semelē), in Greek mythology, was the youngest daughter of Cadmus and Harmonia, and the mother of Dionysus by Zeus in one of his many origin myths.",
    		search_term: "Semele",
    		diameter: "194.0",
    		center_lat: 64.3,
    		center_long: 202.9
    	},
    	{
    		feature_id: 5426,
    		year: 1985,
    		feature: "Dorsum",
    		feature_plural: "Dorsa",
    		name: "Semuni Dorsa",
    		type: "Goddess",
    		origin: "Siberia",
    		continent: "Asia",
    		clean_name: "Semuni",
    		description: "Ulchian (Siberia) sky goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "514.0",
    		center_lat: 75.9,
    		center_long: 8
    	},
    	{
    		feature_id: 5489,
    		year: 1985,
    		feature: "Tessera",
    		feature_plural: "Tesserae",
    		name: "Shimti Tessera",
    		type: "Goddess",
    		origin: "Babylon",
    		continent: "Asia",
    		clean_name: "Shimti",
    		description: "Babylonian; Ishtar as the goddess of fate.",
    		bio: "",
    		search_term: "",
    		diameter: "1,275.0",
    		center_lat: 31.9,
    		center_long: 97.7
    	},
    	{
    		feature_id: 6056,
    		year: 1985,
    		feature: "Dorsum",
    		feature_plural: "Dorsa",
    		name: "Tomem Dorsa",
    		type: "Goddess",
    		origin: "Siberia",
    		continent: "Asia",
    		clean_name: "Tomem",
    		description: "Ketian (Siberia) Mother of the hot; lives in the sky, near the Sun.",
    		bio: "",
    		search_term: "",
    		diameter: "970.0",
    		center_lat: 31.2,
    		center_long: 7.2
    	},
    	{
    		feature_id: 6151,
    		year: 1985,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Tusholi Corona",
    		type: "Goddess",
    		origin: "Caucasus",
    		continent: "Asia",
    		clean_name: "Tusholi",
    		description: "Chechen and Ingush (Caucasus) goddess of fertility.",
    		bio: "Tusholi (Тушоли) is a goddess of Spring and fertility in Ingush and Chechen mythology and the daughter of the supreme god Dyala. She was the best-loved goddess of the Vainakh peoples before their adoption of Islam, revered as the patroness of her people and believed to intercede on their behalf with her father, the more aloof Dyala. Tusholi was the only deity of the Vainakh pantheon who was depicted regularly in an icon - usually a wooden or silver belt ornament depicting a woman with a tear on her cheek.",
    		search_term: "Tusholi",
    		diameter: "350.0",
    		center_lat: 69.5,
    		center_long: 101.2
    	},
    	{
    		feature_id: 6230,
    		year: 1985,
    		feature: "Rupes",
    		feature_plural: "Rupēs",
    		name: "Uorsar Rupes",
    		type: "Goddess",
    		origin: "Caucasus",
    		continent: "Asia",
    		clean_name: "Uorsar",
    		description: "Adygan (Caucasus) goddess of hearth.",
    		bio: "",
    		search_term: "",
    		diameter: "820.0",
    		center_lat: 76.8,
    		center_long: 341.2
    	},
    	{
    		feature_id: 6233,
    		year: 1985,
    		feature: "Tholus",
    		feature_plural: "Tholi",
    		name: "Upunusa Tholus",
    		type: "Goddess",
    		origin: "Indonesia",
    		continent: "Asia",
    		clean_name: "Upunusa",
    		description: "Earth goddess of Leti and Babar (Southwestern islands, eastern Indonesia).",
    		bio: "",
    		search_term: "",
    		diameter: "223.0",
    		center_lat: 66.2,
    		center_long: 252.4
    	},
    	{
    		feature_id: 6323,
    		year: 1985,
    		feature: "Dorsum",
    		feature_plural: "Dorsa",
    		name: "Varma-Ava Dorsa",
    		type: "Goddess",
    		origin: "Mordvinian",
    		continent: "Asia",
    		clean_name: "Varma-Ava",
    		description: "Mordvinian (Volga Finn) wind goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "767.0",
    		center_lat: 62.3,
    		center_long: 268.8
    	},
    	{
    		feature_id: 6326,
    		year: 1985,
    		feature: "Chasma",
    		feature_plural: "Chasmata",
    		name: "Varz Chasma",
    		type: "Goddess",
    		origin: "Caucasus",
    		continent: "Asia",
    		clean_name: "Varz",
    		description: "Lezghin (Caucasus) moon goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "346.0",
    		center_lat: 71.3,
    		center_long: 27
    	},
    	{
    		feature_id: 6589,
    		year: 1985,
    		feature: "Tholus",
    		feature_plural: "Tholi",
    		name: "Wurunsemu Tholus",
    		type: "Goddess",
    		origin: "Turkey",
    		continent: "Asia",
    		clean_name: "Wurunsemu",
    		description: "Hatti (proto-Hittite) sun goddess and mother of gods.",
    		bio: "",
    		search_term: "",
    		diameter: "83.0",
    		center_lat: 40.6,
    		center_long: 209.9
    	},
    	{
    		feature_id: 2098,
    		year: 1985,
    		feature: "Planitia",
    		feature_plural: "Planitiae",
    		name: "Ganiki Planitia",
    		type: "Heroine",
    		origin: "Siberia",
    		continent: "Asia",
    		clean_name: "Ganiki ",
    		description: "Orochian (Siberia) water spirit, mermaid.",
    		bio: "",
    		search_term: "",
    		diameter: "5,160.0",
    		center_lat: 40,
    		center_long: 202
    	},
    	{
    		feature_id: 128,
    		year: 1985,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Akhmatova",
    		type: "Famous Woman",
    		origin: "Soviet",
    		continent: "Europe",
    		clean_name: "Akhmatova",
    		description: "Anna; Soviet poet (1889-1966).",
    		bio: "Anna Andreyevna Gorenko (23 June [O.S. 11 June] 1889 – 5 March 1966), better known by the pen name Anna Akhmatova, was one of the most significant Russian poets of 20th century. She was shortlisted for the Nobel Prize in 1965 and received second-most (three) nominations for the award the following year. Akhmatova's work ranges from short lyric poems to intricately structured cycles, such as Requiem (1935–40), her tragic masterpiece about the Stalinist terror.",
    		search_term: "Anna Akhmatova",
    		diameter: "41.4",
    		center_lat: 61.3,
    		center_long: 307.9
    	},
    	{
    		feature_id: 619,
    		year: 1985,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Barsova",
    		type: "Famous Woman",
    		origin: "Soviet",
    		continent: "Europe",
    		clean_name: "Barsova",
    		description: "Valeria; Soviet singer (1892-1967).",
    		bio: "Valeria Vladimirovna Barsova (Russian: Вале́рия Влади́мировна Ба́рсова; Astrakhan, 13 June 1892 – Sochi, 13 December 1967), PAU, was a Russian operatic soprano, one of the leading lyric-coloratura sopranos of the first half of the 20th century in Russia. Valeria Barsova first studied the piano with Estonian composer Artur Kapp. She then studied singing at the Moscow Conservatory with Mazetti.",
    		search_term: "Valeria Barsova",
    		diameter: "76.0",
    		center_lat: 61.3,
    		center_long: 223
    	},
    	{
    		feature_id: 622,
    		year: 1985,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Barto",
    		type: "Famous Woman",
    		origin: "Soviet",
    		continent: "Europe",
    		clean_name: "Barto",
    		description: "Agniya; Soviet poet (1906-1981).",
    		bio: "Agniya Lvovna Barto (Russian: А́гния Льво́вна Барто́, IPA: [ˈaɡnʲɪjə ˈlʲvovnə bɐrˈto] ; 17 February [O.S. 4 February] 1901 – 1 April 1981) was a Soviet poet and children's writer of Russian Jewish origin.",
    		search_term: "Agniya Barto",
    		diameter: "48.0",
    		center_lat: 45.3,
    		center_long: 146.3
    	},
    	{
    		feature_id: 706,
    		year: 1985,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Bernhardt",
    		type: "Famous Woman",
    		origin: "France",
    		continent: "Europe",
    		clean_name: "Bernhardt",
    		description: "Sarah; French actress (1844-1923).",
    		bio: "Sarah Bernhardt (French: [saʁa bɛʁnɑʁt]; born Henriette-Rosine Bernard; 22 or 23 October 1844 – 26 March 1923) was a French stage actress who starred in some of the most popular French plays of the late 19th and early 20th centuries, including La Dame Aux Camelias by Alexandre Dumas fils; Ruy Blas by Victor Hugo, Fédora and La Tosca by Victorien Sardou, and L'Aiglon by Edmond Rostand. She also played male roles, including Shakespeare's Hamlet. Rostand called her 'the queen of the pose and the princess of the gesture', while Hugo praised her 'golden voice'.",
    		search_term: "Sarah Bernhardt",
    		diameter: "25.3",
    		center_lat: 31.6,
    		center_long: 84.4
    	},
    	{
    		feature_id: 896,
    		year: 1985,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Browning",
    		type: "Famous Woman",
    		origin: "Great Britain",
    		continent: "Europe",
    		clean_name: "Browning",
    		description: "Elizabeth; British poet (1806-1861).",
    		bio: "Elizabeth Barrett Browning (née Moulton-Barrett; 6 March 1806 – 29 June 1861) was an English poet of the Victorian era, popular in Britain and the United States during her lifetime. Born in County Durham, the eldest of 12 children, Elizabeth Barrett wrote poetry from the age of eleven. Her mother's collection of her poems forms one of the largest extant collections of juvenilia by any English writer.",
    		search_term: "Elizabeth Barrett Browning",
    		diameter: "23.4",
    		center_lat: 28.3,
    		center_long: 4.9
    	},
    	{
    		feature_id: 1201,
    		year: 1985,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Christie",
    		type: "Famous Woman",
    		origin: "Great Britain",
    		continent: "Europe",
    		clean_name: "Christie",
    		description: "Agatha; British novelist (1891-1976).",
    		bio: "Dame Agatha Mary Clarissa Christie, Lady Mallowan, (née Miller; 15 September 1890 – 12 January 1976) was an English writer known for her 66 detective novels and 14 short story collections, particularly those revolving around fictional detectives Hercule Poirot and Miss Marple. She also wrote the world's longest-running play, the murder mystery The Mousetrap, which has been performed in the West End since 1952. A writer during the 'Golden Age of Detective Fiction', Christie has been called the 'Queen of Crime'.",
    		search_term: "Agatha Christie",
    		diameter: "23.3",
    		center_lat: 28.3,
    		center_long: 72.7
    	},
    	{
    		feature_id: 1321,
    		year: 1985,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Cotton",
    		type: "Famous Woman",
    		origin: "France",
    		continent: "Europe",
    		clean_name: "Cotton",
    		description: "Egenni; French physicist (1881-1967).",
    		bio: "Eugénie Cotton (13 October 1881 – 16 June 1967) was a French scientist, socialist, women's rights advocate and was active in the resistance. She was awarded the Stalin Peace Prize in 1951, Knight of the Legion of Honor, and the Gold medal from the World Peace Council in 1961. She died at 85 in Sèvres, near Paris.",
    		search_term: "Eugénie Cotton",
    		diameter: "48.1",
    		center_lat: 70.8,
    		center_long: 300.2
    	},
    	{
    		feature_id: 1422,
    		year: 1985,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Dashkova",
    		type: "Famous Woman",
    		origin: "Russia",
    		continent: "Europe",
    		clean_name: "Dashkova",
    		description: "Yekaterina; Russian philologist (1743-1810).",
    		bio: "Yekaterina Romanovna Vorontsova (Russian: Екатери́на Рома́новна Воронцо́ва) (28 March, 1743 – 15 January, 1810) was an influential noblewoman, a major figure of the Russian Enlightenment and a close friend of Empress Catherine the Great. She was part of the coup d'état that placed Catherine on the throne, the first woman in the world to head a national academy of sciences, the first woman in Europe to hold a government office and the president of the Russian Academy, which she helped found. She also published prolifically, with original and translated works on many subjects, and was invited by Benjamin Franklin to become the first female member of the American Philosophical Society.",
    		search_term: "Yekaterina Vorontsova-Dashkova",
    		diameter: "45.1",
    		center_lat: 78.2,
    		center_long: 306.5
    	},
    	{
    		feature_id: 1464,
    		year: 1985,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Deken",
    		type: "Famous Woman",
    		origin: "Netherlands",
    		continent: "Europe",
    		clean_name: "Deken",
    		description: "Agatha; Dutch novelist (1741-1804).",
    		bio: "Agatha ('Aagje') Deken (1741 in Nieuwer-Amstel – 14 November 1804, in The Hague) was a Dutch writer. Agatha Deken was born in 1741. In 1745, after her parents died, she went to live in the 'Oranje Appel' orphanage in Amsterdam, where she remained until 1767.",
    		search_term: "Agatha Deken",
    		diameter: "48.0",
    		center_lat: 47.1,
    		center_long: 288.5
    	},
    	{
    		feature_id: 1469,
    		year: 1985,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Deledda",
    		type: "Famous Woman",
    		origin: "Italy",
    		continent: "Europe",
    		clean_name: "Deledda",
    		description: "Grazia; Italian novelist (1871-1936).",
    		bio: "Grazia Maria Cosima Damiana Deledda (Italian pronunciation: [ˈɡrattsja deˈlɛdda]; 27 September 1871 – 15 August 1936), also known in Sardinian language as Gràssia or Gràtzia Deledda (pronounced [ˈɡɾa(t)si.a ðɛˈlɛɖːa]), was an Italian writer who received the Nobel Prize for Literature in 1926 'for her idealistically inspired writings which with plastic clarity picture the life on her native island [i.e. Sardinia] and with depth and sympathy deal with human problems in general'. She was the first Italian woman to receive the prize, and only the second woman in general after Selma Lagerlöf was awarded hers in 1909.",
    		search_term: "Grazia Deledda",
    		diameter: "32.0",
    		center_lat: 76,
    		center_long: 127.5
    	},
    	{
    		feature_id: 1721,
    		year: 1985,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Edgeworth",
    		type: "Famous Woman",
    		origin: "Ireland",
    		continent: "Europe",
    		clean_name: "Edgeworth",
    		description: "Maria; Irish writer (1767-1849).",
    		bio: "Maria Edgeworth (1 January 1768 – 22 May 1849) was a prolific Anglo-Irish novelist of adults' and children's literature. She was one of the first realist writers in children's literature and was a significant figure in the evolution of the novel in Europe. She held views on estate management, politics and education, and corresponded with some of the leading literary and economic writers, including Sir Walter Scott and David Ricardo.",
    		search_term: "Maria Edgeworth",
    		diameter: "29.0",
    		center_lat: 32.2,
    		center_long: 22.8
    	},
    	{
    		feature_id: 1726,
    		year: 1985,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Efimova",
    		type: "Famous Woman",
    		origin: "Soviet",
    		continent: "Europe",
    		clean_name: "Efimova",
    		description: "(Simonovich-Efimova) Nina; Soviet painter and puppet-theatre designer (1877-1948).",
    		bio: "Nina Yefimova (c. 1971 — May 9, 1996, Russia, Chechnya, Grozny) was a reporter for Vozrozhdeniye ('Revival'), a local Russian language newspaper in the Chechen capital Grozny. She was the 18th journalist to be killed in Chechnya since fighting escalated in December 1994.On May 9, 1996, Nina Yefimova, 25-year-old, was found dead from a shot to the back of the head.",
    		search_term: "Nina Yefimova",
    		diameter: "26.5",
    		center_lat: 81,
    		center_long: 223
    	},
    	{
    		feature_id: 1836,
    		year: 1985,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Ermolova",
    		type: "Famous Woman",
    		origin: "Russia",
    		continent: "Europe",
    		clean_name: "Ermolova",
    		description: "Mariya; Russian actress (1853-1928).",
    		bio: "",
    		search_term: "",
    		diameter: "60.9",
    		center_lat: 60.3,
    		center_long: 154.4
    	},
    	{
    		feature_id: 1927,
    		year: 1985,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Fedorets",
    		type: "Famous Woman",
    		origin: "Soviet",
    		continent: "Europe",
    		clean_name: "Fedorets",
    		description: "Velentina; Soviet astronomer (1923-1976).",
    		bio: "",
    		search_term: "",
    		diameter: "57.6",
    		center_lat: 59.7,
    		center_long: 65.6
    	},
    	{
    		feature_id: 1941,
    		year: 1985,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Fernandez",
    		type: "Famous Woman",
    		origin: "Spain",
    		continent: "Europe",
    		clean_name: "Fernandez",
    		description: "M. A.; Spanish actress (18th century).",
    		bio: "María Antonia Vallejo Fernández (9 March 1751 – 10 June 1787), also known as La Caramba, was a Spanish singer and dancer of tonadilla music. María was born on 9 March 1751 to Bernardo Vallejo and María Manuela Fernández. She left home in 1776 to pursue her career in Madrid.",
    		search_term: "La Caramba",
    		diameter: "23.7",
    		center_lat: 76.2,
    		center_long: 17.2
    	},
    	{
    		feature_id: 2216,
    		year: 1985,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Golubkina",
    		type: "Famous Woman",
    		origin: "Soviet",
    		continent: "Europe",
    		clean_name: "Golubkina",
    		description: "Anna; Soviet sculptor (1864-1927).",
    		bio: "Anna Semyonovna Golubkina (Russian: Анна Семёновна Голубкина; January 28, 1864 – September 7, 1927) was a Russian impressionist sculptor. As the first Russian sculptor to receive the Paris Salon prize, she is regarded as the first female Russian sculptor of note. Golubkina also had an exhibition at the prestigious Alexander III Museum.",
    		search_term: "Anna Golubkina",
    		diameter: "28.4",
    		center_lat: 60.3,
    		center_long: 286.5
    	},
    	{
    		feature_id: 2566,
    		year: 1985,
    		feature: "Patera",
    		feature_plural: "Paterae",
    		name: "Hroswitha Patera",
    		type: "Famous Woman",
    		origin: "Germany",
    		continent: "Europe",
    		clean_name: "Hroswitha",
    		description: "German writer (c. A.D. 935-975).",
    		bio: "Hrotsvitha (c. 935–973) was a secular canoness who wrote drama and Christian poetry under the Ottonian dynasty. She was born in Bad Gandersheim to Saxon nobles and entered Gandersheim Abbey as a canoness.",
    		search_term: "Hroswitha",
    		diameter: "163.0",
    		center_lat: 35.8,
    		center_long: 34.8
    	},
    	{
    		feature_id: 2963,
    		year: 1985,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Kauffman",
    		type: "Famous Woman",
    		origin: "Germany",
    		continent: "Europe",
    		clean_name: "Kauffman",
    		description: "Angelica; German painter (1741-1807).",
    		bio: "Maria Anna Angelika Kauffmann ( KOWF-mən; 30 October 1741 – 5 November 1807), usually known in English as Angelica Kauffman, was a Swiss Neoclassical painter who had a successful career in London and Rome. Remembered primarily as a history painter, Kauffmann was a skilled portraitist, landscape and decoration painter. She was, along with Mary Moser, one of two female painters among the founding members of the Royal Academy in London in 1768.",
    		search_term: "Angelica Kauffman",
    		diameter: "25.5",
    		center_lat: 49.4,
    		center_long: 27.1
    	},
    	{
    		feature_id: 2985,
    		year: 1985,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Kemble",
    		type: "Famous Woman",
    		origin: "Great Britain",
    		continent: "Europe",
    		clean_name: "Kemble",
    		description: "Fanny; English actress (1809-1893).",
    		bio: "Frances Anne 'Fanny' Kemble (27 November 1809 – 15 January 1893) was a British actress from a theatre family in the early and mid-19th century. She was a well-known and popular writer and abolitionist, whose published works included plays, poetry, eleven volumes of memoirs, travel writing and works about the theatre. Kemble's 'lasting historical importance...derives from the private journal she kept during her time in the Sea Islands' on her husband's plantations, where she wrote a journal documenting the conditions of the enslaved people on the plantation and her growing abolitionist feelings.",
    		search_term: "Fanny Kemble",
    		diameter: "23.6",
    		center_lat: 47.7,
    		center_long: 14.9
    	},
    	{
    		feature_id: 3063,
    		year: 1985,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Klenova",
    		type: "Famous Woman",
    		origin: "Soviet",
    		continent: "Europe",
    		clean_name: "Klenova",
    		description: "Mariya; Soviet marine geologist (c. 1910-1978).",
    		bio: "Maria Vasilyevna Klenova (or Klyonova) (Russian: Мари́я Васи́льевна Клёнова; 12 August 1898 – 6 August 1976) was a Russian and Soviet marine geologist and one of the founders of Russian marine science and contributor to the first Soviet Antarctic atlas.Klenova studied to become a professor and later on worked as a member of the Council for Antarctic Research of the USSR Academy of Sciences. During that time she spent nearly thirty years researching in the Polar Regions and become the first woman scientist to do research in Antarctica. She joined in the First Soviet Antarctic Expedition (1955–57) and worked with ANARE (Australian National Antarctic Research Expeditions) at Macquarie Island.",
    		search_term: "Mariya Klenova",
    		diameter: "141.0",
    		center_lat: 78.1,
    		center_long: 104.5
    	},
    	{
    		feature_id: 3072,
    		year: 1985,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Koidula",
    		type: "Famous Woman",
    		origin: "Estonia",
    		continent: "Europe",
    		clean_name: "Koidula",
    		description: "Lydia; Estonian poet (1843-1886).",
    		bio: "Lydia Emilie Florentine Jannsen, (24 December [O.S. 12 December] 1843 – 11 August [O.S. 30 July] 1886), known by her pen name Lydia Koidula, was an Estonian poet. Her sobriquet means 'Lydia of the Dawn' in Estonian. It was given to her by the writer Carl Robert Jakobson.",
    		search_term: "Lydia Koidula",
    		diameter: "67.0",
    		center_lat: 64.2,
    		center_long: 139.6
    	},
    	{
    		feature_id: 3100,
    		year: 1985,
    		feature: "Patera",
    		feature_plural: "Paterae",
    		name: "Kottauer Patera",
    		type: "Famous Woman",
    		origin: "Austria",
    		continent: "Europe",
    		clean_name: "Kottauer",
    		description: "Helena; Austrian historical writer (1410-1471).",
    		bio: "",
    		search_term: "",
    		diameter: "136.0",
    		center_lat: 36.7,
    		center_long: 39.6
    	},
    	{
    		feature_id: 3187,
    		year: 1985,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "La Fayette",
    		type: "Famous Woman",
    		origin: "France",
    		continent: "Europe",
    		clean_name: "La Fayette",
    		description: "Marie; French novelist (1634-1693).",
    		bio: "Marie-Madeleine Pioche de La Vergne, Comtesse de La Fayette (baptized 18 March 1634 – 25 May 1693), better known as Madame de La Fayette, was a French writer; she authored La Princesse de Clèves, France's first historical novel and one of the earliest novels in literature. Christened Marie-Madeleine Pioche de La Vergne, she was born in Paris to a family of minor but wealthy nobility. At 16, de la Vergne became the maid of honour to Queen Anne of Austria and began also to acquire a literary education from Gilles Ménage, who gave her lessons in Italian and Latin.",
    		search_term: "Madame de La Fayette",
    		diameter: "39.6",
    		center_lat: 70.2,
    		center_long: 107.6
    	},
    	{
    		feature_id: 3232,
    		year: 1985,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Lagerlöf",
    		type: "Famous Woman",
    		origin: "Sweden",
    		continent: "Europe",
    		clean_name: "Lagerlöf",
    		description: "Selma; Swedish novelist (1858-1940).",
    		bio: "Selma Ottilia Lovisa Lagerlöf (, US also , Swedish: [ˈsɛ̂lːma ˈlɑ̂ːɡɛˌɭøːv] ; 20 November 1858 – 16 March 1940) was a Swedish author. She published her first novel, Gösta Berling's Saga, at the age of 33. She was the first woman to win the Nobel Prize in Literature, which she was awarded in 1909.",
    		search_term: "Selma Lagerlöf",
    		diameter: "56.0",
    		center_lat: 81.2,
    		center_long: 285.2
    	},
    	{
    		feature_id: 3266,
    		year: 1985,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Landowska",
    		type: "Famous Woman",
    		origin: "Poland",
    		continent: "Europe",
    		clean_name: "Landowska",
    		description: "Wanda; Polish pianist (1877-1959).",
    		bio: "Wanda Aleksandra Landowska (5 July 1879 – 16 August 1959) was a Polish harpsichordist and pianist whose performances, teaching, writings and especially her many recordings played a large role in reviving the popularity of the harpsichord in the early 20th century. She was the first person to record Johann Sebastian Bach's Goldberg Variations on the harpsichord in 1933. She became a naturalized French citizen in 1938.",
    		search_term: "Wanda Landowska",
    		diameter: "33.0",
    		center_lat: 84.6,
    		center_long: 74.3
    	},
    	{
    		feature_id: 3405,
    		year: 1985,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Lind",
    		type: "Famous Woman",
    		origin: "Sweden",
    		continent: "Europe",
    		clean_name: "Lind",
    		description: "Jenny; Swedish singer (1820-1887).",
    		bio: "Johanna Maria 'Jenny' Lind (6 October 1820 – 2 November 1887) was a Swedish opera singer, often called the 'Swedish Nightingale'. One of the most highly regarded singers of the 19th century, she performed in soprano roles in opera in Sweden and across Europe, and undertook an extraordinarily popular concert tour of the United States beginning in 1850. She was a member of the Royal Swedish Academy of Music from 1840.",
    		search_term: "Jenny Lind",
    		diameter: "25.8",
    		center_lat: 50.2,
    		center_long: 355
    	},
    	{
    		feature_id: 3582,
    		year: 1985,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Magnani",
    		type: "Famous Woman",
    		origin: "Italy",
    		continent: "Europe",
    		clean_name: "Magnani",
    		description: "Anna; Italian actress (1908-1973).",
    		bio: "Anna Maria Magnani (Italian pronunciation: [ˈanna maɲˈɲaːni]; 7 March 1908 – 26 September 1973) was an Italian actress. She was known for her explosive acting and earthy, realistic portrayals of characters. Born in Rome, she worked her way through Rome's Academy of Dramatic Art by singing at night clubs.",
    		search_term: "Anna Magnani",
    		diameter: "26.4",
    		center_lat: 58.6,
    		center_long: 337.2
    	},
    	{
    		feature_id: 4020,
    		year: 1985,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Montessori",
    		type: "Famous Woman",
    		origin: "Italy",
    		continent: "Europe",
    		clean_name: "Montessori",
    		description: "Maria; Italian educator (1870-1952).",
    		bio: "Maria Tecla Artemisia Montessori ( MON-tiss-OR-ee, Italian: [maˈriːa montesˈsɔːri]; August 31, 1870 – May 6, 1952) was an Italian physician and educator best known for the philosophy of education that bears her name, and her writing on scientific pedagogy. At an early age, Montessori enrolled in classes at an all-boys technical school, with hopes of becoming an engineer. She soon had a change of heart and began medical school at the Sapienza University of Rome, becoming one of the first women to attend medical school in Italy; she graduated with honors in 1896.",
    		search_term: "Maria Montessori",
    		diameter: "42.1",
    		center_lat: 59.4,
    		center_long: 280
    	},
    	{
    		feature_id: 4063,
    		year: 1985,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Mukhina",
    		type: "Famous Woman",
    		origin: "Soviet",
    		continent: "Europe",
    		clean_name: "Mukhina",
    		description: "Vera; Soviet sculptor (1889-1953).",
    		bio: "Vera Ignatyevna Mukhina (Russian: Ве́ра Игна́тьевна Му́хина; Latvian: Vera Muhina; French: Vera Moukhina; 1 July [O.S. 19 June] 1889 – 6 October 1953) was a prominent Soviet sculptor and painter. She was nicknamed 'the queen of Soviet sculpture'. Mukhina was born 1889 in Riga, Russian Empire into a wealthy merchant family, and lived at 23/25 Turgeneva Street, where a memorial plaque has now been placed.",
    		search_term: "Vera Mukhina",
    		diameter: "24.5",
    		center_lat: 29.5,
    		center_long: 0.5
    	},
    	{
    		feature_id: 4262,
    		year: 1985,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Nightingale Corona",
    		type: "Famous Woman",
    		origin: "Great Britain",
    		continent: "Europe",
    		clean_name: "Nightingale",
    		description: "Florence; English nurse (1820-1910).",
    		bio: "Florence Nightingale (; 12 May 1820 – 13 August 1910) was an English social reformer, statistician and the founder of modern nursing. Nightingale came to prominence while serving as a manager and trainer of nurses during the Crimean War, in which she organised care for wounded soldiers at Constantinople. She significantly reduced death rates by improving hygiene and living standards.",
    		search_term: "Florence Nightingale",
    		diameter: "471.0",
    		center_lat: 63.6,
    		center_long: 129.5
    	},
    	{
    		feature_id: 4391,
    		year: 1985,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Obukhova",
    		type: "Famous Woman",
    		origin: "Soviet",
    		continent: "Europe",
    		clean_name: "Obukhova",
    		description: "Nadezhda; Soviet singer (1886-1961).",
    		bio: "Nadezhda Andreyevna Obukhova (Russian: Наде́жда Андре́евна Обу́хова, 1886–1961) was a Russian mezzo-soprano. She was awarded the title People’s Artist of the USSR in 1937. Pianist Heinrich Neuhaus said that 'he who even once hears her voice, will never forget it...'.",
    		search_term: "Nadezhda Obukhova",
    		diameter: "46.0",
    		center_lat: 70.7,
    		center_long: 289.7
    	},
    	{
    		feature_id: 4494,
    		year: 1985,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Orlova",
    		type: "Famous Woman",
    		origin: "Soviet",
    		continent: "Europe",
    		clean_name: "Orlova",
    		description: "Lyubov; Soviet actress (1902-1975).",
    		bio: "Lyubov Petrovna Orlova (Russian: Любовь Петровна Орлова [lʲʊˈbofʲ pʲɪˈtrovnə ɐrˈɫovə] ; 11 February [O.S. 29 January] 1902 – 26 January 1975) was a Soviet and Russian actress, singer, dancer and People's Artist of the USSR (1950). She was born to a family of Russian hereditary nobles, her maternal side, and gentry, her paternal side. in Zvenigorod, 60 km from Moscow, then lived with her parents and older sister in Yaroslavl.",
    		search_term: "Lyubov Orlova",
    		diameter: "19.6",
    		center_lat: 56.5,
    		center_long: 235
    	},
    	{
    		feature_id: 4507,
    		year: 1985,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Osipenko",
    		type: "Famous Woman",
    		origin: "Soviet",
    		continent: "Europe",
    		clean_name: "Osipenko",
    		description: "Polina; Soviet aviator (1907-1939).",
    		bio: "Polina Denisovna Osipenko (Russian: Полина Денисовна Осипенко, Ukrainian: Поліна Денисівна Осипенко, romanized: Polina Denysivna Osypenko; 8 October 1907 – 11 May 1939) was a Soviet military pilot, most notable as the co-pilot who, together with Valentina Grizodubova and Marina Raskova on September 24–25, 1938 performed a non-stop flight between Moscow and the Sea of Okhotsk, setting a new distance record for non-stop flights operated by women. For this achievement, she and her two colleagues were named Hero of the Soviet Union, the first three women to receive highest military distinction in Soviet Union on 2 November 1938. Osipenko was born as Polina Dudnik in 1907 in Novospasovka, Yekaterinoslav Governorate (currently Zaporizhzhia Oblast of Ukraine) to a Ukrainian peasant family and the ninth child born to her family.",
    		search_term: "Polina Osipenko",
    		diameter: "30.0",
    		center_lat: 71.2,
    		center_long: 321
    	},
    	{
    		feature_id: 4612,
    		year: 1985,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Patti",
    		type: "Famous Woman",
    		origin: "Italy",
    		continent: "Europe",
    		clean_name: "Patti",
    		description: "Adelina; Italian singer (1843-1919).",
    		bio: "Adelina Patti (19 February 1843 – 27 September 1919) was an Italian 19th-century opera singer, earning huge fees at the height of her career in the music capitals of Europe and America. She first sang in public as a child in 1851, and gave her last performance before an audience in 1914. Along with her near contemporaries Jenny Lind and Thérèse Tietjens, Patti remains one of the most famous sopranos in history, owing to the purity and beauty of her lyrical voice and the unmatched quality of her bel canto technique.",
    		search_term: "Adelina Patti",
    		diameter: "47.0",
    		center_lat: 35,
    		center_long: 301.6
    	},
    	{
    		feature_id: 4810,
    		year: 1985,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Potanina",
    		type: "Famous Woman",
    		origin: "Russia",
    		continent: "Europe",
    		clean_name: "Potanina",
    		description: "Aleksandra; Russian explorer (1843-1893).",
    		bio: "Aleksandra Potanina (1843–1893), was a Russian explorer. She was married to Grigory Potanin. One of the craters of Venus is named after her.",
    		search_term: "Aleksandra Potanina",
    		diameter: "94.2",
    		center_lat: 31.6,
    		center_long: 53.1
    	},
    	{
    		feature_id: 5197,
    		year: 1985,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Rossetti",
    		type: "Famous Woman",
    		origin: "Great Britain",
    		continent: "Europe",
    		clean_name: "Rossetti",
    		description: "Christina; English poet (1830-1894).",
    		bio: "Christina Georgina Rossetti (5 December 1830 – 29 December 1894) was an English writer of romantic, devotional and children's poems, including 'Goblin Market' and 'Remember'. She also wrote the words of two Christmas carols well known in Britain: 'In the Bleak Midwinter', later set by Gustav Holst, Katherine Kennicott Davis, and Harold Darke, and 'Love Came Down at Christmas', also set by Darke and other composers. She was a sister of the artist and poet Dante Gabriel Rossetti and features in several of his paintings.",
    		search_term: "Christina Rossetti",
    		diameter: "23.4",
    		center_lat: 57,
    		center_long: 6.4
    	},
    	{
    		feature_id: 5217,
    		year: 1985,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Rudneva",
    		type: "Famous Woman",
    		origin: "Russia",
    		continent: "Europe",
    		clean_name: "Rudneva",
    		description: "Varvara; Russian physician (1844-1899).",
    		bio: "Varvara Aleksandrova Kashevarova-Rudneva (1842–1899), was a Russian Empire medical doctor. Rudneva was the second woman in Russia to become a doctor, after Nadezhda Suslova. She was the first woman in Russia to become a doctor and to have completed their education at a Russian medical school, an event which occurred at a time when women were barred receiving training at such universities.",
    		search_term: "Varvara Rudneva",
    		diameter: "29.8",
    		center_lat: 78.4,
    		center_long: 174.7
    	},
    	{
    		feature_id: 5234,
    		year: 1985,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Ruslanova",
    		type: "Famous Woman",
    		origin: "Soviet",
    		continent: "Europe",
    		clean_name: "Ruslanova",
    		description: "Lidiya; Soviet singer (1900-1973).",
    		bio: "Lidia Andreyevna Ruslanova (sometimes spelt Lidiya or Lydia, Russian: Лидия Андреевна Русланова; 27 October 1900 in Saratov Governorate – 21 September 1973 in Moscow) was a performer of Russian folk songs. She was born in the village of Chernavka near Saratov, into a peasant family, and was baptized as Praskovya Andrianovna Leykina-Gorshenina (Russian: Прасковья Андриановна Ле́йкина-Горшенина). Her mother was an Erzya by ethnicity.",
    		search_term: "Lidia Ruslanova",
    		diameter: "44.3",
    		center_lat: 83.9,
    		center_long: 16.6
    	},
    	{
    		feature_id: 5800,
    		year: 1985,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Sévigné",
    		type: "Famous Woman",
    		origin: "France",
    		continent: "Europe",
    		clean_name: "Sévigné",
    		description: "Marie; French writer (1626-1696).",
    		bio: "Marie de Rabutin-Chantal, marquise de Sévigné (5 February 1626 – 17 April 1696), also widely known as Madame de Sévigné or Mme de Sévigné, was a French aristocrat, remembered for her letter-writing. Most of her letters, celebrated for their wit and vividness, were addressed to her daughter, Françoise-Marguerite de Sévigné. She is revered in France as one of the great icons of French 17th-century literature.",
    		search_term: "Marie de Rabutin-Chantal, marquise de Sévigné",
    		diameter: "29.6",
    		center_lat: 52.6,
    		center_long: 326.5
    	},
    	{
    		feature_id: 5820,
    		year: 1985,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Taglioni",
    		type: "Famous Woman",
    		origin: "Italy",
    		continent: "Europe",
    		clean_name: "Taglioni",
    		description: "Maria; Italian ballet dancer (1804-1884).",
    		bio: "Marie Taglioni, Comtesse de Voisins (23 April 1804 – 22 April 1884) was a Swedish-born ballet dancer of the Romantic ballet era partially of Italian descent, a central figure in the history of European dance. She spent most of her life in the Austrian Empire and France. She was one of the most celebrated ballerinas of the romantic ballet, which was cultivated primarily at Her Majesty's Theatre in London and at the Théâtre de l'Académie Royale de Musique of the Paris Opera Ballet.",
    		search_term: "Maria Taglioni",
    		diameter: "31.0",
    		center_lat: 41.7,
    		center_long: 122.6
    	},
    	{
    		feature_id: 6103,
    		year: 1985,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Tseraskaya",
    		type: "Famous Woman",
    		origin: "Soviet",
    		continent: "Europe",
    		clean_name: "Tseraskaya",
    		description: "Lidiya; Soviet astronomer (1855-1931).",
    		bio: "Lidiya Petrovna Tseraskaya née Shelekhova (Russian: Лидия Петровна Цераская) (22 June 1855 – 24 December 1931) was a Russian astronomer.Tseraskaya was born in Astrakhan, and graduated from the Teacher's Institute in Petersberg. She worked at the Moscow Observatory, where she discovered 219 variable stars; among them (1905) RV Tauri variable and recognized its uniqueness. The Venusian crater Tseraskaya was named after her.",
    		search_term: "Lidiya Tseraskaya",
    		diameter: "30.3",
    		center_lat: 28.6,
    		center_long: 79.2
    	},
    	{
    		feature_id: 6114,
    		year: 1985,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Tsvetayeva",
    		type: "Famous Woman",
    		origin: "Soviet",
    		continent: "Europe",
    		clean_name: "Tsvetayeva",
    		description: "Marina; Soviet poet (1892-1941).",
    		bio: "Marina Ivanovna Tsvetaeva (Russian: Марина Ивановна Цветаева; 8 October [O.S. 26 September] 1892 – 31 August 1941) was a Russian poet. Her work is considered among some of the greatest in twentieth century Russian literature. She lived through and wrote of the Russian Revolution of 1917 and the Moscow famine that followed it.",
    		search_term: "Marina Tsvetayeva",
    		diameter: "42.9",
    		center_lat: 64.6,
    		center_long: 147.4
    	},
    	{
    		feature_id: 6224,
    		year: 1985,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Undset",
    		type: "Famous Woman",
    		origin: "Norway",
    		continent: "Europe",
    		clean_name: "Undset",
    		description: "Sigrid; Norwegian author (1882-1949).",
    		bio: "Sigrid Undset (20 May 1882 – 10 June 1949) was a Norwegian-Danish novelist who was awarded the Nobel Prize for Literature in 1928.Undset was born in Kalundborg, Denmark, but her family moved to Norway when she was two years old. In 1924, she converted to Catholicism. She fled Norway for the United States in 1940 because of her opposition to Nazi Germany and the German invasion and occupation of Norway, but returned after World War II ended in 1945.",
    		search_term: "Sigrid Undset",
    		diameter: "20.0",
    		center_lat: 51.7,
    		center_long: 60.8
    	},
    	{
    		feature_id: 6429,
    		year: 1985,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Volkova",
    		type: "Famous Woman",
    		origin: "Russia",
    		continent: "Europe",
    		clean_name: "Volkova",
    		description: "Anna; Russian chemist (1800-1876).",
    		bio: "Anna Feodorovna Volkova (Russian: Анна Федоровна Волкова; died 1876) was a Russian chemist known for her work in organic chemistry. Volkova was the first chemist to prepare pure ortho-toluene sulfonic acid, its acyl chloride, and its amide (1870). She was the first chemist to synthesize para-tricresol phosphate from para-cresol, a component of plasticizer.",
    		search_term: "Anna Volkova",
    		diameter: "47.5",
    		center_lat: 75.2,
    		center_long: 242.2
    	},
    	{
    		feature_id: 6453,
    		year: 1985,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Voynich",
    		type: "Famous Woman",
    		origin: "Great Britain",
    		continent: "Europe",
    		clean_name: "Voynich",
    		description: "Lilian; English writer (1864-1960).",
    		bio: "Ethel Lilian Voynich, née Boole (11 May 1864 – 27 July 1960) was an Irish-born British novelist and musician, and a supporter of several revolutionary causes. She was born in Cork, but grew up in Lancashire, England. Voynich was a significant figure, not only on the late Victorian literary scene, but also in Russian émigré circles.",
    		search_term: "Ethel Voynich",
    		diameter: "48.7",
    		center_lat: 35.4,
    		center_long: 56.1
    	},
    	{
    		feature_id: 6622,
    		year: 1985,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Yablochkina",
    		type: "Famous Woman",
    		origin: "Soviet",
    		continent: "Europe",
    		clean_name: "Yablochkina",
    		description: "Aleksandra; Soviet actress (1866-1964).",
    		bio: "Aleksandra Aleksandrovna Yablochkina (Александра Александровна Яблочкина; November 3, 1866 - March 20, 1964) was a leading actress of the Maly Theatre in Moscow for more than 75 years. She studied acting under her father before joining the Korsh Theatre troupe in 1886. Two years later, she moved to the Maly, where she worked with Maria Yermolova and Alexander Yuzhin.",
    		search_term: "Aleksandra Yablochkina",
    		diameter: "64.3",
    		center_lat: 48.3,
    		center_long: 195.3
    	},
    	{
    		feature_id: 6731,
    		year: 1985,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Zhilova",
    		type: "Famous Woman",
    		origin: "Russia",
    		continent: "Europe",
    		clean_name: "Zhilova",
    		description: "Maria; Russian astronomer (1870-1934).",
    		bio: "Maria Vasilyevna Zhilova (1870–1934) was the first female Russian professional astronomer. She worked as astronomer and orbit calculator at the Pulkovo Observatory from 1895 to 1930.In 1905 she was given an award by the Russian Astronomical Society for her work in celestial mechanics.The asteroid 1255 Schilowa was named after her in 1932, at first spelled 'Shilowa'. The crater Zhilova on Venus was named after her in 1985.She was one of the women discussed in a 2017 conference on 'Women's Faces of Russian Science', where she was noted as 'one of the first professional woman astronomers'.",
    		search_term: "Maria Zhilova",
    		diameter: "53.0",
    		center_lat: 66.3,
    		center_long: 125.7
    	},
    	{
    		feature_id: 6769,
    		year: 1985,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Zvereva",
    		type: "Famous Woman",
    		origin: "Russia",
    		continent: "Europe",
    		clean_name: "Zvereva",
    		description: "Lidiya; Russian aviator (1890-1916).",
    		bio: "Lydia Vissarionovna Zvereva (13 August 1890 – 1 May 1916) was a Russian aviation pioneer who is credited with being the first woman in Russia to earn a pilot's license. Although she only lived to the age of 25, Zvereva is recognized for her feats as a female aviator. She competed in air shows in Eastern Europe, and later, with her husband Vladimir Victorovich Slusarenko, Zvereva operated an aircraft manufacturing factory in Riga.",
    		search_term: "Lydia Zvereva",
    		diameter: "22.9",
    		center_lat: 45.4,
    		center_long: 283.1
    	},
    	{
    		feature_id: 197,
    		year: 1985,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Almeida",
    		type: "First Name",
    		origin: "Portugal",
    		continent: "Europe",
    		clean_name: "Almeida",
    		description: "Portuguese first name.",
    		bio: "",
    		search_term: "",
    		diameter: "15.5",
    		center_lat: 46.6,
    		center_long: 123.3
    	},
    	{
    		feature_id: 299,
    		year: 1985,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Antonina",
    		type: "First Name",
    		origin: "Russia",
    		continent: "Europe",
    		clean_name: "Antonina",
    		description: "Russian first name.",
    		bio: "",
    		search_term: "",
    		diameter: "13.8",
    		center_lat: 28.1,
    		center_long: 106.8
    	},
    	{
    		feature_id: 308,
    		year: 1985,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Anya",
    		type: "First Name",
    		origin: "Russia",
    		continent: "Europe",
    		clean_name: "Anya",
    		description: "Russian first name.",
    		bio: "",
    		search_term: "",
    		diameter: "18.1",
    		center_lat: 39.5,
    		center_long: 297.8
    	},
    	{
    		feature_id: 374,
    		year: 1985,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Ariadne",
    		type: "First Name",
    		origin: "Greek",
    		continent: "Europe",
    		clean_name: "Ariadne",
    		description: "Greek first name.",
    		bio: "",
    		search_term: "",
    		diameter: "23.6",
    		center_lat: 43.9,
    		center_long: 360
    	},
    	{
    		feature_id: 713,
    		year: 1985,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Berta",
    		type: "First Name",
    		origin: "Finland",
    		continent: "Europe",
    		clean_name: "Berta",
    		description: "Finnish first name.",
    		bio: "",
    		search_term: "",
    		diameter: "20.0",
    		center_lat: 62,
    		center_long: 322
    	},
    	{
    		feature_id: 1567,
    		year: 1985,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Dolores",
    		type: "First Name",
    		origin: "Spain",
    		continent: "Europe",
    		clean_name: "Dolores",
    		description: "Spanish first name.",
    		bio: "",
    		search_term: "",
    		diameter: "12.6",
    		center_lat: 51.4,
    		center_long: 201.6
    	},
    	{
    		feature_id: 1829,
    		year: 1985,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Erika",
    		type: "First Name",
    		origin: "Hungary",
    		continent: "Europe",
    		clean_name: "Erika",
    		description: "Hungarian, German first name.",
    		bio: "",
    		search_term: "",
    		diameter: "10.5",
    		center_lat: 72,
    		center_long: 175.4
    	},
    	{
    		feature_id: 2026,
    		year: 1985,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Frida",
    		type: "First Name",
    		origin: "Sweden",
    		continent: "Europe",
    		clean_name: "Frida",
    		description: "Swedish first name.",
    		bio: "",
    		search_term: "",
    		diameter: "21.6",
    		center_lat: 68.2,
    		center_long: 55.6
    	},
    	{
    		feature_id: 2077,
    		year: 1985,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Galina",
    		type: "First Name",
    		origin: "Bulgaria",
    		continent: "Europe",
    		clean_name: "Galina",
    		description: "Bulgarian first name.",
    		bio: "",
    		search_term: "",
    		diameter: "16.8",
    		center_lat: 47.6,
    		center_long: 307.1
    	},
    	{
    		feature_id: 2168,
    		year: 1985,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Gina",
    		type: "First Name",
    		origin: "Italy",
    		continent: "Europe",
    		clean_name: "Gina",
    		description: "Italian first name.",
    		bio: "",
    		search_term: "",
    		diameter: "14.6",
    		center_lat: 78.1,
    		center_long: 76.5
    	},
    	{
    		feature_id: 2193,
    		year: 1985,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Gloria",
    		type: "First Name",
    		origin: "Portugal",
    		continent: "Europe",
    		clean_name: "Gloria",
    		description: "Portuguese first name.",
    		bio: "",
    		search_term: "",
    		diameter: "20.7",
    		center_lat: 68.5,
    		center_long: 94.2
    	},
    	{
    		feature_id: 2716,
    		year: 1985,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Irina",
    		type: "First Name",
    		origin: "Russia",
    		continent: "Europe",
    		clean_name: "Irina",
    		description: "Russian first name.",
    		bio: "",
    		search_term: "",
    		diameter: "15.2",
    		center_lat: 35,
    		center_long: 91.2
    	},
    	{
    		feature_id: 2762,
    		year: 1985,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Ivka",
    		type: "First Name",
    		origin: "Yugoslavia",
    		continent: "Europe",
    		clean_name: "Ivka",
    		description: "Serbocroatian first name.",
    		bio: "",
    		search_term: "",
    		diameter: "14.9",
    		center_lat: 68.2,
    		center_long: 303.8
    	},
    	{
    		feature_id: 2784,
    		year: 1985,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Jadwiga",
    		type: "First Name",
    		origin: "Poland",
    		continent: "Europe",
    		clean_name: "Jadwiga",
    		description: "Polish first name.",
    		bio: "",
    		search_term: "",
    		diameter: "12.7",
    		center_lat: 68.4,
    		center_long: 91
    	},
    	{
    		feature_id: 2813,
    		year: 1985,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Jeanne",
    		type: "First Name",
    		origin: "France",
    		continent: "Europe",
    		clean_name: "Jeanne",
    		description: "French first name.",
    		bio: "",
    		search_term: "",
    		diameter: "19.4",
    		center_lat: 40.1,
    		center_long: 331.5
    	},
    	{
    		feature_id: 2857,
    		year: 1985,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Julie",
    		type: "First Name",
    		origin: "Czechoslovakia",
    		continent: "Europe",
    		clean_name: "Julie",
    		description: "Czech, German first name.",
    		bio: "",
    		search_term: "",
    		diameter: "13.5",
    		center_lat: 51,
    		center_long: 242.6
    	},
    	{
    		feature_id: 3301,
    		year: 1985,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Laura",
    		type: "First Name",
    		origin: "Spain",
    		continent: "Europe",
    		clean_name: "Laura",
    		description: "Spanish, Italian first name.",
    		bio: "",
    		search_term: "",
    		diameter: "17.2",
    		center_lat: 48.9,
    		center_long: 141.2
    	},
    	{
    		feature_id: 3345,
    		year: 1985,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Lena",
    		type: "First Name",
    		origin: "Russia",
    		continent: "Europe",
    		clean_name: "Lena",
    		description: "Russian first name.",
    		bio: "",
    		search_term: "",
    		diameter: "15.2",
    		center_lat: 39.5,
    		center_long: 23
    	},
    	{
    		feature_id: 3403,
    		year: 1985,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Liliya",
    		type: "First Name",
    		origin: "Russia",
    		continent: "Europe",
    		clean_name: "Liliya",
    		description: "Russian first name.",
    		bio: "",
    		search_term: "",
    		diameter: "15.0",
    		center_lat: 30.2,
    		center_long: 31.1
    	},
    	{
    		feature_id: 3481,
    		year: 1985,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Lotta",
    		type: "First Name",
    		origin: "Sweden",
    		continent: "Europe",
    		clean_name: "Lotta",
    		description: "Swedish first name.",
    		bio: "",
    		search_term: "",
    		diameter: "11.8",
    		center_lat: 51.1,
    		center_long: 335.9
    	},
    	{
    		feature_id: 3542,
    		year: 1985,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Lyudmila",
    		type: "First Name",
    		origin: "Russia",
    		continent: "Europe",
    		clean_name: "Lyudmila",
    		description: "Russian first name.",
    		bio: "",
    		search_term: "",
    		diameter: "14.1",
    		center_lat: 62.1,
    		center_long: 329.7
    	},
    	{
    		feature_id: 3576,
    		year: 1985,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Magda",
    		type: "First Name",
    		origin: "Denmark",
    		continent: "Europe",
    		clean_name: "Magda",
    		description: "Danish first name.",
    		bio: "",
    		search_term: "",
    		diameter: "10.1",
    		center_lat: 67,
    		center_long: 329.7
    	},
    	{
    		feature_id: 3702,
    		year: 1985,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Margit",
    		type: "First Name",
    		origin: "Hungary",
    		continent: "Europe",
    		clean_name: "Margit",
    		description: "Hungarian first name.",
    		bio: "",
    		search_term: "",
    		diameter: "14.0",
    		center_lat: 60.1,
    		center_long: 273.1
    	},
    	{
    		feature_id: 3967,
    		year: 1985,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Monika",
    		type: "First Name",
    		origin: "Germany",
    		continent: "Europe",
    		clean_name: "Monika",
    		description: "German first name.",
    		bio: "",
    		search_term: "",
    		diameter: "25.5",
    		center_lat: 72.3,
    		center_long: 122.4
    	},
    	{
    		feature_id: 4134,
    		year: 1985,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Nana",
    		type: "First Name",
    		origin: "Yugoslavia",
    		continent: "Europe",
    		clean_name: "Nana",
    		description: "Serbocroatian first name.",
    		bio: "",
    		search_term: "",
    		diameter: "8.8",
    		center_lat: 49.8,
    		center_long: 75.4
    	},
    	{
    		feature_id: 4161,
    		year: 1985,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Natalia",
    		type: "First Name",
    		origin: "Romania (Rumania)",
    		continent: "Europe",
    		clean_name: "Natalia",
    		description: "Romanian first name.",
    		bio: "",
    		search_term: "",
    		diameter: "10.8",
    		center_lat: 67.1,
    		center_long: 272.9
    	},
    	{
    		feature_id: 4403,
    		year: 1985,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Odilia",
    		type: "First Name",
    		origin: "Portugal",
    		continent: "Europe",
    		clean_name: "Odilia",
    		description: "Portuguese first name.",
    		bio: "",
    		search_term: "",
    		diameter: "20.8",
    		center_lat: 81.2,
    		center_long: 200.2
    	},
    	{
    		feature_id: 4449,
    		year: 1985,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Olya",
    		type: "First Name",
    		origin: "Russia",
    		continent: "Europe",
    		clean_name: "Olya",
    		description: "Russian first name.",
    		bio: "",
    		search_term: "",
    		diameter: "13.4",
    		center_lat: 51.4,
    		center_long: 291.8
    	},
    	{
    		feature_id: 4781,
    		year: 1985,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Polina",
    		type: "First Name",
    		origin: "Russia",
    		continent: "Europe",
    		clean_name: "Polina",
    		description: "Russian first name.",
    		bio: "",
    		search_term: "",
    		diameter: "21.6",
    		center_lat: 42.4,
    		center_long: 148.2
    	},
    	{
    		feature_id: 4919,
    		year: 1985,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Radka",
    		type: "First Name",
    		origin: "Bulgaria",
    		continent: "Europe",
    		clean_name: "Radka",
    		description: "Bulgarian first name.",
    		bio: "",
    		search_term: "",
    		diameter: "10.5",
    		center_lat: 75.6,
    		center_long: 96.3
    	},
    	{
    		feature_id: 4976,
    		year: 1985,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Regina",
    		type: "First Name",
    		origin: "Romania (Rumania)",
    		continent: "Europe",
    		clean_name: "Regina",
    		description: "First name from Latin.",
    		bio: "",
    		search_term: "",
    		diameter: "24.9",
    		center_lat: 30,
    		center_long: 147.3
    	},
    	{
    		feature_id: 5154,
    		year: 1985,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Rita",
    		type: "First Name",
    		origin: "Italy",
    		continent: "Europe",
    		clean_name: "Rita",
    		description: "Italian first name.",
    		bio: "",
    		search_term: "",
    		diameter: "8.3",
    		center_lat: 71,
    		center_long: 334.8
    	},
    	{
    		feature_id: 5420,
    		year: 1985,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Selma",
    		type: "First Name",
    		origin: "Celtic",
    		continent: "Europe",
    		clean_name: "Selma",
    		description: "First name from Celtic.",
    		bio: "",
    		search_term: "",
    		diameter: "11.4",
    		center_lat: 68.5,
    		center_long: 155.9
    	},
    	{
    		feature_id: 5527,
    		year: 1985,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Sigrid",
    		type: "First Name",
    		origin: "Scandinavian",
    		continent: "Europe",
    		clean_name: "Sigrid",
    		description: "Scandinavian first name.",
    		bio: "",
    		search_term: "",
    		diameter: "16.2",
    		center_lat: 63.6,
    		center_long: 314.4
    	},
    	{
    		feature_id: 5688,
    		year: 1985,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Stefania",
    		type: "First Name",
    		origin: "Romania (Rumania)",
    		continent: "Europe",
    		clean_name: "Stefania",
    		description: "Romanian first name.",
    		bio: "",
    		search_term: "",
    		diameter: "11.7",
    		center_lat: 51.3,
    		center_long: 333.3
    	},
    	{
    		feature_id: 5709,
    		year: 1985,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Stina",
    		type: "First Name",
    		origin: "Sweden",
    		continent: "Europe",
    		clean_name: "Stina",
    		description: "Swedish first name.",
    		bio: "",
    		search_term: "",
    		diameter: "10.4",
    		center_lat: 37.4,
    		center_long: 22.8
    	},
    	{
    		feature_id: 5842,
    		year: 1985,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Tamara",
    		type: "First Name",
    		origin: "Georgia",
    		continent: "Europe",
    		clean_name: "Tamara",
    		description: "Georgian first name.",
    		bio: "",
    		search_term: "",
    		diameter: "11.0",
    		center_lat: 61.6,
    		center_long: 317.2
    	},
    	{
    		feature_id: 5880,
    		year: 1985,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Tatyana",
    		type: "First Name",
    		origin: "Russia",
    		continent: "Europe",
    		clean_name: "Tatyana",
    		description: "Russian first name.",
    		bio: "",
    		search_term: "",
    		diameter: "19.0",
    		center_lat: 85.4,
    		center_long: 212.4
    	},
    	{
    		feature_id: 6177,
    		year: 1985,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Tünde",
    		type: "First Name",
    		origin: "Hungary",
    		continent: "Europe",
    		clean_name: "Tünde",
    		description: "Hungarian first name.",
    		bio: "",
    		search_term: "",
    		diameter: "16.3",
    		center_lat: 76.8,
    		center_long: 193
    	},
    	{
    		feature_id: 6202,
    		year: 1985,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Ulrique",
    		type: "First Name",
    		origin: "France",
    		continent: "Europe",
    		clean_name: "Ulrique",
    		description: "French first name.",
    		bio: "",
    		search_term: "",
    		diameter: "19.6",
    		center_lat: 75.9,
    		center_long: 55.6
    	},
    	{
    		feature_id: 6277,
    		year: 1985,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Valborg",
    		type: "First Name",
    		origin: "Denmark",
    		continent: "Europe",
    		clean_name: "Valborg",
    		description: "Danish first name.",
    		bio: "",
    		search_term: "",
    		diameter: "20.0",
    		center_lat: 75.5,
    		center_long: 272.1
    	},
    	{
    		feature_id: 6278,
    		year: 1985,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Valentina",
    		type: "First Name",
    		origin: "Latin",
    		continent: "Europe",
    		clean_name: "Valentina",
    		description: "Latin first name.",
    		bio: "",
    		search_term: "",
    		diameter: "24.6",
    		center_lat: 46.4,
    		center_long: 144.1
    	},
    	{
    		feature_id: 6485,
    		year: 1985,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Wanda",
    		type: "First Name",
    		origin: "Poland",
    		continent: "Europe",
    		clean_name: "Wanda",
    		description: "Polish first name.",
    		bio: "",
    		search_term: "",
    		diameter: "21.7",
    		center_lat: 71.3,
    		center_long: 323.1
    	},
    	{
    		feature_id: 6707,
    		year: 1985,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Zdravka",
    		type: "First Name",
    		origin: "Bulgaria",
    		continent: "Europe",
    		clean_name: "Zdravka",
    		description: "Bulgarian first name.",
    		bio: "",
    		search_term: "",
    		diameter: "12.5",
    		center_lat: 65.1,
    		center_long: 299
    	},
    	{
    		feature_id: 6740,
    		year: 1985,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Zina",
    		type: "First Name",
    		origin: "Romania (Rumania)",
    		continent: "Europe",
    		clean_name: "Zina",
    		description: "Romanian first name.",
    		bio: "",
    		search_term: "",
    		diameter: "9.0",
    		center_lat: 41.9,
    		center_long: 320.1
    	},
    	{
    		feature_id: 6746,
    		year: 1985,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Zlata",
    		type: "First Name",
    		origin: "Yugoslavia",
    		continent: "Europe",
    		clean_name: "Zlata",
    		description: "Serbocroatian first name.",
    		bio: "",
    		search_term: "",
    		diameter: "7.0",
    		center_lat: 64.6,
    		center_long: 333.9
    	},
    	{
    		feature_id: 6754,
    		year: 1985,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Zoya",
    		type: "First Name",
    		origin: "Russia",
    		continent: "Europe",
    		clean_name: "Zoya",
    		description: "Russian first name.",
    		bio: "",
    		search_term: "",
    		diameter: "20.0",
    		center_lat: 69.1,
    		center_long: 236.2
    	},
    	{
    		feature_id: 135,
    		year: 1985,
    		feature: "Collis",
    		feature_plural: "Colles",
    		name: "Akkruva Colles",
    		type: "Goddess",
    		origin: "Latin",
    		continent: "Europe",
    		clean_name: "Akkruva",
    		description: "Saami-Lapp fishing goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "1,059.0",
    		center_lat: 46.1,
    		center_long: 115.5
    	},
    	{
    		feature_id: 248,
    		year: 1985,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Anahit Corona",
    		type: "Goddess",
    		origin: "Armenia",
    		continent: "Europe",
    		clean_name: "Anahit",
    		description: "Armenian goddess of fertility.",
    		bio: "Anahit (Armenian: Անահիտ, Persian: آناهید) was the goddess of fertility and healing, wisdom and water in Armenian mythology. In early periods she was the goddess of war. By the 5th century BCE she was the main deity in Armenia along with Aramazd.",
    		search_term: "Anahit",
    		diameter: "324.0",
    		center_lat: 77.1,
    		center_long: 277.3
    	},
    	{
    		feature_id: 250,
    		year: 1985,
    		feature: "Tessera",
    		feature_plural: "Tesserae",
    		name: "Ananke Tessera",
    		type: "Goddess",
    		origin: "Greek",
    		continent: "Europe",
    		clean_name: "Ananke",
    		description: "Greek goddess of necessity.",
    		bio: "In ancient Greek religion, Ananke (; Ancient Greek: Ἀνάγκη), from the common noun ἀνάγκη, \"force, constraint, necessity\") is the personification of inevitability, compulsion and necessity. She is customarily depicted as holding a spindle. One of the Greek primordial deities, the births of Ananke and her brother and consort, Chronos (the personification of Time, not to be confused with the Titan Cronus) were thought to mark the division between the eon of Chaos and the beginning of the cosmos.",
    		search_term: "Ananke",
    		diameter: "1,060.0",
    		center_lat: 53.3,
    		center_long: 137
    	},
    	{
    		feature_id: 376,
    		year: 1985,
    		feature: "Fossa",
    		feature_plural: "Fossae",
    		name: "Arianrod Fossae",
    		type: "Goddess",
    		origin: "Celtic",
    		continent: "Europe",
    		clean_name: "Arianrod",
    		description: "Celtic warrior queen.",
    		bio: "Arianrhod is a figure in Welsh mythology who plays her most important role in the Fourth Branch of the Mabinogi. She is the daughter of Dôn and the sister of Gwydion and Gilfaethwy; the Welsh Triads give her father as Beli Mawr. In the Mabinogi her uncle Math ap Mathonwy is the King of Gwynedd, and during the course of the story she gives birth to two sons, Dylan ail Don and Lleu Llaw Gyffes, through magical means.",
    		search_term: "Arianrod",
    		diameter: "715.0",
    		center_lat: 37,
    		center_long: 239.9
    	},
    	{
    		feature_id: 461,
    		year: 1985,
    		feature: "Tessera",
    		feature_plural: "Tesserae",
    		name: "Atropos Tessera",
    		type: "Goddess",
    		origin: "Greek",
    		continent: "Europe",
    		clean_name: "Atropos",
    		description: "Greek; one of three Fates.",
    		bio: "Atropos or Aisa, in Greek mythology, was one of the three Moirai, goddesses of fate and destiny. Her Roman equivalent was Morta. Atropos was the oldest of the Three Fates, and was known as \"the Inflexible One.\" It was Atropos who chose the manner of death and ended the life of mortals by cutting their threads.",
    		search_term: "Atropos",
    		diameter: "469.0",
    		center_lat: 71.5,
    		center_long: 304
    	},
    	{
    		feature_id: 478,
    		year: 1985,
    		feature: "Dorsum",
    		feature_plural: "Dorsa",
    		name: "Auska Dorsum",
    		type: "Goddess",
    		origin: "Lithuania",
    		continent: "Europe",
    		clean_name: "Auska",
    		description: "Lithuanian goddess of sun rays.",
    		bio: "",
    		search_term: "",
    		diameter: "361.0",
    		center_lat: 59.9,
    		center_long: 357.8
    	},
    	{
    		feature_id: 498,
    		year: 1985,
    		feature: "Dorsum",
    		feature_plural: "Dorsa",
    		name: "Aušrā Dorsa",
    		type: "Goddess",
    		origin: "Lithuania",
    		continent: "Europe",
    		clean_name: "Aušrā",
    		description: "Lithuanian dawn goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "859.0",
    		center_lat: 49.4,
    		center_long: 25.3
    	},
    	{
    		feature_id: 676,
    		year: 1985,
    		feature: "Fossa",
    		feature_plural: "Fossae",
    		name: "Bellona Fossae",
    		type: "Goddess",
    		origin: "Romania (Rumania)",
    		continent: "Europe",
    		clean_name: "Bellona",
    		description: "Roman war goddess, wife of Mars.",
    		bio: "",
    		search_term: "",
    		diameter: "855.0",
    		center_lat: 38,
    		center_long: 222.1
    	},
    	{
    		feature_id: 726,
    		year: 1985,
    		feature: "Dorsum",
    		feature_plural: "Dorsa",
    		name: "Bezlea Dorsa",
    		type: "Goddess",
    		origin: "Lithuania",
    		continent: "Europe",
    		clean_name: "Bezlea",
    		description: "Lithuanian evening light goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "807.0",
    		center_lat: 30.4,
    		center_long: 36.5
    	},
    	{
    		feature_id: 870,
    		year: 1985,
    		feature: "Linea",
    		feature_plural: "Lineae",
    		name: "Breksta Linea",
    		type: "Goddess",
    		origin: "Lithuania",
    		continent: "Europe",
    		clean_name: "Breksta",
    		description: "Lithuanian night darkness goddess. (Name changed from Breksta Dorsa August 2004.)",
    		bio: "Goddess of twilight, darkness and dreams.",
    		search_term: "Breksta",
    		diameter: "700.0",
    		center_lat: 35.9,
    		center_long: 304
    	},
    	{
    		feature_id: 1250,
    		year: 1985,
    		feature: "Tessera",
    		feature_plural: "Tesserae",
    		name: "Clotho Tessera",
    		type: "Goddess",
    		origin: "Greek",
    		continent: "Europe",
    		clean_name: "Clotho",
    		description: "Greek; one of three Fates.",
    		bio: "Clotho is a mythological figure. She is the youngest of the Three Fates or Moirai who spins the thread of human life; the other two draw out (Lachesis) and cut (Atropos) in ancient Greek mythology. Her Roman equivalent is Nona.",
    		search_term: "Clotho",
    		diameter: "289.0",
    		center_lat: 56.4,
    		center_long: 334.9
    	},
    	{
    		feature_id: 1406,
    		year: 1985,
    		feature: "Mons",
    		feature_plural: "Montes",
    		name: "Danu Montes",
    		type: "Goddess",
    		origin: "Celtic",
    		continent: "Europe",
    		clean_name: "Danu",
    		description: "Celtic mother of gods.",
    		bio: "",
    		search_term: "",
    		diameter: "808.0",
    		center_lat: 58.5,
    		center_long: 334
    	},
    	{
    		feature_id: 1465,
    		year: 1985,
    		feature: "Tessera",
    		feature_plural: "Tesserae",
    		name: "Dekla Tessera",
    		type: "Goddess",
    		origin: "Latvia",
    		continent: "Europe",
    		clean_name: "Dekla",
    		description: "Latvian goddess of fate.",
    		bio: "",
    		search_term: "",
    		diameter: "1,363.0",
    		center_lat: 57.4,
    		center_long: 71.8
    	},
    	{
    		feature_id: 1482,
    		year: 1985,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Demeter Corona",
    		type: "Goddess",
    		origin: "Greek",
    		continent: "Europe",
    		clean_name: "Demeter",
    		description: "Greek goddess of fertility.",
    		bio: "In ancient Greek religion and mythology, Demeter is the Olympian goddess of the harvest and agriculture, presiding over crops, grains, food, and the fertility of the earth. Although she is mostly known as a grain goddess, she also appeared as a goddess of health, birth, and marriage, and had connections to the Underworld.",
    		search_term: "Demeter",
    		diameter: "560.0",
    		center_lat: 53.9,
    		center_long: 294.8
    	},
    	{
    		feature_id: 1943,
    		year: 1985,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Feronia Corona",
    		type: "Goddess",
    		origin: "Italy",
    		continent: "Europe",
    		clean_name: "Feronia",
    		description: "Ancient Italian goddess of spring and flowers.",
    		bio: "",
    		search_term: "",
    		diameter: "360.0",
    		center_lat: 68,
    		center_long: 281.7
    	},
    	{
    		feature_id: 1994,
    		year: 1985,
    		feature: "Rupes",
    		feature_plural: "Rupēs",
    		name: "Fornax Rupes",
    		type: "Goddess",
    		origin: "Roman",
    		continent: "Europe",
    		clean_name: "Fornax",
    		description: "Roman goddess of hearth and baking of bread.",
    		bio: "",
    		search_term: "",
    		diameter: "729.0",
    		center_lat: 30.3,
    		center_long: 201.1
    	},
    	{
    		feature_id: 1997,
    		year: 1985,
    		feature: "Tessera",
    		feature_plural: "Tesserae",
    		name: "Fortuna Tessera",
    		type: "Goddess",
    		origin: "Roman",
    		continent: "Europe",
    		clean_name: "Fortuna",
    		description: "Roman goddess of chance.",
    		bio: "Fortuna is the goddess of fortune and the personification of luck in Roman religion who, largely thanks to the Late Antique author Boethius, remained popular through the Middle Ages until at least the Renaissance. The blindfolded depiction of her is still an important figure in many aspects of today's Italian culture, where the dichotomy fortuna / sfortuna (luck / unluck) plays a prominent role in everyday social life, also represented by the very common refrain \"La [dea] fortuna è cieca\" (latin Fortuna caeca est; \"Luck [goddess] is blind\").",
    		search_term: "Fortuna",
    		diameter: "2,801.0",
    		center_lat: 69.9,
    		center_long: 45.1
    	},
    	{
    		feature_id: 2025,
    		year: 1985,
    		feature: "Fossa",
    		feature_plural: "Fossae",
    		name: "Friagabi Fossae",
    		type: "Goddess",
    		origin: "Great Britain",
    		continent: "Europe",
    		clean_name: "Friagabi",
    		description: "Old English goddess, connected with Mars.",
    		bio: "",
    		search_term: "",
    		diameter: "141.0",
    		center_lat: 50.2,
    		center_long: 109.5
    	},
    	{
    		feature_id: 2028,
    		year: 1985,
    		feature: "Dorsum",
    		feature_plural: "Dorsa",
    		name: "Frigg Dorsa",
    		type: "Goddess",
    		origin: "Norse",
    		continent: "Europe",
    		clean_name: "Frigg",
    		description: "Norse, wife of supreme god Odin.",
    		bio: "Frigg is a goddess, one of the Æsir, in Germanic mythology. In Norse mythology, the source of most surviving information about her, she is associated with marriage, prophecy, clairvoyance and motherhood, and dwells in the wetland halls of Fensalir.",
    		search_term: "Frigg",
    		diameter: "896.0",
    		center_lat: 51.2,
    		center_long: 150.6
    	},
    	{
    		feature_id: 2048,
    		year: 1985,
    		feature: "Rupes",
    		feature_plural: "Rupēs",
    		name: "Gabie Rupes",
    		type: "Goddess",
    		origin: "Lithuania",
    		continent: "Europe",
    		clean_name: "Gabie",
    		description: "Lithuanian goddess of fire and hearth.",
    		bio: "",
    		search_term: "",
    		diameter: "350.0",
    		center_lat: 67.5,
    		center_long: 109.9
    	},
    	{
    		feature_id: 2444,
    		year: 1985,
    		feature: "Dorsum",
    		feature_plural: "Dorsa",
    		name: "Hemera Dorsa",
    		type: "Goddess",
    		origin: "Greek",
    		continent: "Europe",
    		clean_name: "Hemera",
    		description: "Greek goddess, personification of day.",
    		bio: "In Greek mythology, Hemera was the personification of day. According to Hesiod, she was the daughter of Erebus (Darkness) and Nyx (Night), and the sister of Aether. Though separate entities in Hesiod's Theogony, Hemera and Eos (Dawn) were often identified with each other.",
    		search_term: "Hemera",
    		diameter: "587.0",
    		center_lat: 51,
    		center_long: 243.4
    	},
    	{
    		feature_id: 2464,
    		year: 1985,
    		feature: "Dorsum",
    		feature_plural: "Dorsa",
    		name: "Hera Dorsa",
    		type: "Goddess",
    		origin: "Greek",
    		continent: "Europe",
    		clean_name: "Hera",
    		description: "Greek sky goddess, wife of Zeus.",
    		bio: "In ancient Greek religion, Hera is the goddess of marriage, women and family, and the protector of women during childbirth. In Greek mythology, she is queen of the twelve Olympians and Mount Olympus, sister and wife of Zeus, and daughter of the Titans Cronus and Rhea.",
    		search_term: "Hera",
    		diameter: "813.0",
    		center_lat: 36.4,
    		center_long: 29.5
    	},
    	{
    		feature_id: 2718,
    		year: 1985,
    		feature: "Dorsum",
    		feature_plural: "Dorsa",
    		name: "Iris Dorsa",
    		type: "Goddess",
    		origin: "Greek",
    		continent: "Europe",
    		clean_name: "Iris",
    		description: "Greek goddess of the rainbow.",
    		bio: "",
    		search_term: "",
    		diameter: "2,050.0",
    		center_lat: 52.7,
    		center_long: 221.3
    	},
    	{
    		feature_id: 2770,
    		year: 1985,
    		feature: "Dorsum",
    		feature_plural: "Dorsa",
    		name: "Iyele Dorsa",
    		type: "Goddess",
    		origin: "Moldova",
    		continent: "Europe",
    		clean_name: "Iyele",
    		description: "Moldavian witch who directed the winds.",
    		bio: "",
    		search_term: "",
    		diameter: "595.0",
    		center_lat: 50,
    		center_long: 278.7
    	},
    	{
    		feature_id: 2869,
    		year: 1985,
    		feature: "Collis",
    		feature_plural: "Colles",
    		name: "Jurate Colles",
    		type: "Goddess",
    		origin: "Lithuania",
    		continent: "Europe",
    		clean_name: "Jurate",
    		description: "Lithuanian sea goddess.",
    		bio: "Jūratė and Kastytis (Lithuanian: Jūratė ir Kastytis) is one of the most famous and popular Lithuanian legends and tales. The first time it was recorded was in 1842, in the writings of Liudvikas Adomas Jucevičius. Since then it has been adapted many times for modern poems, ballets, and even rock operas.",
    		search_term: "Jurate",
    		diameter: "418.0",
    		center_lat: 56.8,
    		center_long: 153.5
    	},
    	{
    		feature_id: 2904,
    		year: 1985,
    		feature: "Dorsum",
    		feature_plural: "Dorsa",
    		name: "Kamari Dorsa",
    		type: "Goddess",
    		origin: "Georgia",
    		continent: "Europe",
    		clean_name: "Kamari",
    		description: "Georgian sky maiden, daughter of weather god.",
    		bio: "",
    		search_term: "",
    		diameter: "589.0",
    		center_lat: 59.2,
    		center_long: 55.8
    	},
    	{
    		feature_id: 3108,
    		year: 1985,
    		feature: "Chasma",
    		feature_plural: "Chasmata",
    		name: "Kozhla-Ava Chasma",
    		type: "Goddess",
    		origin: "Finland",
    		continent: "Europe",
    		clean_name: "Kozhla-Ava",
    		description: "Marian (Volga Finn) forest goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "581.0",
    		center_lat: 56.2,
    		center_long: 50.6
    	},
    	{
    		feature_id: 3199,
    		year: 1985,
    		feature: "Tessera",
    		feature_plural: "Tesserae",
    		name: "Lachesis Tessera",
    		type: "Goddess",
    		origin: "Greek",
    		continent: "Europe",
    		clean_name: "Lachesis",
    		description: "Greek, one of three Fates.",
    		bio: "Lachesis, in ancient Greek religion, was the second of the Three Fates, or Moirai; the others were her sisters, Clotho and Atropos. Normally seen clothed in white, Lachesis is the measurer of the thread spun on Clotho's spindle, and in some texts, determines Destiny, or thread of life. Her Roman equivalent was Decima.",
    		search_term: "Lachesis",
    		diameter: "664.0",
    		center_lat: 44.4,
    		center_long: 300.1
    	},
    	{
    		feature_id: 3238,
    		year: 1985,
    		feature: "Tessera",
    		feature_plural: "Tesserae",
    		name: "Laima Tessera",
    		type: "Goddess",
    		origin: "Latvia",
    		continent: "Europe",
    		clean_name: "Laima",
    		description: "Latvian and Lithuanian goddess of fate.",
    		bio: "Laima is a Baltic goddess of fate. She was associated with childbirth, marriage, and death; she was also the patron of pregnant women. Laima and her functions are similar to the Hindu goddess Lakshmi.",
    		search_term: "Laima",
    		diameter: "971.0",
    		center_lat: 55,
    		center_long: 48.5
    	},
    	{
    		feature_id: 3285,
    		year: 1985,
    		feature: "Chasma",
    		feature_plural: "Chasmata",
    		name: "Lasdona Chasma",
    		type: "Goddess",
    		origin: "Lithuania",
    		continent: "Europe",
    		clean_name: "Lasdona",
    		description: "Lithuanian main forest goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "697.0",
    		center_lat: 69.3,
    		center_long: 36.8
    	},
    	{
    		feature_id: 3310,
    		year: 1985,
    		feature: "Dorsum",
    		feature_plural: "Dorsa",
    		name: "Laūma Dorsa",
    		type: "Goddess",
    		origin: "Latvia",
    		continent: "Europe",
    		clean_name: "Laūma",
    		description: "Latvian witch, flies in the sky.",
    		bio: "",
    		search_term: "",
    		diameter: "1,517.0",
    		center_lat: 64.8,
    		center_long: 190.4
    	},
    	{
    		feature_id: 3660,
    		year: 1985,
    		feature: "Dorsum",
    		feature_plural: "Dorsa",
    		name: "Mardezh-Ava Dorsa",
    		type: "Goddess",
    		origin: "Finland",
    		continent: "Europe",
    		clean_name: "Mardezh-Ava",
    		description: "Marian (Volga Finn) wind goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "906.0",
    		center_lat: 32.4,
    		center_long: 68.6
    	},
    	{
    		feature_id: 3791,
    		year: 1985,
    		feature: "Chasma",
    		feature_plural: "Chasmata",
    		name: "Medeina Chasma",
    		type: "Goddess",
    		origin: "Lithuania",
    		continent: "Europe",
    		clean_name: "Medeina",
    		description: "Lithuanian forest goddess.",
    		bio: "Medeina or Medeinė is one of the main deities in the Lithuanian mythology, and is similar to Latvian Meža māte (Forest Mother). She is a ruler of forests, trees and animals. Her sacred animal is a hare.",
    		search_term: "Medeina",
    		diameter: "606.0",
    		center_lat: 46.2,
    		center_long: 89.3
    	},
    	{
    		feature_id: 3817,
    		year: 1985,
    		feature: "Mons",
    		feature_plural: "Montes",
    		name: "Melia Mons",
    		type: "Goddess",
    		origin: "Greek",
    		continent: "Europe",
    		clean_name: "Melia",
    		description: "Greek nymph.",
    		bio: "",
    		search_term: "",
    		diameter: "311.0",
    		center_lat: 62.8,
    		center_long: 119.3
    	},
    	{
    		feature_id: 3878,
    		year: 1985,
    		feature: "Chasma",
    		feature_plural: "Chasmata",
    		name: "Mežas-Mate Chasma",
    		type: "Goddess",
    		origin: "Latvia",
    		continent: "Europe",
    		clean_name: "Mežas-Mate",
    		description: "Latvian forest goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "506.0",
    		center_lat: 51,
    		center_long: 50.7
    	},
    	{
    		feature_id: 3910,
    		year: 1985,
    		feature: "Fossa",
    		feature_plural: "Fossae",
    		name: "Minerva Fossae",
    		type: "Goddess",
    		origin: "Roman",
    		continent: "Europe",
    		clean_name: "Minerva",
    		description: "Roman goddess of war.",
    		bio: "Minerva (Latin: [mɪˈnɛrwa]; Etruscan: Menrva) is the Roman goddess of wisdom, justice, law, victory, and the sponsor of arts, trade, and strategy. Minerva is not a patron of violence such as Mars, but of strategic war. From the second century BC onward, the Romans equated her with the Greek goddess Athena.",
    		search_term: "Minerva",
    		diameter: "0.0",
    		center_lat: 64.5,
    		center_long: 252.5
    	},
    	{
    		feature_id: 3948,
    		year: 1985,
    		feature: "Tessera",
    		feature_plural: "Tesserae",
    		name: "Moira Tessera",
    		type: "Goddess",
    		origin: "Greek",
    		continent: "Europe",
    		clean_name: "Moira",
    		description: "Greek fate goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "361.0",
    		center_lat: 58.7,
    		center_long: 310.5
    	},
    	{
    		feature_id: 4031,
    		year: 1985,
    		feature: "Chasma",
    		feature_plural: "Chasmata",
    		name: "Morana Chasma",
    		type: "Goddess",
    		origin: "Czechoslovakia",
    		continent: "Europe",
    		clean_name: "Morana",
    		description: "Czech moon goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "317.0",
    		center_lat: 68.9,
    		center_long: 24.6
    	},
    	{
    		feature_id: 4204,
    		year: 1985,
    		feature: "Tessera",
    		feature_plural: "Tesserae",
    		name: "Nemesis Tesserae",
    		type: "Goddess",
    		origin: "Greek",
    		continent: "Europe",
    		clean_name: "Nemesis",
    		description: "Greek goddess of fate.",
    		bio: "In ancient Greek religion, Nemesis was the goddess who personifies retribution for the sin of hubris: arrogance before the gods. As the goddess of proportion and the avenger of crime, she has as attributes a measuring rod (tally stick), a bridle, scales, a sword, and a scourge, and she rides in a chariot drawn by griffins.",
    		search_term: "Nemesis",
    		diameter: "355.0",
    		center_lat: 40,
    		center_long: 181
    	},
    	{
    		feature_id: 4209,
    		year: 1985,
    		feature: "Dorsum",
    		feature_plural: "Dorsa",
    		name: "Nephele Dorsa",
    		type: "Goddess",
    		origin: "Greek",
    		continent: "Europe",
    		clean_name: "Nephele",
    		description: "Greek cloud goddess.",
    		bio: "In Greek mythology, Nephele was a cloud nymph who figured prominently in the story of Phrixus and Helle. Greek myth has it that Nephele is the cloud whom Zeus created in the image of Hera to trick Ixion to test his integrity after displaying his lust for Hera during a feast as a guest of Zeus. Ixion's restraint failed him, and he assaulted Nephele, eventually fathering the Centaurs (through Imbros or Centauros).",
    		search_term: "Nephele",
    		diameter: "1,937.0",
    		center_lat: 39.7,
    		center_long: 138.8
    	},
    	{
    		feature_id: 4219,
    		year: 1985,
    		feature: "Tholus",
    		feature_plural: "Tholi",
    		name: "Nertus Tholus",
    		type: "Goddess",
    		origin: "Germany",
    		continent: "Europe",
    		clean_name: "Nertus",
    		description: "German/Norse vegetation goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "66.0",
    		center_lat: 61.2,
    		center_long: 247.9
    	},
    	{
    		feature_id: 4427,
    		year: 1985,
    		feature: "Dorsum",
    		feature_plural: "Dorsa",
    		name: "Okipeta Dorsa",
    		type: "Goddess",
    		origin: "Greek",
    		continent: "Europe",
    		clean_name: "Okipeta",
    		description: "Greek goddess of whirlwind.",
    		bio: "",
    		search_term: "",
    		diameter: "1,200.0",
    		center_lat: 67.5,
    		center_long: 240
    	},
    	{
    		feature_id: 4575,
    		year: 1985,
    		feature: "Dorsum",
    		feature_plural: "Dorsa",
    		name: "Pandrosos Dorsa",
    		type: "Goddess",
    		origin: "Greek",
    		continent: "Europe",
    		clean_name: "Pandrosos",
    		description: "Greek dew goddess.",
    		bio: "Pandrosos or Pandrosus was known in Greek myth as one of the three daughters of Kekrops, the first king of Athen. The name \"Pandrosos\" carries the meaning of \"all dew\" or \"all bedewed\" in the Greek language (drosos, dew). For this reason, Pandrosos is at times called the \"Dew Goddess\" and her three sisters together are sometimes referred to as the \"Dew Sisters.\"",
    		search_term: "Pandrosos",
    		diameter: "1,254.0",
    		center_lat: 58.2,
    		center_long: 207.7
    	},
    	{
    		feature_id: 4790,
    		year: 1985,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Pomona Corona",
    		type: "Goddess",
    		origin: "Roman",
    		continent: "Europe",
    		clean_name: "Pomona",
    		description: "Roman goddess of fruits.",
    		bio: "",
    		search_term: "",
    		diameter: "315.0",
    		center_lat: 79.3,
    		center_long: 299.4
    	},
    	{
    		feature_id: 4943,
    		year: 1985,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Rananeida Corona",
    		type: "Goddess",
    		origin: "Finland",
    		continent: "Europe",
    		clean_name: "Rananeida",
    		description: "Saami-Lapp goddess of spring and fertility.",
    		bio: "",
    		search_term: "",
    		diameter: "448.0",
    		center_lat: 62.6,
    		center_long: 263.5
    	},
    	{
    		feature_id: 4946,
    		year: 1985,
    		feature: "Fossa",
    		feature_plural: "Fossae",
    		name: "Rangrid Fossae",
    		type: "Goddess",
    		origin: "Norse",
    		continent: "Europe",
    		clean_name: "Rangrid",
    		description: "Norse Valkyrie.",
    		bio: "",
    		search_term: "",
    		diameter: "243.0",
    		center_lat: 62.7,
    		center_long: 356.4
    	},
    	{
    		feature_id: 4957,
    		year: 1985,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Rauni Corona",
    		type: "Goddess",
    		origin: "Finland",
    		continent: "Europe",
    		clean_name: "Rauni",
    		description: "Finnish goddess of harvest, earth.",
    		bio: "",
    		search_term: "",
    		diameter: "271.0",
    		center_lat: 40.8,
    		center_long: 271.9
    	},
    	{
    		feature_id: 5528,
    		year: 1985,
    		feature: "Fossa",
    		feature_plural: "Fossae",
    		name: "Sigrun Fossae",
    		type: "Goddess",
    		origin: "Norse",
    		continent: "Europe",
    		clean_name: "Sigrun",
    		description: "Norse Valkyrie.",
    		bio: "Sigrún (Old Norse \"victory rune\") is a valkyrie in Norse mythology. Her story is related in the Poetic Edda. The hero Helgi Hundingsbane first meets her when she leads a band of nine Valkyries.",
    		search_term: "Sigrun",
    		diameter: "970.0",
    		center_lat: 50.5,
    		center_long: 18
    	},
    	{
    		feature_id: 14799,
    		year: 1985,
    		feature: "Linea",
    		feature_plural: "Lineae",
    		name: "Szél-anya Lineae",
    		type: "Goddess",
    		origin: "Hungary",
    		continent: "Europe",
    		clean_name: "Szél-anya",
    		description: "Hungarian wind mother.",
    		bio: "",
    		search_term: "",
    		diameter: "975.0",
    		center_lat: 79.4,
    		center_long: 81.3
    	},
    	{
    		feature_id: 14800,
    		year: 1985,
    		feature: "Linea",
    		feature_plural: "Lineae",
    		name: "Tezan Lineae",
    		type: "Goddess",
    		origin: "Italy",
    		continent: "Europe",
    		clean_name: "Tezan",
    		description: "Etruscan dawn goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "1,079.0",
    		center_lat: 81.4,
    		center_long: 47.1
    	},
    	{
    		feature_id: 5946,
    		year: 1985,
    		feature: "Mons",
    		feature_plural: "Montes",
    		name: "Thallo Mons",
    		type: "Goddess",
    		origin: "Greek",
    		continent: "Europe",
    		clean_name: "Thallo",
    		description: "Greek goddess of vegetation flowering (Spring Hora).",
    		bio: "In Greek mythology the Horae were the goddesses of the seasons and the natural portions of time. Thallo (Θαλλώ, literally \"The one who brings blossoms\"; or Flora for Romans) or Thalatte was the goddess of spring, buds and blooms, a protector of youth.",
    		search_term: "Thallo",
    		diameter: "40.0",
    		center_lat: 74.5,
    		center_long: 231
    	},
    	{
    		feature_id: 6226,
    		year: 1985,
    		feature: "Dorsum",
    		feature_plural: "Dorsa",
    		name: "Uni Dorsa",
    		type: "Goddess",
    		origin: "Italy",
    		continent: "Europe",
    		clean_name: "Uni",
    		description: "Etruscan goddess, same as Hera or Juno.",
    		bio: "",
    		search_term: "",
    		diameter: "800.0",
    		center_lat: 33.7,
    		center_long: 114.3
    	},
    	{
    		feature_id: 6269,
    		year: 1985,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Vacuna Corona",
    		type: "Goddess",
    		origin: "Italy",
    		continent: "Europe",
    		clean_name: "Vacuna",
    		description: "Sabinian (Ancient Italy) goddess of harvest.",
    		bio: "Vacuna was an ancient Sabine goddess, identified by ancient Roman sources and later scholars with numerous other goddesses, including Ceres, Diana, Nike, Minerva, Bellona, Venus and Victoria. She was mainly worshipped at a sanctuary near Horace's villa (now in the commune of Licenza), in sacred woods at Reate, and at Rome. The protection she was asked to provide remains obscure.",
    		search_term: "Vacuna",
    		diameter: "448.0",
    		center_lat: 60.4,
    		center_long: 96
    	},
    	{
    		feature_id: 6347,
    		year: 1985,
    		feature: "Mons",
    		feature_plural: "Montes",
    		name: "Venilia Mons",
    		type: "Goddess",
    		origin: "Italy",
    		continent: "Europe",
    		clean_name: "Venilia",
    		description: "Ancient Italian sea goddess.",
    		bio: "Venilia (pronounced , or as Latin Venīlia) is a Roman deity associated with the winds and the sea. According to Virgil and Ovid, she was a nymph, the sister of Amata and the wife of Janus (or Faunus), with whom she had three children: Turnus, Juturna, and Canens.She and Salacia are the paredrae of Neptune. The Venilia Mons, a mountain on Venus, is named for her.",
    		search_term: "Venilia",
    		diameter: "320.0",
    		center_lat: 32.7,
    		center_long: 238.8
    	},
    	{
    		feature_id: 6400,
    		year: 1985,
    		feature: "Chasma",
    		feature_plural: "Chasmata",
    		name: "Vires-Akka Chasma",
    		type: "Goddess",
    		origin: "Finland",
    		continent: "Europe",
    		clean_name: "Vires-Akka",
    		description: "Saami-Lapp forest goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "742.0",
    		center_lat: 75.6,
    		center_long: 341.6
    	},
    	{
    		feature_id: 6403,
    		year: 1985,
    		feature: "Tessera",
    		feature_plural: "Tesserae",
    		name: "Virilis Tesserae",
    		type: "Goddess",
    		origin: "Roman",
    		continent: "Europe",
    		clean_name: "Virilis",
    		description: "One of the names of Fortuna, Roman goddess of chance.",
    		bio: "Fortuna is the goddess of fortune and the personification of luck in Roman religion who, largely thanks to the Late Antique author Boethius, remained popular through the Middle Ages until at least the Renaissance. The blindfolded depiction of her is still an important figure in many aspects of today's Italian culture, where the dichotomy fortuna / sfortuna (luck / unluck) plays a prominent role in everyday social life, also represented by the very common refrain \"La [dea] fortuna è cieca\" (latin Fortuna caeca est; \"Luck [goddess] is blind\").",
    		search_term: "Virilis",
    		diameter: "782.0",
    		center_lat: 56.1,
    		center_long: 239.7
    	},
    	{
    		feature_id: 6679,
    		year: 1985,
    		feature: "Dorsum",
    		feature_plural: "Dorsa",
    		name: "Yumyn-Udyr Dorsa",
    		type: "Goddess",
    		origin: "Finland",
    		continent: "Europe",
    		clean_name: "Yumyn-Udyr",
    		description: "Marian (Volga Finn) daughter of main god.",
    		bio: "",
    		search_term: "",
    		diameter: "1,086.0",
    		center_lat: 81.4,
    		center_long: 164.7
    	},
    	{
    		feature_id: 6751,
    		year: 1985,
    		feature: "Dorsum",
    		feature_plural: "Dorsa",
    		name: "Zorile Dorsa",
    		type: "Goddess",
    		origin: "Moldova",
    		continent: "Europe",
    		clean_name: "Zorile",
    		description: "Moldavian dawn goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "1,041.0",
    		center_lat: 39.9,
    		center_long: 338.4
    	},
    	{
    		feature_id: 3482,
    		year: 1985,
    		feature: "Planitia",
    		feature_plural: "Planitiae",
    		name: "Louhi Planitia",
    		type: "Heroine",
    		origin: "Finland",
    		continent: "Europe",
    		clean_name: "Louhi ",
    		description: "Karelo-Finn mother of the North.",
    		bio: "Louhi is a wicked queen of the land known as Pohjola in Finnish mythology and a villain of the Kalevala. She is described as a powerful and evil witch queen ruling over the northern realm of Pohjola, with the ability to change shape and weave mighty enchantments.",
    		search_term: "Louhi",
    		diameter: "2,440.0",
    		center_lat: 80.5,
    		center_long: 120.5
    	},
    	{
    		feature_id: 5608,
    		year: 1985,
    		feature: "Planitia",
    		feature_plural: "Planitiae",
    		name: "Snegurochka Planitia",
    		type: "Heroine",
    		origin: "Russia",
    		continent: "Europe",
    		clean_name: "Snegurochka ",
    		description: "Snow maiden in Russian folktales, melted in spring.",
    		bio: "Snegurochka, or The Snow Maiden, is a character in Russian fairy tales. In one version of the story, childless Russian peasants made a snow doll, which came to life and grows quickly. A group of girls invite her for a walk in the woods, after which they make a small fire and take turns leaping over it. When Snegurka's turn comes, she starts to jump, but only gets halfway before evaporating into a small cloud.",
    		search_term: "Snegurochka",
    		diameter: "2,775.0",
    		center_lat: 86.6,
    		center_long: 328
    	},
    	{
    		feature_id: 6344,
    		year: 1985,
    		feature: "Planitia",
    		feature_plural: "Planitiae",
    		name: "Vellamo Planitia",
    		type: "Heroine",
    		origin: "Finland",
    		continent: "Europe",
    		clean_name: "Vellamo ",
    		description: "Karelo-Finn mermaid.",
    		bio: "Vellamo is the goddess of water, lakes and seas in Finnish mythology. Vellamo is said to be tall and beautiful, and is much respected by fishermen, who pray to her for good fishing luck. Vellamo can also control the winds to help sailors, and she controls the storms and waves.",
    		search_term: "Vellamo",
    		diameter: "2,155.0",
    		center_lat: 45.4,
    		center_long: 149.1
    	},
    	{
    		feature_id: 530,
    		year: 1985,
    		feature: "Chasma",
    		feature_plural: "Chasmata",
    		name: "Baba-Jaga Chasma",
    		type: "Goddess",
    		origin: "Slavic",
    		continent: "Multiple",
    		clean_name: "Baba-Jaga",
    		description: "Slavic forest witch.",
    		bio: "In Slavic folklore, Baba Yaga, also spelled Baba Jaga (from Polish), is a supernatural being who appears as a deformed and/or ferocious-looking woman. In fairy tales Baba Yaga flies around in a mortar, wields a pestle, and dwells deep in the forest in a hut usually described as standing on chicken legs. Baba Yaga may help or hinder those that encounter or seek her out and may play a maternal role; she has associations with forest wildlife.",
    		search_term: "Baba-Jaga",
    		diameter: "580.0",
    		center_lat: 53.2,
    		center_long: 49.5
    	},
    	{
    		feature_id: 1491,
    		year: 1985,
    		feature: "Dorsum",
    		feature_plural: "Dorsa",
    		name: "Dennitsa Dorsa",
    		type: "Goddess",
    		origin: "Slavic",
    		continent: "Multiple",
    		clean_name: "Dennitsa",
    		description: "Slavic goddess of day, light.",
    		bio: "",
    		search_term: "",
    		diameter: "872.0",
    		center_lat: 85.6,
    		center_long: 205.9
    	},
    	{
    		feature_id: 1560,
    		year: 1985,
    		feature: "Dorsum",
    		feature_plural: "Dorsa",
    		name: "Dodola Dorsa",
    		type: "Goddess",
    		origin: "Slavic",
    		continent: "Multiple",
    		clean_name: "Dodola",
    		description: "South Slavic rain goddess.",
    		bio: "Dodola and Perperuna are Balkan rainmaking pagan customs practiced until the 20th century. The tradition is found in South Slavic countries as well as in near Albania, Greece, Hungary, Moldavia and Romania. It is a ceremonial ritual of singing and dancing done by young boys and girls in times of droughts.",
    		search_term: "Dodola",
    		diameter: "607.0",
    		center_lat: 46.8,
    		center_long: 272.6
    	},
    	{
    		feature_id: 3841,
    		year: 1985,
    		feature: "Tessera",
    		feature_plural: "Tesserae",
    		name: "Meni Tessera",
    		type: "Goddess",
    		origin: "Semitic",
    		continent: "Multiple",
    		clean_name: "Meni",
    		description: "Semitic goddess of fate.",
    		bio: "",
    		search_term: "",
    		diameter: "454.0",
    		center_lat: 48.1,
    		center_long: 77.9
    	},
    	{
    		feature_id: 3952,
    		year: 1985,
    		feature: "Mons",
    		feature_plural: "Montes",
    		name: "Mokosha Mons",
    		type: "Goddess",
    		origin: "Slavic",
    		continent: "Multiple",
    		clean_name: "Mokosha",
    		description: "East Slavic main goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "270.0",
    		center_lat: 57.7,
    		center_long: 255
    	},
    	{
    		feature_id: 6339,
    		year: 1985,
    		feature: "Dorsum",
    		feature_plural: "Dorsa",
    		name: "Vedma Dorsa",
    		type: "Goddess",
    		origin: "Slavic",
    		continent: "Multiple",
    		clean_name: "Vedma",
    		description: "East Slav witch.",
    		bio: "",
    		search_term: "",
    		diameter: "3,345.0",
    		center_lat: 42,
    		center_long: 159
    	},
    	{
    		feature_id: 697,
    		year: 1985,
    		feature: "Planitia",
    		feature_plural: "Planitiae",
    		name: "Bereghinya Planitia",
    		type: "Heroine",
    		origin: "Slavic",
    		continent: "Multiple",
    		clean_name: "Bereghinya ",
    		description: "Slavic water spirit.",
    		bio: "",
    		search_term: "",
    		diameter: "3,900.0",
    		center_lat: 28.6,
    		center_long: 23.6
    	},
    	{
    		feature_id: 891,
    		year: 1985,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Brooke",
    		type: "Famous Woman",
    		origin: "Canada",
    		continent: "North America",
    		clean_name: "Brooke",
    		description: "Frances; Canadian novelist (1724-1789).",
    		bio: "Frances Brooke (née Moore; 12 January 1724 – 23 January 1789) was an English novelist, essayist, playwright and translator. Hers was the first English novel known to have been written in Canada. Her novel The History of Emily Montague was used in the earliest Oxford English Dictionary citation for the hyperbolic or figurative sense of 'literally'; the sentence from the novel was, 'He is a fortunate man to be introduced to such a party of fine women at his arrival; it is literally to feed among the lilies.'",
    		search_term: "Frances Brooke",
    		diameter: "22.9",
    		center_lat: 48.4,
    		center_long: 296.6
    	},
    	{
    		feature_id: 1077,
    		year: 1985,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Cather",
    		type: "Famous Woman",
    		origin: "United States",
    		continent: "North America",
    		clean_name: "Cather",
    		description: "Willa; American novelist (1876-1947).",
    		bio: "Willa Sibert Cather (; born Wilella Sibert Cather; December 7, 1873 – April 24, 1947) was an American writer known for her novels of life on the Great Plains, including O Pioneers!, The Song of the Lark, and My Ántonia. In 1923, she was awarded the Pulitzer Prize for One of Ours, a novel set during World War I. Willa Cather and her family moved from Virginia to Webster County, Nebraska, when she was nine years old. The family later settled in the town of Red Cloud.",
    		search_term: "Willa Cather",
    		diameter: "24.6",
    		center_lat: 47.1,
    		center_long: 107
    	},
    	{
    		feature_id: 1260,
    		year: 1985,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Cochran",
    		type: "Famous Woman",
    		origin: "United States",
    		continent: "North America",
    		clean_name: "Cochran",
    		description: "Jacqueline; American aviator (c. 1906-1980).",
    		bio: "Jacqueline Cochran (May 11, 1906 – August 9, 1980) was an American pilot and business executive. She pioneered women's aviation as one of the most prominent racing pilots of her generation. She set numerous records and was the first woman to break the sound barrier on 18 May 1953.",
    		search_term: "Jacqueline Cochran",
    		diameter: "100.0",
    		center_lat: 51.9,
    		center_long: 143.4
    	},
    	{
    		feature_id: 1528,
    		year: 1985,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Dickinson",
    		type: "Famous Woman",
    		origin: "United States",
    		continent: "North America",
    		clean_name: "Dickinson",
    		description: "Emily; American poet (1830-1886).",
    		bio: "Emily Elizabeth Dickinson (December 10, 1830 – May 15, 1886) was an American poet. Little-known during her life, she has since been regarded as one of the most important figures in American poetry.Dickinson was born in Amherst, Massachusetts, into a prominent family with strong ties to its community. After studying at the Amherst Academy for seven years in her youth, she briefly attended the Mount Holyoke Female Seminary before returning to her family's home in Amherst.",
    		search_term: "Emily Dickinson",
    		diameter: "67.5",
    		center_lat: 74.6,
    		center_long: 177.2
    	},
    	{
    		feature_id: 1661,
    		year: 1985,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Duncan",
    		type: "Famous Woman",
    		origin: "United States",
    		continent: "North America",
    		clean_name: "Duncan",
    		description: "Isadora; American dancer (1878-1927).",
    		bio: "Angela Isadora Duncan (May 26, 1877 or May 27, 1878 – September 14, 1927) was an American dancer and choreographer, who was a pioneer of modern contemporary dance, who performed to great acclaim throughout Europe and the US. Born and raised in California, she lived and danced in Western Europe, the US and the Soviet Union from the age of 22 until her death at age 50 when her scarf became entangled in the wheel and axle of the car in which she was travelling in Nice, France. Isadora Duncan was born in San Francisco, the youngest of the four children of Joseph Charles Duncan (1819–1898), a banker, mining engineer and connoisseur of the arts, and Mary Isadora Gray (1849–1922). Her brothers were Augustin Duncan and Raymond Duncan; her sister, Elizabeth Duncan, was also a dancer.",
    		search_term: "Isadora Duncan",
    		diameter: "40.3",
    		center_lat: 68.1,
    		center_long: 291.7
    	},
    	{
    		feature_id: 1704,
    		year: 1985,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Earhart Corona",
    		type: "Famous Woman",
    		origin: "United States",
    		continent: "North America",
    		clean_name: "Earhart",
    		description: "Amelia; American aviator (1897-1937).",
    		bio: "Amelia Mary Earhart ( AIR-hart, born July 24, 1897; disappeared July 2, 1937; declared dead January 5, 1939) was an American aviation pioneer and writer. Earhart was the first female aviator to fly solo across the Atlantic Ocean. She set many other records, was one of the first aviators to promote commercial air travel, wrote best-selling books about her flying experiences, and was instrumental in the formation of The Ninety-Nines, an organization for female pilots.Born and raised in Atchison, Kansas, and later in Des Moines, Iowa, Earhart developed a passion for adventure at a young age, steadily gaining flying experience from her twenties.",
    		search_term: "Amelia Earhart",
    		diameter: "414.0",
    		center_lat: 70.1,
    		center_long: 136.2
    	},
    	{
    		feature_id: 4049,
    		year: 1985,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Moses",
    		type: "Famous Woman",
    		origin: "United States",
    		continent: "North America",
    		clean_name: "Moses",
    		description: "Anna Mary Robertson, “Grandma“; American painter (1860-1961).",
    		bio: "Anna Mary Robertson Moses (September 7, 1860 – December 13, 1961), or Grandma Moses, was an American folk artist. She began painting in earnest at the age of 78 and is a prominent example of a newly successful art career at an advanced age. Her works have been shown and sold worldwide, including in museums, and have been merchandised such as on greeting cards.",
    		search_term: "Anna Mary Robertson Moses",
    		diameter: "28.0",
    		center_lat: 34.6,
    		center_long: 119.9
    	},
    	{
    		feature_id: 6530,
    		year: 1985,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Wharton",
    		type: "Famous Woman",
    		origin: "United States",
    		continent: "North America",
    		clean_name: "Wharton",
    		description: "Edith; American writer (1862-1937).",
    		bio: "Edith Wharton (; born Edith Newbold Jones; January 24, 1862 – August 11, 1937) was an American novelist, short story writer, and interior designer. Wharton drew upon her insider's knowledge of the upper-class New York 'aristocracy' to realistically portray the lives and morals of the Gilded Age. In 1921, she became the first woman to win the Pulitzer Prize in Literature, for her novel The Age of Innocence.",
    		search_term: "Edith Wharton",
    		diameter: "50.5",
    		center_lat: 55.7,
    		center_long: 61.9
    	},
    	{
    		feature_id: 101,
    		year: 1985,
    		feature: "Dorsum",
    		feature_plural: "Dorsa",
    		name: "Ahsonnutli Dorsa",
    		type: "Goddess",
    		origin: "Navajo",
    		continent: "North America",
    		clean_name: "Ahsonnutli",
    		description: "Navajo (N. America) spirit of light and sky.",
    		bio: "Asdzą́ą́ Nádleehé (also spelled Ahsonnutli), meaning \"the woman who changes\", is one of the creation spirits of the Navajo. According to the Navajos, she created the Navajo people by taking old skin from her body and using her mountain soil bundle (a bag made of four pieces of buckskin, brought by her father from the underworld) to create four couples, who are the ancestors of the four original Navajo clans. She helped create the sky and the earth.",
    		search_term: "Ahsonnutli",
    		diameter: "1,708.0",
    		center_lat: 47.9,
    		center_long: 196.5
    	},
    	{
    		feature_id: 455,
    		year: 1985,
    		feature: "Mons",
    		feature_plural: "Montes",
    		name: "Atira Mons",
    		type: "Goddess",
    		origin: "Pawnee",
    		continent: "North America",
    		clean_name: "Atira",
    		description: "Pawnee (N. America) wife of Great Spirit Tirawa.",
    		bio: "",
    		search_term: "",
    		diameter: "152.0",
    		center_lat: 52.2,
    		center_long: 267.6
    	},
    	{
    		feature_id: 1254,
    		year: 1985,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Coatlicue Corona",
    		type: "Goddess",
    		origin: "Aztec",
    		continent: "North America",
    		clean_name: "Coatlicue",
    		description: "Aztec earth goddess.",
    		bio: "Coatlicue, also known as Teteoinnan, is the Aztec goddess who gave birth to the moon, stars, and Huītzilōpōchtli, the god of the sun and war. Coatlicue is represented as a woman wearing a skirt of writhing snakes and a necklace made of human hearts, hands, and skulls. Her feet and hands are adorned with claws and her breasts are depicted as hanging flaccid from pregnancy.",
    		search_term: "Coatlicue",
    		diameter: "199.0",
    		center_lat: 63.2,
    		center_long: 273
    	},
    	{
    		feature_id: 2756,
    		year: 1985,
    		feature: "Tessera",
    		feature_plural: "Tesserae",
    		name: "Itzpapalotl Tessera",
    		type: "Goddess",
    		origin: "Aztec",
    		continent: "North America",
    		clean_name: "Itzpapalotl",
    		description: "Aztec goddess of fate.",
    		bio: "In Aztec religion, Ītzpāpālōtl (\"Obsidian Butterfly\") was a striking skeletal warrior goddess who ruled over the paradise world of Tamoanchan, the paradise of victims of infant mortality and the place identified as where humans were created. She is the mother of Mixcoatl and is particularly associated with the moth Rothschildia orizaba from the family Saturniidae. Some of her associations are birds and fire.",
    		search_term: "Itzpapalotl",
    		diameter: "380.0",
    		center_lat: 75.7,
    		center_long: 317.6
    	},
    	{
    		feature_id: 5921,
    		year: 1985,
    		feature: "Mons",
    		feature_plural: "Montes",
    		name: "Tepev Mons",
    		type: "Goddess",
    		origin: "Mayan",
    		continent: "North America",
    		clean_name: "Tepev",
    		description: "Quiche Mayan creator goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "301.0",
    		center_lat: 29,
    		center_long: 44.3
    	},
    	{
    		feature_id: 2968,
    		year: 1985,
    		feature: "Planitia",
    		feature_plural: "Planitiae",
    		name: "Kawelu Planitia",
    		type: "Heroine",
    		origin: "Hawaii",
    		continent: "North America",
    		clean_name: "Kawelu ",
    		description: "Hawaiian mythological heroine, died and brought back to life.",
    		bio: "",
    		search_term: "",
    		diameter: "3,910.0",
    		center_lat: 32.8,
    		center_long: 246.5
    	},
    	{
    		feature_id: 4821,
    		year: 1985,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Prichard",
    		type: "Famous Woman",
    		origin: "Australia",
    		continent: "Oceania",
    		clean_name: "Prichard",
    		description: "Catharina; Australian writer (1884-1969).",
    		bio: "",
    		search_term: "",
    		diameter: "23.3",
    		center_lat: 44,
    		center_long: 11.5
    	},
    	{
    		feature_id: 1903,
    		year: 1985,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Fakahotu Corona",
    		type: "Goddess",
    		origin: "Tuamotu",
    		continent: "Oceania",
    		clean_name: "Fakahotu",
    		description: "Tuamotu earth mother.",
    		bio: "",
    		search_term: "",
    		diameter: "290.0",
    		center_lat: 59.1,
    		center_long: 106.4
    	},
    	{
    		feature_id: 3511,
    		year: 1985,
    		feature: "Dorsum",
    		feature_plural: "Dorsa",
    		name: "Lukelong Dorsa",
    		type: "Goddess",
    		origin: "Caroline Island",
    		continent: "Oceania",
    		clean_name: "Lukelong",
    		description: "Polynesian goddess, creator of heavens.",
    		bio: "",
    		search_term: "",
    		diameter: "1,566.0",
    		center_lat: 73.3,
    		center_long: 178.8
    	},
    	{
    		feature_id: 6393,
    		year: 1985,
    		feature: "Planitia",
    		feature_plural: "Planitiae",
    		name: "Vinmara Planitia",
    		type: "Heroine",
    		origin: "Melanesia",
    		continent: "Oceania",
    		clean_name: "Vinmara ",
    		description: "Swan maiden whom sea god Qat kept on Earth by hiding her wings (New Hebrides).",
    		bio: "In a tale from New Hebrides, a man named Tagaro spies on winged women, named either Banewonowono (\"web skin\", possibly referring to bat-like wings), or Vinmara (\"dove skin\"), who descend to bathe in a lake. The man takes the wings of one of them. One day, when gathering yams, Tagaro's brothers scold her and she cries, her tears washing away the soil that covered the hiding place of her wings. She puts them on and returns to the skies.",
    		search_term: "Swan maiden",
    		diameter: "1,635.0",
    		center_lat: 53.8,
    		center_long: 207.6
    	},
    	{
    		feature_id: 540,
    		year: 1985,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Bachue Corona",
    		type: "Goddess",
    		origin: "Colombia",
    		continent: "South America",
    		clean_name: "Bachue",
    		description: "Chibcha (Colombia) goddess of fertility.",
    		bio: "The goddess Bachué (in Chibcha language: 'the one with the naked breast'), is a mother goddess that according to the Muisca religion is the mother of humanity. She emerged of the waters in the Iguaque Lake with a baby in her arms, who grew to become her husband and populated the Earth.",
    		search_term: "Bachué",
    		diameter: "463.0",
    		center_lat: 73.3,
    		center_long: 261.4
    	},
    	{
    		feature_id: 152,
    		year: 1991,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Al-Taymuriyya",
    		type: "Famous Woman",
    		origin: "Egypt",
    		continent: "Africa",
    		clean_name: "Al-Taymuriyya",
    		description: "Ayesha; Egyptian author, feminist (1840-1902).",
    		bio: "Aisha E'ismat Taymur (Arabic: عائشة عصمت تيمور‎ or 'A'isha al-Taymuriyya عائشة التيمورية‎; 1840–1902) was an Egyptian social activist, poet, novelist, and feminist in the Ottoman era. She was active in the early 19th century in the field of women's rights. Her writings came out in a period of time where women in Egypt were realizing that they were being deprived of some of the rights that Islam granted them.",
    		search_term: "Aisha Taymur",
    		diameter: "19.0",
    		center_lat: 32.9,
    		center_long: 336.1
    	},
    	{
    		feature_id: 224,
    		year: 1991,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Amenardes",
    		type: "Famous Woman",
    		origin: "Egypt",
    		continent: "Africa",
    		clean_name: "Amenardes",
    		description: "Egyptian princess (718-655 B.C.).",
    		bio: "Amenirdis I (throne name: Hatneferumut) was a God's Wife of Amun during the 25th Dynasty of ancient Egypt. Originating from the Kingdom of Kush, she was the daughter of Pharaoh Kashta and Queen Pebatjma, and was later adopted by Shepenupet I. She went on to rule as high priestess, and has been shown in several artifacts from the period. She was a Kushite princess, the daughter of Pharaoh Kashta and Queen Pebatjma.",
    		search_term: "Amenirdis I",
    		diameter: "27.9",
    		center_lat: 15,
    		center_long: 54.3
    	},
    	{
    		feature_id: 4190,
    		year: 1991,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Nefertiti Corona",
    		type: "Famous Woman",
    		origin: "Egypt",
    		continent: "Africa",
    		clean_name: "Nefertiti",
    		description: "Beautiful Egyptian queen (c. 1390-c. 1354 B.C.).",
    		bio: "Neferneferuaten Nefertiti () (c. 1370 – c. 1330 BC) was a queen of the 18th Dynasty of Ancient Egypt, the great royal wife of Pharaoh Akhenaten. Nefertiti and her husband were known for a radical change in national religious policy, in which they promoted a form of proto-monotheism centred on the sun god Aten. With her husband, she reigned at what was arguably the wealthiest period of ancient Egyptian history.",
    		search_term: "Nefertiti",
    		diameter: "371.0",
    		center_lat: 35.9,
    		center_long: 48.2
    	},
    	{
    		feature_id: 921,
    		year: 1991,
    		feature: "Mons",
    		feature_plural: "Montes",
    		name: "Bunzi Mons",
    		type: "Goddess",
    		origin: "Zaire",
    		continent: "Africa",
    		clean_name: "Bunzi",
    		description: "Woyo (Zaire) rainbow goddess.",
    		bio: "Bunzi, in Kongo mythology (mainly in Woyo people), is a goddess of rain. She is the daughter of Mboze, the Great Mother. Bunzi appears as a multicolored serpent, and rewards those who worship her with an abundant harvest.",
    		search_term: "Bunzi",
    		diameter: "36.0",
    		center_lat: 45.8,
    		center_long: 354.9
    	},
    	{
    		feature_id: 2891,
    		year: 1991,
    		feature: "Fluctus",
    		feature_plural: "Fluctūs",
    		name: "Kaiwan Fluctus",
    		type: "Goddess",
    		origin: "Ethiopia",
    		continent: "Africa",
    		clean_name: "Kaiwan",
    		description: "Ethiopian earth mother.",
    		bio: "",
    		search_term: "",
    		diameter: "1,200.0",
    		center_lat: -45.5,
    		center_long: 358
    	},
    	{
    		feature_id: 3764,
    		year: 1991,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Mawu Corona",
    		type: "Goddess",
    		origin: "Benin",
    		continent: "Africa",
    		clean_name: "Mawu",
    		description: "Fon (Benin) goddess of fertility.",
    		bio: "Mawu-Lisa (alternately: Mahu) is a creator goddess, associated with the Sun and Moon in Dahomey mythology. In some myths, she is the wife of the male god Lisa. Mahu and Lisa are the children of Nana Buluku, and are the parents of Xevioso.",
    		search_term: "Mawu",
    		diameter: "295.0",
    		center_lat: 31.7,
    		center_long: 241.3
    	},
    	{
    		feature_id: 4211,
    		year: 1991,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Nepret Corona",
    		type: "Goddess",
    		origin: "Egypt",
    		continent: "Africa",
    		clean_name: "Nepret",
    		description: "Egyptian grain goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "303.0",
    		center_lat: 52.7,
    		center_long: 6.8
    	},
    	{
    		feature_id: 4212,
    		year: 1991,
    		feature: "Mons",
    		feature_plural: "Montes",
    		name: "Nepthys Mons",
    		type: "Goddess",
    		origin: "Egypt",
    		continent: "Africa",
    		clean_name: "Nepthys",
    		description: "Egyptian goddess of barren lands.",
    		bio: "Nephthys or Nebet-Het in ancient Egyptian (Greek: Νέφθυς) was a goddess in ancient Egyptian religion. A member of the Great Ennead of Heliopolis in Egyptian mythology, she was a daughter of Nut and Geb. Nephthys was typically paired with her sister Isis in funerary rites because of their role as protectors of the mummy and the god Osiris and as the sister-wife of Set.",
    		search_term: "Nepthys",
    		diameter: "350.0",
    		center_lat: -33,
    		center_long: 317.5
    	},
    	{
    		feature_id: 4238,
    		year: 1991,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Neyterkob Corona",
    		type: "Goddess",
    		origin: "Kenya",
    		continent: "Africa",
    		clean_name: "Neyterkob",
    		description: "Masai earth/fertility goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "211.0",
    		center_lat: 49.7,
    		center_long: 204.7
    	},
    	{
    		feature_id: 52,
    		year: 1991,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Adivar",
    		type: "Famous Woman",
    		origin: "Turkey",
    		continent: "Asia",
    		clean_name: "Adivar",
    		description: "Halide; Turkish educator, author (1883-1964).",
    		bio: "Halide Edib Adıvar (Ottoman Turkish: خالده اديب [haːliˈde eˈdib], sometimes spelled Halidé Edib in English; 11 June 1884 – 9 January 1964) was a Turkish novelist, teacher, ultranationalist and feminist intellectual. She was best known for her novels criticizing the low social status of Turkish women and what she saw from her observation as the lack of interest of most women in changing their situation. She was a Pan-Turkist and several of her novels advocated for the Turanism movement. Halide Edib Adıvar is also remembered for her role in the forced assimilation of children orphaned in the Armenian genocide.",
    		search_term: "Halide Edib Adıvar",
    		diameter: "30.3",
    		center_lat: 8.9,
    		center_long: 76.2
    	},
    	{
    		feature_id: 258,
    		year: 1991,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Andami",
    		type: "Famous Woman",
    		origin: "Iran",
    		continent: "Asia",
    		clean_name: "Andami",
    		description: "Azar; Iranian doctor (1926-1984).",
    		bio: "Azar Andami (Persian: آذر اندامی, 8 December 1926 – 19 August 1984) was an Iranian physician and bacteriologist noted for her development of a cholera vaccine. Born in Rasht, Iran in 1926, she began her career as a teacher for the Ministry of Culture.",
    		search_term: "Azar Andami",
    		diameter: "28.9",
    		center_lat: -17.5,
    		center_long: 26.5
    	},
    	{
    		feature_id: 512,
    		year: 1991,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Avviyar",
    		type: "Famous Woman",
    		origin: "India",
    		continent: "Asia",
    		clean_name: "Avviyar",
    		description: "Tamil poet (c. 100 B.C.).",
    		bio: "Avvaiyar (Tamil: ஔவையார்) was the title of more than one female poet who were active during different periods of Tamil literature. They were some of the most famous and important female poets of the Tamil canon. Abidhana Chintamani states that there were three female poets titled Avvaiyar.",
    		search_term: "Avvaiyar",
    		diameter: "20.6",
    		center_lat: -18,
    		center_long: 353.7
    	},
    	{
    		feature_id: 591,
    		year: 1991,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Ban Zhao",
    		type: "Famous Woman",
    		origin: "China",
    		continent: "Asia",
    		clean_name: "Ban Zhao",
    		description: "Chinese historian (c. A.D. 35-100).",
    		bio: "Ban Zhao (Chinese: 班昭; 45 or 49 – c. 117/120 CE), courtesy name Huiban (Chinese: 惠班), was a Chinese historian, philosopher, and politician. She was the first known female Chinese historian and, along with Pamphile of Epidaurus, one of the first known female historians.",
    		search_term: "Ban Zhao",
    		diameter: "39.0",
    		center_lat: 17.1,
    		center_long: 147
    	},
    	{
    		feature_id: 1189,
    		year: 1991,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Chiyojo",
    		type: "Famous Woman",
    		origin: "Japan",
    		continent: "Asia",
    		clean_name: "Chiyojo",
    		description: "Japanese poet.",
    		bio: "Fukuda Chiyo-ni (福田 千代尼, 1703 - 2 October 1775) or Kaga no Chiyo (加賀 千代女) was a Japanese poet of the Edo period and a Buddhist nun. She is widely regarded as one of the greatest poets of haiku (then called hokku). Some of Chiyo's best works include The Morning Glory, Putting up my hair, and Again the women. Chiyo-ni's dedication toward her career not only paved a way for her career but it also opened a path for other women to follow.",
    		search_term: "Fukuda Chiyo-ni",
    		diameter: "40.2",
    		center_lat: -47.8,
    		center_long: 95.7
    	},
    	{
    		feature_id: 2509,
    		year: 1991,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Himiko",
    		type: "Famous Woman",
    		origin: "Japan",
    		continent: "Asia",
    		clean_name: "Himiko",
    		description: "Japanese queen (4th century A.D.).",
    		bio: "Himiko (卑弥呼, c. 170–248 AD), also known as Shingi Waō (親魏倭王, 'Ruler of Wa, Friend of Wei'), was a shamaness-queen of Yamatai-koku in Wakoku (倭国). Early Chinese dynastic histories chronicle tributary relations between Queen Himiko and the Cao Wei Kingdom (220–265) and record that the Yayoi period people chose her as ruler following decades of warfare among the kings of Wa. Early Japanese histories do not mention Himiko, but historians associate her with legendary figures such as Empress Consort Jingū, who was regent (c. 200–269) in roughly the same era as Himiko.Scholarly debates over the identity of Himiko and the location of her domain, Yamatai, have raged since the late Edo period, with opinions divided between northern Kyūshū or traditional Yamato Province in present-day Kinki.",
    		search_term: "Himiko",
    		diameter: "36.6",
    		center_lat: 19,
    		center_long: 124.3
    	},
    	{
    		feature_id: 2569,
    		year: 1991,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Hua Mulan",
    		type: "Famous Woman",
    		origin: "China",
    		continent: "Asia",
    		clean_name: "Hua Mulan",
    		description: "Chinese warrior (c. A.D. 590).",
    		bio: "Hua Mulan (traditional Chinese: 花木蘭; simplified Chinese: 花木兰) is a legendary folk heroine from the Northern and Southern dynasties era (4th to 6th century CE) of Chinese history. According to legend, Mulan took her aged father's place in the conscription for the army by disguising herself as a man. In the story, after prolonged and distinguished military service against nomadic hordes beyond the northern frontier, Mulan is honored by the emperor but declines a position of high office.",
    		search_term: "Hua Mulan",
    		diameter: "24.0",
    		center_lat: 86.8,
    		center_long: 337.7
    	},
    	{
    		feature_id: 2571,
    		year: 1991,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Huang Daopo",
    		type: "Famous Woman",
    		origin: "China",
    		continent: "Asia",
    		clean_name: "Huang Daopo",
    		description: "Chinese engineer.",
    		bio: "Huang Daopo (simplified Chinese: 黄道婆; traditional Chinese: 黃道婆; pinyin: Huáng Dàopó; c. 1245 – 1330) rose from poverty to become one of the most famous women in the early Chinese textile industry. Huang was likely born around 1240 or 1245.",
    		search_term: "Huang Daopo",
    		diameter: "29.1",
    		center_lat: -54.2,
    		center_long: 165.3
    	},
    	{
    		feature_id: 2597,
    		year: 1991,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Hwangcini",
    		type: "Famous Woman",
    		origin: "Korea",
    		continent: "Asia",
    		clean_name: "Hwangcini",
    		description: "Korean poet (16th century A.D.).",
    		bio: "Hwang Jini or Hwang Jin-Yi (Korean: 황진이; c. 1506 – c. 1560), also known by her gisaeng name Myeongwol ('bright moon', 명월), was one of the most famous gisaeng of the Joseon Dynasty.",
    		search_term: "Hwang Jini",
    		diameter: "30.2",
    		center_lat: 6.3,
    		center_long: 141.8
    	},
    	{
    		feature_id: 2940,
    		year: 1991,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Kartini",
    		type: "Famous Woman",
    		origin: "Indonesia",
    		continent: "Asia",
    		clean_name: "Kartini",
    		description: "Raden Adjeng; Javanese educator (1879-1904).",
    		bio: "Raden Adjeng Kartini (21 April 1879 – 17 September 1904), also known as Raden Ayu Kartini, was a prominent Indonesian activist who advocated for women's rights and female education. She was born into an aristocratic Javanese family in the Dutch East Indies (present-day Indonesia). After attending a Dutch-language primary school, she wanted to pursue further education, but Javanese women at the time were barred from higher education.",
    		search_term: "Kartini",
    		diameter: "23.4",
    		center_lat: 57.8,
    		center_long: 333
    	},
    	{
    		feature_id: 3381,
    		year: 1991,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Li Qingzhao",
    		type: "Famous Woman",
    		origin: "China",
    		continent: "Asia",
    		clean_name: "Li Qingzhao",
    		description: "Chinese essayist, scholar (1085-1151).",
    		bio: "Li Qingzhao (1084 – ca. 1155), alias Yian Jushi (Chinese: 易安居士) was a Chinese poet and essayist during the Song dynasty. She is considered one of the greatest poets in Chinese history.",
    		search_term: "Li Qingzhao",
    		diameter: "22.8",
    		center_lat: 23.7,
    		center_long: 94.6
    	},
    	{
    		feature_id: 4059,
    		year: 1991,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Mu Guiying",
    		type: "Famous Woman",
    		origin: "China",
    		continent: "Asia",
    		clean_name: "Mu Guiying",
    		description: "Chinese warrior.",
    		bio: "Mu Guiying (穆桂英) is a legendary heroine from ancient China's Northern Song Dynasty and a prominent figure in the Generals of the Yang Family legends. She is the wife of Yang Zongbao and mother of Yang Wenguang. Brave, resolute and loyal, Mu is the cultural symbol of a steadfast woman.",
    		search_term: "Mu Guiying",
    		diameter: "32.3",
    		center_lat: 41.2,
    		center_long: 81
    	},
    	{
    		feature_id: 5293,
    		year: 1991,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Samintang",
    		type: "Famous Woman",
    		origin: "Korea",
    		continent: "Asia",
    		clean_name: "Samintang",
    		description: "16th century Korean poet.",
    		bio: "Shin Saimdang (Hangul: 신사임당, Hanja: 申師任堂; 29 October 1504 – 17 May 1551) was a Korean artist, writer, calligraphist, and poet, who lived during the Joseon period. She was born in Gangneung, Gangwon Province. Her birth home, Ojukheon, which is also her maternal family's home, is well-preserved to this day.",
    		search_term: "Shin Saimdang",
    		diameter: "25.9",
    		center_lat: -39,
    		center_long: 80.7
    	},
    	{
    		feature_id: 6610,
    		year: 1991,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Xiao Hong",
    		type: "Famous Woman",
    		origin: "China",
    		continent: "Asia",
    		clean_name: "Xiao Hong",
    		description: "Chinese novelist (1911-1942).",
    		bio: "Xiao Hong or Hsiao Hung (1 June 1911 – 22 January 1942) was a Chinese writer. Her ruming (乳名，infant name) was Zhang Ronghua (張榮華). Her xueming (學名，formal name used at school) was Zhang Xiuhuan (張秀環).",
    		search_term: "Xiao Hong",
    		diameter: "38.7",
    		center_lat: -43.5,
    		center_long: 101.7
    	},
    	{
    		feature_id: 6734,
    		year: 1991,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Zhu Shuzhen",
    		type: "Famous Woman",
    		origin: "China",
    		continent: "Asia",
    		clean_name: "Zhu Shuzhen",
    		description: "Chinese poet (1126-1200).",
    		bio: "Zhu Shuzhen (Chinese: 朱淑真; c. 1135 – 1180) was a Chinese poet who lived during the Song dynasty. She married an official with whom she had a bad marriage.",
    		search_term: "Zhu Shuzhen",
    		diameter: "29.4",
    		center_lat: -26.5,
    		center_long: 356.5
    	},
    	{
    		feature_id: 5205,
    		year: 1991,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Roxanna",
    		type: "First Name",
    		origin: "Persian",
    		continent: "Asia",
    		clean_name: "Roxanna",
    		description: "First name from Persian.",
    		bio: "",
    		search_term: "",
    		diameter: "9.5",
    		center_lat: 26.5,
    		center_long: 334.6
    	},
    	{
    		feature_id: 642,
    		year: 1991,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Bau Corona",
    		type: "Goddess",
    		origin: "Sumerian",
    		continent: "Asia",
    		clean_name: "Bau",
    		description: "Sumerian fertility goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "355.0",
    		center_lat: 52.8,
    		center_long: 259.3
    	},
    	{
    		feature_id: 1931,
    		year: 1991,
    		feature: "Fossa",
    		feature_plural: "Fossae",
    		name: "Felesta Fossae",
    		type: "Goddess",
    		origin: "Scythia",
    		continent: "Asia",
    		clean_name: "Felesta",
    		description: "Amazon queen in Scythian epic tales.",
    		bio: "",
    		search_term: "",
    		diameter: "570.0",
    		center_lat: 34.5,
    		center_long: 46.5
    	},
    	{
    		feature_id: 2785,
    		year: 1991,
    		feature: "Mons",
    		feature_plural: "Montes",
    		name: "Jael Mons",
    		type: "Goddess",
    		origin: "Hebrew",
    		continent: "Asia",
    		clean_name: "Jael",
    		description: "Hebrew goddess of dawn.",
    		bio: "Jael or Yael (Hebrew: יָעֵל Yāʿēl) is the name of the heroine who delivered Israel from the army of King Jabin of Canaan in the Book of Judges of the Hebrew Bible. After Barak demurred at the behest of the prophetess Deborah, God turned Sisera over to Jael, who killed him by driving a tent peg through his skull after he entered her tent near the great tree in Zaanannim near Kedesh. The Hebrew ya'el means ibex, a nimble, sure-footed mountain goat native to that region.",
    		search_term: "Jael",
    		diameter: "36.0",
    		center_lat: 51.2,
    		center_long: 120.8
    	},
    	{
    		feature_id: 2910,
    		year: 1991,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Kamui-Huci Corona",
    		type: "Goddess",
    		origin: "Japan",
    		continent: "Asia",
    		clean_name: "Kamui-Huci",
    		description: "Ainu (Japan) earth goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "300.0",
    		center_lat: -63.5,
    		center_long: 322.5
    	},
    	{
    		feature_id: 3170,
    		year: 1991,
    		feature: "Mons",
    		feature_plural: "Montes",
    		name: "Kurukulla Mons",
    		type: "Goddess",
    		origin: "Tibet",
    		continent: "Asia",
    		clean_name: "Kurukulla",
    		description: "Etan (Tibet) goddess of wealth.",
    		bio: "Kurukullā is a female, peaceful to semi-wrathful Yidam in Tibetan Buddhism particularly associated with rites of magnetization or enchantment. Kurukullā is a goddess whose body is usually depicted in red with four arms, holding a bow and arrow made of flowers in one pair of hands and a hook and noose of flowers in the other pair. She dances in a Dakini-pose and crushes the asura Rahu (the one who devours the sun).",
    		search_term: "Kurukulla",
    		diameter: "59.0",
    		center_lat: 48.7,
    		center_long: 103
    	},
    	{
    		feature_id: 3875,
    		year: 1991,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Metra Corona",
    		type: "Goddess",
    		origin: "Persian",
    		continent: "Asia",
    		clean_name: "Metra",
    		description: "Persian fertility/moon goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "101.0",
    		center_lat: 26,
    		center_long: 97.7
    	},
    	{
    		feature_id: 4527,
    		year: 1991,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Otygen Corona",
    		type: "Goddess",
    		origin: "Mongolia",
    		continent: "Asia",
    		clean_name: "Otygen",
    		description: "Mongolian earth mother.",
    		bio: "",
    		search_term: "",
    		diameter: "400.0",
    		center_lat: -57,
    		center_long: 30.5
    	},
    	{
    		feature_id: 5525,
    		year: 1991,
    		feature: "Dorsum",
    		feature_plural: "Dorsa",
    		name: "Sige Dorsa",
    		type: "Goddess",
    		origin: "Babylon",
    		continent: "Asia",
    		clean_name: "Sige",
    		description: "Babylonian sky goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "478.0",
    		center_lat: 31.2,
    		center_long: 106.9
    	},
    	{
    		feature_id: 6176,
    		year: 1991,
    		feature: "Collis",
    		feature_plural: "Colles",
    		name: "T'ien Hu Colles",
    		type: "Goddess",
    		origin: "China",
    		continent: "Asia",
    		clean_name: "T'ien Hu",
    		description: "Chinese sea goddess.",
    		bio: "Mazu or Matsu is a Chinese sea goddess also known by several other names and titles. She is the deified form of the legendary figure Lin Mo or Lin Moniang, a Fujianese shamaness whose life span is traditionally dated from 960 to 987. She was revered after her death as a tutelary deity of seafarers, including fishermen and sailors. She was thought to roam the seas, protecting her believers through miraculous interventions.",
    		search_term: "Mazu",
    		diameter: "947.0",
    		center_lat: 30.7,
    		center_long: 15.1
    	},
    	{
    		feature_id: 85,
    		year: 1991,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Aglaonice",
    		type: "Famous Woman",
    		origin: "Greek",
    		continent: "Europe",
    		clean_name: "Aglaonice",
    		description: "Ancient Greek astronomer.",
    		bio: "Aglaonice or Aganice of Thessaly (Ancient Greek: Ἀγλαονίκη, Aglaoníkē, compound of αγλαὸς (aglaòs) 'luminous' and νίκη (nikē) 'victory') was a Greek astronomer and thaumaturge of the 2nd or 1st century BC. She is mentioned in the writings of Plutarch and in the scholia to Apollonius of Rhodes as a female astronomer and as the daughter of Hegetor (or Hegemon) of Thessaly. She was regarded as a sorceress for (amongst other extraordinary feats) her (self-proclaimed) ability to 'make the moon disappear from the sky' (καθαιρεῖν τὴν σελήνην : kathaireĩn tìn selénen) which has been taken – first by Plutarch and subsequently by modern astronomers – to mean that she could predict the time and general area where a lunar eclipse would occur. A Greek proverb makes reference to Aglaonice's alleged boasting: 'Yes, as the Moon obeys Aglaonice'.",
    		search_term: "Aglaonice",
    		diameter: "63.7",
    		center_lat: -26.4,
    		center_long: 339.9
    	},
    	{
    		feature_id: 87,
    		year: 1991,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Agnesi",
    		type: "Famous Woman",
    		origin: "Italy",
    		continent: "Europe",
    		clean_name: "Agnesi",
    		description: "Maria; Italian mathematician (1718-1799).",
    		bio: "Maria Gaetana Agnesi (UK: an-YAY-zee, US: ahn-, Italian: [maˈriːa ɡaeˈtaːna aɲˈɲeːzi, -ɲɛːz-]; 16 May 1718 – 9 January 1799) was an Italian mathematician, philosopher, theologian, and humanitarian. She was the first woman to write a mathematics handbook and the first woman appointed as a mathematics professor at a university.",
    		search_term: "Maria Gaetana Agnesi",
    		diameter: "42.4",
    		center_lat: -39.4,
    		center_long: 37.7
    	},
    	{
    		feature_id: 93,
    		year: 1991,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Agrippina",
    		type: "Famous Woman",
    		origin: "Roman",
    		continent: "Europe",
    		clean_name: "Agrippina",
    		description: "Roman empress (c. 13 B.C.-A.D. 33).",
    		bio: "Agrippina 'the Elder' (also, in Latin, Agrippina Germanici, 'Germanicus's Agrippina'; c. 14 BC – AD 33) was a prominent member of the Julio-Claudian dynasty. She was the daughter of Marcus Vipsanius Agrippa (a close supporter of the first Roman emperor, Augustus) and Augustus' daughter, Julia the Elder. Her brothers Lucius and Gaius Caesar were the adoptive sons of Augustus, and were his heirs until their deaths in AD 2 and 4, respectively.",
    		search_term: "Agrippina the Elder",
    		diameter: "38.6",
    		center_lat: -33.2,
    		center_long: 65.7
    	},
    	{
    		feature_id: 212,
    		year: 1991,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Amalasuntha",
    		type: "Famous Woman",
    		origin: "Italy",
    		continent: "Europe",
    		clean_name: "Amalasuntha",
    		description: "Ostrogoth queen (c. 498-535 A.D.). Changed from Amalasthuna.",
    		bio: "Amalasuintha (c. 495 – 30 April 534/535) was an Ostrogoth queen and regent. She ruled the Ostrogoths as regent during the minority of her son from 526 to 534 and then as queen regnant from 534 to 535. She was the youngest daughter of Theoderic the Great, and firmly believed in the upholding of Roman virtues and values.",
    		search_term: "Amalasuintha",
    		diameter: "15.4",
    		center_lat: -11.5,
    		center_long: 342.4
    	},
    	{
    		feature_id: 217,
    		year: 1991,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Amaya",
    		type: "Famous Woman",
    		origin: "Spain",
    		continent: "Europe",
    		clean_name: "Amaya",
    		description: "Carmen; Spanish Romani dancer (1913-1963).",
    		bio: "Carmen Amaya Amaya (2 November 1913/1915 – 19 November 1963) was a Spanish Romani flamenco dancer and singer, born in the Somorrostro district of Barcelona, Catalonia, Spain. She has been called 'the greatest Flamenco dancer ever and 'the most extraordinary personality of all time in flamenco dance.' She was the first female flamenco dancer to master footwork previously reserved for the best male dancers, due to its speed and intensity. She sometimes danced in high-waisted trousers as a symbol of her strong character.",
    		search_term: "Carmen Amaya",
    		diameter: "34.5",
    		center_lat: 11.3,
    		center_long: 89.4
    	},
    	{
    		feature_id: 278,
    		year: 1991,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Anicia",
    		type: "Famous Woman",
    		origin: "Greek",
    		continent: "Europe",
    		clean_name: "Anicia",
    		description: "Greek physician, poet (fl. c.300 B.C.).",
    		bio: "",
    		search_term: "",
    		diameter: "38.2",
    		center_lat: -26.3,
    		center_long: 31.3
    	},
    	{
    		feature_id: 284,
    		year: 1991,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Annia Faustina",
    		type: "Famous Woman",
    		origin: "Roman",
    		continent: "Europe",
    		clean_name: "Annia Faustina",
    		description: "Roman empress, wife of Marcus Aurelius (125-175 A.D.).",
    		bio: "Annia Aurelia Faustina (fl. c. 201 – c. 222) was an Anatolian Roman noblewoman. She was briefly married to the Roman emperor Elagabalus in 221 and thus a Roman empress. She was Elagabalus' third wife. ",
    		search_term: "Annia Faustina",
    		diameter: "23.4",
    		center_lat: 22.1,
    		center_long: 4.7
    	},
    	{
    		feature_id: 285,
    		year: 1991,
    		feature: "Patera",
    		feature_plural: "Paterae",
    		name: "Anning Paterae",
    		type: "Famous Woman",
    		origin: "Great Britain",
    		continent: "Europe",
    		clean_name: "Anninge",
    		description: "Mary; English paleontologist (1799-1847).",
    		bio: "Mary Anning (21 May 1799 – 9 March 1847) was an English fossil collector, dealer, and palaeontologist who became known around the world for the discoveries she made in Jurassic marine fossil beds in the cliffs along the English Channel at Lyme Regis in the county of Dorset in Southwest England. Anning's findings contributed to changes in scientific thinking about prehistoric life and the history of the Earth. Anning searched for fossils in the area's Blue Lias and Charmouth Mudstone cliffs, particularly during the winter months when landslides exposed new fossils that had to be collected quickly before they were lost to the sea.",
    		search_term: "Mary Anning",
    		diameter: "0.0",
    		center_lat: 66.5,
    		center_long: 57.8
    	},
    	{
    		feature_id: 472,
    		year: 1991,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Aurelia",
    		type: "Famous Woman",
    		origin: "Roman",
    		continent: "Europe",
    		clean_name: "Aurelia",
    		description: "Mother of Julius Caesar.",
    		bio: "Aurelia (c. 120 BC – July 31, 54 BC) was the mother of the Roman general and statesman Julius Caesar. The historian Tacitus considered her an ideal Roman matron and thought highly of her, because she offered her children the best opportunities of education. Plutarch described her as a woman of discretion. Highly intelligent, independent and renowned for her beauty and common sense, Aurelia was held in high regard throughout Rome.",
    		search_term: "Aurelia (mother of Caesar)",
    		diameter: "31.1",
    		center_lat: 20.3,
    		center_long: 331.8
    	},
    	{
    		feature_id: 547,
    		year: 1991,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Badarzewska",
    		type: "Famous Woman",
    		origin: "Poland",
    		continent: "Europe",
    		clean_name: "Badarzewska",
    		description: "Thekla; Polish composer (1834-1861).",
    		bio: "Tekla Bądarzewska-Baranowska (1829/1834 – 29 September 1861) was a Polish composer and pianist. She composed mainly for the piano and is internationally known for her composition A Maiden's Prayer. Bądarzewska was born in 1829 in Mława or 1834 in Warsaw to Andrzej Bądarzewski and Tekla Bądarzewska (Chrzanowska).",
    		search_term: "Tekla Bądarzewska-Baranowska",
    		diameter: "29.6",
    		center_lat: -22.6,
    		center_long: 137.2
    	},
    	{
    		feature_id: 614,
    		year: 1991,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Barrera",
    		type: "Famous Woman",
    		origin: "Spain",
    		continent: "Europe",
    		clean_name: "Barrera",
    		description: "Olivia; Spanish medical writer (b. 1562).",
    		bio: "Oliva Sabuco de Nantes Barrera (2 December 1562 in Alcaraz – c. 1646) was a Spanish writer in holistic medical philosophy in the late 16th – early 17th century. She was interested in the interaction between the physical and psychological phenomena; therefore she wrote a collection of medical and psychological treatises that target human nature and explain the effects of emotions on the body and soul. She analyzed theoretical claims of ancient philosophers and wrote an early theory of what is now considered applied psychology.",
    		search_term: "Oliva Sabuco",
    		diameter: "27.0",
    		center_lat: 16.6,
    		center_long: 109.4
    	},
    	{
    		feature_id: 630,
    		year: 1991,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Bassi",
    		type: "Famous Woman",
    		origin: "Italy",
    		continent: "Europe",
    		clean_name: "Bassi",
    		description: "Laura; Italian physicist, mathematician (1711-1778).",
    		bio: "Laura Maria Caterina Bassi Veratti (29 October 1711 – 20 February 1778) was an Italian physicist and academic. Recognized and depicted as 'Minerva' (goddess of wisdom), she was the first woman to have a doctorate in science, and the second woman in the world to earn the Doctor of Philosophy degree. Working at the University of Bologna, she was also the first salaried female teacher in a university.",
    		search_term: "Laura Bassi",
    		diameter: "31.0",
    		center_lat: -19,
    		center_long: 64.6
    	},
    	{
    		feature_id: 663,
    		year: 1991,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Behn",
    		type: "Famous Woman",
    		origin: "England",
    		continent: "Europe",
    		clean_name: "Behn",
    		description: "Aphra; English novelist, poet, playwright (1640-1689).",
    		bio: "Aphra Behn (; bapt. 14 December 1640 – 16 April 1689) was an English playwright, poet, prose writer and translator from the Restoration era. As one of the first English women to earn her living by her writing, she broke cultural barriers and served as a literary role model for later generations of women authors.",
    		search_term: "Aphra Behn",
    		diameter: "25.4",
    		center_lat: -32.4,
    		center_long: 142
    	},
    	{
    		feature_id: 778,
    		year: 1991,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Blixen",
    		type: "Famous Woman",
    		origin: "Denmark",
    		continent: "Europe",
    		clean_name: "Blixen",
    		description: "Karen; Danish author (1885-1962).",
    		bio: "Baroness Karen Christenze von Blixen-Finecke (born Dinesen; 17 April 1885 – 7 September 1962) was a Danish author who wrote works in Danish and English. She is also known under her pen names Isak Dinesen, used in English-speaking countries, Tania Blixen, used in German-speaking countries, Osceola, and Pierre Andrézel. Blixen is best known for Out of Africa, an account of her life while living in Kenya, and for one of her stories, Babette's Feast, both of which have been adapted into Academy Award–winning motion pictures.",
    		search_term: "Karen Blixen",
    		diameter: "20.8",
    		center_lat: -60.1,
    		center_long: 145.7
    	},
    	{
    		feature_id: 783,
    		year: 1991,
    		feature: "Patera",
    		feature_plural: "Paterae",
    		name: "Boadicea Paterae",
    		type: "Famous Woman",
    		origin: "Great Britain",
    		continent: "Europe",
    		clean_name: "Boadiceae",
    		description: "(Boudicca); queen and heroine of Iceni (English Celtic tribe) (d. A.D. 62).",
    		bio: "Boudica or Boudicca (, known in Latin chronicles as Boadicea or Boudicea, and in Welsh as Buddug (Welsh pronunciation: [bɨðɨɡ]), was the wife of a Celtic Briton king of the Iceni tribe, who led a failed uprising against the conquering forces of the Roman Empire in AD 60 or 61. According to Roman sources, shortly after the uprising failed, she poisoned herself or died of her wounds, although there is no actual evidence of either fate. She is considered a British national heroine and a symbol of the struggle for justice and independence.",
    		search_term: "Boudica",
    		diameter: "220.0",
    		center_lat: 56.6,
    		center_long: 96.5
    	},
    	{
    		feature_id: 815,
    		year: 1991,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Bonnevie",
    		type: "Famous Woman",
    		origin: "Norway",
    		continent: "Europe",
    		clean_name: "Bonnevie",
    		description: "Kristine; Norwegian biologist (1872-1948).",
    		bio: "Kristine Elisabeth Heuch Bonnevie (8 October 1872 – 30 August 1948) was a Norwegian biologist, Norway's first female professor, women's rights activist and politician for the Free-minded Liberal Party. Her fields of research were cytology, genetics and embryology. She was among the first women to be elected to political positions in Norway.",
    		search_term: "Kristine Bonnevie",
    		diameter: "92.2",
    		center_lat: -36.1,
    		center_long: 127
    	},
    	{
    		feature_id: 841,
    		year: 1991,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Boulanger",
    		type: "Famous Woman",
    		origin: "France",
    		continent: "Europe",
    		clean_name: "Boulanger",
    		description: "Nadia; French pianist, composer (1881-1979).",
    		bio: "Juliette Nadia Boulanger (French: [ʒyljɛt nadja bulɑ̃ʒe] ; 16 September 1887 – 22 October 1979) was a French music teacher and conductor. She taught many of the leading composers and musicians of the 20th century, and also performed occasionally as a pianist and organist. From a musical family, she achieved early honours as a student at the Conservatoire de Paris but, believing that she had no particular talent as a composer, she gave up writing music and became a teacher. In that capacity, she influenced generations of young composers, especially those from the United States and other English-speaking countries.",
    		search_term: "Nadia Boulanger",
    		diameter: "71.5",
    		center_lat: -26.6,
    		center_long: 99.2
    	},
    	{
    		feature_id: 871,
    		year: 1991,
    		feature: "Patera",
    		feature_plural: "Paterae",
    		name: "Bremer Patera",
    		type: "Famous Woman",
    		origin: "Sweden",
    		continent: "Europe",
    		clean_name: "Bremer",
    		description: "Frederika; Swedish writer, reformer, feminist (1801-1865).",
    		bio: "Fredrika Bremer (17 August 1801 – 31 December 1865) was a Finnish-born Swedish writer and feminist reformer. Her Sketches of Everyday Life were wildly popular in Britain and the United States during the 1840s and 1850s and she is regarded as the Swedish Jane Austen, bringing the realist novel to prominence in Swedish literature. In her late 30s, she successfully petitioned King Charles XIV for emancipation from her brother's wardship; in her 50s, her novel Hertha prompted a social movement that granted all unmarried Swedish women legal majority at the age of 25 and established Högre Lärarinneseminariet, Sweden's first female tertiary school.",
    		search_term: "Frederika Bremer",
    		diameter: "91.0",
    		center_lat: 66.8,
    		center_long: 63.7
    	},
    	{
    		feature_id: 908,
    		year: 1991,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Budevska",
    		type: "Famous Woman",
    		origin: "Bulgaria",
    		continent: "Europe",
    		clean_name: "Budevska",
    		description: "Adriana; Bulgarian actress (1878-1955).",
    		bio: "Adriana Budevska (13 December 1878 – 9 December 1955), was a Bulgarian actress, one of the founders of the professional theater in Bulgaria. She has been called one of the biggest Bulgarian interpretators of tragic roles.",
    		search_term: "Adriana Budevska",
    		diameter: "18.0",
    		center_lat: 0.5,
    		center_long: 143.2
    	},
    	{
    		feature_id: 977,
    		year: 1991,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Callirhoe",
    		type: "Famous Woman",
    		origin: "Greek",
    		continent: "Europe",
    		clean_name: "Callirhoe",
    		description: "Kora of Sicyon; Greek sculptor (c. 600 B.C.).",
    		bio: "Kora (Greek: Κόρα) or Callirhoe (fl. c. 650 BC) is considered to be the first female artist for whom there is evidence. She was said to be the daughter of Butades of Sicyon, a potter and sculpture of the time. Kora drew the shadow of the face of her lover with coal on the wall. Butades immediately recognized the likeness and quickly filled his daughter's portrait with clay. This was considered to be the first clay relief.",
    		search_term: "Kora of Sicyon",
    		diameter: "33.8",
    		center_lat: 21.2,
    		center_long: 140.7
    	},
    	{
    		feature_id: 1309,
    		year: 1991,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Cori",
    		type: "Famous Woman",
    		origin: "Czechoslovakia",
    		continent: "Europe",
    		clean_name: "Cori",
    		description: "Gerty; Czech biochemist, Nobel laureate (1896-1957).",
    		bio: "Gerty Theresa Cori (née Radnitz; August 15, 1896 – October 26, 1957) was an Austro-Hungarian and American biochemist who in 1947 was the third woman to win a Nobel Prize in science, and the first woman to be awarded the Nobel Prize in Physiology or Medicine, for her significant role in the 'discovery of the course of the catalytic conversion of glycogen'.",
    		search_term: "Gerty Cori",
    		diameter: "56.1",
    		center_lat: 25.4,
    		center_long: 72.9
    	},
    	{
    		feature_id: 1348,
    		year: 1991,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Cunitz",
    		type: "Famous Woman",
    		origin: "Poland",
    		continent: "Europe",
    		clean_name: "Cunitz",
    		description: "Maria; Polish astronomer-mathematician (1610-1664).",
    		bio: "Maria Cunitz or Maria Cunitia (other versions of surname include: Cunicia, Cunitzin, Kunic, Cunitiae, Kunicia, Kunicka; 1610 – 22 August 1664) was an accomplished Silesian astronomer, and the most notable female astronomer of the early modern era. She authored a book Urania propitia, in which she provided new tables, new ephemera, and a simpler working solution to Kepler's second law for determining the position of a planet on its elliptical path. The Cunitz crater on Venus is named after her.",
    		search_term: "Maria Cunitz",
    		diameter: "48.6",
    		center_lat: 14.5,
    		center_long: 350.9
    	},
    	{
    		feature_id: 1401,
    		year: 1991,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Danilova",
    		type: "Famous Woman",
    		origin: "Russia",
    		continent: "Europe",
    		clean_name: "Danilova",
    		description: "Maria; Russian ballet dancer (1793-1810), Alexandra; Russian-American ballet dancer (1903-1997).",
    		bio: "Maria Danilova (1793 – 1810) was a Russian ballet dancer. Danilova enrolled in the St. Petersburg school at the age of eight.",
    		search_term: "Maria Danilova",
    		diameter: "48.8",
    		center_lat: -26.4,
    		center_long: 337.2
    	},
    	{
    		feature_id: 1427,
    		year: 1991,
    		feature: "Patera",
    		feature_plural: "Paterae",
    		name: "Davies Patera",
    		type: "Famous Woman",
    		origin: "Great Britain",
    		continent: "Europe",
    		clean_name: "Davies",
    		description: "Sarah Emily; British educator; college founder (1830-1921).",
    		bio: "Sarah Emily Davies (22 April 1830 – 13 July 1921) was an English feminist and suffragist, and a pioneering campaigner for women's rights to university access. She is remembered above all as a co-founder and an early Mistress of Girton College, Cambridge, the first university college in England to educate women. Davies was born in Carlton Crescent, Southampton, England, to an evangelical clergyman and a teacher, although she spent most of her youth in Gateshead, where her father, John D. Davies, was Rector.Davies had been tempted to train in medicine.",
    		search_term: "Emily Davies",
    		diameter: "93.0",
    		center_lat: 47.2,
    		center_long: 269.3
    	},
    	{
    		feature_id: 1436,
    		year: 1991,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "de Beauvoir",
    		type: "Famous Woman",
    		origin: "France",
    		continent: "Europe",
    		clean_name: "de Beauvoir",
    		description: "Simone; French writer (1908-1986).",
    		bio: "Simone Lucie Ernestine Marie Bertrand de Beauvoir (UK: , US: ; French: [simɔn də bovwaʁ] ; 9 January 1908 – 14 April 1986) was a French existentialist philosopher, writer, social theorist, and feminist activist. Though she did not consider herself a philosopher, and even though she was not considered one at the time of her death, she had a significant influence on both feminist existentialism and feminist theory.Beauvoir wrote novels, essays, biographies, autobiographies, and monographs on philosophy, politics, and social issues. She was known for her 1949 treatise The Second Sex, a detailed analysis of women's oppression and a foundational tract of contemporary feminism; and for her novels, including She Came to Stay (1943) and The Mandarins (1954).",
    		search_term: "Simone de Beauvoir",
    		diameter: "52.5",
    		center_lat: 2,
    		center_long: 96.1
    	},
    	{
    		feature_id: 1441,
    		year: 1991,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "de Lalande",
    		type: "Famous Woman",
    		origin: "France",
    		continent: "Europe",
    		clean_name: "de Lalande",
    		description: "Marie-Jeanne; French astronomer (1768-1832).",
    		bio: "Marie-Jeanne-Amélie Le Francais de Lalande, born Marie-Jeanne Harlay (1768 – November 8, 1832), was a French astronomer and mathematician. Lalande married her father's young cousin, also an astronomer, Michel Lefrançois de Lalande (1776-1839) in 1788. She was also the niece of the astronomer and writer Jérôme Lalande, who was said to have valued Lalande for her mathematical disposition.Her father taught the young couple calculation and observation methods in astronomy.",
    		search_term: "Marie-Jeanne de Lalande",
    		diameter: "21.3",
    		center_lat: 20.5,
    		center_long: 355
    	},
    	{
    		feature_id: 1766,
    		year: 1991,
    		feature: "Patera",
    		feature_plural: "Paterae",
    		name: "Eliot Patera",
    		type: "Famous Woman",
    		origin: "Great Britain",
    		continent: "Europe",
    		clean_name: "Eliot",
    		description: "George; (Mary Ann Evans) English writer (1819-1880).",
    		bio: "Mary Ann Evans (22 November 1819 – 22 December 1880; alternatively Mary Anne or Marian), known by her pen name George Eliot, was an English novelist, poet, journalist, translator, and one of the leading writers of the Victorian era. She wrote seven novels: Adam Bede (1859), The Mill on the Floss (1860), Silas Marner (1861), Romola (1862–63), Felix Holt, the Radical (1866), Middlemarch (1871–72) and Daniel Deronda (1876). Like Charles Dickens and Thomas Hardy, she emerged from provincial England; most of her works are set there.",
    		search_term: "George Eliot",
    		diameter: "116.0",
    		center_lat: 39.1,
    		center_long: 79
    	},
    	{
    		feature_id: 1838,
    		year: 1991,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Erxleben",
    		type: "Famous Woman",
    		origin: "Germany",
    		continent: "Europe",
    		clean_name: "Erxleben",
    		description: "Dorothea; first woman Ph.D in Germany (1715-1762).",
    		bio: "Dorothea Christiane Erxleben (13 November 1715 – 13 June 1762) was a German doctor who became the first female doctor of medicinal science in Germany. Dorothea was born in the small town of Quedlinburg, Germany to the town’s progressive doctor, physician Christian Polycarp Leporin. Her father noticed her excelling at her schoolwork early on in life as well as her general brightness and arranged for Dorothea to be tutored in Latin, math and the sciences alongside her brother Tobias.",
    		search_term: "Dorothea Erxleben",
    		diameter: "31.6",
    		center_lat: -50.9,
    		center_long: 39.4
    	},
    	{
    		feature_id: 1944,
    		year: 1991,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Ferrier",
    		type: "Famous Woman",
    		origin: "England",
    		continent: "Europe",
    		clean_name: "Ferrier",
    		description: "Kathleen; English opera singer (1912-1953).",
    		bio: "Kathleen Mary Ferrier, CBE (22 April 1912 – 8 October 1953) was an English contralto singer who achieved an international reputation as a stage, concert and recording artist, with a repertoire extending from folksong and popular ballads to the classical works of Bach, Brahms, Mahler and Elgar. Her death from cancer, at the height of her fame, was a shock to the musical world and particularly to the general public, which was kept in ignorance of the nature of her illness until after her death. The daughter of a Lancashire village schoolmaster, Ferrier showed early talent as a pianist, and won numerous amateur piano competitions while working as a telephonist with the General Post Office.",
    		search_term: "Kathleen Ferrier",
    		diameter: "29.1",
    		center_lat: 15.7,
    		center_long: 111.3
    	},
    	{
    		feature_id: 1949,
    		year: 1991,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Festa",
    		type: "Famous Woman",
    		origin: "Italy",
    		continent: "Europe",
    		clean_name: "Festa",
    		description: "Italian painter.",
    		bio: "",
    		search_term: "",
    		diameter: "35.3",
    		center_lat: 11.5,
    		center_long: 27.2
    	},
    	{
    		feature_id: 1971,
    		year: 1991,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Flagstad",
    		type: "Famous Woman",
    		origin: "Norway",
    		continent: "Europe",
    		clean_name: "Flagstad",
    		description: "Kirsten; Norwegian opera singer (1895-1962).",
    		bio: "Kirsten Malfrid Flagstad (12 July 1895 – 7 December 1962) was a Norwegian opera singer, who was the outstanding Wagnerian soprano of her era. Her triumphant debut in New York on 2 February 1935 is one of the legends of opera. Giulio Gatti-Casazza, the longstanding General Manager of the Metropolitan Opera said, “I have given America two great gifts — Caruso and Flagstad.” Called 'the voice of the century', she ranks among the greatest singers of the 20th century.",
    		search_term: "Kirsten Flagstad",
    		diameter: "39.2",
    		center_lat: -54.3,
    		center_long: 18.9
    	},
    	{
    		feature_id: 2013,
    		year: 1991,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Frank",
    		type: "Famous Woman",
    		origin: "Netherlands",
    		continent: "Europe",
    		clean_name: "Frank",
    		description: "Anne; Dutch heroine, diarist (1929-1945).",
    		bio: "Annelies Marie 'Anne' Frank (German: [ˈanə(liːs maˈʁiː) ˈfʁaŋk] , Dutch: [ˌɑnəˈlis maːˈri ˈfrɑŋk, ˈɑnə ˈfrɑŋk] ; 12 June 1929 – c. February or March 1945) was a Jewish girl who kept a diary in which she documented life in hiding under Nazi persecution. She is a celebrated diarist who described everyday life from her family hiding place in an Amsterdam attic. One of the most-discussed Jewish victims of the Holocaust, she gained fame posthumously with the 1947 publication of The Diary of a Young Girl (originally Het Achterhuis in Dutch, lit. 'the back house'; English: The Secret Annex), in which she documents her life in hiding from 1942 to 1944, during the German occupation of the Netherlands in World War II. It is one of the world's best-known books and has been the basis for several plays and films.",
    		search_term: "Anne Frank",
    		diameter: "22.7",
    		center_lat: -13.1,
    		center_long: 12.9
    	},
    	{
    		feature_id: 2017,
    		year: 1991,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Fredegonde",
    		type: "Famous Woman",
    		origin: "Germany",
    		continent: "Europe",
    		clean_name: "Fredegonde",
    		description: "Frankish queen (d. A.D. 597).",
    		bio: "Fredegund or Fredegunda (Latin: Fredegundis; French: Frédégonde; died 8 December 597) was the Queen consort of Chilperic I, the Merovingian Frankish king of Soissons. Fredegund served as regent during the minority of her son Chlothar II from 584 until 597. Fredegund has traditionally been given a very bad reputation, foremost by the accounts of Gregory of Tours, who depicts her as ruthlessly murderous and sadistically cruel, and she is known for the many cruel stories about her, particularly for her long feud with queen Brunhilda of Austrasia, Fredegund's sister-in-law.",
    		search_term: "Fredegund",
    		diameter: "25.2",
    		center_lat: -50.5,
    		center_long: 93.3
    	},
    	{
    		feature_id: 2147,
    		year: 1991,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Germain",
    		type: "Famous Woman",
    		origin: "France",
    		continent: "Europe",
    		clean_name: "Germain",
    		description: "Sophie; French mathematician (1776-1831).",
    		bio: "Marie-Sophie Germain (French: [maʁi sɔfi ʒɛʁmɛ̃]; 1 April 1776 – 27 June 1831) was a French mathematician, physicist, and philosopher. Despite initial opposition from her parents and difficulties presented by society, she gained education from books in her father's library, including ones by Euler, and from correspondence with famous mathematicians such as Lagrange, Legendre, and Gauss (under the pseudonym of Monsieur LeBlanc). One of the pioneers of elasticity theory, she won the grand prize from the Paris Academy of Sciences for her essay on the subject.",
    		search_term: "Sophie Germain",
    		diameter: "35.5",
    		center_lat: -37.9,
    		center_long: 63.7
    	},
    	{
    		feature_id: 2203,
    		year: 1991,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Goeppert-Mayer",
    		type: "Famous Woman",
    		origin: "Poland",
    		continent: "Europe",
    		clean_name: "Goeppert-Mayer",
    		description: "Maria; Polish physicist, Nobel laureate (1907-1972).",
    		bio: "Maria Goeppert Mayer (German pronunciation: [maˈʁiːa ˈɡœpɛʁt ˈmaɪ̯ɐ] ; June 28, 1906 – February 20, 1972) was a German-born American theoretical physicist, and Nobel laureate in Physics for proposing the nuclear shell model of the atomic nucleus. She was the second woman to win a Nobel Prize in physics, the first being Marie Curie. In 1986, the Maria Goeppert-Mayer Award for early-career women physicists was established in her honor.",
    		search_term: "Maria Goeppert Mayer",
    		diameter: "33.5",
    		center_lat: 59.7,
    		center_long: 26.8
    	},
    	{
    		feature_id: 2245,
    		year: 1991,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Greenaway",
    		type: "Famous Woman",
    		origin: "England",
    		continent: "Europe",
    		clean_name: "Greenaway",
    		description: "Kate; English author, illustrator (1846-1901).",
    		bio: "Catherine Greenaway (17 March 1846 – 6 November 1901) was an English Victorian artist and writer, known for her children's book illustrations. She received her education in graphic design and art between 1858 and 1871 from the Finsbury School of Art, the South Kensington School of Art, the Heatherley School of Art and the Slade School of Fine Art. She began her career designing for the burgeoning holiday card market, producing Christmas and Valentine's cards.",
    		search_term: "Kate Greenaway",
    		diameter: "93.0",
    		center_lat: 22.9,
    		center_long: 145.1
    	},
    	{
    		feature_id: 2271,
    		year: 1991,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Guilbert",
    		type: "Famous Woman",
    		origin: "France",
    		continent: "Europe",
    		clean_name: "Guilbert",
    		description: "Yvette; French singer (1865-1944).",
    		bio: "Yvette Guilbert (French pronunciation: ​[ivɛt gilbɛʁ]; born Emma Laure Esther Guilbert, 20 January 1865 – 3 February 1944) was a French cabaret singer and actress of the Belle Époque. Born in Paris into a poor family as Emma Laure Esther Guilbert, Guilbert began singing as a child but at age sixteen worked as a model at the Printemps department store in Paris. She was discovered by a journalist.",
    		search_term: "Yvette Guilbert",
    		diameter: "25.5",
    		center_lat: -58,
    		center_long: 13.6
    	},
    	{
    		feature_id: 2329,
    		year: 1991,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Halle",
    		type: "Famous Woman",
    		origin: "Austria",
    		continent: "Europe",
    		clean_name: "Halle",
    		description: "Wilhelmina; Austrian violinist (1839-1911).",
    		bio: "Wilhelmine Maria Franziska Neruda (1838–1911), also known as Wilma Norman-Neruda and Lady Hallé, was a Moravian virtuoso violinist, chamber musician, and teacher. Born in Brno, Moravia, then part of the Austrian Empire, Neruda came from a musical family. Her grandfather was the noted Bohemian composer Johann Baptist Georg Neruda (1708–1780), and her father, Josef Neruda (1807–1875), was the organist of the cathedral of Brno.",
    		search_term: "Wilma Neruda",
    		diameter: "21.5",
    		center_lat: -19.8,
    		center_long: 145.5
    	},
    	{
    		feature_id: 2449,
    		year: 1991,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Henie",
    		type: "Famous Woman",
    		origin: "Norway",
    		continent: "Europe",
    		clean_name: "Henie",
    		description: "Sonja; Norwegian skater (1912-1969).",
    		bio: "Sonja Henie (8 April 1912 – 12 October 1969) was a Norwegian figure skater and film star. She was a three-time Olympic champion (1928, 1932, 1936) in women's singles, a ten-time World champion (1927–1936) and a six-time European champion (1931–1936). Henie has won more Olympic and World titles than any other ladies' figure skater.",
    		search_term: "Sonja Henie",
    		diameter: "70.4",
    		center_lat: -51.9,
    		center_long: 146
    	},
    	{
    		feature_id: 2461,
    		year: 1991,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Hepworth",
    		type: "Famous Woman",
    		origin: "England",
    		continent: "Europe",
    		clean_name: "Hepworth",
    		description: "Barbara; English sculptor (1903-1975).",
    		bio: "Dame Jocelyn Barbara Hepworth (10 January 1903 – 20 May 1975) was an English artist and sculptor. Her work exemplifies Modernism and in particular modern sculpture. Along with artists such as Ben Nicholson and Naum Gabo, Hepworth was a leading figure in the colony of artists who resided in St Ives during the Second World War.",
    		search_term: "Barbara Hepworth",
    		diameter: "62.6",
    		center_lat: 5.1,
    		center_long: 94.7
    	},
    	{
    		feature_id: 2555,
    		year: 1991,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Horner",
    		type: "Famous Woman",
    		origin: "England",
    		continent: "Europe",
    		clean_name: "Horner",
    		description: "Mary; English naturalist, geologist (19th century).",
    		bio: "Mary Horner Lyell (9 October 1808 – 24 April 1873) was a conchologist and geologist. She was married to the famed British geologist Charles Lyell and assisted him in his scientific work. She never became widely known in her own right, although it is believed by historians that she likely made major contributions to her husband's work.",
    		search_term: "Mary Horner Lyell",
    		diameter: "25.2",
    		center_lat: 23.4,
    		center_long: 97.7
    	},
    	{
    		feature_id: 2825,
    		year: 1991,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Jex-Blake",
    		type: "Famous Woman",
    		origin: "Great Britain",
    		continent: "Europe",
    		clean_name: "Jex-Blake",
    		description: "Sophia; British pioneer woman physician (1840-1912).",
    		bio: "Sophia Louisa Jex-Blake (21 January 1840 – 7 January 1912) was an English physician, teacher and feminist. She led the campaign to secure women access to a University education when she and six other women, collectively known as the Edinburgh Seven, began studying medicine at the University of Edinburgh in 1869. She was the first practising female doctor in Scotland, and one of the first in the wider United Kingdom of Great Britain and Ireland; a leading campaigner for medical education for women and was involved in founding two medical schools for women, in London and Edinburgh at a time when no other medical schools were training women.",
    		search_term: "Sophia Jex-Blake",
    		diameter: "31.6",
    		center_lat: 65.4,
    		center_long: 169.3
    	},
    	{
    		feature_id: 2840,
    		year: 1991,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Joliot-Curie",
    		type: "Famous Woman",
    		origin: "France",
    		continent: "Europe",
    		clean_name: "Joliot-Curie",
    		description: "Irene; French physicist, Nobel laureate (1897-1956).",
    		bio: "Irène Joliot-Curie (French: [iʁɛn ʒɔljo kyʁi] ; née Curie; 12 September 1897 – 17 March 1956) was a French chemist, physicist and politician, the elder daughter of Pierre and Marie Curie, and the wife of Frédéric Joliot-Curie. Jointly with her husband, Joliot-Curie was awarded the Nobel Prize in Chemistry in 1935 for their discovery of induced radioactivity, making them the second-ever married couple (after her parents) to win the Nobel Prize, while adding to the Curie family legacy of five Nobel Prizes. This made the Curies the family with the most Nobel laureates to date.",
    		search_term: "Irène Joliot-Curie",
    		diameter: "91.1",
    		center_lat: -1.6,
    		center_long: 62.4
    	},
    	{
    		feature_id: 3081,
    		year: 1991,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Kollwitz",
    		type: "Famous Woman",
    		origin: "Germany",
    		continent: "Europe",
    		clean_name: "Kollwitz",
    		description: "Kathe; German artist (1867-1945).",
    		bio: "Käthe Kollwitz (German pronunciation: [kɛːtə kɔlvɪt͡s]; born as Schmidt; 8 July 1867 – 22 April 1945) was a German artist who worked with painting, printmaking (including etching, lithography and woodcuts) and sculpture. Her most famous art cycles, including The Weavers and The Peasant War, depict the effects of poverty, hunger and war on the working class. Despite the realism of her early works, her art is now more closely associated with Expressionism.",
    		search_term: "Käthe Kollwitz",
    		diameter: "29.1",
    		center_lat: 25.2,
    		center_long: 133.6
    	},
    	{
    		feature_id: 3198,
    		year: 1991,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Lachappelle",
    		type: "Famous Woman",
    		origin: "France",
    		continent: "Europe",
    		clean_name: "Lachappelle",
    		description: "Marie; French medical researcher (1769-1821).",
    		bio: "Marie-Louise Lachapelle (1 January 1769 – 4 October 1821) was a French midwife, head of obstetrics at the Hôtel-Dieu, the oldest hospital in Paris. She published textbooks about women's bodies, gynecology, and obstetrics. She argued against forceps deliveries and wrote Pratique des accouchements, long a standard obstetric text, which promoted natural deliveries.",
    		search_term: "Marie-Louise Lachapelle",
    		diameter: "36.8",
    		center_lat: 26.7,
    		center_long: 336.7
    	},
    	{
    		feature_id: 3332,
    		year: 1991,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Lehmann",
    		type: "Famous Woman",
    		origin: "Denmark",
    		continent: "Europe",
    		clean_name: "Lehmann",
    		description: "Inge; Danish geophysicist (1888-1993).",
    		bio: "Inge Lehmann (13 May 1888 – 21 February 1993) was a Danish seismologist and geophysicist. In 1936, she discovered that the Earth has a solid inner core inside a molten outer core. Before that, seismologists believed Earth's core to be a single molten sphere, being unable, however, to explain careful measurements of seismic waves from earthquakes, which were inconsistent with this idea.",
    		search_term: "Inge Lehmann",
    		diameter: "21.7",
    		center_lat: -44.1,
    		center_long: 39.1
    	},
    	{
    		feature_id: 3513,
    		year: 1991,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Lullin",
    		type: "Famous Woman",
    		origin: "Switzerland",
    		continent: "Europe",
    		clean_name: "Lullin",
    		description: "Maria; Swiss entomologist (1750-1831).",
    		bio: "Marie-Aimée Lullin (5 April 1751 – 25 January 1822) was the transcriber and observer for her husband, a highly regarded entomologist who became blind at an early age. Lullin was the daughter of Pierre Lullin (1712-1789), who served as syndic of Geneva, and Sarah Rilliet (1723-1751). She married François Huber (1750-1831), the famous blind entomologist, on 28 April 1776 in Geneva, Republic of Geneva after having to wait seven years to do so.",
    		search_term: "Marie-Aimée Lullin",
    		diameter: "25.1",
    		center_lat: 23,
    		center_long: 81.3
    	},
    	{
    		feature_id: 3647,
    		year: 1991,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Manzolini",
    		type: "Famous Woman",
    		origin: "Italy",
    		continent: "Europe",
    		clean_name: "Manzolini",
    		description: "Anna; Italian anatomist, teacher (1716-1774).",
    		bio: "Anna Morandi Manzolini (21 January 1714 – 9 July 1774) was an internationally known anatomist and anatomical wax modeler, as lecturer of anatomical design at the University of Bologna. Morandi was born in 1714 in Bologna, Italy. She was raised in a traditional home where marriage, children, and a domestic lifestyle were natural choices for women.",
    		search_term: "Anna Manzolini",
    		diameter: "41.8",
    		center_lat: 25.6,
    		center_long: 91.3
    	},
    	{
    		feature_id: 3705,
    		year: 1991,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Maria Celeste",
    		type: "Famous Woman",
    		origin: "Italy",
    		continent: "Europe",
    		clean_name: "Maria Celeste",
    		description: "Daughter of Galileo (d. 1634).",
    		bio: "Sister Maria Celeste (born Virginia Galilei; 16 August 1600 – 2 April 1634) was an Italian nun. She was the daughter of the scientist Galileo Galilei and Marina Gamba. Virginia was the eldest of three siblings, with a sister Livia and a brother Vincenzio.",
    		search_term: "Maria Celeste",
    		diameter: "97.5",
    		center_lat: 23.4,
    		center_long: 140.4
    	},
    	{
    		feature_id: 3853,
    		year: 1991,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Merian",
    		type: "Famous Woman",
    		origin: "Netherlands",
    		continent: "Europe",
    		clean_name: "Merian",
    		description: "Maria; Dutch entomologist (1647-1717).",
    		bio: "Maria Sibylla Merian (2 April 1647 – 13 January 1717) was a German naturalist and scientific illustrator. She was one of the earliest European naturalists to observe insects directly. Merian was a descendant of the Frankfurt branch of the Swiss Merian family.",
    		search_term: "Maria Sibylla Merian",
    		diameter: "22.2",
    		center_lat: 34.5,
    		center_long: 76.3
    	},
    	{
    		feature_id: 3960,
    		year: 1991,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Mona Lisa",
    		type: "Famous Woman",
    		origin: "Italy",
    		continent: "Europe",
    		clean_name: "Mona Lisa",
    		description: "(Lisa Giacondo); Leonardo da Vinci's model (b. c. 1474).",
    		bio: "The Mona Lisa ( MOH-nə LEE-sə; Italian: Gioconda [dʒoˈkonda] or Monna Lisa [ˈmɔnna ˈliːza]; French: Joconde [ʒɔkɔ̃d]) is a half-length portrait painting by Italian artist Leonardo da Vinci. Considered an archetypal masterpiece of the Italian Renaissance, it has been described as 'the best known, the most visited, the most written about, the most sung about, the most parodied work of art in the world'. The painting's novel qualities include the subject's enigmatic expression, the monumentality of the composition, the subtle modelling of forms, and the atmospheric illusionism.The painting has been definitively identified to depict Italian noblewoman Lisa Gherardini, the wife of Francesco del Giocondo.",
    		search_term: "Mona Lisa",
    		diameter: "79.4",
    		center_lat: 25.6,
    		center_long: 25.1
    	},
    	{
    		feature_id: 4381,
    		year: 1991,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Němcová",
    		type: "Famous Woman",
    		origin: "Czechoslovakia",
    		continent: "Europe",
    		clean_name: "Němcová",
    		description: "Božena; Czech novelist, poet (1820-1882).",
    		bio: "Božena Němcová (Czech pronunciation: [ˈboʒɛna ˈɲɛmtsovaː]) (4 February 1820 in Vienna – 21 January 1862 in Prague) was a Czech writer of the final phase of the Czech National Revival movement. Her image is featured on the 500 CZK denomination of the Česká koruna. According to the dating up to now accepted by the majority of Czech authors, Božena Němcová was born in 1820 as Barbara Pankel (or Barbora Panklová according to the usual Czech name-giving for women) in Vienna as a daughter of Johann Pankel from Lower Austria and Teresie Novotná, a maid of Bohemian origin.",
    		search_term: "Božena Němcová",
    		diameter: "22.9",
    		center_lat: 5.9,
    		center_long: 125.1
    	},
    	{
    		feature_id: 4264,
    		year: 1991,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Nijinskaya",
    		type: "Famous Woman",
    		origin: "Russia",
    		continent: "Europe",
    		clean_name: "Nijinskaya",
    		description: "Bronislava; Russian dancer (1891-1972).",
    		bio: "Bronislava Nijinska (; Polish: Bronisława Niżyńska [brɔɲiˈswava ɲiˈʐɨj̃ska]; Russian: Бронисла́ва Фоми́нична Нижи́нская, romanized: Bronisláva Fomínična Nižínskaja; Belarusian: Браніслава Ніжынская, romanized: Branislava Nižynskaja; January 8, 1891 [O.S. December 27, 1890] – February 21, 1972) was a Polish ballet dancer, and an innovative choreographer. She came of age in a family of traveling, professional dancers.Her own career began in Saint Petersburg. Soon she joined Ballets Russes which ventured to success in Paris.",
    		search_term: "Bronislava Nijinska",
    		diameter: "36.2",
    		center_lat: 25.8,
    		center_long: 122.5
    	},
    	{
    		feature_id: 4716,
    		year: 1991,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Piaf",
    		type: "Famous Woman",
    		origin: "France",
    		continent: "Europe",
    		clean_name: "Piaf",
    		description: "Edith; French singer, songwriter (1915-1963).",
    		bio: "Édith Piaf (UK: , US: , French: [edit pjaf] ; born Édith Giovanna Gassion, French: [edit dʒɔvana ɡasjɔ̃]; 19 December 1915 – 10 October 1963) was a French singer, lyricist and actress. Noted as France's national chanteuse, she was one of the country's most widely known international stars.Piaf's music was often autobiographical, and she specialized in chanson réaliste and torch ballads about love, loss and sorrow. Her most widely known songs include 'La Vie en rose' (1946), 'Non, je ne regrette rien' (1960), 'Hymne à l'amour' (1949), 'Milord' (1959), 'La Foule' (1957), 'L'Accordéoniste' (1940), and 'Padam, padam...' (1951).",
    		search_term: "Édith Piaf",
    		diameter: "39.1",
    		center_lat: 0.8,
    		center_long: 5.3
    	},
    	{
    		feature_id: 4973,
    		year: 1991,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Recamier",
    		type: "Famous Woman",
    		origin: "France",
    		continent: "Europe",
    		clean_name: "Recamier",
    		description: "Julie; French patriot; defied Napoleon (c. 1777-c. 1849).",
    		bio: "Jeanne Françoise Julie Adélaïde Récamier (French pronunciation: ​[ʒan fʁɑ̃swaz ʒyli adela.id ʁekamje]; 3 December 1777 – 11 May 1849), known as Juliette (French pronunciation: ​[ʒyljɛt]), was a French socialite whose salon drew people from the leading literary and political circles of early 19th-century Paris. As an icon of neoclassicism, Récamier cultivated a public persona as a great beauty, and her fame quickly spread across Europe. She befriended many intellectuals, sat for the finest artists of the age, and spurned an offer of marriage from Prince Augustus of Prussia.",
    		search_term: "Juliette Récamier",
    		diameter: "25.3",
    		center_lat: -12.6,
    		center_long: 58.1
    	},
    	{
    		feature_id: 5034,
    		year: 1991,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Riley",
    		type: "Famous Woman",
    		origin: "England",
    		continent: "Europe",
    		clean_name: "Riley",
    		description: "Margaretta; English botanist (1804-1899).",
    		bio: "Margaretta Riley, née Hopper (May 4, 1804 - July 16, 1899) was an English botanist. She studied ferns and was the first British pteridologist of her sex. She was born in Castle Gate, Nottingham on 4 May 1804 to Richard and Margaretta Hopper.",
    		search_term: "Margaretta Riley",
    		diameter: "20.2",
    		center_lat: 14.1,
    		center_long: 72.5
    	},
    	{
    		feature_id: 5265,
    		year: 1991,
    		feature: "Patera",
    		feature_plural: "Paterae",
    		name: "Sachs Patera",
    		type: "Famous Woman",
    		origin: "Sweden",
    		continent: "Europe",
    		clean_name: "Sachs",
    		description: "Nelly; German-born Swedish playwright, poet (1891-1970).",
    		bio: "Nelly Sachs (German pronunciation: [ˈnɛliː zaks] ; 10 December 1891 – 12 May 1970) was a German-Swedish poet and playwright. Her experiences resulting from the rise of the Nazis in World War II Europe transformed her into a poignant spokesperson for the grief and yearnings of her fellow Jews. Her best-known play is Eli: Ein Mysterienspiel vom Leiden Israels (1950); other works include the poems 'Zeichen im Sand' (1962), 'Verzauberung' (1970), and the collections of poetry In den Wohnungen des Todes (1947), Flucht und Verwandlung (1959), Fahrt ins Staublose (1961), and Suche nach Lebenden (1971).",
    		search_term: "Nelly Sachs",
    		diameter: "65.0",
    		center_lat: 49.1,
    		center_long: 334.2
    	},
    	{
    		feature_id: 5334,
    		year: 1991,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Saskia",
    		type: "Famous Woman",
    		origin: "Netherlands",
    		continent: "Europe",
    		clean_name: "Saskia",
    		description: "Artist's model, wife of Rembrandt.",
    		bio: "Saskia van Uylenburgh (West Frisian: Saakje fan Uylenburgh; 2 August 1612 – 14 June 1642) was the wife of painter Rembrandt van Rijn. In the course of her life, she was his model for some of his paintings, drawings and etchings. She was the daughter of Rombertus Uylenburg, the mayor as well as the justice of the Court of Friesland.",
    		search_term: "Saskia van Uylenburgh",
    		diameter: "37.1",
    		center_lat: -28.6,
    		center_long: 337.1
    	},
    	{
    		feature_id: 5360,
    		year: 1991,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Scarpellini",
    		type: "Famous Woman",
    		origin: "Italy",
    		continent: "Europe",
    		clean_name: "Scarpellini",
    		description: "Caterina; 19th century Italian astronomer.",
    		bio: "Caterina Scarpellini (29 October 1808 – 28 November 1873), was an Italian astronomer who discovered a comet and as a meteorologist she established a station in Rome in the 1850s. She was born in Foligno on 29 October 1808, Scarpellini moved to Rome at the age of 18. She was an assistant to her uncle, who was the director of the Roman Campidoglio Observatory.",
    		search_term: "Caterina Scarpellini",
    		diameter: "27.1",
    		center_lat: -23.2,
    		center_long: 34.6
    	},
    	{
    		feature_id: 5540,
    		year: 1991,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Simonenko",
    		type: "Famous Woman",
    		origin: "Russia",
    		continent: "Europe",
    		clean_name: "Simonenko",
    		description: "Alla Nikolayevna; Soviet astronomer (1935-1984).",
    		bio: "",
    		search_term: "",
    		diameter: "31.9",
    		center_lat: -26.9,
    		center_long: 97.6
    	},
    	{
    		feature_id: 5718,
    		year: 1991,
    		feature: "Patera",
    		feature_plural: "Paterae",
    		name: "Stopes Patera",
    		type: "Famous Woman",
    		origin: "Great Britain",
    		continent: "Europe",
    		clean_name: "Stopes",
    		description: "Marie; English paleontologist (1880-1959).",
    		bio: "Marie Charlotte Carmichael Stopes (15 October 1880 – 2 October 1958) was a British author, palaeobotanist and campaigner for eugenics and women's rights. She made significant contributions to plant palaeontology and coal classification, and was the first female academic on the faculty of the University of Manchester. With her second husband, Humphrey Verdon Roe, Stopes founded the first birth control clinic in Britain.",
    		search_term: "Marie Stopes",
    		diameter: "169.0",
    		center_lat: 42.6,
    		center_long: 46.5
    	},
    	{
    		feature_id: 5729,
    		year: 1991,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Stuart",
    		type: "Famous Woman",
    		origin: "Scotland",
    		continent: "Europe",
    		clean_name: "Stuart",
    		description: "Mary; Queen of Scots (1542-1587).",
    		bio: "Mary, Queen of Scots (8 December 1542 – 8 February 1587), also known as Mary Stuart or Mary I of Scotland, was Queen of Scotland from 14 December 1542 until her forced abdication in 1567. The only surviving legitimate child of James V of Scotland, Mary was six days old when her father died and she inherited the throne. During her childhood, Scotland was governed by regents, first by the heir to the throne, James Hamilton, Earl of Arran, and then by her mother, Mary of Guise.",
    		search_term: "Mary, Queen of Scots",
    		diameter: "68.6",
    		center_lat: -30.8,
    		center_long: 20.2
    	},
    	{
    		feature_id: 6385,
    		year: 1991,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Vigée-Lebrun",
    		type: "Famous Woman",
    		origin: "France",
    		continent: "Europe",
    		clean_name: "Vigée-Lebrun",
    		description: "Marie; French painter (1755-1842). Spelling changed from Vigier Lebrun.",
    		bio: "Élisabeth Louise Vigée Le Brun (French: [elizabɛt lwiz viʒe ləbʁœ̃]; 16 April 1755 – 30 March 1842), also known as Madame Le Brun, was a French portrait painter, especially of women, in the late 18th and early 19th centuries. Her artistic style is generally considered part of the aftermath of Rococo with elements of an adopted Neoclassical style. Her subject matter and color palette can be classified as Rococo, but her style is aligned with the emergence of Neoclassicism.",
    		search_term: "Élisabeth Vigée Le Brun",
    		diameter: "57.8",
    		center_lat: 17.3,
    		center_long: 141.4
    	},
    	{
    		feature_id: 6445,
    		year: 1991,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Von Siebold",
    		type: "Famous Woman",
    		origin: "Germany",
    		continent: "Europe",
    		clean_name: "Von Siebold",
    		description: "Regina; German physician, educator (1771-1849).",
    		bio: "",
    		search_term: "",
    		diameter: "32.4",
    		center_lat: -52,
    		center_long: 36.6
    	},
    	{
    		feature_id: 6574,
    		year: 1991,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Woolf",
    		type: "Famous Woman",
    		origin: "Great Britain",
    		continent: "Europe",
    		clean_name: "Woolf",
    		description: "Virginia; British writer (1882-1941).",
    		bio: "Adeline Virginia Woolf (; née Stephen; 25 January 1882 – 28 March 1941) was an English writer, considered one of the most important modernist 20th-century authors and a pioneer in the use of stream of consciousness as a narrative device. Woolf was born into an affluent household in South Kensington, London, the seventh child of Julia Prinsep Jackson and Leslie Stephen in a blended family of eight which included the modernist painter Vanessa Bell. She was home-schooled in English classics and Victorian literature from a young age.",
    		search_term: "Virginia Woolf",
    		diameter: "24.5",
    		center_lat: -37.7,
    		center_long: 27.2
    	},
    	{
    		feature_id: 6601,
    		year: 1991,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Xantippe",
    		type: "Famous Woman",
    		origin: "Greek",
    		continent: "Europe",
    		clean_name: "Xantippe",
    		description: "Wife of Socrates (5th century B.C.).",
    		bio: "Xanthippe (; Greek: Ξανθίππη, Ancient: [ksantʰíppɛː], Modern: [ksanˈθipi]; 5th–4th century BCE) was an ancient Athenian, the wife of Socrates and mother of their three sons: Lamprocles, Sophroniscus, and Menexenus. She was likely much younger than Socrates, perhaps by as much as 40 years. Xanthippe means 'yellow horse', from Ancient Greek: ξανθός xanthos 'blond' and ἵππος hippos 'horse'.",
    		search_term: "Xantippe",
    		diameter: "40.4",
    		center_lat: -10.9,
    		center_long: 11.8
    	},
    	{
    		feature_id: 441,
    		year: 1991,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Astrid",
    		type: "First Name",
    		origin: "Scandinavian",
    		continent: "Europe",
    		clean_name: "Astrid",
    		description: "Scandinavian first name.",
    		bio: "",
    		search_term: "",
    		diameter: "10.5",
    		center_lat: -21.4,
    		center_long: 335.2
    	},
    	{
    		feature_id: 756,
    		year: 1991,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Birute",
    		type: "First Name",
    		origin: "Lithuania",
    		continent: "Europe",
    		clean_name: "Birute",
    		description: "Lithuanian first name.",
    		bio: "",
    		search_term: "",
    		diameter: "22.3",
    		center_lat: 36.1,
    		center_long: 32
    	},
    	{
    		feature_id: 879,
    		year: 1991,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Bridgit",
    		type: "First Name",
    		origin: "Ireland",
    		continent: "Europe",
    		clean_name: "Bridgit",
    		description: "Irish first name.",
    		bio: "",
    		search_term: "",
    		diameter: "10.0",
    		center_lat: -45.3,
    		center_long: 348.9
    	},
    	{
    		feature_id: 1369,
    		year: 1991,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Cynthia",
    		type: "First Name",
    		origin: "Greek",
    		continent: "Europe",
    		clean_name: "Cynthia",
    		description: "First name from Greek.",
    		bio: "",
    		search_term: "",
    		diameter: "15.9",
    		center_lat: -16.7,
    		center_long: 347.5
    	},
    	{
    		feature_id: 3396,
    		year: 1991,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Lida",
    		type: "First Name",
    		origin: "Russia",
    		continent: "Europe",
    		clean_name: "Lida",
    		description: "Russian first name.",
    		bio: "",
    		search_term: "",
    		diameter: "20.3",
    		center_lat: 36.6,
    		center_long: 273.9
    	},
    	{
    		feature_id: 4736,
    		year: 1991,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Piret",
    		type: "First Name",
    		origin: "Estonia",
    		continent: "Europe",
    		clean_name: "Piret",
    		description: "Estonian first name.",
    		bio: "",
    		search_term: "",
    		diameter: "27.0",
    		center_lat: 37.8,
    		center_long: 41.7
    	},
    	{
    		feature_id: 5783,
    		year: 1991,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Sveta",
    		type: "First Name",
    		origin: "Russia",
    		continent: "Europe",
    		clean_name: "Sveta",
    		description: "Russian first name.",
    		bio: "",
    		search_term: "",
    		diameter: "21.0",
    		center_lat: 82.5,
    		center_long: 273.2
    	},
    	{
    		feature_id: 946,
    		year: 1991,
    		feature: "Mons",
    		feature_plural: "Montes",
    		name: "Bécuma Mons",
    		type: "Goddess",
    		origin: "Ireland",
    		continent: "Europe",
    		clean_name: "Bécuma",
    		description: "Irish dawn goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "0.0",
    		center_lat: 34,
    		center_long: 21.9
    	},
    	{
    		feature_id: 725,
    		year: 1991,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Beyla Corona",
    		type: "Goddess",
    		origin: "Norse",
    		continent: "Europe",
    		clean_name: "Beyla",
    		description: "Norse earth goddess.",
    		bio: "Beyla (Old Norse: [ˈbœylɑ]) is one of Freyr's servants along with her husband, Byggvir, in Norse mythology. Proposals have been made that Beyla and her husband are personifications of agriculture associated with Freyr: Beyla as the manure that softens the earth and develops the seed, Byggvir as the refuse of the mill, chaff.",
    		search_term: "Beyla",
    		diameter: "400.0",
    		center_lat: 26.5,
    		center_long: 15.5
    	},
    	{
    		feature_id: 1541,
    		year: 1991,
    		feature: "Regio",
    		feature_plural: "Regiones",
    		name: "Dione Regio",
    		type: "Goddess",
    		origin: "Greek",
    		continent: "Europe",
    		clean_name: "Dione",
    		description: "Greek Titanness; 1st wife of Zeus.",
    		bio: "",
    		search_term: "",
    		diameter: "2,300.0",
    		center_lat: -31.5,
    		center_long: 328
    	},
    	{
    		feature_id: 1808,
    		year: 1991,
    		feature: "Fossa",
    		feature_plural: "Fossae",
    		name: "Enyo Fossae",
    		type: "Goddess",
    		origin: "Greek",
    		continent: "Europe",
    		clean_name: "Enyo",
    		description: "Greek war goddess.",
    		bio: "Enyo (; Ancient Greek: Ἐνυώ, romanized: Enȳṓ) is a goddess of war in Greek mythology. She frequently is associated with the war god Ares. The Romans identified her with Bellona.",
    		search_term: "Enyo",
    		diameter: "700.0",
    		center_lat: -62,
    		center_long: 351
    	},
    	{
    		feature_id: 1812,
    		year: 1991,
    		feature: "Mons",
    		feature_plural: "Montes",
    		name: "Eostre Mons",
    		type: "Goddess",
    		origin: "Teutonic",
    		continent: "Europe",
    		clean_name: "Eostre",
    		description: "Teutonic goddess of spring.",
    		bio: "Ēostre is a West Germanic spring goddess. She is the namesake of the festival of Easter in some languages.",
    		search_term: "Eostre",
    		diameter: "26.0",
    		center_lat: 45.1,
    		center_long: 329.1
    	},
    	{
    		feature_id: 1832,
    		year: 1991,
    		feature: "Fluctus",
    		feature_plural: "Fluctūs",
    		name: "Eriu Fluctus",
    		type: "Goddess",
    		origin: "Ireland",
    		continent: "Europe",
    		clean_name: "Eriu",
    		description: "Irish earth mother.",
    		bio: "In Irish mythology, Ériu, daughter of Delbáeth and Ernmas of the Tuatha Dé Danann, was the eponymous matron goddess of Ireland. The English name for Ireland comes from the name Ériu and the Germanic (Old Norse or Old English) word land. Since Ériu is represented as goddess of Ireland, she is often interpreted as a modern-day personification of Ireland, although since the name Ériu is the Old Irish form of the word Ireland, her modern name is often modified to Éire or Erin to suit a modern form.",
    		search_term: "Eriu",
    		diameter: "600.0",
    		center_lat: -37,
    		center_long: 357
    	},
    	{
    		feature_id: 2149,
    		year: 1991,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Gertjon Corona",
    		type: "Goddess",
    		origin: "Germany",
    		continent: "Europe",
    		clean_name: "Gertjon",
    		description: "Teutonic goddess of fertility.",
    		bio: "",
    		search_term: "",
    		diameter: "250.0",
    		center_lat: -30,
    		center_long: 276
    	},
    	{
    		feature_id: 2332,
    		year: 1991,
    		feature: "Mons",
    		feature_plural: "Montes",
    		name: "Hallgerda Mons",
    		type: "Goddess",
    		origin: "Iceland",
    		continent: "Europe",
    		clean_name: "Hallgerda",
    		description: "Icelandic goddess of vanity.",
    		bio: "Njáls saga or \"The Story of Burnt Njáll\", is a thirteenth-century Icelandic saga that describes events between 960 and 1020. Part of the saga centers on Hallgerður, the daughter of a local leader, who was considered the most beautiful of women, but was at the same time big-hearted and unruly.",
    		search_term: "Hallgerda",
    		diameter: "57.0",
    		center_lat: 53.1,
    		center_long: 198.3
    	},
    	{
    		feature_id: 2483,
    		year: 1991,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Hervor Corona",
    		type: "Goddess",
    		origin: "Norse",
    		continent: "Europe",
    		clean_name: "Hervor",
    		description: "Norse fertility goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "250.0",
    		center_lat: -25.5,
    		center_long: 269
    	},
    	{
    		feature_id: 2608,
    		year: 1991,
    		feature: "Regio",
    		feature_plural: "Regiones",
    		name: "Hyndla Regio",
    		type: "Goddess",
    		origin: "Norse",
    		continent: "Europe",
    		clean_name: "Hyndla",
    		description: "Norse wood giantess.",
    		bio: "Hyndluljóð (is an Old Norse poem often considered a part of the Poetic Edda. In the poem, the goddess Freyja meets the völva Hyndla and they ride together towards Valhalla. Freyja rides on her boar Hildisvíni and Hyndla on a wolf. Their mission is to find out the pedigree of Óttarr so that he can touch his inheritance, and the lay consists mostly of Hyndla reciting a number of names from Óttarr's ancestry.",
    		search_term: "Hyndla",
    		diameter: "2,300.0",
    		center_lat: 22.5,
    		center_long: 294.5
    	},
    	{
    		feature_id: 3640,
    		year: 1991,
    		feature: "Fossa",
    		feature_plural: "Fossae",
    		name: "Manto Fossae",
    		type: "Goddess",
    		origin: "Greek",
    		continent: "Europe",
    		clean_name: "Manto",
    		description: "Greek war goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "536.0",
    		center_lat: 63.6,
    		center_long: 64.9
    	},
    	{
    		feature_id: 3894,
    		year: 1991,
    		feature: "Mons",
    		feature_plural: "Montes",
    		name: "Milda Mons",
    		type: "Goddess",
    		origin: "Lithuania",
    		continent: "Europe",
    		clean_name: "Milda",
    		description: "Lithuanian goddess of love.",
    		bio: "",
    		search_term: "",
    		diameter: "48.0",
    		center_lat: 52.5,
    		center_long: 159.4
    	},
    	{
    		feature_id: 3956,
    		year: 1991,
    		feature: "Collis",
    		feature_plural: "Colles",
    		name: "Molpe Colles",
    		type: "Goddess",
    		origin: "Greek",
    		continent: "Europe",
    		clean_name: "Molpe",
    		description: "Greek; mother of Sirens.",
    		bio: "",
    		search_term: "",
    		diameter: "548.0",
    		center_lat: 76,
    		center_long: 192
    	},
    	{
    		feature_id: 4042,
    		year: 1991,
    		feature: "Linea",
    		feature_plural: "Lineae",
    		name: "Morrigan Linea",
    		type: "Goddess",
    		origin: "Celtic",
    		continent: "Europe",
    		clean_name: "Morrigan",
    		description: "Celtic war goddess.",
    		bio: "The Morrígan or Mórrígan, also known as Morrígu, is a figure from Irish mythology. The name is Mór-Ríoghain in Modern Irish, and it has been translated as \"great queen\" or \"phantom queen\". The Morrígan is mainly associated with war and fate, especially with foretelling doom, death, or victory in battle.",
    		search_term: "Morrigan",
    		diameter: "3,200.0",
    		center_lat: -54.5,
    		center_long: 311
    	},
    	{
    		feature_id: 4081,
    		year: 1991,
    		feature: "Mons",
    		feature_plural: "Montes",
    		name: "Muta Mons",
    		type: "Goddess",
    		origin: "Romania (Rumania)",
    		continent: "Europe",
    		clean_name: "Muta",
    		description: "Roman goddess of silence.",
    		bio: "",
    		search_term: "",
    		diameter: "54.0",
    		center_lat: 55.5,
    		center_long: 358.3
    	},
    	{
    		feature_id: 4267,
    		year: 1991,
    		feature: "Fossa",
    		feature_plural: "Fossae",
    		name: "Nike Fossae",
    		type: "Goddess",
    		origin: "Greek",
    		continent: "Europe",
    		clean_name: "Nike",
    		description: "Greek goddess of victory.",
    		bio: "",
    		search_term: "",
    		diameter: "800.0",
    		center_lat: -59.5,
    		center_long: 340
    	},
    	{
    		feature_id: 4482,
    		year: 1991,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Ops Corona",
    		type: "Goddess",
    		origin: "Greek",
    		continent: "Europe",
    		clean_name: "Ops",
    		description: "Greek fertility goddess.",
    		bio: "In ancient Roman religion, Ops or Opis (Latin: \"Plenty\") was a fertility deity and earth goddess of Sabine origin. Her equivalent in Greek mythology was Rhea. In Ops' statues and coins, she is figured sitting down, as Chthonian deities normally are, and generally holds a scepter, or a corn spray and cornucopia.",
    		search_term: "Ops",
    		diameter: "183.0",
    		center_lat: 68.8,
    		center_long: 89
    	},
    	{
    		feature_id: 4644,
    		year: 1991,
    		feature: "Linea",
    		feature_plural: "Lineae",
    		name: "Penardun Linea",
    		type: "Goddess",
    		origin: "Celtic",
    		continent: "Europe",
    		clean_name: "Penardun",
    		description: "Celtic sky goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "975.0",
    		center_lat: -54,
    		center_long: 344
    	},
    	{
    		feature_id: 5032,
    		year: 1991,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Rigatona Corona",
    		type: "Goddess",
    		origin: "Celtic",
    		continent: "Europe",
    		clean_name: "Rigatona",
    		description: "Celtic fertility goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "300.0",
    		center_lat: -33.5,
    		center_long: 278.5
    	},
    	{
    		feature_id: 5284,
    		year: 1991,
    		feature: "Dorsum",
    		feature_plural: "Dorsa",
    		name: "Salme Dorsa",
    		type: "Goddess",
    		origin: "Estonia",
    		continent: "Europe",
    		clean_name: "Salme",
    		description: "Estonian sky maiden.",
    		bio: "",
    		search_term: "",
    		diameter: "447.0",
    		center_lat: 58,
    		center_long: 25.2
    	},
    	{
    		feature_id: 6287,
    		year: 1991,
    		feature: "Fossa",
    		feature_plural: "Fossae",
    		name: "Valkyrie Fossae",
    		type: "Goddess",
    		origin: "Teutonic",
    		continent: "Europe",
    		clean_name: "Valkyrie",
    		description: "Norse battle maidens.",
    		bio: "In Norse mythology, a valkyrie (\"chooser of the slain\") is one of a host of female figures who guide souls of the dead to the god Odin's hall Valhalla. There, the deceased warriors become einherjar (Old Norse \"single (or once) fighters\"). When the einherjar are not preparing for the events of Ragnarök, the valkyries bear them mead.",
    		search_term: "Valkyrie",
    		diameter: "357.0",
    		center_lat: 58.2,
    		center_long: 7
    	},
    	{
    		feature_id: 469,
    		year: 1991,
    		feature: "Planitia",
    		feature_plural: "Planitiae",
    		name: "Audra Planitia",
    		type: "Heroine",
    		origin: "Lithuania",
    		continent: "Europe",
    		clean_name: "Audra ",
    		description: "Lithuanian sea mistress.",
    		bio: "",
    		search_term: "",
    		diameter: "1,900.0",
    		center_lat: 61,
    		center_long: 72
    	},
    	{
    		feature_id: 1514,
    		year: 1991,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Devorguilla",
    		type: "Heroine",
    		origin: "Ireland",
    		continent: "Europe",
    		clean_name: "Devorguilla",
    		description: "Irish heroine (d. 1193).",
    		bio: "Dervorguilla of Galloway (c. 1210 – 28 January 1290) was a 'lady of substance' in 13th century Scotland, the wife from 1223 of John, 5th Baron de Balliol, and mother of John I, a future king of Scotland.",
    		search_term: "Dervorguilla of Galloway",
    		diameter: "22.9",
    		center_lat: 15.3,
    		center_long: 4
    	},
    	{
    		feature_id: 3741,
    		year: 1991,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Maslenitsa Corona",
    		type: "Goddess",
    		origin: "Slavic",
    		continent: "Multiple",
    		clean_name: "Maslenitsa",
    		description: "Slavonic personification of fertility.",
    		bio: "Maslenitsa is an Eastern Slavic religious and folk holiday, which has retained a number of elements of Slavic mythology in its ritual, celebrated during the last week before Great Lent, that is, the eighth week before Eastern Orthodox Pascha. Since Lent excludes parties, secular music, dancing and other distractions from spiritual life, Maslenitsa represents the last chance to take part in social activities that are not appropriate during the more prayerful, sober and introspective Lenten season.",
    		search_term: "Maslenitsa",
    		diameter: "0.0",
    		center_lat: 77,
    		center_long: 202.5
    	},
    	{
    		feature_id: 4087,
    		year: 1991,
    		feature: "Fluctus",
    		feature_plural: "Fluctūs",
    		name: "Mylitta Fluctus",
    		type: "Goddess",
    		origin: "Semitic",
    		continent: "Multiple",
    		clean_name: "Mylitta",
    		description: "Semitic mother goddess.",
    		bio: "Mullissu is a goddess who is the consort of the Assyrian god Asshur. She is identified with Ishtar of Nineveh in the Neo-Assyrian Empire times.",
    		search_term: "Mylitta",
    		diameter: "1,250.0",
    		center_lat: -54,
    		center_long: 355.5
    	},
    	{
    		feature_id: 168,
    		year: 1991,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Alcott",
    		type: "Famous Woman",
    		origin: "United States",
    		continent: "North America",
    		clean_name: "Alcott",
    		description: "Louisa M.; American author (1832-1888).",
    		bio: "Louisa May Alcott (; November 29, 1832 – March 6, 1888) was an American novelist, short story writer, and poet best known as the author of the novel Little Women (1868) and its sequels Little Men (1871) and Jo's Boys (1886). Raised in New England by her transcendentalist parents, Abigail May and Amos Bronson Alcott, she grew up among many well-known intellectuals of the day, such as Ralph Waldo Emerson, Nathaniel Hawthorne, Henry David Thoreau, and Henry Wadsworth Longfellow. Alcott's family suffered from financial difficulties, and while she worked to help support the family from an early age, she also sought an outlet in writing. She began to receive critical success for her writing in the 1860s.",
    		search_term: "Louisa M. Alcott",
    		diameter: "66.0",
    		center_lat: -59.5,
    		center_long: 354.4
    	},
    	{
    		feature_id: 292,
    		year: 1991,
    		feature: "Patera",
    		feature_plural: "Paterae",
    		name: "Anthony Patera",
    		type: "Famous Woman",
    		origin: "United States",
    		continent: "North America",
    		clean_name: "Anthony",
    		description: "Susan B.; American suffrage leader (1820-1906).",
    		bio: "Susan B. Anthony (born Susan Anthony; February 15, 1820 – March 13, 1906) was an American social reformer and women's rights activist who played a pivotal role in the women's suffrage movement. Born into a Quaker family committed to social equality, she collected anti-slavery petitions at the age of 17. In 1856, she became the New York state agent for the American Anti-Slavery Society.",
    		search_term: "Susan B. Anthony",
    		diameter: "70.0",
    		center_lat: 48.2,
    		center_long: 32.6
    	},
    	{
    		feature_id: 316,
    		year: 1991,
    		feature: "Patera",
    		feature_plural: "Paterae",
    		name: "Apgar Patera",
    		type: "Famous Woman",
    		origin: "United States",
    		continent: "North America",
    		clean_name: "Apgar",
    		description: "Virginia; American doctor (1909-1974).",
    		bio: "Virginia Apgar (June 7, 1909 – August 7, 1974) was an American physician, obstetrical anesthesiologist and medical researcher, best known as the inventor of the Apgar Score, a way to quickly assess the health of a newborn child immediately after birth in order to combat infant mortality. A friend said, 'She probably did more than any other physician to bring the problem of birth defects out of back rooms.' She was a leader in the fields of anesthesiology and teratology, and introduced obstetrical considerations to the established field of neonatology.",
    		search_term: "Virginia Apgar",
    		diameter: "126.0",
    		center_lat: 43.1,
    		center_long: 83.8
    	},
    	{
    		feature_id: 623,
    		year: 1991,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Barton",
    		type: "Famous Woman",
    		origin: "United States",
    		continent: "North America",
    		clean_name: "Barton",
    		description: "Clara; American Red Cross founder (1821-1912).",
    		bio: "Clarissa Harlowe Barton (December 25, 1821 – April 12, 1912) was an American nurse who founded the American Red Cross. She was a hospital nurse in the American Civil War, a teacher, and a patent clerk. Since nursing education was not then very formalized and she did not attend nursing school, she provided self-taught nursing care.",
    		search_term: "Clara Barton",
    		diameter: "52.2",
    		center_lat: 27.4,
    		center_long: 337.5
    	},
    	{
    		feature_id: 722,
    		year: 1991,
    		feature: "Patera",
    		feature_plural: "Paterae",
    		name: "Bethune Patera",
    		type: "Famous Woman",
    		origin: "United States",
    		continent: "North America",
    		clean_name: "Bethune",
    		description: "Mary; American educator (1875-1955).",
    		bio: "Mary Jane McLeod Bethune (née McLeod; July 10, 1875 – May 18, 1955) was an American educator, philanthropist, humanitarian, womanist, and civil rights activist. Bethune founded the National Council of Negro Women in 1935, established the organization's flagship journal Aframerican Women's Journal, and presided as president or leader for a myriad of African American women's organizations including the National Association for Colored Women and the National Youth Administration's Negro Division. She also was appointed as a national adviser to president Franklin D. Roosevelt, whom she worked with to create the Federal Council on Colored Affairs, also known as the Black Cabinet. She is well-known for starting a private school for African-American students in Daytona Beach, Florida.",
    		search_term: "Mary McLeod Bethune",
    		diameter: "94.0",
    		center_lat: 46.5,
    		center_long: 321.3
    	},
    	{
    		feature_id: 843,
    		year: 1991,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Bourke-White",
    		type: "Famous Woman",
    		origin: "United States",
    		continent: "North America",
    		clean_name: "Bourke-White",
    		description: "Margaret; American photo-journalist (1905-1971).",
    		bio: "Margaret Bourke-White (; June 14, 1904 – August 27, 1971), an American photographer and documentary photographer, became arguably best known as the first foreign photographer permitted to take pictures of Soviet industry under the Soviets' five-year plan, as the first American female war photojournalist, and for taking the photograph (of the construction of Fort Peck Dam) that became the cover of the first issue of Life magazine.",
    		search_term: "Margaret Bourke-White",
    		diameter: "33.6",
    		center_lat: 21.2,
    		center_long: 147.9
    	},
    	{
    		feature_id: 907,
    		year: 1991,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Buck",
    		type: "Famous Woman",
    		origin: "United States",
    		continent: "North America",
    		clean_name: "Buck",
    		description: "Pearl S.; American writer (1892-1973).",
    		bio: "Pearl Sydenstricker Buck (June 26, 1892 – March 6, 1973) was an American writer and novelist. She is best known for The Good Earth, a bestselling novel in the United States in 1931 and 1932, and won the Pulitzer Prize in 1932. In 1938, Buck won the Nobel Prize in Literature 'for her rich and truly epic descriptions of peasant life in China' and for her 'masterpieces', two memoir-biographies of her missionary parents.",
    		search_term: "Pearl S. Buck",
    		diameter: "21.8",
    		center_lat: -5.7,
    		center_long: 349.6
    	},
    	{
    		feature_id: 975,
    		year: 1991,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Callas",
    		type: "Famous Woman",
    		origin: "United States",
    		continent: "North America",
    		clean_name: "Callas",
    		description: "Maria; American opera singer (1923-1977).",
    		bio: "Maria Callas (born Sophie Cecilia Kalos; December 2, 1923 – September 16, 1977) was an American-born Greek soprano who was one of the most renowned and influential opera singers of the 20th century. Many critics praised her bel canto technique, wide-ranging voice and dramatic interpretations. Her repertoire ranged from classical opera seria to the bel canto operas of Donizetti, Bellini and Rossini and, further, to the works of Verdi and Puccini; and, in her early career, to the music dramas of Wagner.",
    		search_term: "Maria Callas",
    		diameter: "33.8",
    		center_lat: 2.4,
    		center_long: 27
    	},
    	{
    		feature_id: 1033,
    		year: 1991,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Carson",
    		type: "Famous Woman",
    		origin: "United States",
    		continent: "North America",
    		clean_name: "Carson",
    		description: "Rachel; American biologist, author (1907-1964).",
    		bio: "Rachel Louise Carson (May 27, 1907 – April 14, 1964) was an American marine biologist, writer, and conservationist whose influential book Silent Spring (1962) and other writings are credited with advancing the global environmental movement. Carson began her career as an aquatic biologist in the U.S. Bureau of Fisheries, and became a full-time nature writer in the 1950s. Her widely praised 1951 bestseller The Sea Around Us won her a U.S. National Book Award, recognition as a gifted writer and financial security.",
    		search_term: "Rachel Carson",
    		diameter: "38.8",
    		center_lat: -24.2,
    		center_long: 344.1
    	},
    	{
    		feature_id: 1142,
    		year: 1991,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Chapelle",
    		type: "Famous Woman",
    		origin: "United States",
    		continent: "North America",
    		clean_name: "Chapelle",
    		description: "Georgette; Am. photo-journalist, killed in Vietnam (1919-1965).",
    		bio: "Georgette Louise Meyer (March 14, 1918 – November 4, 1965) known as Dickey Chapelle was an American photojournalist known for her work as a war correspondent from World War II through the Vietnam War. She became the first female war correspondent to be killed in Vietnam, as well as the first American female reporter to be killed in action. Chapelle 'was a tiny woman known for her refusal to kowtow to authority and her signature uniform: fatigues, an Australian bush hat, dramatic Harlequin glasses, and pearl earrings.'",
    		search_term: "Dickey Chapelle",
    		diameter: "22.0",
    		center_lat: 6.4,
    		center_long: 103.8
    	},
    	{
    		feature_id: 1475,
    		year: 1991,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Deloria",
    		type: "Famous Woman",
    		origin: "Dakota",
    		continent: "North America",
    		clean_name: "Deloria",
    		description: "Ella; Dakota (Sioux) anthropologist (1888-1971).",
    		bio: "Ella Cara Deloria (January 31, 1889 – February 12, 1971), also called Aŋpétu Wašté Wiŋ (Beautiful Day Woman), was a Yankton Dakota (Sioux) educator, anthropologist, ethnographer, linguist, and novelist. She recorded Native American oral history and contributed to the study of Native American languages. According to Cotera (2008), Deloria was 'a pre-eminent expert on Dakota/Lakota/Nakota cultural religious, and linguistic practices.' In the 1940s, Deloria wrote a novel titled Waterlily, which was published in 1988, and republished in 2009.",
    		search_term: "Ella Cara Deloria",
    		diameter: "31.9",
    		center_lat: -32,
    		center_long: 97.1
    	},
    	{
    		feature_id: 1937,
    		year: 1991,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Ferber",
    		type: "Famous Woman",
    		origin: "United States",
    		continent: "North America",
    		clean_name: "Ferber",
    		description: "Edna; American author (1887-1968).",
    		bio: "Edna Ferber (August 15, 1885 – April 16, 1968) was an American novelist, short story writer and playwright. Her novels include the Pulitzer Prize-winning So Big (1924), Show Boat (1926; made into the celebrated 1927 musical), Cimarron (1930; adapted into the 1931 film which won the Academy Award for Best Picture), Giant (1952; made into the 1956 film of the same name) and Ice Palace (1958), which also received a film adaptation in 1960. = = Ferber was born August 15, 1885, in Kalamazoo, Michigan, to a Hungarian-born Jewish storekeeper, Jacob Charles Ferber, and his Milwaukee, Wisconsin-born wife, Julia (Neumann) Ferber, who was of German Jewish descent.",
    		search_term: "Edna Ferber",
    		diameter: "23.1",
    		center_lat: 26.4,
    		center_long: 12.9
    	},
    	{
    		feature_id: 2436,
    		year: 1991,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Hellman",
    		type: "Famous Woman",
    		origin: "United States",
    		continent: "North America",
    		clean_name: "Hellman",
    		description: "Lillian; American playwright, author (1905-1984).",
    		bio: "Lillian Florence Hellman (June 20, 1905 – June 30, 1984) was an American playwright, prose writer, memoirist and screenwriter known for her success on Broadway, as well as her communist sympathies and political activism. She was blacklisted after her appearance before the House Committee on Un-American Activities (HUAC) at the height of the anti-communist campaigns of 1947–1952. Although she continued to work on Broadway in the 1950s, her blacklisting by the American film industry caused a drop in her income.",
    		search_term: "Lillian Hellman",
    		diameter: "34.7",
    		center_lat: 4.7,
    		center_long: 356.3
    	},
    	{
    		feature_id: 2542,
    		year: 1991,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Holiday",
    		type: "Famous Woman",
    		origin: "United States",
    		continent: "North America",
    		clean_name: "Holiday",
    		description: "Billie; American singer (1915-1959).",
    		bio: "Billie Holiday (born Eleanora Fagan; April 7, 1915 – July 17, 1959) was an American jazz and swing music singer. Nicknamed 'Lady Day' by her friend and music partner, Lester Young, Holiday had an innovative influence on jazz music and pop singing. Her vocal style, strongly inspired by jazz instrumentalists, pioneered a new way of manipulating phrasing and tempo.",
    		search_term: "Billie Holiday",
    		diameter: "27.7",
    		center_lat: -46.7,
    		center_long: 12.8
    	},
    	{
    		feature_id: 2983,
    		year: 1991,
    		feature: "Patera",
    		feature_plural: "Paterae",
    		name: "Keller Patera",
    		type: "Famous Woman",
    		origin: "United States",
    		continent: "North America",
    		clean_name: "Keller",
    		description: "Helen; blind and deaf American writer (1880-1968).",
    		bio: "Helen Adams Keller (June 27, 1880 – June 1, 1968) was an American author, disability rights advocate, political activist and lecturer. Born in West Tuscumbia, Alabama, she lost her sight and her hearing after a bout of illness at the age of 19 months. She then communicated primarily using home signs until the age of seven, when she met her first teacher and life-long companion Anne Sullivan.",
    		search_term: "Helen Keller",
    		diameter: "69.0",
    		center_lat: 45,
    		center_long: 274
    	},
    	{
    		feature_id: 3609,
    		year: 1991,
    		feature: "Patera",
    		feature_plural: "Paterae",
    		name: "Malintzin Patera",
    		type: "Famous Woman",
    		origin: "Aztec",
    		continent: "North America",
    		clean_name: "Malintzin",
    		description: "(Malina); Aztec Indian guide, interpreter (1501-1550).",
    		bio: "Marina [maˈɾina] or Malintzin [maˈlintsin] (c. 1500 – c. 1529), more popularly known as La Malinche [la maˈlintʃe], a Nahua woman from the Mexican Gulf Coast, became known for contributing to the Spanish conquest of the Aztec Empire (1519–1521), by acting as an interpreter, advisor, and intermediary for the Spanish conquistador Hernán Cortés.",
    		search_term: "La Malinche",
    		diameter: "60.0",
    		center_lat: 57,
    		center_long: 81.5
    	},
    	{
    		feature_id: 3787,
    		year: 1991,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Mead",
    		type: "Famous Woman",
    		origin: "United States",
    		continent: "North America",
    		clean_name: "Mead",
    		description: "Margaret; American anthropologist (1901-1978).",
    		bio: "Margaret Mead (December 16, 1901 – November 15, 1978) was an American cultural anthropologist who featured frequently as an author and speaker in the mass media during the 1960s and the 1970s.She earned her bachelor's degree at Barnard College of Columbia University and her M.A. and Ph.D. degrees from Columbia. Mead served as President of the American Association for the Advancement of Science in 1975.Mead was a communicator of anthropology in modern American and Western culture and was often controversial as an academic. Her reports detailing the attitudes towards sex in South Pacific and Southeast Asian traditional cultures influenced the 1960s sexual revolution.",
    		search_term: "Margaret Mead",
    		diameter: "270.0",
    		center_lat: 12.5,
    		center_long: 57.2
    	},
    	{
    		feature_id: 3898,
    		year: 1991,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Millay",
    		type: "Famous Woman",
    		origin: "United States",
    		continent: "North America",
    		clean_name: "Millay",
    		description: "Edna St. Vincent; American poet (1892-1950).",
    		bio: "Edna St. Vincent Millay (February 22, 1892 – October 19, 1950) was an American lyrical poet and playwright. Millay was a renowned social figure and noted feminist in New York City during the Roaring Twenties and beyond.",
    		search_term: "Edna St. Vincent Millay",
    		diameter: "48.0",
    		center_lat: 24.4,
    		center_long: 111.2
    	},
    	{
    		feature_id: 4539,
    		year: 1991,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "O'Connor",
    		type: "Famous Woman",
    		origin: "United States",
    		continent: "North America",
    		clean_name: "O'Connor",
    		description: "Flannery; American novelist (1925-1964).",
    		bio: "Mary Flannery O'Connor (March 25, 1925 – August 3, 1964) was an American novelist, short story writer and essayist. She wrote two novels and 31 short stories, as well as a number of reviews and commentaries. She was a Southern writer who often wrote in a sardonic Southern Gothic style and relied heavily on regional settings and grotesque characters, often in violent situations.",
    		search_term: "Flannery O'Connor",
    		diameter: "30.4",
    		center_lat: -26,
    		center_long: 143.9
    	},
    	{
    		feature_id: 4769,
    		year: 1991,
    		feature: "Patera",
    		feature_plural: "Paterae",
    		name: "Pocahontas Patera",
    		type: "Famous Woman",
    		origin: "Potawatomi",
    		continent: "North America",
    		clean_name: "Pocahontas",
    		description: "Powhatan Indian peacemaker (1595-1617).",
    		bio: "Pocahontas (US: , UK: ; born Amonute, known as Matoaka, c. 1596 – March 1617) was a Native American woman, belonging to the Powhatan people, notable for her association with the colonial settlement at Jamestown, Virginia. She was the daughter of Powhatan, the paramount chief of a network of tributary tribes in the Tsenacommacah, encompassing the Tidewater region of Virginia.",
    		search_term: "Pocahontas",
    		diameter: "78.0",
    		center_lat: 64.9,
    		center_long: 49.4
    	},
    	{
    		feature_id: 5691,
    		year: 1991,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Stein",
    		type: "Famous Woman",
    		origin: "United States",
    		continent: "North America",
    		clean_name: "Stein",
    		description: "Gertrude; American writer (1874-1946).",
    		bio: "Gertrude Stein (February 3, 1874 – July 27, 1946) was an American novelist, poet, playwright, and art collector. Born in Pittsburgh, Pennsylvania, in the Allegheny West neighborhood and raised in Oakland, California, Stein moved to Paris in 1903, and made France her home for the remainder of her life. She hosted a Paris salon, where the leading figures of modernism in literature and art, such as Pablo Picasso, Ernest Hemingway, F. Scott Fitzgerald, Sinclair Lewis, Ezra Pound, Sherwood Anderson and Henri Matisse, would meet.In 1933, Stein published a quasi-memoir of her Paris years, The Autobiography of Alice B. Toklas, written in the voice of Alice B. Toklas, her life partner.",
    		search_term: "Gertrude Stein",
    		diameter: "13.3",
    		center_lat: -30.1,
    		center_long: 345.5
    	},
    	{
    		feature_id: 6546,
    		year: 1991,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Wilder",
    		type: "Famous Woman",
    		origin: "United States",
    		continent: "North America",
    		clean_name: "Wilder",
    		description: "Laura Ingalls; American author (1867-1957).",
    		bio: "Laura Elizabeth Ingalls Wilder (February 7, 1867 – February 10, 1957) was an American writer, mostly known for the Little House on the Prairie series of children's books, published between 1932 and 1943, which were based on her childhood in a settler and pioneer family.The television series Little House on the Prairie (1974–1983) was loosely based on the books, and starred Melissa Gilbert as Laura and Michael Landon as her father, Charles Ingalls. Laura Elizabeth Ingalls was born to Charles Phillip and Caroline Lake (née Quiner) Ingalls on February 7, 1867. At the time of Ingalls' birth, the family lived seven miles north of the village of Pepin, Wisconsin, in the Big Woods region of Wisconsin.",
    		search_term: "Laura Ingalls Wilder",
    		diameter: "35.1",
    		center_lat: 17.4,
    		center_long: 122.6
    	},
    	{
    		feature_id: 1748,
    		year: 1991,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Eithinoha Corona",
    		type: "Goddess",
    		origin: "United States",
    		continent: "North America",
    		clean_name: "Eithinoha",
    		description: "Iroquois earth goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "500.0",
    		center_lat: -57,
    		center_long: 7.5
    	},
    	{
    		feature_id: 2510,
    		year: 1991,
    		feature: "Chasma",
    		feature_plural: "Chasmata",
    		name: "Hina Chasma",
    		type: "Goddess",
    		origin: "Hawaii",
    		continent: "North America",
    		clean_name: "Hina",
    		description: "Hawaiian moon goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "415.0",
    		center_lat: 63.7,
    		center_long: 20
    	},
    	{
    		feature_id: 2895,
    		year: 1991,
    		feature: "Linea",
    		feature_plural: "Lineae",
    		name: "Kalaipahoa Linea",
    		type: "Goddess",
    		origin: "Hawaii",
    		continent: "North America",
    		clean_name: "Kalaipahoa",
    		description: "Hawaiian war goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "2,400.0",
    		center_lat: -60.5,
    		center_long: 336.5
    	},
    	{
    		feature_id: 4179,
    		year: 1991,
    		feature: "Fluctus",
    		feature_plural: "Fluctūs",
    		name: "Neago Fluctūs",
    		type: "Goddess",
    		origin: "Seneca",
    		continent: "North America",
    		clean_name: "Neago",
    		description: "Seneca (USA) goddess of silence.",
    		bio: "",
    		search_term: "",
    		diameter: "0.0",
    		center_lat: 49.3,
    		center_long: 351
    	},
    	{
    		feature_id: 4463,
    		year: 1991,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Onatah Corona",
    		type: "Goddess",
    		origin: "Iroquois",
    		continent: "North America",
    		clean_name: "Onatah",
    		description: "Iroquois corn spirit.",
    		bio: "",
    		search_term: "",
    		diameter: "298.0",
    		center_lat: 49,
    		center_long: 5.5
    	},
    	{
    		feature_id: 4899,
    		year: 1991,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Quetzalpetlatl Corona",
    		type: "Goddess",
    		origin: "Aztec",
    		continent: "North America",
    		clean_name: "Quetzalpetlatl",
    		description: "Aztec fertility goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "780.0",
    		center_lat: -68,
    		center_long: 357
    	},
    	{
    		feature_id: 6612,
    		year: 1991,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Xilonen Corona",
    		type: "Goddess",
    		origin: "Aztec",
    		continent: "North America",
    		clean_name: "Xilonen",
    		description: "Aztec maize (fertility) goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "300.0",
    		center_lat: 51,
    		center_long: 321
    	},
    	{
    		feature_id: 3721,
    		year: 1991,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Marsh",
    		type: "Famous Woman",
    		origin: "New Zealand",
    		continent: "Oceania",
    		clean_name: "Marsh",
    		description: "Ngaio; New Zealand playwright, novelist (1899-1982).",
    		bio: "Dame Edith Ngaio Marsh (; 23 April 1895 – 18 February 1982) was a New Zealand mystery writer and theatre director. She was appointed a Dame Commander of the Order of the British Empire in 1966.As a crime writer during the 'Golden Age of Detective Fiction', Marsh is known as one of the 'Queens of Crime', along with Agatha Christie, Dorothy L. Sayers, and Margery Allingham. She is known primarily for her character Inspector Roderick Alleyn, a gentleman detective who works for the Metropolitan Police (London).",
    		search_term: "Ngaio Marsh",
    		diameter: "47.7",
    		center_lat: -63.6,
    		center_long: 46.6
    	},
    	{
    		feature_id: 1030,
    		year: 1991,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Carreno",
    		type: "Famous Woman",
    		origin: "Venezuela",
    		continent: "South America",
    		clean_name: "Carreno",
    		description: "Teresa; Venezuelan pianist, composer (1853-1917).",
    		bio: "María Teresa Gertrudis de Jesús Carreño García (December 22, 1853 – June 12, 1917) was a Venezuelan pianist, soprano, composer, and conductor. Over the course of her 54-year concert career, she became an internationally renowned virtuoso pianist and was often referred to as the 'Valkyrie of the Piano'. Carreño was an early adopter of the works of one of her students, American composer and pianist Edward MacDowell (1860–1908) and premiered several of his compositions across the globe.",
    		search_term: "Teresa Carreño",
    		diameter: "57.0",
    		center_lat: -3.9,
    		center_long: 16.1
    	},
    	{
    		feature_id: 4593,
    		year: 1991,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Parra",
    		type: "Famous Woman",
    		origin: "Chile",
    		continent: "South America",
    		clean_name: "Parra",
    		description: "Chilean writer.",
    		bio: "Violeta del Carmen Parra Sandoval (Spanish pronunciation: [bjoˈleta ˈpara]; 4 October 1917 – 5 February 1967) was a Chilean composer, singer-songwriter, folklorist, ethnomusicologist and visual artist. She pioneered the Nueva Canción Chilena (The Chilean New Song), a renewal and a reinvention of Chilean folk music that would extend its sphere of influence outside Chile. Her birthdate (4 October) was chosen 'Chilean Musicians' Day'.",
    		search_term: "Violeta Parra",
    		diameter: "42.4",
    		center_lat: 20.5,
    		center_long: 78.5
    	},
    	{
    		feature_id: 1082,
    		year: 1991,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Cauteovan Corona",
    		type: "Goddess",
    		origin: "Colombia",
    		continent: "South America",
    		clean_name: "Cauteovan",
    		description: "Kataba (Columbia) fertility goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "553.0",
    		center_lat: 31.5,
    		center_long: 142.9
    	},
    	{
    		feature_id: 3856,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Merit Ptah",
    		type: "Famous Woman",
    		origin: "Egypt",
    		continent: "Africa",
    		clean_name: "Merit Ptah",
    		description: "Egyptian queen, physician (c. 2700 B.C.).",
    		bio: "Merit-Ptah ('Beloved of Ptah') was thought to be a female chief physician of the pharaoh's court during the Second Dynasty of Egypt, c. 2700 BCE; she is purportedly referred as such on an inscription left on her grave at Saqqara by her son.However, in recent times it has been argued that she most likely never existed, being a modern 1938 invention of a Canadian feminist called Kate Campbell Hurd-Mead. Jakub Kwiecinski, a historian at the University of Colorado, was cited by secondary source Newsweek arguing that the made-up story of Merit-Ptah exemplifies how 'seemingly well-sourced Wikipedia articles' can mislead, and he cautioned against over-reliance on secondary sources.",
    		search_term: "Merit-Ptah",
    		diameter: "16.5",
    		center_lat: 11.4,
    		center_long: 115.6
    	},
    	{
    		feature_id: 4325,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Nofret",
    		type: "Famous Woman",
    		origin: "Egypt",
    		continent: "Africa",
    		clean_name: "Nofret",
    		description: "Egyptian queen (c. 1900 B.C.).",
    		bio: "Nofret was a noblewoman and princess who lived in Ancient Egypt during the 4th dynasty of Egypt c. 2613 to 2494 BC. Nefert means 'beautiful'. Nofret is alternatively known as Nefert or Neferet. Nofret's parents are not known.",
    		search_term: "Nofret",
    		diameter: "22.5",
    		center_lat: -58.8,
    		center_long: 252.2
    	},
    	{
    		feature_id: 225,
    		year: 1994,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Ament Corona",
    		type: "Goddess",
    		origin: "Egypt",
    		continent: "Africa",
    		clean_name: "Ament",
    		description: "Egyptian earth goddess.",
    		bio: "Imentet (Ament, Amentet or Imentit, meaning 'She of the West') was a goddess in ancient Egyptian religion representing the necropolises west of the Nile. She was the consort of Aqen, a god who guided Ra through parts of the underworld. Although she was never officially worshipped, she was mentioned in various hymns and passages of the Book of the Dead.",
    		search_term: "Imentet",
    		diameter: "115.0",
    		center_lat: -67.2,
    		center_long: 217.9
    	},
    	{
    		feature_id: 287,
    		year: 1994,
    		feature: "Farrum",
    		feature_plural: "Farra",
    		name: "Anqet Farra",
    		type: "Goddess",
    		origin: "Egypt",
    		continent: "Africa",
    		clean_name: "Anqet",
    		description: "Egyptian goddess of fertile waters.",
    		bio: "Anuket was the ancient Egyptian goddess of the cataracts of the Nile and Lower Nubia in general, worshipped especially at Elephantine near the First Cataract. In ancient Egyptian, she was known as Anuket, Anaka, or Anqet. Her name meant the \"Clasper\" or \"Embracer\".",
    		search_term: "Anqet",
    		diameter: "125.0",
    		center_lat: 33.6,
    		center_long: 311.5
    	},
    	{
    		feature_id: 305,
    		year: 1994,
    		feature: "Vallis",
    		feature_plural: "Valles",
    		name: "Anuket Vallis",
    		type: "Goddess",
    		origin: "Egypt",
    		continent: "Africa",
    		clean_name: "Anuket",
    		description: "Egyptian river goddess.",
    		bio: "Anuket was the ancient Egyptian goddess of the cataracts of the Nile and Lower Nubia in general, worshipped especially at Elephantine near the First Cataract. In ancient Egyptian, she was known as Anuket, Anaka, or Anqet. Her name meant the \"Clasper\" or \"Embracer\".",
    		search_term: "Anuket",
    		diameter: "350.0",
    		center_lat: 66.7,
    		center_long: 8
    	},
    	{
    		feature_id: 452,
    		year: 1994,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Atete Corona",
    		type: "Goddess",
    		origin: "Ethiopia",
    		continent: "Africa",
    		clean_name: "Atete",
    		description: "Oromo (Ethiopia) fertility goddess.",
    		bio: "Atete is a fertility goddess worshipped at Kafa (Ethiopia). It is probably the subject of an ancient fertility rite performed by women who collect various sacred plants and throw them into the river.",
    		search_term: "Atete",
    		diameter: "600.0",
    		center_lat: -16,
    		center_long: 243.5
    	},
    	{
    		feature_id: 2744,
    		year: 1994,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Isong Corona",
    		type: "Goddess",
    		origin: "Niger",
    		continent: "Africa",
    		clean_name: "Isong",
    		description: "Ibibio (Nigeria) fertility goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "540.0",
    		center_lat: 12,
    		center_long: 49.2
    	},
    	{
    		feature_id: 3652,
    		year: 1994,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Maram Corona",
    		type: "Goddess",
    		origin: "Ethiopia",
    		continent: "Africa",
    		clean_name: "Maram",
    		description: "Oromo (Ethiopia) fertility goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "600.0",
    		center_lat: -7.5,
    		center_long: 221.5
    	},
    	{
    		feature_id: 3774,
    		year: 1994,
    		feature: "Mons",
    		feature_plural: "Montes",
    		name: "Mbokomu Mons",
    		type: "Goddess",
    		origin: "Zaire",
    		continent: "Africa",
    		clean_name: "Mbokomu",
    		description: "Ngombe (Zaire) ancestor goddess.",
    		bio: "Mbokomu was the first woman of Earth according to the traditional belief of the Ngombe people of today's Democratic Republic of the Congo. She was also the first gardener. She is the ancestor of all people.",
    		search_term: "Mbokomu (deity)",
    		diameter: "460.0",
    		center_lat: -15.1,
    		center_long: 215.2
    	},
    	{
    		feature_id: 4101,
    		year: 1994,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Nabuzana Corona",
    		type: "Goddess",
    		origin: "Uganda",
    		continent: "Africa",
    		clean_name: "Nabuzana",
    		description: "Ganda (Uganda) crop goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "525.0",
    		center_lat: -8.5,
    		center_long: 47
    	},
    	{
    		feature_id: 4107,
    		year: 1994,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Nagavonyi Corona",
    		type: "Goddess",
    		origin: "Uganda",
    		continent: "Africa",
    		clean_name: "Nagavonyi",
    		description: "Ganda (Uganda) crop goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "190.0",
    		center_lat: -18.5,
    		center_long: 259
    	},
    	{
    		feature_id: 4126,
    		year: 1994,
    		feature: "Dorsum",
    		feature_plural: "Dorsa",
    		name: "Nambi Dorsum",
    		type: "Goddess",
    		origin: "Uganda",
    		continent: "Africa",
    		clean_name: "Nambi",
    		description: "Ugandan sky goddess.",
    		bio: "Nambi is the daughter of Mugulu, also known as Ggulu in some versions of Ugandan mythology. In the Ugandan creation myth, it is Nambi and her younger sister who discover Kintu, the first man. Nambi helps Kintu throughout his journey and trials, and eventually becomes his wife and mother of his children.",
    		search_term: "Nambi (mythology)",
    		diameter: "1,125.0",
    		center_lat: -72.5,
    		center_long: 213
    	},
    	{
    		feature_id: 4405,
    		year: 1994,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Oduduwa Corona",
    		type: "Goddess",
    		origin: "Nigeria",
    		continent: "Africa",
    		clean_name: "Oduduwa",
    		description: "Yoruba (Nigeria) fertility goddess.",
    		bio: "Yoruba religious traditions about the dawn of time claim that Oduduwa was the favorite spirit of Olodumare (the Supreme Being). As such, he (or she, as the primordial Oduduwa originally represented the Divine Feminine aspect and Obatala the Divine Masculine) was sent from heaven to create the earth upon the waters, a mission he/she had usurped from his/her consort and sibling Obatala, who had been equipped with a snail shell filled with sand and a rooster to scatter the said sand in order to create land. These beliefs are held by Yoruba traditionalists to be the cornerstone of their story of creation.",
    		search_term: "Oduduwa",
    		diameter: "150.0",
    		center_lat: -11,
    		center_long: 211.5
    	},
    	{
    		feature_id: 4506,
    		year: 1994,
    		feature: "Farrum",
    		feature_plural: "Farra",
    		name: "Oshun Farra",
    		type: "Goddess",
    		origin: "Nigeria",
    		continent: "Africa",
    		clean_name: "Oshun",
    		description: "Yoruba (Nigeria) fresh water goddess.",
    		bio: "Ọṣun, is an orisha, a spirit, a deity, or a goddess that reflects one of the manifestations of the Yorùbá Supreme Being in the Ifá oral tradition and Yoruba-based religions of West Africa. She is one of the most popular and venerated Orishas. Oshun is an important river deity among the Yorùbá people.",
    		search_term: "Oshun",
    		diameter: "80.0",
    		center_lat: 4.2,
    		center_long: 19.3
    	},
    	{
    		feature_id: 4894,
    		year: 1994,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Qetesh Corona",
    		type: "Goddess",
    		origin: "Egypt",
    		continent: "Africa",
    		clean_name: "Qetesh",
    		description: "Egyptian fertility goddess.",
    		bio: "Qetesh was a goddess who was incorporated into the ancient Egyptian religion in the late Bronze Age. The functions of Qetesh in Egyptian religion are hard to determine due to lack of direct references, but her epithets (especially the default one, \"lady of heaven\") might point at an astral character, and lack of presence in royal cult might mean that she was regarded as a protective goddess mostly by commoners.",
    		search_term: "Qetesh",
    		diameter: "80.0",
    		center_lat: -20.5,
    		center_long: 343.5
    	},
    	{
    		feature_id: 4993,
    		year: 1994,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Renenti Corona",
    		type: "Goddess",
    		origin: "Egypt",
    		continent: "Africa",
    		clean_name: "Renenti",
    		description: "Egyptian goddess of abundance.",
    		bio: "Renenūtet (also transliterated Ernūtet, Renen-wetet, Renenet) was a goddess of nourishment and the harvest in the ancient Egyptian religion. The importance of the harvest caused people to make many offerings to Renenutet during harvest time.",
    		search_term: "Renenti",
    		diameter: "200.0",
    		center_lat: 32.7,
    		center_long: 326.2
    	},
    	{
    		feature_id: 5337,
    		year: 1994,
    		feature: "Vallis",
    		feature_plural: "Valles",
    		name: "Sati Vallis",
    		type: "Goddess",
    		origin: "Egypt",
    		continent: "Africa",
    		clean_name: "Sati",
    		description: "Egyptian river goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "225.0",
    		center_lat: 3.2,
    		center_long: 334.4
    	},
    	{
    		feature_id: 5969,
    		year: 1994,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Thermuthis Corona",
    		type: "Goddess",
    		origin: "Egypt",
    		continent: "Africa",
    		clean_name: "Thermuthis",
    		description: "Egyptian fertility/harvest goddess.",
    		bio: "The Pharaoh's daughter (Hebrew: בַּת־פַּרְעֹה, lit. 'daughter of Pharaoh') in the story of the finding of Moses in the biblical Book of Exodus is an important, albeit minor, figure in Abrahamic religions. Though some variations of her story exist, the general consensus among Jews, Christians, and Muslims is that she is the adoptive mother of the prophet Moses. Muslims identify her with Asiya, the Great Royal Wife of the pharaoh.",
    		search_term: "Thermuthis",
    		diameter: "330.0",
    		center_lat: -8,
    		center_long: 33
    	},
    	{
    		feature_id: 5983,
    		year: 1994,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Thouris Corona",
    		type: "Goddess",
    		origin: "Egypt",
    		continent: "Africa",
    		clean_name: "Thouris",
    		description: "Egyptian fertility goddess .",
    		bio: "",
    		search_term: "",
    		diameter: "190.0",
    		center_lat: -6.5,
    		center_long: 12.9
    	},
    	{
    		feature_id: 6662,
    		year: 1994,
    		feature: "Vallis",
    		feature_plural: "Valles",
    		name: "Ymoja Vallis",
    		type: "Goddess",
    		origin: "Nigeria",
    		continent: "Africa",
    		clean_name: "Ymoja",
    		description: "Yoruba (Nigeria) river goddess.",
    		bio: "Yemanjá (Yoruba: Yemọja; also: yemoya, yemaya; there are many different transliterations in other languages) is a major water spirit from the Yoruba religion. She is the mother of all Orishas. She is an orisha, in this case patron spirit of rivers, particularly the Ogun River in Nigeria, and oceans in Cuban and Brazilian orisa religions.",
    		search_term: "Ymoja",
    		diameter: "390.0",
    		center_lat: -71.6,
    		center_long: 204.8
    	},
    	{
    		feature_id: 4349,
    		year: 1994,
    		feature: "Planitia",
    		feature_plural: "Planitiae",
    		name: "Nsomeka Planitia",
    		type: "Heroine",
    		origin: "Bantu",
    		continent: "Africa",
    		clean_name: "Nsomeka ",
    		description: "Bantu culture heroine.",
    		bio: "",
    		search_term: "",
    		diameter: "2,100.0",
    		center_lat: -53,
    		center_long: 195
    	},
    	{
    		feature_id: 645,
    		year: 1994,
    		feature: "Vallis",
    		feature_plural: "Valles",
    		name: "Bayara Vallis",
    		type: "Other",
    		origin: "Mali",
    		continent: "Africa",
    		clean_name: "Bayara ",
    		description: "Dogon (Mali) word for planet Venus.",
    		bio: "",
    		search_term: "",
    		diameter: "500.0",
    		center_lat: 45.6,
    		center_long: 16.5
    	},
    	{
    		feature_id: 691,
    		year: 1994,
    		feature: "Vallis",
    		feature_plural: "Valles",
    		name: "Bennu Vallis",
    		type: "Other",
    		origin: "Egypt",
    		continent: "Africa",
    		clean_name: "Bennu ",
    		description: "Egyptian word for planet Venus.",
    		bio: "",
    		search_term: "",
    		diameter: "710.0",
    		center_lat: 1.3,
    		center_long: 341.2
    	},
    	{
    		feature_id: 132,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Akiko",
    		type: "Famous Woman",
    		origin: "Japan",
    		continent: "Asia",
    		clean_name: "Akiko",
    		description: "Yosano; Japanese Tanka poet (1878-1942).",
    		bio: "Yosano Akiko (Shinjitai: 与謝野 晶子, seiji: 與謝野 晶子; 7 December 1878 – 29 May 1942) was the pen-name of a Japanese author, poet, pioneering feminist, pacifist, and social reformer, active in the late Meiji period as well as the Taishō and early Shōwa periods of Japan. Her name at birth was Shō Hō (鳳 志やう, Hō Shō). She is one of the most noted, and most controversial, post-classical woman poets of Japan.",
    		search_term: "Yosano Akiko",
    		diameter: "17.4",
    		center_lat: 30.6,
    		center_long: 187.3
    	},
    	{
    		feature_id: 602,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Baranamtarra",
    		type: "Famous Woman",
    		origin: "Assyro-Babylonian",
    		continent: "Asia",
    		clean_name: "Baranamtarra",
    		description: "Mesopotamian queen (c. 2500 B.C.).",
    		bio: "Baranamtarra was the Queen of Lagash during the 24th century BCE. In 2384 BCE, Baranamtarra and her husband, Lugalanda, seized power of Lagash, one of the oldest cities in Sumer. They became the largest landholders in the city, and Baranamtarra presided over a temple and several estates herself. Queen Baranamtarra managed her own private estates and those of the temple of the goddess Bau.",
    		search_term: "Baranamtarra",
    		diameter: "25.5",
    		center_lat: 17.9,
    		center_long: 267.8
    	},
    	{
    		feature_id: 636,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Bathsheba",
    		type: "Famous Woman",
    		origin: "Hebrew",
    		continent: "Asia",
    		clean_name: "Bathsheba",
    		description: "Hebrew queen (c. 1030 B.C.).",
    		bio: "Bathsheba ( or ; Hebrew: בַּת־שֶׁבַע, Baṯ-šeḇaʿ, Bat-Sheva or Batsheva, 'daughter of Sheba' or 'daughter of the oath') was the wife of Uriah the Hittite and later of David, according to the Hebrew Bible. She was the mother of Solomon, who succeeded David as king, making her the Gebirah (Queen mother). She is best known for the Biblical narrative in which she was summoned by King David, who had seen her bathing and lusted after her.",
    		search_term: "Bathsheba",
    		diameter: "32.3",
    		center_lat: -15.1,
    		center_long: 49.5
    	},
    	{
    		feature_id: 963,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Caiwenji",
    		type: "Famous Woman",
    		origin: "China",
    		continent: "Asia",
    		clean_name: "Caiwenji",
    		description: "Chinese painter, calligrapher (907-960).",
    		bio: "Cai Yan (c. 178 – post 206; or c. 170–215; or died c. 249), courtesy name Wenji, was a Chinese composer, poet, and writer who lived during the late Eastern Han dynasty of China. She spent part of her life as a captive of the Xiongnu until 207, when the warlord Cao Cao, who controlled the Han central government in the final years of the Eastern Han dynasty, paid a heavy ransom to bring her back to Han territory. She was an established calligrapher of her time. Her poems were noted for their sorrowful tone, which paralleled her hard life.",
    		search_term: "Cai Yan",
    		diameter: "22.6",
    		center_lat: -12.4,
    		center_long: 287.6
    	},
    	{
    		feature_id: 1843,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Escoda",
    		type: "Famous Woman",
    		origin: "Philippines",
    		continent: "Asia",
    		clean_name: "Escoda",
    		description: "Josefa Llanes; Philipino organizer of Girl Scouts of P.I. (1898-1945).",
    		bio: "Josefa Madamba Llanes Escoda (20 September 1898 – 6 January 1945) was a Filipino civic leader, social worker, World War II heroine, and suffragette. She is most known for campaigning for women's suffrage and as a founder of the Girl Scouts of the Philippines. Together with José Abad Santos and Vicente Lim, she is memorialized on the Philippines' 1,000-Peso banknote depicting Filipinos who fought and died resisting the Japanese occupation of the Philippines during the Second World War at the Far Eastern University in Manila.",
    		search_term: "Josefa Llanes Escoda",
    		diameter: "19.6",
    		center_lat: 18.2,
    		center_long: 149.5
    	},
    	{
    		feature_id: 2265,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Guan Daosheng",
    		type: "Famous Woman",
    		origin: "China",
    		continent: "Asia",
    		clean_name: "Guan Daosheng",
    		description: "Chinese painter, calligrapher (1262-1319).",
    		bio: "Guan Daosheng also known as Guan Zhongji or Lady Zhongji (her courtesy name) (Chinese: 管道昇; Wade–Giles: Kuan Tao-sheng; 字仲姬；1262–1319) was a Chinese painter and poet who was active during the early Yuan dynasty. She is credited with being 'the most famous female painter and calligrapher in the Chinese history...remembered not only as a talented woman, but also as a prominent figure in the history of bamboo painting.' She is also a well-known poet in the Yuan dynasty. She was born into a landed family in Huzhou, which is believed to be descended from the high-ranking Wuxing official Guan Zhong.",
    		search_term: "Guan Daosheng",
    		diameter: "43.6",
    		center_lat: -61.1,
    		center_long: 181.8
    	},
    	{
    		feature_id: 2567,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Hsueh T'ao",
    		type: "Famous Woman",
    		origin: "China",
    		continent: "Asia",
    		clean_name: "Hsueh T'ao",
    		description: "Chinese poet, artist (c. A.D.760).",
    		bio: "Xue Tao (simplified Chinese: 薛涛; traditional Chinese: 薛濤; pinyin: Xuē Tāo; Wade–Giles: Hsüeh T&#x02BB;ao, c770–832), courtesy name Hongdu (洪度/宏度) was a Chinese poet and courtesan of the Tang dynasty. She was one of the most famous women poets of Tang poetry, along with Yu Xuanji and Li Ye. Xue Tao was the daughter of a minor government official in Chang'an, which was the Chinese capital during the Tang Dynasty.",
    		search_term: "Hsueh T'ao",
    		diameter: "21.0",
    		center_lat: -52.6,
    		center_long: 13.8
    	},
    	{
    		feature_id: 2644,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Ichikawa",
    		type: "Famous Woman",
    		origin: "Japan",
    		continent: "Asia",
    		clean_name: "Ichikawa",
    		description: "Fusaye; Japanese feminist (1893-1981).",
    		bio: "Ichikawa Fusae (市川 房枝, May 15, 1893 – February 11, 1981) was a Japanese feminist, politician and a leader of the women's suffrage movement. Ichikawa was a key supporter of women's suffrage in Japan, and her activism was partially responsible for the extension of the franchise to women in 1945. Born in Bisai, Aichi Prefecture in 1893, Ichikawa was raised with an emphasis on education but also as a witness to her mother's physical abuse from her father.",
    		search_term: "Fusaye Ichikawa",
    		diameter: "31.4",
    		center_lat: -61.6,
    		center_long: 156.3
    	},
    	{
    		feature_id: 2827,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Jhirad",
    		type: "Famous Woman",
    		origin: "India",
    		continent: "Asia",
    		clean_name: "Jhirad",
    		description: "Jerusha; Indian physician.",
    		bio: "Jerusha Jacob Jhirad FRCOG, MBE (21 March 1891 – 2 June 1984) was an Indian physician. Jhirad born in Shivamogga, Karnataka. She was a member of the Bene Israel Jewish community.",
    		search_term: "Jerusha Jhirad",
    		diameter: "50.2",
    		center_lat: -16.8,
    		center_long: 105.6
    	},
    	{
    		feature_id: 2845,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Joshee",
    		type: "Famous Woman",
    		origin: "India",
    		continent: "Asia",
    		clean_name: "Joshee",
    		description: "Anandibai; Indian pioneer physician (1865-1887).",
    		bio: "Dr. Anandibai Gopalrao Joshi (31 March 1865 – 26 February 1887) was the first Indian female doctor of western medicine. She was the first woman from the erstwhile Bombay presidency of India to study and graduate with a two-year degree in western medicine in the United States.",
    		search_term: "Anandibai Joshee",
    		diameter: "37.0",
    		center_lat: 5.5,
    		center_long: 288.7
    	},
    	{
    		feature_id: 3545,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Ma Shouzhen",
    		type: "Famous Woman",
    		origin: "China",
    		continent: "Asia",
    		clean_name: "Ma Shouzhen",
    		description: "Chinese poet, painter (1592-1628).",
    		bio: "Ma Shouzhen (Chinese: 馬守真; c. 1548–1604), also known by her courtesy name Ma Xianglan (Chinese: 馬湘蘭, meaning 'Orchid of the Xiang River') and pen name Yuejiao ('Lunar Beauty'), was a Chinese courtesan and artist born in Nanjing during the late Ming dynasty (1550–1644). She was a renowned painter, poet, and composer.",
    		search_term: "Ma Shouzhen",
    		diameter: "18.9",
    		center_lat: -35.7,
    		center_long: 92.5
    	},
    	{
    		feature_id: 3735,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Masako",
    		type: "Famous Woman",
    		origin: "Japan",
    		continent: "Asia",
    		clean_name: "Masako",
    		description: "Hozyo; Japanese ruler (1157-1225).",
    		bio: "Hōjō Masako (北条 政子, 1156 – August 16, 1225) was a Japanese Buddhist nun and politician who exercised significant power in the early years of the Kamakura period, which was reflected by her contemporary sobriquet of the 'nun shogun'. She was the eldest daughter of Hōjō Tokimasa and sister of Hōjō Yoshitoki, both of them shikkens of the Kamakura shogunate. She was the wife of Minamoto no Yoritomo, and mother of Minamoto no Yoriie and Minamoto no Sanetomo, the first, second and third shōguns of the Kamakura period.",
    		search_term: "Hōjō Masako",
    		diameter: "23.8",
    		center_lat: -30.2,
    		center_long: 53.2
    	},
    	{
    		feature_id: 3792,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Medhavi",
    		type: "Famous Woman",
    		origin: "India",
    		continent: "Asia",
    		clean_name: "Medhavi",
    		description: "Ramabai; East Indian author, humanitarian (1858-1922).",
    		bio: "Pandita Ramabai Sarasvati (23 April 1858 – 5 April 1922) was an Indian Social Reformer. She was the first woman to be awarded the titles of Pandita as a Sanskrit scholar and Sarasvati after being examined by the faculty of the University of Calcutta. She was one of the ten women delegates of the Congress session of 1889.During her stay in England in early 1880s she converted to christianity.After that she toured extensively in the United states to collect funds for destitute Indian women.With the funds raised she started Sharada sadan for child widows.",
    		search_term: "Pandita Ramabai",
    		diameter: "30.4",
    		center_lat: -19.4,
    		center_long: 40.6
    	},
    	{
    		feature_id: 4067,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Mumtaz-Mahal",
    		type: "Famous Woman",
    		origin: "India",
    		continent: "Asia",
    		clean_name: "Mumtaz-Mahal",
    		description: "Mogul empress, Taj Mahal namesake (1592-1631).",
    		bio: "Mumtaz Mahal (/[mʊmˈt̪aːz mɛˈɦɛl]/; lit. 'the exalted one of the Palace'), born Arjumand Banu Begum (27 April 1593 – 17 June 1631) was the empress consort of the Mughal Empire from 19 January 1628 to 17 June 1631 as the chief consort of the Mughal emperor Shah Jahan. The Taj Mahal in Agra, often cited as one of the Wonders of the World, was commissioned by her husband to act as her tomb.Mumtaz Mahal was born Arjumand Banu Begum in Agra to a family of Persian nobility. She was the daughter of Abu'l-Hasan Asaf Khan, a wealthy Persian noble who held high office in the Mughal Empire, and the niece of Empress Nur Jahan, the chief wife of Emperor Jahangir and the power behind the emperor.",
    		search_term: "Mumtaz Mahal",
    		diameter: "38.2",
    		center_lat: 30.3,
    		center_long: 228.4
    	},
    	{
    		feature_id: 5330,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Sartika",
    		type: "Famous Woman",
    		origin: "Indonesia",
    		continent: "Asia",
    		clean_name: "Sartika",
    		description: "Ibu Dewi; Indonesian educator (1884-1942).",
    		bio: "Dewi Sartika (4 December 1884 – 11 September 1947) was an advocate for and pioneer of education for women in Indonesia. She founded the first school for women in the Dutch East Indies. She was honoured as a National Hero of Indonesia in 1966.",
    		search_term: "Dewi Sartika",
    		diameter: "18.7",
    		center_lat: -63.4,
    		center_long: 67
    	},
    	{
    		feature_id: 5488,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Shih Mai-Yu",
    		type: "Famous Woman",
    		origin: "China",
    		continent: "Asia",
    		clean_name: "Shih Mai-Yu",
    		description: "Chinese physician (1873-1954).",
    		bio: "Mary Stone (May 1, 1873 – 30 December 1954), also known as Shi Meiyu (Chinese: 石美玉), was a doctor of medicine graduated from the University of Michigan. She founded Danforth Memorial Hospital in Kiukiang (now called the Women and Children's Hospital of Jiujiang). Born to a Chinese Christian family in Kiukiang (now called Jiujiang) on May 1, 1873, Stone's father was a Methodist pastor and mother was the principal of a Methodist school for girls.",
    		search_term: "Mary Stone (doctor)",
    		diameter: "22.3",
    		center_lat: 18.4,
    		center_long: 318.9
    	},
    	{
    		feature_id: 6264,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Uvaysi",
    		type: "Famous Woman",
    		origin: "Uzbekistan",
    		continent: "Asia",
    		clean_name: "Uvaysi",
    		description: "Uzbek poet (c. 1780-c. 1850).",
    		bio: "Jahonotin Uvaysiy (1780–1845) was a Sufi poet from Margilon in the Ferghana Valley in Uzbekistan. She was an Otin-Oys, an Uzbek religious woman held in great esteem.She produced over 15,000 hemistiches of verse and it is still popular in Uzbekistan today. The Institute of the Academy of Science of the Republic of Uzbekistan in Tashkent has a collection of her works.",
    		search_term: "Jahonotin Uvaysiy",
    		diameter: "38.9",
    		center_lat: 2.3,
    		center_long: 198.3
    	},
    	{
    		feature_id: 6487,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Wang Zhenyi",
    		type: "Famous Woman",
    		origin: "China",
    		continent: "Asia",
    		clean_name: "Wang Zhenyi",
    		description: "Chinese astronomer, mathematician (18th century).",
    		bio: "Wang Zhenyi (simplified Chinese: 王贞仪; traditional Chinese: 王貞儀; pinyin: Wáng Zhēnyí; 1768–1797) was a scientist from the Qing dynasty. She breached the feudal customs of the time, which hindered women's rights, by working to educate herself in subjects such as astronomy, mathematics, geography, and medicine. She was well known for her contributions in astronomy, mathematics, and poetry.",
    		search_term: "Wang Zhenyi (astronomer)",
    		diameter: "23.4",
    		center_lat: 13.2,
    		center_long: 217.8
    	},
    	{
    		feature_id: 6517,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Wen Shu",
    		type: "Famous Woman",
    		origin: "China",
    		continent: "Asia",
    		clean_name: "Wen Shu",
    		description: "Chinese painter (1595-1634).",
    		bio: "Wen Shu or Wen Chu (Chinese: 文俶; 1595-1634) was a Chinese illustrator and painter who worked under the art name Hanshan and was known for her paintings of flora and small insects during the Ming dynasty. She is considered the finest flower painter of the period.Her work was popular at the time, and consistently sells well at auction. Her painting Rising Early in the Spring to Lament Flowers (1631) was sold at Christie's New York on 16 September 2015 for US$413,000, four times its estimate.",
    		search_term: "Wen Shu",
    		diameter: "31.5",
    		center_lat: -5,
    		center_long: 303.7
    	},
    	{
    		feature_id: 6585,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Wu Hou",
    		type: "Famous Woman",
    		origin: "China",
    		continent: "Asia",
    		clean_name: "Wu Hou",
    		description: "Original name Wu Zhao, also called Wu Zetian, Chinese empress (c.624-705).",
    		bio: "Wu Zetian (17 February 624 – 16 December 705), also known as Wu Zhao or Wu Hou, and during the later Tang dynasty as Tian Hou, was the de facto ruler of China from 665 to 705, ruling first through others and then (from 690) in her own right. From 665 to 690, she was first empress consort of the Tang dynasty (as wife of the Emperor Gaozong) and then, after his death, empress dowager (ruling through her sons Emperors Zhongzong and Ruizong), which had occurred before in China. Unprecedented in Chinese history, she subsequently ruled as empress regnant of the Wu Zhou dynasty of China from 690 to 705.",
    		search_term: "Wu Zetian",
    		diameter: "27.5",
    		center_lat: -25.5,
    		center_long: 317.4
    	},
    	{
    		feature_id: 6674,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Yoshioka",
    		type: "Famous Woman",
    		origin: "Japan",
    		continent: "Asia",
    		clean_name: "Yoshioka",
    		description: "Yayoi; Japanese physician, college founder (c. 1871-1959).",
    		bio: "Yoshioka Yayoi (吉岡 彌生, April 29, 1871 – May 22, 1959) was a Japanese physician, educator, and women's rights activist. She founded the Tokyo Women's Medical University in 1900, as the first medical school for women in Japan. She was also known as Washiyama Yayoi.",
    		search_term: "Yayoi Yoshioka",
    		diameter: "16.6",
    		center_lat: -32.4,
    		center_long: 59
    	},
    	{
    		feature_id: 6718,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Zenobia",
    		type: "Famous Woman",
    		origin: "Syria",
    		continent: "Asia",
    		clean_name: "Zenobia",
    		description: "Queen of Palmyra (Syria) (third century A.D.).",
    		bio: "Septimia Zenobia (Palmyrene: 𐡡𐡶𐡦𐡡𐡩‎ : BTZBY, vocalized as Bat-Zabbai; c. AD 240 – c. 274) was a third-century queen of the Palmyrene Empire in Syria.",
    		search_term: "Zenobia",
    		diameter: "39.1",
    		center_lat: -29.3,
    		center_long: 28.6
    	},
    	{
    		feature_id: 17,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Abigail",
    		type: "First Name",
    		origin: "Hebrew",
    		continent: "Asia",
    		clean_name: "Abigail",
    		description: "First name from Hebrew.",
    		bio: "",
    		search_term: "",
    		diameter: "18.4",
    		center_lat: -52.2,
    		center_long: 111.2
    	},
    	{
    		feature_id: 43,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Adaiah",
    		type: "First Name",
    		origin: "Hebrew",
    		continent: "Asia",
    		clean_name: "Adaiah",
    		description: "Hebrew first name.",
    		bio: "",
    		search_term: "",
    		diameter: "18.0",
    		center_lat: -47.3,
    		center_long: 253.4
    	},
    	{
    		feature_id: 194,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Alma",
    		type: "First Name",
    		origin: "Kazakhstan",
    		continent: "Asia",
    		clean_name: "Alma",
    		description: "Kazakh first name.",
    		bio: "",
    		search_term: "",
    		diameter: "16.8",
    		center_lat: -2.4,
    		center_long: 228.8
    	},
    	{
    		feature_id: 1471,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Delilah",
    		type: "First Name",
    		origin: "Hebrew",
    		continent: "Asia",
    		clean_name: "Delilah",
    		description: "First name from Hebrew.",
    		bio: "",
    		search_term: "",
    		diameter: "18.5",
    		center_lat: -57.9,
    		center_long: 250.2
    	},
    	{
    		feature_id: 1513,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Devorah",
    		type: "First Name",
    		origin: "Hebrew",
    		continent: "Asia",
    		clean_name: "Devorah",
    		description: "Hebrew first name.",
    		bio: "",
    		search_term: "",
    		diameter: "4.8",
    		center_lat: -22.5,
    		center_long: 343.4
    	},
    	{
    		feature_id: 1537,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Dinah",
    		type: "First Name",
    		origin: "Hebrew",
    		continent: "Asia",
    		clean_name: "Dinah",
    		description: "Hebrew first name.",
    		bio: "",
    		search_term: "",
    		diameter: "15.6",
    		center_lat: -62.9,
    		center_long: 37.1
    	},
    	{
    		feature_id: 1854,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Esther",
    		type: "First Name",
    		origin: "Persian",
    		continent: "Asia",
    		clean_name: "Esther",
    		description: "First name from Persian.",
    		bio: "",
    		search_term: "",
    		diameter: "17.6",
    		center_lat: 19.4,
    		center_long: 21.8
    	},
    	{
    		feature_id: 2037,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Fukiko",
    		type: "First Name",
    		origin: "Japan",
    		continent: "Asia",
    		clean_name: "Fukiko",
    		description: "Japanese first name.",
    		bio: "",
    		search_term: "",
    		diameter: "13.9",
    		center_lat: -23.1,
    		center_long: 105.8
    	},
    	{
    		feature_id: 2050,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Gabriela",
    		type: "First Name",
    		origin: "Hebrew",
    		continent: "Asia",
    		clean_name: "Gabriela",
    		description: "First name from Hebrew.",
    		bio: "",
    		search_term: "",
    		diameter: "17.5",
    		center_lat: -17.8,
    		center_long: 240.4
    	},
    	{
    		feature_id: 2349,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Hannah",
    		type: "First Name",
    		origin: "Hebrew",
    		continent: "Asia",
    		clean_name: "Hannah",
    		description: "First name from Hebrew.",
    		bio: "",
    		search_term: "",
    		diameter: "19.8",
    		center_lat: 17.9,
    		center_long: 102.6
    	},
    	{
    		feature_id: 2725,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Isako",
    		type: "First Name",
    		origin: "Japan",
    		continent: "Asia",
    		clean_name: "Isako",
    		description: "Japanese first name.",
    		bio: "",
    		search_term: "",
    		diameter: "13.5",
    		center_lat: -9,
    		center_long: 278
    	},
    	{
    		feature_id: 2823,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Jerusha",
    		type: "First Name",
    		origin: "Hebrew",
    		continent: "Asia",
    		clean_name: "Jerusha",
    		description: "Hebrew first name.",
    		bio: "",
    		search_term: "",
    		diameter: "17.2",
    		center_lat: -22,
    		center_long: 342.7
    	},
    	{
    		feature_id: 2834,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Johanna",
    		type: "First Name",
    		origin: "Hebrew",
    		continent: "Asia",
    		clean_name: "Johanna",
    		description: "Hebrew first name.",
    		bio: "",
    		search_term: "",
    		diameter: "15.1",
    		center_lat: 19.5,
    		center_long: 247.3
    	},
    	{
    		feature_id: 2854,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Judith",
    		type: "First Name",
    		origin: "Hebrew",
    		continent: "Asia",
    		clean_name: "Judith",
    		description: "Hebrew first name.",
    		bio: "",
    		search_term: "",
    		diameter: "16.6",
    		center_lat: -29.1,
    		center_long: 104.5
    	},
    	{
    		feature_id: 2894,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Kala",
    		type: "First Name",
    		origin: "Siberia",
    		continent: "Asia",
    		clean_name: "Kala",
    		description: "Koryak (Kamchatka) first name.",
    		bio: "",
    		search_term: "",
    		diameter: "17.4",
    		center_lat: 1.5,
    		center_long: 314.4
    	},
    	{
    		feature_id: 3007,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Khelifa",
    		type: "First Name",
    		origin: "Arabian",
    		continent: "Asia",
    		clean_name: "Khelifa",
    		description: "Arabic first name.",
    		bio: "",
    		search_term: "",
    		diameter: "10.8",
    		center_lat: -1.5,
    		center_long: 129.9
    	},
    	{
    		feature_id: 3315,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Leah",
    		type: "First Name",
    		origin: "Hebrew",
    		continent: "Asia",
    		clean_name: "Leah",
    		description: "Hebrew first name.",
    		bio: "",
    		search_term: "",
    		diameter: "12.0",
    		center_lat: -34.2,
    		center_long: 187.8
    	},
    	{
    		feature_id: 3401,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Lilian",
    		type: "First Name",
    		origin: "Hebrew",
    		continent: "Asia",
    		clean_name: "Lilian",
    		description: "First name from Hebrew.",
    		bio: "",
    		search_term: "",
    		diameter: "13.5",
    		center_lat: 25.6,
    		center_long: 336
    	},
    	{
    		feature_id: 3548,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Maa-Ling",
    		type: "First Name",
    		origin: "China",
    		continent: "Asia",
    		clean_name: "Maa-Ling",
    		description: "Chinese first name.",
    		bio: "",
    		search_term: "",
    		diameter: "6.0",
    		center_lat: -14.7,
    		center_long: 359.5
    	},
    	{
    		feature_id: 3733,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Marzhan",
    		type: "First Name",
    		origin: "Uzbekistan",
    		continent: "Asia",
    		clean_name: "Marzhan",
    		description: "Karakal first name.",
    		bio: "",
    		search_term: "",
    		diameter: "13.8",
    		center_lat: -58.9,
    		center_long: 248.3
    	},
    	{
    		feature_id: 3921,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Miriam",
    		type: "First Name",
    		origin: "Hebrew",
    		continent: "Asia",
    		clean_name: "Miriam",
    		description: "First name from Hebrew.",
    		bio: "",
    		search_term: "",
    		diameter: "16.5",
    		center_lat: 36.5,
    		center_long: 48.2
    	},
    	{
    		feature_id: 4147,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Naomi",
    		type: "First Name",
    		origin: "Hebrew",
    		continent: "Asia",
    		clean_name: "Naomi",
    		description: "First name from Hebrew.",
    		bio: "",
    		search_term: "",
    		diameter: "17.5",
    		center_lat: 6,
    		center_long: 70.3
    	},
    	{
    		feature_id: 4335,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Noriko",
    		type: "First Name",
    		origin: "Japan",
    		continent: "Asia",
    		clean_name: "Noriko",
    		description: "Japanese first name.",
    		bio: "",
    		search_term: "",
    		diameter: "7.5",
    		center_lat: -5.3,
    		center_long: 358.3
    	},
    	{
    		feature_id: 4914,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Rachel",
    		type: "First Name",
    		origin: "Hebrew",
    		continent: "Asia",
    		clean_name: "Rachel",
    		description: "First name from Hebrew.",
    		bio: "",
    		search_term: "",
    		diameter: "12.5",
    		center_lat: -48.7,
    		center_long: 13.5
    	},
    	{
    		feature_id: 5321,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Sarah",
    		type: "First Name",
    		origin: "Hebrew",
    		continent: "Asia",
    		clean_name: "Sarah",
    		description: "Hebrew first name.",
    		bio: "",
    		search_term: "",
    		diameter: "18.5",
    		center_lat: -42.4,
    		center_long: 1.8
    	},
    	{
    		feature_id: 5777,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Susanna",
    		type: "First Name",
    		origin: "Hebrew",
    		continent: "Asia",
    		clean_name: "Susanna",
    		description: "First name from Hebrew.",
    		bio: "",
    		search_term: "",
    		diameter: "13.3",
    		center_lat: 6,
    		center_long: 93.3
    	},
    	{
    		feature_id: 6329,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Vashti",
    		type: "First Name",
    		origin: "Persian",
    		continent: "Asia",
    		clean_name: "Vashti",
    		description: "Persian first name.",
    		bio: "",
    		search_term: "",
    		diameter: "17.0",
    		center_lat: -6.8,
    		center_long: 43.7
    	},
    	{
    		feature_id: 153,
    		year: 1994,
    		feature: "Unda",
    		feature_plural: "Undae",
    		name: "Al-Uzza Undae",
    		type: "Goddess",
    		origin: "Arabian",
    		continent: "Asia",
    		clean_name: "Al-Uzza",
    		description: "Arabian desert goddess.",
    		bio: "Al-ʻUzzā was one of the three chief goddesses of Arabian religion in pre-Islamic times and she was worshiped by the pre-Islamic Arabs along with al-Lāt and Manāt. A stone cube at Nakhla (near Mecca) was held sacred as part of her cult. She is mentioned in Qur'an 53:19 as being one of the goddesses who people worshiped.",
    		search_term: "Al-Uzza ",
    		diameter: "150.0",
    		center_lat: 67.7,
    		center_long: 90.5
    	},
    	{
    		feature_id: 192,
    		year: 1994,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Allatu Corona",
    		type: "Goddess",
    		origin: "Akkadian (Accadian)",
    		continent: "Asia",
    		clean_name: "Allatu",
    		description: "Akkadian earth goddess.",
    		bio: "Allani, also known under the Akkadian name Allatu (or Allatum) was the Hurrian goddess of the underworld, incorporated into Hittite and Mesopotamian pantheons as well. The name Allani is derived from a Hurrian word meaning 'lady.' Giving gods simple epithet-like names like Allani or Shaushka ('the great') was common in Hurrian culture.",
    		search_term: "Allani",
    		diameter: "125.0",
    		center_lat: 15.5,
    		center_long: 114
    	},
    	{
    		feature_id: 282,
    		year: 1994,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Annapurna Corona",
    		type: "Goddess",
    		origin: "India",
    		continent: "Asia",
    		clean_name: "Annapurna",
    		description: "Indian goddess of wealth.",
    		bio: "Annapurna is a manifestation of Parvati and is known as the Hindu Goddess of food and nourishment. The Agamas (religious texts) describe the iconography of Annapoorna as a youthful goddess having red complexion with a face round like the full moon, three eyes, high breasts, and four hands. The lower left hand is depicted as holding a vessel full of delicious porridge. The right hand with a golden ladle adorned with various jewels.",
    		search_term: "Annapurna (goddess)",
    		diameter: "300.0",
    		center_lat: -35.5,
    		center_long: 152
    	},
    	{
    		feature_id: 340,
    		year: 1994,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Aramaiti Corona",
    		type: "Goddess",
    		origin: "Persian",
    		continent: "Asia",
    		clean_name: "Aramaiti",
    		description: "Persian fertility goddess.",
    		bio: "In Zoroastrianism, Spənta Ārmaiti is one of the Amesha Spentas, the seven divine manifestations of Wisdom and Ahura Mazda. She is associated with earth and sacred literature describes her role as a Mother Nature character. Thus, she is linked to fertility and to farmers. She is also associated with the dead.",
    		search_term: "Spenta Armaiti",
    		diameter: "350.0",
    		center_lat: -26.3,
    		center_long: 82
    	},
    	{
    		feature_id: 409,
    		year: 1994,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Aruru Corona",
    		type: "Goddess",
    		origin: "Sumerian",
    		continent: "Asia",
    		clean_name: "Aruru",
    		description: "Sumerian earth goddess.",
    		bio: "Aruru was a Mesopotamian goddess. The origin of her name is presently uncertain. While initially considered an independent deity associated with vegetation and portrayed in hymns as violent, she eventually came to be viewed as analogous Ninhursag.",
    		search_term: "Aruru (goddess)",
    		diameter: "450.0",
    		center_lat: 9,
    		center_long: 262
    	},
    	{
    		feature_id: 424,
    		year: 1994,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Ashnan Corona",
    		type: "Goddess",
    		origin: "Sumerian",
    		continent: "Asia",
    		clean_name: "Ashnan",
    		description: "Sumerian harvest goddess.",
    		bio: "Ashnan or Ezina was a Mesopotamian goddess considered to be the personification of grain. The debate poem \"Debate between Sheep and Grain\" involves Ashnan arguing with Laḫar, a sheep deity, over which of them is more important.",
    		search_term: "Ashnan",
    		diameter: "300.0",
    		center_lat: 50.2,
    		center_long: 357
    	},
    	{
    		feature_id: 449,
    		year: 1994,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Atargatis Corona",
    		type: "Goddess",
    		origin: "Turkey",
    		continent: "Asia",
    		clean_name: "Atargatis",
    		description: "Hittite fertility goddess.",
    		bio: "Atargatis was the chief goddess of northern Syria in Classical antiquity. Primarily she was a fertility goddess, but, as the baalat ('mistress') of her city and people she was also responsible for their protection and well-being.",
    		search_term: "Atargatis",
    		diameter: "360.0",
    		center_lat: -8,
    		center_long: 8.6
    	},
    	{
    		feature_id: 668,
    		year: 1994,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Belet-Ili Corona",
    		type: "Goddess",
    		origin: "Assyro-Babylonian",
    		continent: "Asia",
    		clean_name: "Belet-Ili",
    		description: "Mesopotamian nature/fertility goddess.",
    		bio: "Ninḫursaĝ (also known as Belet-Ili) was the ancient Sumerian mother goddess of the mountains, and one of the seven great deities of Sumer. She is known earliest as a nurturing or fertility goddess. Temple hymn sources identify her as the \"true and great lady of heaven\" (possibly in relation to her standing on the mountain) and kings of Lagash were \"nourished by Ninhursag's milk\".",
    		search_term: "Belet-Ili",
    		diameter: "300.0",
    		center_lat: 6,
    		center_long: 20
    	},
    	{
    		feature_id: 692,
    		year: 1994,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Benten Corona",
    		type: "Goddess",
    		origin: "Japan",
    		continent: "Asia",
    		clean_name: "Benten",
    		description: "Japanese love/fertility goddess.",
    		bio: "Benzaiten, also simply known as Benten, is a Japanese Buddhist goddess who originated mainly from Saraswati, the Hindu goddess of speech, the arts, and learning, with certain traits deriving from the warrior goddess Durga. Apart from being a patron of music and the arts, she was eventually also worshiped as a bestower of monetary fortune and was reckoned as one of the Seven Lucky Gods (Shichifukujin).",
    		search_term: "Benten",
    		diameter: "310.0",
    		center_lat: 16,
    		center_long: 340
    	},
    	{
    		feature_id: 714,
    		year: 1994,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Beruth Corona",
    		type: "Goddess",
    		origin: "Phoenician",
    		continent: "Asia",
    		clean_name: "Beruth",
    		description: "Phoenician earth goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "350.0",
    		center_lat: -19,
    		center_long: 233.5
    	},
    	{
    		feature_id: 731,
    		year: 1994,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Bhumidevi Corona",
    		type: "Goddess",
    		origin: "India",
    		continent: "Asia",
    		clean_name: "Bhumidevi",
    		description: "Hindu earth goddess.",
    		bio: "Bhumi (Sanskrit: भूमि, romanized: Bhūmi), also known as Bhudevi and Vasundhara, is a Hindu goddess who is the personification of the Earth. She is a consort of the god Vishnu. According to Vaishnava tradition, she is the second aspect of Vishnu's consort, Lakshmi, along with the aspects of Sridevi and Niladevi.",
    		search_term: "Bhumidevi",
    		diameter: "150.0",
    		center_lat: -17.2,
    		center_long: 343.6
    	},
    	{
    		feature_id: 732,
    		year: 1994,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Bhumiya Corona",
    		type: "Goddess",
    		origin: "India",
    		continent: "Asia",
    		clean_name: "Bhumiya",
    		description: "Hindu earth goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "100.0",
    		center_lat: 15,
    		center_long: 118
    	},
    	{
    		feature_id: 1180,
    		year: 1994,
    		feature: "Dorsum",
    		feature_plural: "Dorsa",
    		name: "Chih Nu Dorsum",
    		type: "Goddess",
    		origin: "China",
    		continent: "Asia",
    		clean_name: "Chih Nu",
    		description: "Chinese sky goddess.",
    		bio: "The Cowherd and the Weaver Girl",
    		search_term: "Chih Nu",
    		diameter: "625.0",
    		center_lat: -73,
    		center_long: 195
    	},
    	{
    		feature_id: 1187,
    		year: 1994,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Chiun Corona",
    		type: "Goddess",
    		origin: "Hebrew",
    		continent: "Asia",
    		clean_name: "Chiun",
    		description: "Hebrew fertility goddess.",
    		bio: "Remphan was the subject of idolatrous worship mentioned by Stephen at the time of his death in the New Testament Book of Acts 7:43. It is presumed by Biblical scholars to be the same as Kiyyun or Chiun (Hebrew: כִּיּוּן), mentioned in Amos 5:26.",
    		search_term: "Chiun",
    		diameter: "150.0",
    		center_lat: 18.3,
    		center_long: 340.5
    	},
    	{
    		feature_id: 1360,
    		year: 1994,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Cybele Corona",
    		type: "Goddess",
    		origin: "Turkey",
    		continent: "Asia",
    		clean_name: "Cybele",
    		description: "Phrygian fertility goddess.",
    		bio: "Cybele is an Anatolian mother goddess; she may have a possible forerunner in the earliest neolithic at Çatalhöyük, where statues of plump women, sometimes sitting, accompanied by lionesses, have been found in excavations. Phrygia's only known goddess, she was probably its national deity. Greek colonists in Asia Minor adopted and adapted her Phrygian cult and spread it to mainland Greece and to the more distant western Greek colonies around the 6th century BC. In Greece, Cybele met with a mixed reception.",
    		search_term: "Cybele",
    		diameter: "500.0",
    		center_lat: -7.5,
    		center_long: 20.7
    	},
    	{
    		feature_id: 1411,
    		year: 1994,
    		feature: "Fluctus",
    		feature_plural: "Fluctūs",
    		name: "Darago Fluctus",
    		type: "Goddess",
    		origin: "Philippines",
    		continent: "Asia",
    		clean_name: "Darago",
    		description: "Philippine volcano goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "775.0",
    		center_lat: -11.5,
    		center_long: 313.5
    	},
    	{
    		feature_id: 1518,
    		year: 1994,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Dhisana Corona",
    		type: "Goddess",
    		origin: "India",
    		continent: "Asia",
    		clean_name: "Dhisana",
    		description: "Vedic goddess of plenty.",
    		bio: "Dhisana is one of the Hindu goddess of prosperity in Hinduism. She had also been mentioned as the goddess of fire, sun, moon and stars. As per the other Hindu texts, Dhisana also referrs to various other things such as knowledge, intelligence, and speech.",
    		search_term: "Dhisana",
    		diameter: "100.0",
    		center_lat: 14.5,
    		center_long: 111.7
    	},
    	{
    		feature_id: 1823,
    		year: 1994,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Ereshkigal Corona",
    		type: "Goddess",
    		origin: "Assyro-Babylonian",
    		continent: "Asia",
    		clean_name: "Ereshkigal",
    		description: "Mesopotamian nature/fertility goddess.",
    		bio: "In Mesopotamian mythology, Ereshkigal was the goddess of Kur, the land of the dead or underworld in Sumerian mythology. In later myths, she was said to rule Irkalla alongside her husband Nergal.",
    		search_term: "Ereshkigal",
    		diameter: "320.0",
    		center_lat: 21,
    		center_long: 84.5
    	},
    	{
    		feature_id: 1885,
    		year: 1994,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Eve Corona",
    		type: "Goddess",
    		origin: "Hebrew",
    		continent: "Asia",
    		clean_name: "Eve",
    		description: "Hebrew first name; name changed from Eve (crater).",
    		bio: "Eve is a figure in the Book of Genesis in the Hebrew Bible. According to the origin story of the Abrahamic religions, she was the first woman, yet some debate within Judaism has also given that position to Lilith. Eve is known also as Adam's wife.",
    		search_term: "Eve",
    		diameter: "330.0",
    		center_lat: -32,
    		center_long: 359.8
    	},
    	{
    		feature_id: 2448,
    		year: 1994,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Heng-o Corona",
    		type: "Goddess",
    		origin: "China",
    		continent: "Asia",
    		clean_name: "Heng-o",
    		description: "Named for associated chasma.",
    		bio: "",
    		search_term: "",
    		diameter: "1,060.0",
    		center_lat: 2,
    		center_long: 355
    	},
    	{
    		feature_id: 2456,
    		year: 1994,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Hepat Corona",
    		type: "Goddess",
    		origin: "Turkey",
    		continent: "Asia",
    		clean_name: "Hepat",
    		description: "Hittite mother goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "150.0",
    		center_lat: -2,
    		center_long: 145.5
    	},
    	{
    		feature_id: 2684,
    		year: 1994,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Inari Corona",
    		type: "Goddess",
    		origin: "Japan",
    		continent: "Asia",
    		clean_name: "Inari",
    		description: "Japanese rice goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "300.0",
    		center_lat: -18,
    		center_long: 120.3
    	},
    	{
    		feature_id: 2687,
    		year: 1994,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Indrani Corona",
    		type: "Goddess",
    		origin: "India",
    		continent: "Asia",
    		clean_name: "Indrani",
    		description: "Hindu fertility goddess.",
    		bio: "Indrani, also known as Shachi, is the queen of the devas in Hinduism. Described as tantalisingly beautiful, proud and kind, she is the daughter of the asura Puloman and the consort of the king of the devas, Indra.",
    		search_term: "Indrani",
    		diameter: "200.0",
    		center_lat: -37.5,
    		center_long: 70.5
    	},
    	{
    		feature_id: 2903,
    		year: 1994,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Kamadhenu Corona",
    		type: "Goddess",
    		origin: "India",
    		continent: "Asia",
    		clean_name: "Kamadhenu",
    		description: "Hindu goddess of plenty.",
    		bio: "Kamadhenu, also known as Surabhi, is a divine bovine-goddess described in Hinduism as the mother of all cows. She is a miraculous cow of plenty who provides her owner whatever he desires and is often portrayed as the mother of other cattle. In iconography, she is generally depicted as a white cow with a female head and breasts, the wings of a bird, and the tail of a peafowl or as a white cow containing various deities within her body.",
    		search_term: "Kamadhenu",
    		diameter: "400.0",
    		center_lat: 21,
    		center_long: 136.5
    	},
    	{
    		feature_id: 2970,
    		year: 1994,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Kayanu-Hime Corona",
    		type: "Goddess",
    		origin: "Japan",
    		continent: "Asia",
    		clean_name: "Kayanu-Hime",
    		description: "Shinto grain goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "150.0",
    		center_lat: 33.5,
    		center_long: 57
    	},
    	{
    		feature_id: 3015,
    		year: 1994,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Khotun Corona",
    		type: "Goddess",
    		origin: "Yakutian",
    		continent: "Asia",
    		clean_name: "Khotun",
    		description: "Yakut goddess of plenty.",
    		bio: "",
    		search_term: "",
    		diameter: "200.0",
    		center_lat: -46.5,
    		center_long: 81.5
    	},
    	{
    		feature_id: 3132,
    		year: 1994,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Kuan-Yin Corona",
    		type: "Goddess",
    		origin: "China",
    		continent: "Asia",
    		clean_name: "Kuan-Yin",
    		description: "Chinese fertility goddess.",
    		bio: "Guanyin is a Bodhisattva associated with compassion. Some Buddhists believe that when one of their adherents departs from this world, they are placed by Guanyin in the heart of a lotus, and then sent to the western pure land of Sukhāvatī.",
    		search_term: "Kuan-Yin",
    		diameter: "310.0",
    		center_lat: -4.3,
    		center_long: 10
    	},
    	{
    		feature_id: 3135,
    		year: 1994,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Kubebe Corona",
    		type: "Goddess",
    		origin: "Turkey",
    		continent: "Asia",
    		clean_name: "Kubebe",
    		description: "Hittite mother earth goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "125.0",
    		center_lat: 15.5,
    		center_long: 132.5
    	},
    	{
    		feature_id: 3404,
    		year: 1994,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Lilwani Corona",
    		type: "Goddess",
    		origin: "Turkey",
    		continent: "Asia",
    		clean_name: "Lilwani",
    		description: "Hittite earth goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "500.0",
    		center_lat: -29.5,
    		center_long: 271.5
    	},
    	{
    		feature_id: 3436,
    		year: 1994,
    		feature: "Vallis",
    		feature_plural: "Valles",
    		name: "Lo Shen Valles",
    		type: "Goddess",
    		origin: "China",
    		continent: "Asia",
    		clean_name: "Lo Shen",
    		description: "Chinese river goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "225.0",
    		center_lat: -12.8,
    		center_long: 89.6
    	},
    	{
    		feature_id: 3600,
    		year: 1994,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Makh Corona",
    		type: "Goddess",
    		origin: "Assyro-Babylonian",
    		continent: "Asia",
    		clean_name: "Makh",
    		description: "Assyro-Babylonian goddess of fecundity.",
    		bio: "",
    		search_term: "",
    		diameter: "200.0",
    		center_lat: -48.7,
    		center_long: 85
    	},
    	{
    		feature_id: 3768,
    		year: 1994,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Maya Corona",
    		type: "Goddess",
    		origin: "India",
    		continent: "Asia",
    		clean_name: "Maya",
    		description: "Hindu mother earth goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "225.0",
    		center_lat: 23,
    		center_long: 98
    	},
    	{
    		feature_id: 3834,
    		year: 1994,
    		feature: "Unda",
    		feature_plural: "Undae",
    		name: "Menat Undae",
    		type: "Goddess",
    		origin: "Arabian",
    		continent: "Asia",
    		clean_name: "Menat",
    		description: "Arabian desert goddess.",
    		bio: "Manāt (Arabic: مناة Arabic pronunciation: [maˈnaːh] pausa, [maˈnaːt] or Old Arabic manawat; also transliterated as manāh) was a pre-Islamic Arabian goddess worshiped in the Arabian Peninsula before the rise of Islam and the Islamic prophet Muhammad in the 7th century. She was among Mecca's three chief goddesses, alongside her sisters, Allat and Al-‘Uzzá, and among them, she was the original and the oldest.",
    		search_term: "Manat (goddess)",
    		diameter: "100.0",
    		center_lat: -24.8,
    		center_long: 339.4
    	},
    	{
    		feature_id: 4291,
    		year: 1994,
    		feature: "Fluctus",
    		feature_plural: "Fluctūs",
    		name: "Ningyo Fluctus",
    		type: "Goddess",
    		origin: "Japan",
    		continent: "Asia",
    		clean_name: "Ningyo",
    		description: "Japanese fish goddess.",
    		bio: "Ningyo is a creature with both human and fish-like features, described in various pieces of Japanese literature. Though often translated as \"mermaid\", the term is technically not gender-specific and may include the \"mermen\". One of the most famous folk stories involving ningyo (or rather the flesh of the human-fish), purports that a girl who ate it acquired everlasting youth and longevity, and became the nun Yao Bikuni, living to the age of 800 years.",
    		search_term: "Ningyo",
    		diameter: "970.0",
    		center_lat: -5.5,
    		center_long: 206
    	},
    	{
    		feature_id: 4292,
    		year: 1994,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Ninhursag Corona",
    		type: "Goddess",
    		origin: "Babylon",
    		continent: "Asia",
    		clean_name: "Ninhursag",
    		description: "Babylonian earth goddess.",
    		bio: "Ninḫursaĝ (also known as Belet-Ili) was the ancient Sumerian mother goddess of the mountains, and one of the seven great deities of Sumer. She is known earliest as a nurturing or fertility goddess. Temple hymn sources identify her as the \"true and great lady of heaven\" (possibly in relation to her standing on the mountain) and kings of Lagash were \"nourished by Ninhursag's milk\".",
    		search_term: "Ninhursag",
    		diameter: "125.0",
    		center_lat: -38,
    		center_long: 23.5
    	},
    	{
    		feature_id: 4300,
    		year: 1994,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Nintu Corona",
    		type: "Goddess",
    		origin: "Akkadian (Accadian)",
    		continent: "Asia",
    		clean_name: "Nintu",
    		description: "Akkadian earth goddess.",
    		bio: "Mami is a goddess in the Babylonian epic Atra-Hasis and in other creation legends. She was probably synonymous with Ninhursag. She was involved in the creation of humankind from clay and blood.",
    		search_term: "Nintu",
    		diameter: "75.0",
    		center_lat: 19.2,
    		center_long: 123.5
    	},
    	{
    		feature_id: 4311,
    		year: 1994,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Nishtigri Corona",
    		type: "Goddess",
    		origin: "India",
    		continent: "Asia",
    		clean_name: "Nishtigri",
    		description: "Hindu earth mother.",
    		bio: "",
    		search_term: "",
    		diameter: "275.0",
    		center_lat: -24.5,
    		center_long: 72
    	},
    	{
    		feature_id: 4312,
    		year: 1994,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Nissaba Corona",
    		type: "Goddess",
    		origin: "Mesopotamian",
    		continent: "Asia",
    		clean_name: "Nissaba",
    		description: "Mesopotamian wisdom/fetility goddess.",
    		bio: "Nisaba was the Mesopotamian goddess of writing and grain. She is one of the oldest Sumerian deities attested in writing, and remained prominent through many periods of Mesopotamian history. She was commonly worshiped by scribes, and numerous Sumerian texts end with the doxology \"praise to Nisaba\" as a result.",
    		search_term: "Nissaba",
    		diameter: "300.0",
    		center_lat: 25.5,
    		center_long: 355.5
    	},
    	{
    		feature_id: 4418,
    		year: 1994,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Ohogetsu Corona",
    		type: "Goddess",
    		origin: "Japan",
    		continent: "Asia",
    		clean_name: "Ohogetsu",
    		description: "Japanese food goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "175.0",
    		center_lat: -27,
    		center_long: 85.7
    	},
    	{
    		feature_id: 4530,
    		year: 1994,
    		feature: "Fluctus",
    		feature_plural: "Fluctūs",
    		name: "Ovda Fluctus",
    		type: "Goddess",
    		origin: "Mari",
    		continent: "Asia",
    		clean_name: "Ovda",
    		description: "Named from regio where feature is located.",
    		bio: "",
    		search_term: "",
    		diameter: "310.0",
    		center_lat: -6.1,
    		center_long: 95.5
    	},
    	{
    		feature_id: 4710,
    		year: 1994,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Phra Naret Corona",
    		type: "Goddess",
    		origin: "Thailand",
    		continent: "Asia",
    		clean_name: "Phra Naret",
    		description: "Thai fertility goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "150.0",
    		center_lat: -66.6,
    		center_long: 209.6
    	},
    	{
    		feature_id: 4871,
    		year: 1994,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Purandhi Corona",
    		type: "Goddess",
    		origin: "India",
    		continent: "Asia",
    		clean_name: "Purandhi",
    		description: "Hindu goddess of plenty.",
    		bio: "",
    		search_term: "",
    		diameter: "170.0",
    		center_lat: 26.1,
    		center_long: 343.5
    	},
    	{
    		feature_id: 5298,
    		year: 1994,
    		feature: "Vallis",
    		feature_plural: "Valles",
    		name: "Samundra Vallis",
    		type: "Goddess",
    		origin: "India",
    		continent: "Asia",
    		clean_name: "Samundra",
    		description: "Indian river goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "110.0",
    		center_lat: -24.1,
    		center_long: 347.1
    	},
    	{
    		feature_id: 5328,
    		year: 1994,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Sarpanitum Corona",
    		type: "Goddess",
    		origin: "Babylon",
    		continent: "Asia",
    		clean_name: "Sarpanitum",
    		description: "Babylonian fertility goddess.",
    		bio: "Sarpanit was the consort of Marduk, the main god of Babylon, and a goddess of birth. She was already attested as the wife of Marduk before his ascension to the top of the Mesopotamian pantheon, appearing in inscriptions of the Babylonian kings Sumulael and Samsu-iluna. Some researchers regard her simply as one of the \"prototypical divine wives.\"",
    		search_term: "Sarpanitum",
    		diameter: "170.0",
    		center_lat: -52.3,
    		center_long: 14.6
    	},
    	{
    		feature_id: 5432,
    		year: 1994,
    		feature: "Farrum",
    		feature_plural: "Farra",
    		name: "Seoritsu Farra",
    		type: "Goddess",
    		origin: "Japan",
    		continent: "Asia",
    		clean_name: "Seoritsu",
    		description: "Japanese stream goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "230.0",
    		center_lat: -30,
    		center_long: 11
    	},
    	{
    		feature_id: 5765,
    		year: 1994,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Sunrta Corona",
    		type: "Goddess",
    		origin: "India",
    		continent: "Asia",
    		clean_name: "Sunrta",
    		description: "Hindu fertility goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "170.0",
    		center_lat: 8.3,
    		center_long: 11.7
    	},
    	{
    		feature_id: 5824,
    		year: 1994,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Tai Shan Corona",
    		type: "Goddess",
    		origin: "China",
    		continent: "Asia",
    		clean_name: "Tai Shan",
    		description: "Chinese fertility goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "175.0",
    		center_lat: -32.5,
    		center_long: 95
    	},
    	{
    		feature_id: 5845,
    		year: 1994,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Tamiyo Corona",
    		type: "Goddess",
    		origin: "Japan",
    		continent: "Asia",
    		clean_name: "Tamiyo",
    		description: "Japanese goddess of abundance.",
    		bio: "",
    		search_term: "",
    		diameter: "400.0",
    		center_lat: -36,
    		center_long: 298.5
    	},
    	{
    		feature_id: 6072,
    		year: 1994,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Toyo-uke Corona",
    		type: "Goddess",
    		origin: "Japan",
    		continent: "Asia",
    		clean_name: "Toyo-uke",
    		description: "Shinto fertility goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "300.0",
    		center_lat: -62.5,
    		center_long: 41.5
    	},
    	{
    		feature_id: 6191,
    		year: 1994,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Ukemochi Corona",
    		type: "Goddess",
    		origin: "Japan",
    		continent: "Asia",
    		clean_name: "Ukemochi",
    		description: "Japanese fertility goddess.",
    		bio: "Ōgetsu-hime commonly known as Ukemochi, the daughter of the Shinto deities Izanagi and Izanami, is a goddess of food in the Shinto religion of Japan. In some differing interpretations, Ukemochi is referred to as both male and female. When shown in other forms, Ukemochi takes the shape of a fox.",
    		search_term: "Ukemochi",
    		diameter: "300.0",
    		center_lat: -39,
    		center_long: 296.1
    	},
    	{
    		feature_id: 6334,
    		year: 1994,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Vasudhara Corona",
    		type: "Goddess",
    		origin: "India",
    		continent: "Asia",
    		clean_name: "Vasudhara",
    		description: "Buddhist female Bodhisattva of abundance.",
    		bio: "Vasudhārā whose name means \"stream of gems\" in Sanskrit, is the Buddhist goddess of wealth, prosperity, and abundance. She is one of the most popular goddesses worshipped in many Buddhist countries and is a subject of Buddhist legends and art. Her popularity peaks in Nepal where she has a strong following among the Buddhist Newars of the Kathmandu Valley and is thus a central figure in Newar Buddhism.",
    		search_term: "Vasudhara",
    		diameter: "160.0",
    		center_lat: 43.2,
    		center_long: 2.7
    	},
    	{
    		feature_id: 584,
    		year: 1994,
    		feature: "Vallis",
    		feature_plural: "Valles",
    		name: "Baltis Vallis",
    		type: "Other",
    		origin: "Syria",
    		continent: "Asia",
    		clean_name: "Baltis ",
    		description: "Syrian word for planet Venus.",
    		bio: "",
    		search_term: "",
    		diameter: "6,000.0",
    		center_lat: 37.3,
    		center_long: 161.4
    	},
    	{
    		feature_id: 19,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Abington",
    		type: "Famous Woman",
    		origin: "England",
    		continent: "Europe",
    		clean_name: "Abington",
    		description: "Frances; English actress (1737-1815).",
    		bio: "Frances 'Fanny' Abington (1737 – 4 March 1815) was an English actress who was also known for her sense of fashion. Writer and politician Horace Walpole described her as one of the finest actors of their time, and Richard Brinsley Sheridan was said to have written the part of Lady Teazle in The School for Scandal for her to perform. She was born Frances Barton or Frances 'Fanny' Barton, as the daughter of a private soldier.",
    		search_term: "Frances Abington",
    		diameter: "21.7",
    		center_lat: -47.8,
    		center_long: 277.7
    	},
    	{
    		feature_id: 48,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Adamson",
    		type: "Famous Woman",
    		origin: "Austria",
    		continent: "Europe",
    		clean_name: "Adamson",
    		description: "Joy; Austrian author, animal expert (1910-1980).",
    		bio: "Friederike Victoria 'Joy' Adamson (née Gessner; 20 January 1910 – 3 January 1980) was a naturalist, artist and author. Her book, Born Free, describes her experiences raising a lion cub named Elsa. Born Free was printed in several languages, and made into an Academy Award-winning movie of the same name.",
    		search_term: "Joy Adamson",
    		diameter: "27.2",
    		center_lat: -14.8,
    		center_long: 29.6
    	},
    	{
    		feature_id: 70,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Aethelflaed",
    		type: "Famous Woman",
    		origin: "England",
    		continent: "Europe",
    		clean_name: "Aethelflaed",
    		description: "English leader of the Mercians (c. 884-918).",
    		bio: "Æthelflæd, Lady of the Mercians (c. 870 – 12 June 918) ruled Mercia in the English Midlands from 911 until her death. She was the eldest daughter of Alfred the Great, king of the Anglo-Saxon kingdom of Wessex, and his wife Ealhswith.",
    		search_term: "Æthelflæd",
    		diameter: "20.0",
    		center_lat: -18.2,
    		center_long: 196.6
    	},
    	{
    		feature_id: 138,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Aksentyeva",
    		type: "Famous Woman",
    		origin: "Soviet",
    		continent: "Europe",
    		clean_name: "Aksentyeva",
    		description: "Zinaida; Soviet geophysicist, astronomer (1900-1969).",
    		bio: "Zinaïda Mikolaïevna Aksentieva (Ukrainian: Зінаїда Миколаївна Аксентьєва; July 25, 1900 – April 8, 1969) was a Ukrainian/Soviet astronomer and geophysicist. She worked on mapping gravity and her observatory was one of the first to be able to accurately find the centre of the earth.",
    		search_term: "Zinaida Aksentyeva",
    		diameter: "42.5",
    		center_lat: -42,
    		center_long: 271.9
    	},
    	{
    		feature_id: 253,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Anaxandra",
    		type: "Famous Woman",
    		origin: "Greek",
    		continent: "Europe",
    		clean_name: "Anaxandra",
    		description: "Greek artist (fl. c. 228 B.C.).",
    		bio: "Anaxandra (Greek: Ἀναξάνδρα; fl. 220s BC) was an ancient Greek female artist and painter from Greece. She was the daughter and student of Nealkes, a painter of mythological and genre scenes.",
    		search_term: "Anaxandra",
    		diameter: "20.4",
    		center_lat: 44.2,
    		center_long: 162.3
    	},
    	{
    		feature_id: 263,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Andreianova",
    		type: "Famous Woman",
    		origin: "Russia",
    		continent: "Europe",
    		clean_name: "Andreianova",
    		description: "Elena; Russian ballerina (c. 1821-c. 1855).",
    		bio: "Elena Ivanovna Andreïanova, sometimes spelt Yelena Andreyanova (Russian Елена Ивановна Андреянова), 13 July 1819 St. Petersburg - 28 October 1857 Paris, was a Russian ballerina. She is considered to be the outstanding Russian ballerina of the romantic genre, but her life was one full of tragedy.",
    		search_term: "Elena Andreianova",
    		diameter: "66.1",
    		center_lat: -3,
    		center_long: 68.8
    	},
    	{
    		feature_id: 483,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Austen",
    		type: "Famous Woman",
    		origin: "England",
    		continent: "Europe",
    		clean_name: "Austen",
    		description: "Jane; English novelist (1775-1817).",
    		bio: "Jane Austen (; 16 December 1775 – 18 July 1817) was an English novelist known primarily for her six major novels, which interpret, critique, and comment upon the British landed gentry at the end of the 18th century. Austen's plots often explore the dependence of women on marriage in the pursuit of favourable social standing and economic security. Her works critique the novels of sensibility of the second half of the 18th century and are part of the transition to 19th-century literary realism.",
    		search_term: "Jane Austen",
    		diameter: "45.1",
    		center_lat: -25,
    		center_long: 168.4
    	},
    	{
    		feature_id: 522,
    		year: 1994,
    		feature: "Patera",
    		feature_plural: "Paterae",
    		name: "Ayrton Patera",
    		type: "Famous Woman",
    		origin: "England",
    		continent: "Europe",
    		clean_name: "Ayrton",
    		description: "Hertha M.; English physicist (1854-1923).",
    		bio: "",
    		search_term: "",
    		diameter: "85.0",
    		center_lat: 6,
    		center_long: 227.3
    	},
    	{
    		feature_id: 627,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Bashkirtseff",
    		type: "Famous Woman",
    		origin: "Russia",
    		continent: "Europe",
    		clean_name: "Bashkirtseff",
    		description: "Marie; Russian painter, diarist (c. 1859-1884).",
    		bio: "Marie Bashkirtseff (born Maria Konstantinovna Bashkirtseva, Russian: Мария Константиновна Башки́рцева; 1858–1884) was a Russian artist. From approximately the age of 13, Bashkirtseff kept a journal, and it is probably for this that she is most famous today. It has been called 'a strikingly modern psychological self-portrait of a young, gifted mind,' and her urgent prose, which occasionally breaks out into dialogue, remains extremely readable.",
    		search_term: "Marie Bashkirtseff",
    		diameter: "36.2",
    		center_lat: 14.7,
    		center_long: 194
    	},
    	{
    		feature_id: 699,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Berggolts",
    		type: "Famous Woman",
    		origin: "Russia",
    		continent: "Europe",
    		clean_name: "Berggolts",
    		description: "Olga; Russian poet (1910-1975).",
    		bio: "Olga Fyodorovna Bergholz (Russian: Ольга Фёдоровна Берггольц, IPA: [ˈolʲɡə ˈfʲɵdərəvnə bʲɪrˈɡolʲts] ; May 16 [O.S. May 3] 1910 – November 13, 1975) was a Soviet and Russian poet, writer, playwright and journalist. She is most famous for her work on the Leningrad radio during the city's blockade, when she became the symbol of city's strength and determination.",
    		search_term: "Olga Bergholz",
    		diameter: "29.5",
    		center_lat: -63.5,
    		center_long: 53
    	},
    	{
    		feature_id: 763,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Blackburne",
    		type: "Famous Woman",
    		origin: "England",
    		continent: "Europe",
    		clean_name: "Blackburne",
    		description: "Anna; English biologist (1726-1793).",
    		bio: "Anna Blackburne (1726 – 30 December 1793) was an English naturalist. Anna Blackburne was born at Orford Hall, Orford, Warrington, Lancashire, the daughter of John Blackburne and Jane (born Ashton). Her father was a wealthy Cheshire salt dealer, who studied natural history and had famous greenhouses admired by Thomas Pennant (1726–1798). Inspired by her father, she devoted herself to study natural history in a more systematic way.",
    		search_term: "Anna Blackburne",
    		diameter: "30.5",
    		center_lat: 11,
    		center_long: 183.9
    	},
    	{
    		feature_id: 799,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Boivin",
    		type: "Famous Woman",
    		origin: "France",
    		continent: "Europe",
    		clean_name: "Boivin",
    		description: "Marie; French medical researcher (1773-1847).",
    		bio: "Marie-Anne Victoire Gillain Boivin (9 April 1773 – 16 May 1841) was a French midwife, inventor, and obstetrics writer. Mme Boivin has been called one of the most important women in medicine in the 19th century. Boivin invented a new pelvimeter and a vaginal speculum, and the medical textbooks that she wrote were translated to different languages and used for 150 years.",
    		search_term: "Marie Boivin",
    		diameter: "20.4",
    		center_lat: 4.3,
    		center_long: 299.5
    	},
    	{
    		feature_id: 803,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Boleyn",
    		type: "Famous Woman",
    		origin: "England",
    		continent: "Europe",
    		clean_name: "Boleyn",
    		description: "Anne; English queen (1507-1536).",
    		bio: "Anne Boleyn (; c. 1501 or 1507 – 19 May 1536) was Queen of England from 1533 to 1536, as the second wife of King Henry VIII. The circumstances of her marriage and of her execution by beheading for treason and other charges made her a key figure in the political and religious upheaval that marked the start of the English Reformation.",
    		search_term: "Anne Boleyn",
    		diameter: "70.4",
    		center_lat: 24.4,
    		center_long: 220.1
    	},
    	{
    		feature_id: 850,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Boye",
    		type: "Famous Woman",
    		origin: "Sweden",
    		continent: "Europe",
    		clean_name: "Boye",
    		description: "Karen; Swedish poet, novelist (1900-1941).",
    		bio: "",
    		search_term: "",
    		diameter: "28.0",
    		center_lat: -9.6,
    		center_long: 292.3
    	},
    	{
    		feature_id: 912,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Bugoslavskaya",
    		type: "Famous Woman",
    		origin: "Soviet",
    		continent: "Europe",
    		clean_name: "Bugoslavskaya",
    		description: "Yevgenia; Soviet astronomer (1899-1960).",
    		bio: "Yevgenia Yakovlevna Bugoslavskaya (21 December 1899 – 30 May 1960) was a Soviet astronomer. She had a lifelong career in astronomy and became professor of astronomy at Moscow University.",
    		search_term: "Yevgenia Bugoslavskaya",
    		diameter: "29.9",
    		center_lat: -23,
    		center_long: 300.4
    	},
    	{
    		feature_id: 954,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Caccini",
    		type: "Famous Woman",
    		origin: "Italy",
    		continent: "Europe",
    		clean_name: "Caccini",
    		description: "Francesca; Italian poet, composer (c. 1581-c. 1640).",
    		bio: "Francesca Caccini ([franˈtʃeska katˈtʃiːni]; 18 September 1587 – after 1641) was an Italian composer, singer, lutenist, poet, and music teacher of the early Baroque era. She was also known by the nickname 'La Cecchina' [la tʃekˈkiːna], given to her by the Florentines and probably a diminutive of 'Francesca'. She was the daughter of Giulio Caccini.",
    		search_term: "Francesca Caccini",
    		diameter: "38.1",
    		center_lat: 17.4,
    		center_long: 170.4
    	},
    	{
    		feature_id: 1052,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Castro",
    		type: "Famous Woman",
    		origin: "Spain",
    		continent: "Europe",
    		clean_name: "Castro",
    		description: "Rosalie; Spanish poet, novelist (1837-1885).",
    		bio: "María Rosalía Rita de Castro (Galician pronunciation: [rosaˈli.ɐ ðɪ ˈkastɾʊ]; 23 February 1837 – 15 July 1885), was a Galician poet, strongly identified with her native Galicia and the celebration of the Galician language. Writing in Galician and Spanish, after the period known as the Séculos Escuros (lit. Dark Centuries), she became an important figure of the Galician Romantic movement, known today as the Rexurdimento ('Renaissance'), along with Manuel Curros Enríquez and Eduardo Pondal.",
    		search_term: "Rosalía de Castro",
    		diameter: "22.9",
    		center_lat: 3.4,
    		center_long: 233.9
    	},
    	{
    		feature_id: 1101,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Centlivre",
    		type: "Famous Woman",
    		origin: "England",
    		continent: "Europe",
    		clean_name: "Centlivre",
    		description: "Susannah; English actress, playwright (c. 1667-1723).",
    		bio: "Susanna Centlivre (c. 1669 (baptised) – 1 December 1723), born Susanna Freeman and also known professionally as Susanna Carroll, was an English poet, actress, and 'the most successful female playwright of the eighteenth century'. Centlivre's 'pieces continued to be acted after the theatre managers had forgotten most of her contemporaries.' During a long career at the Theatre Royal, Drury Lane, she became known as the second woman of the English stage, after Aphra Behn.",
    		search_term: "Susannah Centlivre",
    		diameter: "28.8",
    		center_lat: 19.1,
    		center_long: 290.4
    	},
    	{
    		feature_id: 1290,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Conway",
    		type: "Famous Woman",
    		origin: "England",
    		continent: "Europe",
    		clean_name: "Conway",
    		description: "Anne Finch; English natural scientist (1631-1679).",
    		bio: "Anne Conway (also known as Viscountess Conway; née Finch; 14 December 1631 – 23 February 1679) was an English philosopher whose work, in the tradition of the Cambridge Platonists, was an influence on Gottfried Leibniz. Conway's thought is a deeply original form of rationalist philosophy, with hallmarks of gynocentric concerns and patterns that lead some to think of it as unique among seventeenth-century systems.",
    		search_term: "Anne Finch Conway",
    		diameter: "49.3",
    		center_lat: 48.3,
    		center_long: 39
    	},
    	{
    		feature_id: 1311,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Corinna",
    		type: "Famous Woman",
    		origin: "Greek",
    		continent: "Europe",
    		clean_name: "Corinna",
    		description: "Greek poet (fl. c. 490 B.C.).",
    		bio: "Corinna or Korinna (Ancient Greek: Κόριννα, romanized: Korinna) was an ancient Greek lyric poet from Tanagra in Boeotia. Corinna's works survive only in fragments, focus on local Boeotian legends, and are distinctive for their mythological innovations. Though respected in her hometown, Tanagra, and popular in ancient Rome, modern critics have often regarded her as parochial and dull; her poetry is nonetheless of interest as she is one of the few female poets from ancient Greece whose work survives.",
    		search_term: "Corinna",
    		diameter: "19.2",
    		center_lat: 22.9,
    		center_long: 40.6
    	},
    	{
    		feature_id: 1317,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Corpman",
    		type: "Famous Woman",
    		origin: "Poland",
    		continent: "Europe",
    		clean_name: "Corpman",
    		description: "Elizabeth; Polish astronomer, wife of Hevelius (17th century).",
    		bio: "Elisabeth Catherina Koopmann-Hevelius (in Polish called Elżbieta Heweliusz; January 17, 1647–December 22, 1693) is considered one of the first female astronomers. Originally from Danzig, Poland, she contributed to improve the work and observations done together with her husband Johannes Hevelius. Elisabeth Koopmann (or Kaufmann, German: 'merchant') was, like Hevelius and his first wife, a member of a rich merchant family in the city of Danzig (Gdańsk) located in Pomeranian Voivodeship of the Polish–Lithuanian Commonwealth and a member of the trade organisation called Hansa.",
    		search_term: "Elisabeth Hevelius",
    		diameter: "46.0",
    		center_lat: 0.3,
    		center_long: 151.8
    	},
    	{
    		feature_id: 1318,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Cortese",
    		type: "Famous Woman",
    		origin: "Italy",
    		continent: "Europe",
    		clean_name: "Cortese",
    		description: "Isabella; Italian physician, medical writer (d. 1561).",
    		bio: "Isabella Cortese (fl. 1561), was an Italian alchemist and writer of the Renaissance. All that is known of her life and work is from her book on alchemy, The Secrets of Lady Isabella Cortese.",
    		search_term: "Isabella Cortese",
    		diameter: "27.7",
    		center_lat: -11.4,
    		center_long: 218.4
    	},
    	{
    		feature_id: 1698,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "d'Este",
    		type: "Famous Woman",
    		origin: "Italy",
    		continent: "Europe",
    		clean_name: "d'Este",
    		description: "Isabella; Italian archaeologist, businesswoman (1474-1539).",
    		bio: "Isabella d'Este (19 May 1474 – 13 February 1539) was Marchioness of Mantua and one of the leading women of the Italian Renaissance as a major cultural and political figure. She was a patron of the arts as well as a leader of fashion, whose innovative style of dressing was copied by numerous women. The poet Ariosto labeled her as the 'liberal and magnanimous Isabella', while author Matteo Bandello described her as having been 'supreme among women'.",
    		search_term: "Isabella d'Este",
    		diameter: "21.6",
    		center_lat: -34.3,
    		center_long: 238.9
    	},
    	{
    		feature_id: 1434,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "de Ayala",
    		type: "Famous Woman",
    		origin: "Spain",
    		continent: "Europe",
    		clean_name: "de Ayala",
    		description: "Josefa; Spanish painter (1630-1684).",
    		bio: "Josefa de Óbidos (Portuguese: [ʒuˈzɛfɐ ð(j) ˈɔβiðuʃ]; c. 1630 – 22 July 1684) was a Spanish-born Portuguese painter. Her birth name was Josefa de Ayala Figueira, but she signed her work as 'Josefa em Óbidos' or 'Josefa de Ayalla'. All of her work was executed in Portugal, her father's native country, where she lived from the age of four.",
    		search_term: "Josefa de Óbidos",
    		diameter: "19.0",
    		center_lat: 12.4,
    		center_long: 31.9
    	},
    	{
    		feature_id: 1435,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "de Beausoleil",
    		type: "Famous Woman",
    		origin: "France",
    		continent: "Europe",
    		clean_name: "de Beausoleil",
    		description: "Martine; French earth science researcher (17th century).",
    		bio: "Martine de Bertereau, also known as Baroness de Beausoleil, (c. 1600 – after 1642) was the first recorded female mineralogist as well as mining engineer along with her husband, Jean de Chastelet. She traveled extensively throughout Europe in search of mineral deposits and fresh ground water under the employment of various nobles and royals.",
    		search_term: "Martine Bertereau",
    		diameter: "28.2",
    		center_lat: -5,
    		center_long: 102.8
    	},
    	{
    		feature_id: 1446,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "de Staël",
    		type: "Famous Woman",
    		origin: "France",
    		continent: "Europe",
    		clean_name: "de Staël",
    		description: "Anne; French writer (1766-1817).",
    		bio: "Anne Louise Germaine de Staël-Holstein (French: [an lwiz ʒɛʁmɛn də stal ɔlstajn]; née Necker; 22 April 1766 – 14 July 1817), commonly known as Madame de Staël (French: [madam də stal]), was a French woman of letters and political theorist, the daughter of banker and French finance minister Jacques Necker and Suzanne Curchod, a leading salonnière. She was a voice of moderation in the French Revolution and the Napoleonic era up to the French Restoration. She was present at the Estates General of 1789 and at the 1789 Declaration of the Rights of Man and of the Citizen.",
    		search_term: "Germaine de Staël",
    		diameter: "25.0",
    		center_lat: 37.4,
    		center_long: 324.3
    	},
    	{
    		feature_id: 1649,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "du Chatelet",
    		type: "Famous Woman",
    		origin: "France",
    		continent: "Europe",
    		clean_name: "du Chatelet",
    		description: "Emilie; French mathematician, physicist (1706-1749).",
    		bio: "Gabrielle Émilie Le Tonnelier de Breteuil, Marquise du Châtelet (French pronunciation: [emili dy ʃɑtlɛ] ; 17 December 1706 – 10 September 1749) was a French natural philosopher and mathematician from the early 1730s until her death due to complications during childbirth in 1749. Her most recognized achievement is her translation of and commentary on Isaac Newton's 1687 book Philosophiæ Naturalis Principia Mathematica containing basic laws of physics. The translation, published posthumously in 1756, is still considered the standard French translation.",
    		search_term: "Émilie du Châtelet",
    		diameter: "18.5",
    		center_lat: 21.5,
    		center_long: 165
    	},
    	{
    		feature_id: 1674,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Duse",
    		type: "Famous Woman",
    		origin: "Italy",
    		continent: "Europe",
    		clean_name: "Duse",
    		description: "Eleonora; Italian actress (1858-1924).",
    		bio: "Eleonora Giulia Amalia Duse ( DEW-zay, Italian: [eleoˈnɔːra ˈduːze]; 3 October 1858 – 21 April 1924), often known simply as Duse, was an Italian actress, rated by many as the greatest of her time. She performed in many countries, notably in the plays of Gabriele d'Annunzio and Henrik Ibsen. Duse achieved a unique power of conviction and verity on the stage through intense absorption in the character, 'eliminating the self' as she put it, and letting the qualities emerge from within, not imposed through artifice.",
    		search_term: "Eleonora Duse",
    		diameter: "30.4",
    		center_lat: -82.5,
    		center_long: 358
    	},
    	{
    		feature_id: 1831,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Erinna",
    		type: "Famous Woman",
    		origin: "Greek",
    		continent: "Europe",
    		clean_name: "Erinna",
    		description: "Greek poet (c. 500 B.C.).",
    		bio: "Erinna (; Greek: Ἤριννα) was an ancient Greek poet. She is best known for her long poem 'The Distaff', a 300-line hexameter lament for her childhood friend Baucis, who had died shortly after her marriage. A large fragment of this poem was discovered in 1928 at Oxyrhynchus in Egypt.",
    		search_term: "Erinna",
    		diameter: "33.8",
    		center_lat: -78,
    		center_long: 309.1
    	},
    	{
    		feature_id: 2002,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Fouquet",
    		type: "Famous Woman",
    		origin: "France",
    		continent: "Europe",
    		clean_name: "Fouquet",
    		description: "Marie; French medical writer, charity worker (17th century).",
    		bio: "Marie François Fouquet (1590–1681), was a French medical writer and philanthropist. She was born to Gilles de Maupeou, and married to François IV Fouquet (1587–1640). She was the manager of the hospital Dame de la Charité de l'Hôtel-Dieu in Paris (1634), director of the hospital l'Hôpital des Filles de la Providence in Paris (1658), and manager of the hospital des Dames de la Propagation de La Foi (1664).",
    		search_term: "Marie Fouquet",
    		diameter: "47.8",
    		center_lat: -15.1,
    		center_long: 203.5
    	},
    	{
    		feature_id: 2078,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Galindo",
    		type: "Famous Woman",
    		origin: "Spain",
    		continent: "Europe",
    		clean_name: "Galindo",
    		description: "Beatriz (Beatrix); Spanish professor of Latin, philosophy, and medicine (1473-1535).",
    		bio: "Beatriz Galindo, sometimes spelled Beatrix and also known as La Latina (c. 1465 – 23 November 1535), was a Spanish Latinist and educator. She was a writer, humanist and a teacher of Queen Isabella of Castile and her children. She was one of the most educated women of her time.",
    		search_term: "Beatriz Galindo",
    		diameter: "23.8",
    		center_lat: -23.3,
    		center_long: 258.8
    	},
    	{
    		feature_id: 2121,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Gautier",
    		type: "Famous Woman",
    		origin: "France",
    		continent: "Europe",
    		clean_name: "Gautier",
    		description: "Judith; French novelist (1845-1917).",
    		bio: "Judith Gautier (25 August 1845, Paris – 26 December 1917) was a French poet, translator and historical novelist, the daughter of Théophile Gautier and Ernesta Grisi, sister of the noted singer and ballet dancer Carlotta Grisi. She was married to Catulle Mendès, but soon separated from him and had a brief affair with the composer Richard Wagner during the late summer of 1876. She collaborated with Pierre Loti, the famous novelist, in writing a play, La fille du ciel (1912; English, The Daughter of Heaven), translated and produced under their personal supervision at the Century Theatre, New York City.",
    		search_term: "Judith Gautier",
    		diameter: "59.3",
    		center_lat: 26.3,
    		center_long: 42.8
    	},
    	{
    		feature_id: 2125,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Gaze",
    		type: "Famous Woman",
    		origin: "Soviet",
    		continent: "Europe",
    		clean_name: "Gaze",
    		description: "Vera; Soviet astronomer (1899-1954).",
    		bio: "Vera Fedorovna Gaze (Russian: Вера Фёдоровна Газе; 29 December 1899 – 3 October 1954) was a Russian astronomer who studied emission nebula and minor planets. She discovered around 150 new nebulae and was posthumously honored for her discovery of the planet 2388 Gase and the Gaze Crater on Venus, both of which are named after her. Gaze was born on 29 December (17 December O.S.) 1899 (N.S.) in Saint Petersburg, Russia.",
    		search_term: "Vera Fedorovna Gaze",
    		diameter: "33.3",
    		center_lat: 17.9,
    		center_long: 240.2
    	},
    	{
    		feature_id: 2141,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Gentileschi",
    		type: "Famous Woman",
    		origin: "Italy",
    		continent: "Europe",
    		clean_name: "Gentileschi",
    		description: "Artemisia; Italian painter (1593-c. 1652).",
    		bio: "Artemisia Lomi or Artemisia Gentileschi (US: , Italian: [arteˈmiːzja dʒentiˈleski]; 8 July 1593 – c. 1656) was an Italian Baroque painter. Gentileschi is considered among the most accomplished seventeenth-century artists, initially working in the style of Caravaggio. She was producing professional work by the age of 15.",
    		search_term: "Artemisia Gentileschi",
    		diameter: "20.5",
    		center_lat: 45.2,
    		center_long: 260.6
    	},
    	{
    		feature_id: 2162,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Giliani",
    		type: "Famous Woman",
    		origin: "Italy",
    		continent: "Europe",
    		clean_name: "Giliani",
    		description: "Alessandra; Italian anatomist (c. 1307-1326).",
    		bio: "Alessandra Giliani (1307-1326) was thought to be an Italian natural historian, best known as the first woman to be recorded in historical documents as practicing anatomy and pathology. However, the historical evidence for her existence is limited. Some scholars consider her to be a fiction invented by Alessandro Machiavelli (1693-1766) .",
    		search_term: "Alessandra Giliani",
    		diameter: "19.9",
    		center_lat: -72.9,
    		center_long: 142.1
    	},
    	{
    		feature_id: 2202,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Godiva",
    		type: "Famous Woman",
    		origin: "England",
    		continent: "Europe",
    		clean_name: "Godiva",
    		description: "(Godgifu); Mercian noblewoman (c. 1040-1085).",
    		bio: "Lady Godiva (; died between 1066 and 1086), in Old English Godgifu, was a late Anglo-Saxon noblewoman who is relatively well documented as the wife of Leofric, Earl of Mercia, and a patron of various churches and monasteries. Today, she is mainly remembered for a legend dating back to at least the 13th century, in which she rode naked – covered only in her long hair – through the streets of Coventry to gain a remission of the oppressive taxation that her husband, Leofric, imposed on his tenants. The name 'Peeping Tom' for a voyeur originates from later versions of this legend, in which a man named Thomas watched her ride and was struck blind or dead.",
    		search_term: "Lady Godiva",
    		diameter: "30.7",
    		center_lat: -56.1,
    		center_long: 251.6
    	},
    	{
    		feature_id: 2218,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Goncharova",
    		type: "Famous Woman",
    		origin: "Russia",
    		continent: "Europe",
    		clean_name: "Goncharova",
    		description: "Natalya; Russian artist (1881-1962).",
    		bio: "Natalia Sergeevna Goncharova (Russian: Ната́лья Серге́евна Гончаро́ва; 3 July 1881 – 17 October 1962) was a Russian avant-garde artist, painter, costume designer, writer, illustrator, and set designer. Goncharova's lifelong partner was fellow Russian avant-garde artist Mikhail Larionov. She was a founding member of both the Jack of Diamonds (1909–1911), Moscow's first radical independent exhibiting group, the more radical Donkey's Tail (1912–1913), and with Larionov invented Rayonism (1912–1914).",
    		search_term: "Natalia Goncharova",
    		diameter: "30.3",
    		center_lat: -63,
    		center_long: 97.7
    	},
    	{
    		feature_id: 2247,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Gregory",
    		type: "Famous Woman",
    		origin: "Ireland",
    		continent: "Europe",
    		clean_name: "Gregory",
    		description: "Isabella; Irish playwright (1852-1932).",
    		bio: "Isabella Augusta, Lady Gregory (née Persse; 15 March 1852 – 22 May 1932) was an Irish dramatist, folklorist and theatre manager. With William Butler Yeats and Edward Martyn, she co-founded the Irish Literary Theatre and the Abbey Theatre, and wrote numerous short works for both companies. Lady Gregory produced a number of books of retellings of stories taken from Irish mythology.",
    		search_term: "Lady Gregory",
    		diameter: "18.0",
    		center_lat: 7.1,
    		center_long: 95.8
    	},
    	{
    		feature_id: 2249,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Grey",
    		type: "Famous Woman",
    		origin: "England",
    		continent: "Europe",
    		clean_name: "Grey",
    		description: "Jane; English queen (1537-1554).",
    		bio: "Lady Jane Grey (c. 1537 – 12 February 1554), later known as Lady Jane Dudley (after her marriage) and as the 'Nine Days' Queen', was an English noblewoman who claimed the throne of England and Ireland from 10 July until 19 July 1553. Jane was the great-granddaughter of Henry VII through his younger daughter Mary, and was a first cousin once removed of Edward VI. She had an excellent humanist education, and a reputation as one of the most learned young women of her day.",
    		search_term: "Lady Jane Grey",
    		diameter: "50.0",
    		center_lat: -52.4,
    		center_long: 329.4
    	},
    	{
    		feature_id: 2299,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Gwynn",
    		type: "Famous Woman",
    		origin: "England",
    		continent: "Europe",
    		clean_name: "Gwynn",
    		description: "Nell; English actress, courtesan (1650-1687).",
    		bio: "Eleanor Gwyn (2 February 1650 – 14 November 1687; also spelled Gwynn, Gwynne) was a celebrity figure of the Restoration period. Praised by Samuel Pepys for her comic performances as one of the first actresses on the English stage, she became best known for being a long-time mistress of King Charles II of England and Scotland. Called 'pretty, witty Nell' by Pepys, she has been regarded as a living embodiment of the spirit of Restoration England and has come to be considered a folk heroine, with a story echoing the rags-to-royalty tale of Cinderella.",
    		search_term: "Nell Gwyn",
    		diameter: "32.0",
    		center_lat: 9.7,
    		center_long: 37.2
    	},
    	{
    		feature_id: 2441,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Heloise",
    		type: "Famous Woman",
    		origin: "France",
    		continent: "Europe",
    		clean_name: "Heloise",
    		description: "French physician, hospital founder (c. 1098-1164).",
    		bio: "Héloïse (French: [elɔ.iz]; c. 1100–01? – 16 May 1163–64?), variously Héloïse d'Argenteuil or Héloïse du Paraclet, was a French nun, philosopher, writer, scholar, and abbess.",
    		search_term: "Héloïse",
    		diameter: "38.0",
    		center_lat: 40,
    		center_long: 51.9
    	},
    	{
    		feature_id: 2723,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Isabella",
    		type: "Famous Woman",
    		origin: "Spain",
    		continent: "Europe",
    		clean_name: "Isabella",
    		description: "Of Castile; Spanish queen (1451-1504).",
    		bio: "Isabella I (Spanish: Isabel I; 22 April 1451 – 26 November 1504), also called Isabella the Catholic (Spanish: la Católica), was Queen of Castile from 1474 until her death in 1504, as well as Queen consort of Aragon from 1479 until 1504 by virtue of her marriage to King Ferdinand II of Aragon. Reigning together over a dynastically unified Spain, Isabella and Ferdinand are known as the Catholic Monarchs.After a struggle to claim the throne, Isabella reorganized the governmental system, brought the crime rate to the lowest it had been in years, and unburdened the kingdom of the enormous debt her half-brother King Henry IV had left behind. Isabella's marriage to Ferdinand in 1469 created the basis of the de facto unification of Spain.",
    		search_term: "Isabella I of Castile",
    		diameter: "175.0",
    		center_lat: -29.8,
    		center_long: 204.2
    	},
    	{
    		feature_id: 3038,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Kingsley",
    		type: "Famous Woman",
    		origin: "England",
    		continent: "Europe",
    		clean_name: "Kingsley",
    		description: "Mary; English explorer, writer (1862-1900).",
    		bio: "Mary Henrietta Kingsley (13 October 1862 – 3 June 1900) was an English ethnographer, scientific writer, and explorer whose travels throughout West Africa and resulting work helped shape European perceptions of both African cultures and British colonialism in Africa. Kingsley was born in London on 13 October 1862, the daughter and oldest child of physician, traveller and writer George Kingsley and Mary Bailey. She came from a family of writers, as she was also the niece of novelists Charles Kingsley and Henry Kingsley.",
    		search_term: "Mary Kingsley",
    		diameter: "26.6",
    		center_lat: -22.6,
    		center_long: 306.4
    	},
    	{
    		feature_id: 3060,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Klafsky",
    		type: "Famous Woman",
    		origin: "Hungary",
    		continent: "Europe",
    		clean_name: "Klafsky",
    		description: "Katherina; Hungarian opera singer (1855-1896).",
    		bio: "",
    		search_term: "",
    		diameter: "25.5",
    		center_lat: -20.7,
    		center_long: 188.1
    	},
    	{
    		feature_id: 3086,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Konopnicka",
    		type: "Famous Woman",
    		origin: "Poland",
    		continent: "Europe",
    		clean_name: "Konopnicka",
    		description: "Marie; Polish author (1842-1910).",
    		bio: "",
    		search_term: "",
    		diameter: "20.1",
    		center_lat: 14.5,
    		center_long: 166.6
    	},
    	{
    		feature_id: 3274,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Langtry",
    		type: "Famous Woman",
    		origin: "England",
    		continent: "Europe",
    		clean_name: "Langtry",
    		description: "Lillie; English actress (1853-1929).",
    		bio: "Emilie Charlotte, Lady de Bathe (née Le Breton, formerly Langtry; 13 October 1853 – 12 February 1929), known as Lillie (or Lily) Langtry and nicknamed 'The Jersey Lily', was a British socialite, stage actress and producer.Born on the island of Jersey, upon marrying she moved to London in 1876. Her looks and personality attracted interest, commentary, and invitations from artists and society hostesses, and she was celebrated as a young woman of great beauty and charm. During the aesthetic movement in England she had been painted by aesthete artists, and in 1882 she became the poster-girl for Pears Soap, becoming the first celebrity to endorse a commercial product.In 1881, Langtry became an actress and made her West End debut in the comedy She Stoops to Conquer, causing a sensation in London by becoming the first socialite to appear on stage.",
    		search_term: "Lillie Langtry",
    		diameter: "50.3",
    		center_lat: -17,
    		center_long: 155
    	},
    	{
    		feature_id: 3302,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Laurencin",
    		type: "Famous Woman",
    		origin: "France",
    		continent: "Europe",
    		clean_name: "Laurencin",
    		description: "Marie; French painter (1885-1956).",
    		bio: "Marie Laurencin (31 October 1883 – 8 June 1956) was a French painter and printmaker. She became an important figure in the Parisian avant-garde as a member of the Cubists associated with the Section d'Or. Laurencin was born in Paris, where she was raised by her mother and lived much of her life.",
    		search_term: "Marie Laurencin",
    		diameter: "29.8",
    		center_lat: -15.4,
    		center_long: 46.5
    	},
    	{
    		feature_id: 3321,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Lebedeva",
    		type: "Famous Woman",
    		origin: "Soviet",
    		continent: "Europe",
    		clean_name: "Lebedeva",
    		description: "Sarah; Soviet sculptor (1881-1968).",
    		bio: "Sarra Dmitrievna Lebedeva (December 11 (23), 1892 – March 7, 1967) was a Soviet sculptor, mainly of portraits, but also of statuettes, figures for porcelain and delft ware. Born Sara Darmolatova into a wealthy Saint Petersburg family, Her elder sister was the writer and socialite Anna Radlova. Lebedeva was educated privately in her youth.",
    		search_term: "Sarra Lebedeva",
    		diameter: "37.4",
    		center_lat: 45.2,
    		center_long: 49.8
    	},
    	{
    		feature_id: 3327,
    		year: 1994,
    		feature: "Patera",
    		feature_plural: "Paterae",
    		name: "Ledoux Patera",
    		type: "Famous Woman",
    		origin: "France",
    		continent: "Europe",
    		clean_name: "Ledoux",
    		description: "Jeanne; French artist (1767- 1840).",
    		bio: "Jeanne-Philiberte Ledoux (1767 – 12 October 1840) was a French painter. Ledoux was born in Paris and took lessons from Jean-Baptiste Greuze. Her work was first seen in public in 1793, when she showed three paintings in the Salon: Painting at Rest, Little Girls at a Crossroads, and Concealed Love.",
    		search_term: "Jeanne-Philiberte Ledoux",
    		diameter: "75.0",
    		center_lat: -9.2,
    		center_long: 224.8
    	},
    	{
    		feature_id: 3374,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Leyster",
    		type: "Famous Woman",
    		origin: "Netherlands",
    		continent: "Europe",
    		clean_name: "Leyster",
    		description: "Judith; Dutch painter (1609-1660).",
    		bio: "Judith Jans Leyster (also Leijster; baptised July 28, 1609 – February 10, 1660) was a Dutch Golden Age painter. She painted genre works, portraits and still lifes. Although her work was highly regarded by her contemporaries, Leyster and her work became almost forgotten after her death.",
    		search_term: "Judith Leyster",
    		diameter: "45.8",
    		center_lat: 1,
    		center_long: 260
    	},
    	{
    		feature_id: 3467,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Lonsdale",
    		type: "Famous Woman",
    		origin: "England",
    		continent: "Europe",
    		clean_name: "Lonsdale",
    		description: "Kathleen; English physicist, crystallographer (1903-1971).",
    		bio: "Dame Kathleen Lonsdale (née Yardley; 28 January 1903 – 1 April 1971) was an Irish-born British pacifist, prison reformer and crystallographer. She proved, in 1929, that the benzene ring is flat by using X-ray diffraction methods to elucidate the structure of hexamethylbenzene. She was the first to use Fourier spectral methods while solving the structure of hexachlorobenzene in 1931.",
    		search_term: "Kathleen Lonsdale",
    		diameter: "43.0",
    		center_lat: 55.6,
    		center_long: 222.4
    	},
    	{
    		feature_id: 3553,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "MacDonald",
    		type: "Famous Woman",
    		origin: "Scotland",
    		continent: "Europe",
    		clean_name: "MacDonald",
    		description: "Flora; Scottish heroine (1722-1790).",
    		bio: "Flora MacDonald (Gaelic: Fionnghal nic Dhòmhnaill, 1722 - 5 March 1790) was a member of Clan Macdonald of Sleat, best known for helping Charles Edward Stuart evade government troops after the Battle of Culloden in April 1746. Her family generally backed the government during the 1745 Rising and MacDonald later claimed to have assisted Charles out of sympathy for his situation. Arrested and held in the Tower of London, she was released under a general amnesty in June 1747.",
    		search_term: "Flora MacDonald",
    		diameter: "17.6",
    		center_lat: 30,
    		center_long: 120.7
    	},
    	{
    		feature_id: 3641,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Manton",
    		type: "Famous Woman",
    		origin: "England",
    		continent: "Europe",
    		clean_name: "Manton",
    		description: "Sidnie; English zoologist (1902-1980) and Irene; botanist (1904-1988).",
    		bio: "Sidnie Milana Manton, FLS FRS (4 May 1902 – 2 January 1979) was an influential British zoologist. She is known for making advances in the field of functional morphology. She is regarded as being one of the most outstanding zoologists of the twentieth century.",
    		search_term: "Sidnie Manton",
    		diameter: "20.5",
    		center_lat: 9.3,
    		center_long: 26.9
    	},
    	{
    		feature_id: 3719,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Markham",
    		type: "Famous Woman",
    		origin: "England",
    		continent: "Europe",
    		clean_name: "Markham",
    		description: "Beryl; English aviator (1902-1986).",
    		bio: "Beryl Markham (née Clutterbuck; 26 October 1902 – 3 August 1986) was a Kenyan aviator born in England (one of the first bush pilots), adventurer, racehorse trainer and author. She was the first person to fly solo, non-stop across the Atlantic from Britain to North America. She wrote about her adventures in her memoir, West with the Night.",
    		search_term: "Beryl Markham",
    		diameter: "71.8",
    		center_lat: -4.1,
    		center_long: 155.6
    	},
    	{
    		feature_id: 3919,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Mirabeau",
    		type: "Famous Woman",
    		origin: "France",
    		continent: "Europe",
    		clean_name: "Mirabeau",
    		description: "Sibylle; French writer (d. 1932).",
    		bio: "Sibylle Aimée Marie-Antoinette Gabrielle de Riquetti de Mirabeau, Comtesse de Martel de Janville (16 August 1849 – 28 June 1932) was a French writer who wrote under the pseudonym Gyp. She was born at the château de Coëtsal near Plumergat, in the département of the Morbihan, in Brittany, her father, Joseph-Arundel de Riquetti, comte de Mirabeau, 1820–1860, being the great-grandson of Victor de Riquetti, marquis de Mirabeau (Mirabeau Père), noted 18th-century economist, and grandnephew of Honoré Mirabeau the celebrated revolutionary orator. In view of her later opinions, it is interesting to remember that Sibylle was actually descended from Octave Mirabeau's royalist younger brother, André-Boniface-Louis de Riquetti, vicomte de Mirabeau, (1754–1792) known as Mirabeau-Tonneau because of his notorious embonpoint, who famously broke his sword in front of France's Revolutionary Assembly (where he represented the nobility of the Limousin) while bitterly crying out: 'now that The King is giving up his kingdom, a nobleman no longer needs a sword to fight for him!' Although, in her memoirs, 'Gyp' stated that she had been born on August 15, which happens to have been Napoleon Bonaparte's birthday, her birth certificate reads 'morning of August 16, 1849', according to her biographer, W. Z. Silvermann.",
    		search_term: "Sibylle Riqueti de Mirabeau",
    		diameter: "23.8",
    		center_lat: 1.1,
    		center_long: 284.3
    	},
    	{
    		feature_id: 4023,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Montez",
    		type: "Famous Woman",
    		origin: "Ireland",
    		continent: "Europe",
    		clean_name: "Montez",
    		description: "Lola; Irish dancer (1818-1861).",
    		bio: "Eliza Rosanna Gilbert, Countess of Landsfeld (17 February 1821 – 17 January 1861), better known by the stage name Lola Montez (), was an Irish dancer and actress who became famous as a Spanish dancer, courtesan, and mistress of King Ludwig I of Bavaria, who made her Gräfin von Landsfeld (Countess of Landsfeld). At the start of the Revolutions of 1848 in the German states, she was forced to flee. She proceeded to the United States via Austria, Switzerland, France and London, returning to her work as an entertainer and lecturer.",
    		search_term: "Lola Montez",
    		diameter: "21.1",
    		center_lat: 17.9,
    		center_long: 266.5
    	},
    	{
    		feature_id: 4037,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Morisot",
    		type: "Famous Woman",
    		origin: "France",
    		continent: "Europe",
    		clean_name: "Morisot",
    		description: "Berthe; French artist (1841-1895).",
    		bio: "Berthe Marie Pauline Morisot (French: [bɛʁt mɔʁizo]; January 14, 1841 – March 2, 1895) was a French painter and a member of the circle of painters in Paris who became known as the Impressionists. In 1864, Morisot exhibited for the first time in the highly esteemed Salon de Paris. Sponsored by the government and judged by Academicians, the Salon was the official, annual exhibition of the Académie des beaux-arts in Paris.",
    		search_term: "Berthe Morisot",
    		diameter: "48.0",
    		center_lat: -61.2,
    		center_long: 211.3
    	},
    	{
    		feature_id: 4069,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Munter",
    		type: "Famous Woman",
    		origin: "Germany",
    		continent: "Europe",
    		clean_name: "Munter",
    		description: "Gabriele; German painter (1877-1962).",
    		bio: "Gabriele Münter (19 February 1877 – 19 May 1962) was a German expressionist painter who was at the forefront of the Munich avant-garde in the early 20th century. She studied and lived with the painter Wassily Kandinsky and was a founding member of the expressionist group Der Blaue Reiter. Münter was born to upper middle-class parents in Berlin on 19 February 1877.",
    		search_term: "Gabriele Münter",
    		diameter: "32.1",
    		center_lat: -15.3,
    		center_long: 39.3
    	},
    	{
    		feature_id: 4120,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Nalkowska",
    		type: "Famous Woman",
    		origin: "Poland",
    		continent: "Europe",
    		clean_name: "Nalkowska",
    		description: "Zofia; Polish novelist, playwright (1884-1954).",
    		bio: "Zofia Nałkowska ([ˈzɔfia nawˈkɔvska], Warsaw, Congress Poland, 10 November 1884 – 17 December 1954, Warsaw) was a Polish prose writer, dramatist, and prolific essayist. She served as the executive member of the prestigious Polish Academy of Literature (1933–1939) during the interwar period. Nałkowska was born into a family of intellectuals dedicated to issues of social justice, and studied at the clandestine Flying University under the Russian partition.",
    		search_term: "Zofia Nałkowska",
    		diameter: "22.2",
    		center_lat: 28.1,
    		center_long: 290
    	},
    	{
    		feature_id: 4280,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Nilsson",
    		type: "Famous Woman",
    		origin: "Sweden",
    		continent: "Europe",
    		clean_name: "Nilsson",
    		description: "Christine; Swedish opera singer, violinist (1843-1921).",
    		bio: "Christina Nilsson, Countess de Casa Miranda, also called Christine Nilsson (20 August 1843 – 22 November 1921) was a Swedish dramatic coloratura soprano. Possessed of a pure and brilliant voice of first three then two and a half octaves trained in the bel canto technique, and noted for her graceful appearance and stage presence, she enjoyed a twenty-year career as a top-rank international singer before her 1888 retirement. A contemporary of one of the Victorian era's most famous divas, Adelina Patti, the two were often compared by reviewers and audiences, and were sometimes believed to be rivals.",
    		search_term: "Christine Nilsson",
    		diameter: "27.3",
    		center_lat: -75.9,
    		center_long: 277.6
    	},
    	{
    		feature_id: 4285,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Nin",
    		type: "Famous Woman",
    		origin: "France",
    		continent: "Europe",
    		clean_name: "Nin",
    		description: "Anais; French novelist (1903-1977).",
    		bio: "Angela Anaïs Juana Antolina Rosa Edelmira Nin y Culmell (February 21, 1903 – January 14, 1977; , French: [ana.is nin]) was a French-born American diarist, essayist, novelist, and writer of short stories and erotica. Born to Cuban parents in France, Nin was the daughter of the composer Joaquín Nin and the classically trained singer Rosa Culmell. Nin spent her early years in Spain and Cuba, about sixteen years in Paris (1924–1940), and the remaining half of her life in the United States, where she became an established author.",
    		search_term: "Anaïs Nin",
    		diameter: "27.1",
    		center_lat: -3.9,
    		center_long: 266.4
    	},
    	{
    		feature_id: 4437,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Olesnicka",
    		type: "Famous Woman",
    		origin: "Poland",
    		continent: "Europe",
    		clean_name: "Olesnicka",
    		description: "Zofia; Polish poet (fl. c. 1550).",
    		bio: "Zofia Oleśnicka (Pieskowa Skała ? - c.1567) was a Polish Calvinist noblewoman, for many years considered to be the first Polish woman poet for a collection of Protestant hymns published in Cracow in 1556. However more recent scholarship has questioned the attribution of this collection to Zofia, and has ascribed the poems to Cyprian Bazylik, a poet and composer among the Calvinist nobility.",
    		search_term: "Zofia Oleśnicka",
    		diameter: "33.0",
    		center_lat: 18.3,
    		center_long: 210.9
    	},
    	{
    		feature_id: 4485,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Orczy",
    		type: "Famous Woman",
    		origin: "Hungary",
    		continent: "Europe",
    		clean_name: "Orczy",
    		description: "Emmuska; Hungarian novelist, playwright (1865-1947).",
    		bio: "Baroness Emma Orczy (full name: Emma Magdolna Rozália Mária Jozefa Borbála Orczy de Orci) (; 23 September 1865 – 12 November 1947), usually known as Baroness Orczy (the name under which she was published) or to her family and friends as Emmuska Orczy, was a Hungarian-born British novelist and playwright. She is best known for her series of novels featuring the Scarlet Pimpernel, the alter ego of Sir Percy Blakeney, a wealthy English fop who turns into a quick-thinking escape artist in order to save French aristocrats from 'Madame Guillotine' during the French Revolution, establishing the 'hero with a secret identity' in popular culture.Opening in London's West End on 5 January 1905, The Scarlet Pimpernel became a favourite of British audiences. Some of Orczy's paintings were exhibited at the Royal Academy in London.",
    		search_term: "Baroness Orczy",
    		diameter: "26.9",
    		center_lat: 3.7,
    		center_long: 52.3
    	},
    	{
    		feature_id: 4617,
    		year: 1994,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Pavlova Corona",
    		type: "Famous Woman",
    		origin: "Russia",
    		continent: "Europe",
    		clean_name: "Pavlova",
    		description: "Anna; Russian ballet dancer (1881-1931).",
    		bio: "Anna Pavlovna Pavlova (English: PAV-lə-və, pahv-LOH-və, pav-, Russian: Анна Павловна Павлова [ˈanːə ˈpavləvə]), born Anna Matveyevna Pavlova (Russian: Анна Матвеевна Павлова; 12 February [O.S. 31 January] 1881 – 23 January 1931), was a Russian prima ballerina of the late 19th and the early 20th centuries. She was a principal artist of the Imperial Russian Ballet and the Ballets Russes of Sergei Diaghilev. Pavlova is most recognized for her creation of the role of The Dying Swan and, with her own company, became the first ballerina to tour around the world, including performances in South America, India and Australia.",
    		search_term: "Anna Pavlova",
    		diameter: "440.0",
    		center_lat: 14.5,
    		center_long: 40
    	},
    	{
    		feature_id: 4713,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Phryne",
    		type: "Famous Woman",
    		origin: "Greek",
    		continent: "Europe",
    		clean_name: "Phryne",
    		description: "Greek model, courtesan (fourth century B.C.).",
    		bio: "Phryne (/ˈfraɪni/; Ancient Greek: Φρύνη) (c. 371 BC – after 316 BC) was an ancient Greek hetaira (courtesan). From Thespiae in Boeotia, she was active in Athens, where she became one of the wealthiest women in Greece.",
    		search_term: "Phryne",
    		diameter: "39.4",
    		center_lat: -46.2,
    		center_long: 314.7
    	},
    	{
    		feature_id: 4739,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Piscopia",
    		type: "Famous Woman",
    		origin: "Italy",
    		continent: "Europe",
    		clean_name: "Piscopia",
    		description: "Elena; Italian mathematician, educator (1646-1684).",
    		bio: "Elena Lucrezia Cornaro Piscopia (US: , Italian: [ˈɛːlena luˈkrɛttsja korˈnaːro piˈskɔːpja]; 5 June 1646 – 26 July 1684) or Elena Lucrezia Corner (Italian: [korˈnɛr]), also known in English as Helen Cornaro, was a Venetian philosopher of noble descent who in 1678 became one of the first women to receive an academic degree from a university, and the first to receive a Doctor of Philosophy degree. Elena Cornaro Piscopia was born in the Palazzo Loredan, at Venice, Republic of Venice on 5 June 1646. She was the third child of Gianbattista Cornaro-Piscopia and his mistress Zanetta Boni.",
    		search_term: "Elena Cornaro Piscopia",
    		diameter: "26.2",
    		center_lat: 1.5,
    		center_long: 190.9
    	},
    	{
    		feature_id: 4812,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Potter",
    		type: "Famous Woman",
    		origin: "England",
    		continent: "Europe",
    		clean_name: "Potter",
    		description: "Beatrix; English children's author (1866-1943).",
    		bio: "Helen Beatrix Potter (, 28 July 1866 – 22 December 1943) was an English writer, illustrator, natural scientist, and conservationist. She is best known for her children's books featuring animals, such as The Tale of Peter Rabbit, which was her first published work in 1902. Her books, including 23 Tales, have sold more than 250 million copies.",
    		search_term: "Beatrix Potter",
    		diameter: "46.9",
    		center_lat: 7.2,
    		center_long: 309.1
    	},
    	{
    		feature_id: 4951,
    		year: 1994,
    		feature: "Patera",
    		feature_plural: "Paterae",
    		name: "Raskova Paterae",
    		type: "Famous Woman",
    		origin: "Russia",
    		continent: "Europe",
    		clean_name: "Raskovae",
    		description: "Marina M.; Russian aviator (1912-1943).",
    		bio: "",
    		search_term: "",
    		diameter: "80.0",
    		center_lat: -51,
    		center_long: 222.8
    	},
    	{
    		feature_id: 5019,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Rhys",
    		type: "Famous Woman",
    		origin: "Wales",
    		continent: "Europe",
    		clean_name: "Rhys",
    		description: "Jean; Welsh writer (1894-1979).",
    		bio: "Jean Rhys, ( REESS; born Ella Gwendolyn Rees Williams; 24 August 1890 – 14 May 1979) was a British novelist who was born and grew up in the Caribbean island of Dominica. From the age of 16, she was mainly resident in England, where she was sent for her education. She is best known for her novel Wide Sargasso Sea (1966), written as a prequel to Charlotte Brontë's Jane Eyre.",
    		search_term: "Jean Rhys",
    		diameter: "44.0",
    		center_lat: 8.6,
    		center_long: 298.8
    	},
    	{
    		feature_id: 5174,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Romanskaya",
    		type: "Famous Woman",
    		origin: "Soviet",
    		continent: "Europe",
    		clean_name: "Romanskaya",
    		description: "Sofia; Soviet astronomer (1886-1969).",
    		bio: "Sofia Romanskaya (1886–1969) was a Soviet astronomer known as one of the first Russian women to have a significant role in the field. Sofia (also spelled Sofya) Vasilievna Voroshilova-Romanskaya was born in St. Petersburg.",
    		search_term: "Sofia Romanskaya",
    		diameter: "30.4",
    		center_lat: 23.2,
    		center_long: 178.4
    	},
    	{
    		feature_id: 5187,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Rosa Bonheur",
    		type: "Famous Woman",
    		origin: "France",
    		continent: "Europe",
    		clean_name: "Rosa Bonheur",
    		description: "French painter (1822-1899).",
    		bio: "Rosa Bonheur (born Marie-Rosalie Bonheur; 16 March 1822 – 25 May 1899) was a French artist known best as a painter of animals (animalière). She also made sculpture in a realist style. Her paintings include Ploughing in the Nivernais, first exhibited at the Paris Salon of 1848, and now in the Musée d'Orsay in Paris, and The Horse Fair (in French: Le marché aux chevaux), which was exhibited at the Salon of 1853 (finished in 1855) and is now in the Metropolitan Museum of Art in New York City.",
    		search_term: "Rosa Bonheur",
    		diameter: "104.0",
    		center_lat: 9.7,
    		center_long: 288.8
    	},
    	{
    		feature_id: 5301,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Sandel",
    		type: "Famous Woman",
    		origin: "Norway",
    		continent: "Europe",
    		clean_name: "Sandel",
    		description: "Cora; Norwegian author (1880-1974).",
    		bio: "Sara Cecilia Görvell Fabricius (20 December 1880 – 3 April 1974), better known by her pen name Cora Sandel, was a Norwegian writer and painter who lived most of her adult life abroad. Her best-known works are the novels now known as the Alberta Trilogy. Sara Cecilia Görvell Fabricius was born in Kristiania (now Oslo), Norway.",
    		search_term: "Cora Sandel",
    		diameter: "17.9",
    		center_lat: -45.7,
    		center_long: 211.7
    	},
    	{
    		feature_id: 5349,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Sayers",
    		type: "Famous Woman",
    		origin: "England",
    		continent: "Europe",
    		clean_name: "Sayers",
    		description: "Dorothy L.; English novelist, playwright (1893-1957).",
    		bio: "Dorothy Leigh Sayers (; 13 June 1893 – 17 December 1957) was an English crime writer and poet. She was also a student of classical and modern languages. She is best known for her mysteries, a series of novels and short stories set between the First and Second World Wars that feature English aristocrat and amateur sleuth Lord Peter Wimsey.",
    		search_term: "Dorothy L. Sayers",
    		diameter: "98.0",
    		center_lat: -67.5,
    		center_long: 229.8
    	},
    	{
    		feature_id: 5447,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Seymour",
    		type: "Famous Woman",
    		origin: "England",
    		continent: "Europe",
    		clean_name: "Seymour",
    		description: "Jane; English queen (c. 1509-1537).",
    		bio: "Jane Seymour (c. 1508 – 24 October 1537) was Queen of England as the third wife of King Henry VIII of England from their marriage on 30 May 1536 until her death the next year. She became queen following the execution of Henry's second wife, Anne Boleyn.",
    		search_term: "Jane Seymour",
    		diameter: "63.0",
    		center_lat: 18.2,
    		center_long: 326.5
    	},
    	{
    		feature_id: 5519,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Sidney",
    		type: "Famous Woman",
    		origin: "England",
    		continent: "Europe",
    		clean_name: "Sidney",
    		description: "Mary; Elizabethan dramatist (1561-1621).",
    		bio: "Mary Herbert, Countess of Pembroke (born Sidney, 27 October 1561 – 25 September 1621) was among the first Englishwomen to gain notice for her poetry and her literary patronage. By the age of 39, she was listed with her brother Philip Sidney and with Edmund Spenser and William Shakespeare among the notable authors of the day in John Bodenham's verse miscellany Belvidere. Her play Antonius is widely seen as reviving interest in soliloquy based on classical models and as a likely source of Samuel Daniel's closet drama Cleopatra (1594) and of Shakespeare's Antony and Cleopatra (1607).",
    		search_term: "Mary Sidney",
    		diameter: "20.2",
    		center_lat: 13.4,
    		center_long: 199.6
    	},
    	{
    		feature_id: 5574,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Sirani",
    		type: "Famous Woman",
    		origin: "Italy",
    		continent: "Europe",
    		clean_name: "Sirani",
    		description: "Elisabetta; Italian painter, etcher, printmaker (1638-1665).",
    		bio: "Elisabetta Sirani (8 January 1638 – 28 August 1665) was an Italian Baroque painter and printmaker who died in unexplained circumstances at the age of 27. She was a pioneering female artist in early modern Bologna, who established an academy for other women artists. Elisabetta Sirani was born in Bologna on 8 January 1638, the first of four children of Margherita and Giovanni Andrea Sirani.",
    		search_term: "Elisabetta Sirani",
    		diameter: "28.3",
    		center_lat: -31.5,
    		center_long: 230.4
    	},
    	{
    		feature_id: 5587,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Sitwell",
    		type: "Famous Woman",
    		origin: "England",
    		continent: "Europe",
    		clean_name: "Sitwell",
    		description: "Edith; English poet, critic (1887-1964).",
    		bio: "Dame Edith Louisa Sitwell (7 September 1887 – 9 December 1964) was a British poet and critic and the eldest of the three literary Sitwells. She reacted badly to her eccentric, unloving parents and lived much of her life with her governess. She never married but became passionately attached to Russian painter Pavel Tchelitchew, and her home was always open to London's poetic circle, to whom she was generous and helpful.",
    		search_term: "Edith Sitwell",
    		diameter: "32.8",
    		center_lat: 16.6,
    		center_long: 190.4
    	},
    	{
    		feature_id: 5692,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Steinbach",
    		type: "Famous Woman",
    		origin: "Germany",
    		continent: "Europe",
    		clean_name: "Steinbach",
    		description: "Sabina; German sculptor (c. 1250).",
    		bio: "Sabina von Steinbach was – according to legend – a female stonemason living in Alsace (in what is now eastern France) during the 13th century. She is said to have been the daughter of Erwin von Steinbach, architect and master builder at Notre-Dame de Strasbourg, the cathedral in Strasbourg. When after her father's death her brother Johann continued to build the cathedral tower from 1318 to 1339, Sabina is believed to have been employed as a skillful mason and sculptor in its completion.",
    		search_term: "Sabina von Steinbach",
    		diameter: "20.3",
    		center_lat: -41.4,
    		center_long: 256.9
    	},
    	{
    		feature_id: 5943,
    		year: 1994,
    		feature: "Patera",
    		feature_plural: "Paterae",
    		name: "Tey Patera",
    		type: "Famous Woman",
    		origin: "Scotland",
    		continent: "Europe",
    		clean_name: "Tey",
    		description: "Josephine; Scottish author (1897-1952).",
    		bio: "Josephine Tey was a pseudonym used by Elizabeth MacKintosh (25 July 1896 – 13 February 1952), a Scottish author. Her novel The Daughter of Time was a detective work investigating the role of Richard III of England in the death of the Princes in the Tower, and named as the greatest crime novel of all time by the Crime Writers' Association. Her first play Richard of Bordeaux, written under another pseudonym, Gordon Daviot, starred John Gielgud in its successful West End run.",
    		search_term: "Josephine Tey",
    		diameter: "20.0",
    		center_lat: -17.8,
    		center_long: 349.1
    	},
    	{
    		feature_id: 6090,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Trollope",
    		type: "Famous Woman",
    		origin: "England",
    		continent: "Europe",
    		clean_name: "Trollope",
    		description: "Frances; English novelist (1780-1863).",
    		bio: "Frances Milton Trollope, also known as Fanny Trollope (10 March 1779 – 6 October 1863), was an English novelist who wrote as Mrs. Trollope or Mrs. Frances Trollope.",
    		search_term: "Frances Milton Trollope",
    		diameter: "27.2",
    		center_lat: -54.8,
    		center_long: 246.4
    	},
    	{
    		feature_id: 6153,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Tussaud",
    		type: "Famous Woman",
    		origin: "Switzerland",
    		continent: "Europe",
    		clean_name: "Tussaud",
    		description: "Marie; Swiss wax artist (1760-1850).",
    		bio: "Anna Maria 'Marie' Tussaud (French pronunciation: ​[maʁi tyso]; née Grosholtz; 1 December 1761 – 16 April 1850) was a French artist known for her wax sculptures and Madame Tussauds, the wax museum she founded in London. Marie Tussaud was born 1 December 1761 in Strasbourg, France. Her father, Joseph Grosholtz, was killed in the Seven Years' War just two months before Marie was born.",
    		search_term: "Marie Tussaud",
    		diameter: "16.0",
    		center_lat: 21.7,
    		center_long: 221
    	},
    	{
    		feature_id: 6185,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Udaltsova",
    		type: "Famous Woman",
    		origin: "Russia",
    		continent: "Europe",
    		clean_name: "Udaltsova",
    		description: "Nadezhda; Russian artist (1885-1961).",
    		bio: "Nadezhda Andreevna Udaltsova (Russian: Наде́жда Андре́евна Удальцо́ва, 29 December 1885 – 25 January 1961) was a Russian avant-garde artist (Cubist, Suprematist), painter and teacher. Nadezhda Udaltsova was born in the village of Orel, Russia, on 29 December 1885. When she was six, her family moved to Moscow, where she graduated from high school and began her artistic career.",
    		search_term: "Nadezhda Udaltsova",
    		diameter: "26.7",
    		center_lat: -20.3,
    		center_long: 275.3
    	},
    	{
    		feature_id: 6465,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Văcărescu",
    		type: "Famous Woman",
    		origin: "Romania (Rumania)",
    		continent: "Europe",
    		clean_name: "Văcărescu",
    		description: "Helene; Rumanian poet, novelist (1866-1947).",
    		bio: "Elena Văcărescu, or Hélène Vacaresco (September 21, 1864 in Bucharest – February 17, 1947 in Paris), was a Romanian-French aristocrat writer, twice a laureate of the Académie française. Through her father, Ioan Văcărescu, she descended from a long line of boyars of Wallachia (the Văcărescu family), including Ienăchiță Văcărescu, the poet who wrote the first Romanian grammar. She was also a granddaughter of Romanian poet Iancu Văcărescu.",
    		search_term: "Elena Văcărescu",
    		diameter: "31.5",
    		center_lat: -63,
    		center_long: 199.8
    	},
    	{
    		feature_id: 6276,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Valadon",
    		type: "Famous Woman",
    		origin: "France",
    		continent: "Europe",
    		clean_name: "Valadon",
    		description: "Suzanne; French painter (1865-1940).",
    		bio: "Suzanne Valadon (23 September 1865 – 7 April 1938) was a French painter who was born Marie-Clémentine Valadon at Bessines-sur-Gartempe, Haute-Vienne, France. In 1894, Valadon became the first woman painter admitted to the Société Nationale des Beaux-Arts. She was also the mother of painter Maurice Utrillo.",
    		search_term: "Suzanne Valadon",
    		diameter: "25.2",
    		center_lat: -49,
    		center_long: 167.7
    	},
    	{
    		feature_id: 6443,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "von Paradis",
    		type: "Famous Woman",
    		origin: "Austria",
    		continent: "Europe",
    		clean_name: "von Paradis",
    		description: "Maria; Austrian pianist (1759-1834).",
    		bio: "Maria Theresia von Paradis (May 15, 1759 – February 1, 1824) was an Austrian musician and composer who lost her sight at an early age, and for whom her close friend Mozart may have written his Piano Concerto No. 18 in B-flat major. She was also in contact with Salieri, Haydn, and Gluck.",
    		search_term: "Maria Theresia von Paradis",
    		diameter: "37.5",
    		center_lat: -32.2,
    		center_long: 314.9
    	},
    	{
    		feature_id: 6444,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "von Schuurman",
    		type: "Famous Woman",
    		origin: "Netherlands",
    		continent: "Europe",
    		clean_name: "von Schuurman",
    		description: "Anna; Dutch linguist, writer, artist (1607-1678).",
    		bio: "Anna Maria van Schurman (November 5, 1607 – May 4, 1678) was a Dutch painter, engraver, poet, and scholar, who is best known for her exceptional learning and her defence of female education. She was a highly educated woman, who excelled in art, music, and literature, and became proficient in fourteen languages, including Latin, Greek, Hebrew, Arabic, Syriac, Aramaic, and Ethiopic, as well as various contemporary European languages. She was the first woman to unofficially study at a Dutch university.",
    		search_term: "Anna Maria van Schurman",
    		diameter: "29.1",
    		center_lat: -5,
    		center_long: 191
    	},
    	{
    		feature_id: 6446,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "von Suttner",
    		type: "Famous Woman",
    		origin: "Austria",
    		continent: "Europe",
    		clean_name: "von Suttner",
    		description: "Bertha; Austrian journalist, pacifist (1843-1914).",
    		bio: "Bertha Sophie Felicitas Freifrau von Suttner (pronounced [ˈbɛʁtaː fɔn ˈzʊtnɐ]; née Countess Kinsky von Wchinitz und Tettau; 9 June 1843 – 21 June 1914) was an Austrian-Bohemian pacifist and novelist. In 1905, she became the second female Nobel laureate (after Marie Curie in 1903), the first woman to be awarded the Nobel Peace Prize, and the first Austrian laureate. Bertha Kinský was born on 9 June 1843 at Kinský Palace in the Obecní dvůr (cz) district of Prague.",
    		search_term: "Bertha von Suttner",
    		diameter: "24.0",
    		center_lat: -10.6,
    		center_long: 234.9
    	},
    	{
    		feature_id: 6511,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Weil",
    		type: "Famous Woman",
    		origin: "France",
    		continent: "Europe",
    		clean_name: "Weil",
    		description: "Simone; French author (1909-1943).",
    		bio: "Simone Adolphine Weil ( VAY, French: [simɔn vɛj] ; 3 February 1909 – 24 August 1943) was a French philosopher, mystic, and political activist. Over 2,500 scholarly works have been published about her, including close analyses and readings of her work, since 1995.After her graduation from formal education, Weil became a teacher. She taught intermittently throughout the 1930s, taking several breaks due to poor health and to devote herself to political activism.",
    		search_term: "Simone Weil",
    		diameter: "24.2",
    		center_lat: 19.4,
    		center_long: 283.1
    	},
    	{
    		feature_id: 6526,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "West",
    		type: "Famous Woman",
    		origin: "Ireland",
    		continent: "Europe",
    		clean_name: "West",
    		description: "Rebecca; Irish novelist, critic, actress (1892-1983).",
    		bio: "Dame Cicily Isabel Fairfield (21 December 1892 – 15 March 1983), known as Rebecca West, or Dame Rebecca West, was a British author, journalist, literary critic and travel writer. An author who wrote in many genres, West reviewed books for The Times, the New York Herald Tribune, The Sunday Telegraph and The New Republic, and she was a correspondent for The Bookman. Her major works include Black Lamb and Grey Falcon (1941), on the history and culture of Yugoslavia; A Train of Powder (1955), her coverage of the Nuremberg trials, published originally in The New Yorker; The Meaning of Treason (first published as a magazine article in 1945 and then expanded to the book in 1947), later The New Meaning of Treason (1964), a study of the trial of the British fascist William Joyce and others; The Return of the Soldier (1918), a modernist World War I novel; and the 'Aubrey trilogy' of autobiographical novels, The Fountain Overflows (1956), This Real Night (published posthumously in 1984), and Cousin Rosamund (1985).",
    		search_term: "Rebecca West",
    		diameter: "28.8",
    		center_lat: 26.1,
    		center_long: 303
    	},
    	{
    		feature_id: 6542,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Wieck",
    		type: "Famous Woman",
    		origin: "Germany",
    		continent: "Europe",
    		clean_name: "Wieck",
    		description: "Clara; German pianist, composer (1819-1896).",
    		bio: "Clara Josephine Schumann ([ˈklaːʁa ˈʃuːman]; née Wieck; 13 September 1819 – 20 May 1896) was a German pianist, composer, and piano teacher. Regarded as one of the most distinguished pianists of the Romantic era, she exerted her influence over the course of a 61-year concert career, changing the format and repertoire of the piano recital by lessening the importance of purely virtuosic works. She also composed solo piano pieces, a piano concerto (her Op.",
    		search_term: "Clara Wieck",
    		diameter: "20.2",
    		center_lat: -74.2,
    		center_long: 244.8
    	},
    	{
    		feature_id: 6571,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Wollstonecraft",
    		type: "Famous Woman",
    		origin: "England",
    		continent: "Europe",
    		clean_name: "Wollstonecraft",
    		description: "Mary; English author (1759-1797).",
    		bio: "Mary Wollstonecraft (, also UK: ; 27 April 1759 – 10 September 1797) was a British writer, philosopher, and advocate of women's rights. Until the late 20th century, Wollstonecraft's life, which encompassed several unconventional personal relationships at the time, received more attention than her writing. Today Wollstonecraft is regarded as one of the founding feminist philosophers, and feminists often cite both her life and her works as important influences.",
    		search_term: "Mary Wollstonecraft",
    		diameter: "44.1",
    		center_lat: -39.1,
    		center_long: 260.8
    	},
    	{
    		feature_id: 6668,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Yonge",
    		type: "Famous Woman",
    		origin: "England",
    		continent: "Europe",
    		clean_name: "Yonge",
    		description: "Charlotte; English writer (1823-1901).",
    		bio: "Charlotte Mary Yonge (1823–1901) was an English novelist, who wrote in the service of the church. Her abundant books helped to spread the influence of the Oxford Movement and show her keen interest in matters of public health and sanitation. Her work is mostly out of print.",
    		search_term: "Charlotte Yonge",
    		diameter: "42.8",
    		center_lat: -14,
    		center_long: 115.1
    	},
    	{
    		feature_id: 18,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Abika",
    		type: "First Name",
    		origin: "Russia",
    		continent: "Europe",
    		clean_name: "Abika",
    		description: "Mari first name.",
    		bio: "",
    		search_term: "",
    		diameter: "14.5",
    		center_lat: -52.5,
    		center_long: 104.4
    	},
    	{
    		feature_id: 111,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Aimee",
    		type: "First Name",
    		origin: "France",
    		continent: "Europe",
    		clean_name: "Aimee",
    		description: "French first name.",
    		bio: "",
    		search_term: "",
    		diameter: "17.0",
    		center_lat: 16.1,
    		center_long: 127.2
    	},
    	{
    		feature_id: 117,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Aita",
    		type: "First Name",
    		origin: "Estonia",
    		continent: "Europe",
    		clean_name: "Aita",
    		description: "Estonian first name.",
    		bio: "",
    		search_term: "",
    		diameter: "14.0",
    		center_lat: 8.9,
    		center_long: 270.7
    	},
    	{
    		feature_id: 186,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Alima",
    		type: "First Name",
    		origin: "Russia",
    		continent: "Europe",
    		clean_name: "Alima",
    		description: "Tatar first name.",
    		bio: "",
    		search_term: "",
    		diameter: "10.3",
    		center_lat: -46,
    		center_long: 229.2
    	},
    	{
    		feature_id: 187,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Alimat",
    		type: "First Name",
    		origin: "Georgia",
    		continent: "Europe",
    		clean_name: "Alimat",
    		description: "Osset first name.",
    		bio: "",
    		search_term: "",
    		diameter: "13.5",
    		center_lat: -29.5,
    		center_long: 205.9
    	},
    	{
    		feature_id: 188,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Alison",
    		type: "First Name",
    		origin: "Ireland",
    		continent: "Europe",
    		clean_name: "Alison",
    		description: "Irish first name.",
    		bio: "",
    		search_term: "",
    		diameter: "14.4",
    		center_lat: -4,
    		center_long: 165.6
    	},
    	{
    		feature_id: 306,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Anush",
    		type: "First Name",
    		origin: "Armenia",
    		continent: "Europe",
    		clean_name: "Anush",
    		description: "Armenian first name.",
    		bio: "",
    		search_term: "",
    		diameter: "12.7",
    		center_lat: 14.9,
    		center_long: 86.5
    	},
    	{
    		feature_id: 430,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Asmik",
    		type: "First Name",
    		origin: "Armenia",
    		continent: "Europe",
    		clean_name: "Asmik",
    		description: "Armenian first name.",
    		bio: "",
    		search_term: "",
    		diameter: "19.5",
    		center_lat: 3.9,
    		center_long: 166.4
    	},
    	{
    		feature_id: 470,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Audrey",
    		type: "First Name",
    		origin: "England",
    		continent: "Europe",
    		clean_name: "Audrey",
    		description: "English first name.",
    		bio: "",
    		search_term: "",
    		diameter: "15.2",
    		center_lat: 23.8,
    		center_long: 348.1
    	},
    	{
    		feature_id: 518,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Ayana",
    		type: "First Name",
    		origin: "Russia",
    		continent: "Europe",
    		clean_name: "Ayana",
    		description: "Altai first name.",
    		bio: "",
    		search_term: "",
    		diameter: "13.8",
    		center_lat: -29.2,
    		center_long: 175.5
    	},
    	{
    		feature_id: 704,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Bernadette",
    		type: "First Name",
    		origin: "France",
    		continent: "Europe",
    		clean_name: "Bernadette",
    		description: "French first name.",
    		bio: "",
    		search_term: "",
    		diameter: "12.8",
    		center_lat: -46.6,
    		center_long: 285.6
    	},
    	{
    		feature_id: 723,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Bette",
    		type: "First Name",
    		origin: "Germany",
    		continent: "Europe",
    		clean_name: "Bette",
    		description: "German first name (form of Elizabeth).",
    		bio: "",
    		search_term: "",
    		diameter: "7.2",
    		center_lat: -24.6,
    		center_long: 347.9
    	},
    	{
    		feature_id: 962,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Caitlin",
    		type: "First Name",
    		origin: "Wales",
    		continent: "Europe",
    		clean_name: "Caitlin",
    		description: "Welsh first name.",
    		bio: "",
    		search_term: "",
    		diameter: "14.7",
    		center_lat: -65.3,
    		center_long: 12
    	},
    	{
    		feature_id: 1025,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Caroline",
    		type: "First Name",
    		origin: "France",
    		continent: "Europe",
    		clean_name: "Caroline",
    		description: "First name from French.",
    		bio: "",
    		search_term: "",
    		diameter: "18.0",
    		center_lat: 6.9,
    		center_long: 306.3
    	},
    	{
    		feature_id: 1191,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Chloe",
    		type: "First Name",
    		origin: "Greek",
    		continent: "Europe",
    		clean_name: "Chloe",
    		description: "First name from Greek.",
    		bio: "",
    		search_term: "",
    		diameter: "18.6",
    		center_lat: -7.4,
    		center_long: 98.6
    	},
    	{
    		feature_id: 1269,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Colleen",
    		type: "First Name",
    		origin: "Ireland",
    		continent: "Europe",
    		clean_name: "Colleen",
    		description: "Irish first name.",
    		bio: "",
    		search_term: "",
    		diameter: "13.5",
    		center_lat: -60.8,
    		center_long: 162.2
    	},
    	{
    		feature_id: 1408,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Danute",
    		type: "First Name",
    		origin: "Lithuania",
    		continent: "Europe",
    		clean_name: "Danute",
    		description: "Lithuanian first name.",
    		bio: "",
    		search_term: "",
    		diameter: "12.3",
    		center_lat: -63.5,
    		center_long: 56.5
    	},
    	{
    		feature_id: 1410,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Daphne",
    		type: "First Name",
    		origin: "Greek",
    		continent: "Europe",
    		clean_name: "Daphne",
    		description: "First name from Greek.",
    		bio: "",
    		search_term: "",
    		diameter: "15.5",
    		center_lat: 41.3,
    		center_long: 280.4
    	},
    	{
    		feature_id: 1414,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Darline",
    		type: "First Name",
    		origin: "England",
    		continent: "Europe",
    		clean_name: "Darline",
    		description: "Anglo-Saxon first name.",
    		bio: "",
    		search_term: "",
    		diameter: "13.0",
    		center_lat: -19.3,
    		center_long: 232.6
    	},
    	{
    		feature_id: 1582,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Doris",
    		type: "First Name",
    		origin: "Greek",
    		continent: "Europe",
    		clean_name: "Doris",
    		description: "First name from Greek.",
    		bio: "",
    		search_term: "",
    		diameter: "14.5",
    		center_lat: 2.3,
    		center_long: 90
    	},
    	{
    		feature_id: 1741,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Eileen",
    		type: "First Name",
    		origin: "Ireland",
    		continent: "Europe",
    		clean_name: "Eileen",
    		description: "Irish first name.",
    		bio: "",
    		search_term: "",
    		diameter: "16.1",
    		center_lat: -22.8,
    		center_long: 232.7
    	},
    	{
    		feature_id: 1761,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Elena",
    		type: "First Name",
    		origin: "Italy",
    		continent: "Europe",
    		clean_name: "Elena",
    		description: "Italian first name.",
    		bio: "",
    		search_term: "",
    		diameter: "17.6",
    		center_lat: -18.3,
    		center_long: 73.4
    	},
    	{
    		feature_id: 1786,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Elza",
    		type: "First Name",
    		origin: "Latvia",
    		continent: "Europe",
    		clean_name: "Elza",
    		description: "Latvian first name.",
    		bio: "",
    		search_term: "",
    		diameter: "18.0",
    		center_lat: -34.4,
    		center_long: 275.9
    	},
    	{
    		feature_id: 1830,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Erin",
    		type: "First Name",
    		origin: "Ireland",
    		continent: "Europe",
    		clean_name: "Erin",
    		description: "Irish first name.",
    		bio: "",
    		search_term: "",
    		diameter: "13.6",
    		center_lat: -47,
    		center_long: 184.8
    	},
    	{
    		feature_id: 1852,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Estelle",
    		type: "First Name",
    		origin: "Latin",
    		continent: "Europe",
    		clean_name: "Estelle",
    		description: "First name from Latin.",
    		bio: "",
    		search_term: "",
    		diameter: "18.8",
    		center_lat: 1.1,
    		center_long: 93.7
    	},
    	{
    		feature_id: 1882,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Evangeline",
    		type: "First Name",
    		origin: "Greek",
    		continent: "Europe",
    		clean_name: "Evangeline",
    		description: "First name from Greek.",
    		bio: "",
    		search_term: "",
    		diameter: "16.0",
    		center_lat: 69.6,
    		center_long: 221.9
    	},
    	{
    		feature_id: 1888,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Evika",
    		type: "First Name",
    		origin: "Russia",
    		continent: "Europe",
    		clean_name: "Evika",
    		description: "Tatar first name.",
    		bio: "",
    		search_term: "",
    		diameter: "20.3",
    		center_lat: -5.1,
    		center_long: 31.4
    	},
    	{
    		feature_id: 1899,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Faiga",
    		type: "First Name",
    		origin: "England",
    		continent: "Europe",
    		clean_name: "Faiga",
    		description: "Anglo-Saxon first name.",
    		bio: "",
    		search_term: "",
    		diameter: "9.6",
    		center_lat: 4.9,
    		center_long: 170.9
    	},
    	{
    		feature_id: 1913,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Farida",
    		type: "First Name",
    		origin: "Azerbaijan",
    		continent: "Europe",
    		clean_name: "Farida",
    		description: "Azeri first name.",
    		bio: "",
    		search_term: "",
    		diameter: "18.0",
    		center_lat: 4.8,
    		center_long: 39
    	},
    	{
    		feature_id: 1932,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Felicia",
    		type: "First Name",
    		origin: "Latin",
    		continent: "Europe",
    		clean_name: "Felicia",
    		description: "First name from Latin.",
    		bio: "",
    		search_term: "",
    		diameter: "11.5",
    		center_lat: -19.8,
    		center_long: 226.5
    	},
    	{
    		feature_id: 2010,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Francesca",
    		type: "First Name",
    		origin: "Italy",
    		continent: "Europe",
    		clean_name: "Francesca",
    		description: "Italian first name.",
    		bio: "",
    		search_term: "",
    		diameter: "17.0",
    		center_lat: -28,
    		center_long: 57.7
    	},
    	{
    		feature_id: 2165,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Gillian",
    		type: "First Name",
    		origin: "Latin",
    		continent: "Europe",
    		clean_name: "Gillian",
    		description: "First name from Latin.",
    		bio: "",
    		search_term: "",
    		diameter: "14.7",
    		center_lat: -15.2,
    		center_long: 50.1
    	},
    	{
    		feature_id: 2231,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Grace",
    		type: "First Name",
    		origin: "Greek",
    		continent: "Europe",
    		clean_name: "Grace",
    		description: "First name from Greek.",
    		bio: "",
    		search_term: "",
    		diameter: "19.0",
    		center_lat: -13.8,
    		center_long: 268.9
    	},
    	{
    		feature_id: 2240,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Gražina",
    		type: "First Name",
    		origin: "Lithuania",
    		continent: "Europe",
    		clean_name: "Gražina",
    		description: "Lithuanian first name.",
    		bio: "",
    		search_term: "",
    		diameter: "16.5",
    		center_lat: 72.4,
    		center_long: 337.5
    	},
    	{
    		feature_id: 2248,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Gretchen",
    		type: "First Name",
    		origin: "Germany",
    		continent: "Europe",
    		clean_name: "Gretchen",
    		description: "German first name.",
    		bio: "",
    		search_term: "",
    		diameter: "20.8",
    		center_lat: -59.7,
    		center_long: 212.3
    	},
    	{
    		feature_id: 2267,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Gudrun",
    		type: "First Name",
    		origin: "Norse",
    		continent: "Europe",
    		clean_name: "Gudrun",
    		description: "First name from Norse.",
    		bio: "",
    		search_term: "",
    		diameter: "13.3",
    		center_lat: 10.6,
    		center_long: 326.4
    	},
    	{
    		feature_id: 2399,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Heather",
    		type: "First Name",
    		origin: "England",
    		continent: "Europe",
    		clean_name: "Heather",
    		description: "English first name.",
    		bio: "",
    		search_term: "",
    		diameter: "11.5",
    		center_lat: -6.8,
    		center_long: 334.1
    	},
    	{
    		feature_id: 2412,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Heidi",
    		type: "First Name",
    		origin: "Latin",
    		continent: "Europe",
    		clean_name: "Heidi",
    		description: "First name; form of Hester.",
    		bio: "",
    		search_term: "",
    		diameter: "15.2",
    		center_lat: 23.6,
    		center_long: 350.1
    	},
    	{
    		feature_id: 2663,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Ilga",
    		type: "First Name",
    		origin: "Latvia",
    		continent: "Europe",
    		clean_name: "Ilga",
    		description: "Latvian first name.",
    		bio: "",
    		search_term: "",
    		diameter: "10.8",
    		center_lat: -12.4,
    		center_long: 307.3
    	},
    	{
    		feature_id: 2693,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Ingrid",
    		type: "First Name",
    		origin: "Scandinavian",
    		continent: "Europe",
    		clean_name: "Ingrid",
    		description: "Scandanavian first name.",
    		bio: "",
    		search_term: "",
    		diameter: "11.5",
    		center_lat: -12.4,
    		center_long: 308.9
    	},
    	{
    		feature_id: 2694,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Inira",
    		type: "First Name",
    		origin: "Russia",
    		continent: "Europe",
    		clean_name: "Inira",
    		description: "Eskimo first name.",
    		bio: "",
    		search_term: "",
    		diameter: "16.5",
    		center_lat: -43.1,
    		center_long: 239.4
    	},
    	{
    		feature_id: 2714,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Irene",
    		type: "First Name",
    		origin: "Greek",
    		continent: "Europe",
    		clean_name: "Irene",
    		description: "First name from Greek.",
    		bio: "",
    		search_term: "",
    		diameter: "13.6",
    		center_lat: 49.8,
    		center_long: 134
    	},
    	{
    		feature_id: 2783,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Jacqueline",
    		type: "First Name",
    		origin: "France",
    		continent: "Europe",
    		clean_name: "Jacqueline",
    		description: "First name from French.",
    		bio: "",
    		search_term: "",
    		diameter: "16.5",
    		center_lat: -70.1,
    		center_long: 123.6
    	},
    	{
    		feature_id: 2820,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Jennifer",
    		type: "First Name",
    		origin: "Greek",
    		continent: "Europe",
    		clean_name: "Jennifer",
    		description: "First name from Greek.",
    		bio: "",
    		search_term: "",
    		diameter: "9.6",
    		center_lat: -4.6,
    		center_long: 99.8
    	},
    	{
    		feature_id: 2831,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Jocelyn",
    		type: "First Name",
    		origin: "Germany",
    		continent: "Europe",
    		clean_name: "Jocelyn",
    		description: "German first name.",
    		bio: "",
    		search_term: "",
    		diameter: "14.0",
    		center_lat: -33.2,
    		center_long: 276.4
    	},
    	{
    		feature_id: 2852,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Juanita",
    		type: "First Name",
    		origin: "Spain",
    		continent: "Europe",
    		clean_name: "Juanita",
    		description: "Spanish first name.",
    		bio: "",
    		search_term: "",
    		diameter: "19.3",
    		center_lat: -62.8,
    		center_long: 90
    	},
    	{
    		feature_id: 2917,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Kanik",
    		type: "First Name",
    		origin: "Russia",
    		continent: "Europe",
    		clean_name: "Kanik",
    		description: "Sakhalin first name.",
    		bio: "",
    		search_term: "",
    		diameter: "16.5",
    		center_lat: -32.5,
    		center_long: 249.9
    	},
    	{
    		feature_id: 2984,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Kelly",
    		type: "First Name",
    		origin: "Celtic",
    		continent: "Europe",
    		clean_name: "Kelly",
    		description: "Gaelic first name.",
    		bio: "",
    		search_term: "",
    		diameter: "11.2",
    		center_lat: -4.8,
    		center_long: 359.2
    	},
    	{
    		feature_id: 3049,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Kiris",
    		type: "First Name",
    		origin: "Latvia",
    		continent: "Europe",
    		clean_name: "Kiris",
    		description: "Latvian first name.",
    		bio: "",
    		search_term: "",
    		diameter: "13.3",
    		center_lat: 20.9,
    		center_long: 98.8
    	},
    	{
    		feature_id: 3057,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Kitna",
    		type: "First Name",
    		origin: "Russia",
    		continent: "Europe",
    		clean_name: "Kitna",
    		description: "Kamchatka first name.",
    		bio: "",
    		search_term: "",
    		diameter: "15.3",
    		center_lat: -28.9,
    		center_long: 277.3
    	},
    	{
    		feature_id: 3336,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Leida",
    		type: "First Name",
    		origin: "Estonia",
    		continent: "Europe",
    		clean_name: "Leida",
    		description: "Estonian first name.",
    		bio: "",
    		search_term: "",
    		diameter: "18.8",
    		center_lat: -23.3,
    		center_long: 266.6
    	},
    	{
    		feature_id: 3347,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Lenore",
    		type: "First Name",
    		origin: "Greek",
    		continent: "Europe",
    		clean_name: "Lenore",
    		description: "Greek first name (form of Helen).",
    		bio: "",
    		search_term: "",
    		diameter: "15.5",
    		center_lat: 38.7,
    		center_long: 292.2
    	},
    	{
    		feature_id: 3361,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Letitia",
    		type: "First Name",
    		origin: "Latin",
    		continent: "Europe",
    		clean_name: "Letitia",
    		description: "First name from Latin.",
    		bio: "",
    		search_term: "",
    		diameter: "17.5",
    		center_lat: 34.5,
    		center_long: 288.7
    	},
    	{
    		feature_id: 3412,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Lineta",
    		type: "First Name",
    		origin: "Latvia",
    		continent: "Europe",
    		clean_name: "Lineta",
    		description: "Latvian first name.",
    		bio: "",
    		search_term: "",
    		diameter: "15.6",
    		center_lat: -5,
    		center_long: 354.1
    	},
    	{
    		feature_id: 3456,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Lois",
    		type: "First Name",
    		origin: "Greek",
    		continent: "Europe",
    		clean_name: "Lois",
    		description: "First name from Greek.",
    		bio: "",
    		search_term: "",
    		diameter: "13.5",
    		center_lat: -17.9,
    		center_long: 214.7
    	},
    	{
    		feature_id: 3473,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Loretta",
    		type: "First Name",
    		origin: "Latin",
    		continent: "Europe",
    		clean_name: "Loretta",
    		description: "First name from Latin.",
    		bio: "",
    		search_term: "",
    		diameter: "13.5",
    		center_lat: -19.7,
    		center_long: 202.6
    	},
    	{
    		feature_id: 3502,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Lucia",
    		type: "First Name",
    		origin: "Latin",
    		continent: "Europe",
    		clean_name: "Lucia",
    		description: "First name from Latin.",
    		bio: "",
    		search_term: "",
    		diameter: "16.0",
    		center_lat: -62.1,
    		center_long: 67.8
    	},
    	{
    		feature_id: 3531,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Lydia",
    		type: "First Name",
    		origin: "Greek",
    		continent: "Europe",
    		clean_name: "Lydia",
    		description: "First name from Greek.",
    		bio: "",
    		search_term: "",
    		diameter: "15.2",
    		center_lat: 10.7,
    		center_long: 340.7
    	},
    	{
    		feature_id: 3564,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Madeleine",
    		type: "First Name",
    		origin: "France",
    		continent: "Europe",
    		clean_name: "Madeleine",
    		description: "French first name.",
    		bio: "",
    		search_term: "",
    		diameter: "16.0",
    		center_lat: -4.7,
    		center_long: 293.2
    	},
    	{
    		feature_id: 3653,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Maranda",
    		type: "First Name",
    		origin: "Latvia",
    		continent: "Europe",
    		clean_name: "Maranda",
    		description: "Latvian first name.",
    		bio: "",
    		search_term: "",
    		diameter: "16.8",
    		center_lat: 4.9,
    		center_long: 169.7
    	},
    	{
    		feature_id: 3698,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Margarita",
    		type: "First Name",
    		origin: "Greek",
    		continent: "Europe",
    		clean_name: "Margarita",
    		description: "Greek first name.",
    		bio: "",
    		search_term: "",
    		diameter: "13.0",
    		center_lat: 12.7,
    		center_long: 9.2
    	},
    	{
    		feature_id: 3707,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Marie",
    		type: "First Name",
    		origin: "France",
    		continent: "Europe",
    		clean_name: "Marie",
    		description: "French first name.",
    		bio: "",
    		search_term: "",
    		diameter: "14.2",
    		center_lat: -21.7,
    		center_long: 232.4
    	},
    	{
    		feature_id: 3800,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Megan",
    		type: "First Name",
    		origin: "Wales",
    		continent: "Europe",
    		clean_name: "Megan",
    		description: "Welsh first name.",
    		bio: "",
    		search_term: "",
    		diameter: "15.8",
    		center_lat: -61.8,
    		center_long: 130.6
    	},
    	{
    		feature_id: 3809,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Melanie",
    		type: "First Name",
    		origin: "Greek",
    		continent: "Europe",
    		clean_name: "Melanie",
    		description: "First name from Greek.",
    		bio: "",
    		search_term: "",
    		diameter: "12.3",
    		center_lat: -62.8,
    		center_long: 144.3
    	},
    	{
    		feature_id: 3882,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Michelle",
    		type: "First Name",
    		origin: "France",
    		continent: "Europe",
    		clean_name: "Michelle",
    		description: "First name from French.",
    		bio: "",
    		search_term: "",
    		diameter: "15.0",
    		center_lat: -19.6,
    		center_long: 40.5
    	},
    	{
    		feature_id: 4075,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Muriel",
    		type: "First Name",
    		origin: "Greek",
    		continent: "Europe",
    		clean_name: "Muriel",
    		description: "First name from Greek.",
    		bio: "",
    		search_term: "",
    		diameter: "20.2",
    		center_lat: -41.7,
    		center_long: 12.4
    	},
    	{
    		feature_id: 4104,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Nadine",
    		type: "First Name",
    		origin: "France",
    		continent: "Europe",
    		clean_name: "Nadine",
    		description: "First name from French.",
    		bio: "",
    		search_term: "",
    		diameter: "18.6",
    		center_lat: 7.8,
    		center_long: 359.1
    	},
    	{
    		feature_id: 4286,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Nina",
    		type: "First Name",
    		origin: "Russia",
    		continent: "Europe",
    		clean_name: "Nina",
    		description: "First name from Russian.",
    		bio: "",
    		search_term: "",
    		diameter: "24.6",
    		center_lat: -55.5,
    		center_long: 238.7
    	},
    	{
    		feature_id: 4333,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Noreen",
    		type: "First Name",
    		origin: "Ireland",
    		continent: "Europe",
    		clean_name: "Noreen",
    		description: "Irish first name.",
    		bio: "",
    		search_term: "",
    		diameter: "18.6",
    		center_lat: 33.6,
    		center_long: 22.7
    	},
    	{
    		feature_id: 4439,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Olga",
    		type: "First Name",
    		origin: "Russia",
    		continent: "Europe",
    		clean_name: "Olga",
    		description: "Russian first name.",
    		bio: "",
    		search_term: "",
    		diameter: "15.5",
    		center_lat: 26.1,
    		center_long: 283.8
    	},
    	{
    		feature_id: 4568,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Pamela",
    		type: "First Name",
    		origin: "England",
    		continent: "Europe",
    		clean_name: "Pamela",
    		description: "English first name.",
    		bio: "",
    		search_term: "",
    		diameter: "14.2",
    		center_lat: 11,
    		center_long: 238.5
    	},
    	{
    		feature_id: 4632,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Peggy",
    		type: "First Name",
    		origin: "England",
    		continent: "Europe",
    		clean_name: "Peggy",
    		description: "English first name (form of Margaret).",
    		bio: "",
    		search_term: "",
    		diameter: "11.9",
    		center_lat: -20.4,
    		center_long: 357.2
    	},
    	{
    		feature_id: 4680,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Phaedra",
    		type: "First Name",
    		origin: "Greek",
    		continent: "Europe",
    		clean_name: "Phaedra",
    		description: "First name from Greek.",
    		bio: "",
    		search_term: "",
    		diameter: "15.7",
    		center_lat: 35.9,
    		center_long: 252.7
    	},
    	{
    		feature_id: 4715,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Phyllis",
    		type: "First Name",
    		origin: "Greek",
    		continent: "Europe",
    		clean_name: "Phyllis",
    		description: "First name from Greek.",
    		bio: "",
    		search_term: "",
    		diameter: "11.4",
    		center_lat: 12.3,
    		center_long: 132.4
    	},
    	{
    		feature_id: 4929,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Raisa",
    		type: "First Name",
    		origin: "Russia",
    		continent: "Europe",
    		clean_name: "Raisa",
    		description: "Russian first name.",
    		bio: "",
    		search_term: "",
    		diameter: "13.5",
    		center_lat: 27.5,
    		center_long: 280.3
    	},
    	{
    		feature_id: 5017,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Rhoda",
    		type: "First Name",
    		origin: "Greek",
    		continent: "Europe",
    		clean_name: "Rhoda",
    		description: "First name from Greek.",
    		bio: "",
    		search_term: "",
    		diameter: "12.2",
    		center_lat: 11.4,
    		center_long: 347.7
    	},
    	{
    		feature_id: 5188,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Rose",
    		type: "First Name",
    		origin: "Germany",
    		continent: "Europe",
    		clean_name: "Rose",
    		description: "German first name.",
    		bio: "",
    		search_term: "",
    		diameter: "15.5",
    		center_lat: -35.2,
    		center_long: 248.2
    	},
    	{
    		feature_id: 5203,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Rowena",
    		type: "First Name",
    		origin: "Celtic",
    		continent: "Europe",
    		clean_name: "Rowena",
    		description: "Celtic first name.",
    		bio: "",
    		search_term: "",
    		diameter: "19.5",
    		center_lat: 10.4,
    		center_long: 171.4
    	},
    	{
    		feature_id: 5260,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Sabira",
    		type: "First Name",
    		origin: "Russia",
    		continent: "Europe",
    		clean_name: "Sabira",
    		description: "Tatar first name.",
    		bio: "",
    		search_term: "",
    		diameter: "15.7",
    		center_lat: -5.8,
    		center_long: 239.9
    	},
    	{
    		feature_id: 5283,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Salika",
    		type: "First Name",
    		origin: "Russia",
    		continent: "Europe",
    		clean_name: "Salika",
    		description: "Mari first name.",
    		bio: "",
    		search_term: "",
    		diameter: "12.5",
    		center_lat: -5,
    		center_long: 97.7
    	},
    	{
    		feature_id: 5308,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Sanija",
    		type: "First Name",
    		origin: "Russia",
    		continent: "Europe",
    		clean_name: "Sanija",
    		description: "Tatar first name.",
    		bio: "",
    		search_term: "",
    		diameter: "18.0",
    		center_lat: 33.1,
    		center_long: 251
    	},
    	{
    		feature_id: 5457,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Shakira",
    		type: "First Name",
    		origin: "Russia",
    		continent: "Europe",
    		clean_name: "Shakira",
    		description: "Bashkir first name.",
    		bio: "",
    		search_term: "",
    		diameter: "17.6",
    		center_lat: 3,
    		center_long: 213.6
    	},
    	{
    		feature_id: 5649,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Sophia",
    		type: "First Name",
    		origin: "Greek",
    		continent: "Europe",
    		clean_name: "Sophia",
    		description: "First name from Greek.",
    		bio: "",
    		search_term: "",
    		diameter: "17.6",
    		center_lat: -28.6,
    		center_long: 18.8
    	},
    	{
    		feature_id: 5753,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Suliko",
    		type: "First Name",
    		origin: "Georgia",
    		continent: "Europe",
    		clean_name: "Suliko",
    		description: "Georgian first name.",
    		bio: "",
    		search_term: "",
    		diameter: "14.9",
    		center_lat: 9.6,
    		center_long: 214.6
    	},
    	{
    		feature_id: 5766,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Surija",
    		type: "First Name",
    		origin: "Azerbaijan",
    		continent: "Europe",
    		clean_name: "Surija",
    		description: "Azeri first name.",
    		bio: "",
    		search_term: "",
    		diameter: "15.3",
    		center_lat: 5.3,
    		center_long: 178.2
    	},
    	{
    		feature_id: 5827,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Taira",
    		type: "First Name",
    		origin: "Georgia",
    		continent: "Europe",
    		clean_name: "Taira",
    		description: "Osset first name.",
    		bio: "",
    		search_term: "",
    		diameter: "19.6",
    		center_lat: -1.6,
    		center_long: 296.8
    	},
    	{
    		feature_id: 5861,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Tanya",
    		type: "First Name",
    		origin: "Russia",
    		continent: "Europe",
    		clean_name: "Tanya",
    		description: "Russian first name.",
    		bio: "",
    		search_term: "",
    		diameter: "14.0",
    		center_lat: -19.3,
    		center_long: 282.7
    	},
    	{
    		feature_id: 5925,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Teresa",
    		type: "First Name",
    		origin: "Greek",
    		continent: "Europe",
    		clean_name: "Teresa",
    		description: "First name from Greek.",
    		bio: "",
    		search_term: "",
    		diameter: "14.8",
    		center_lat: -42.5,
    		center_long: 10
    	},
    	{
    		feature_id: 6106,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Tsiala",
    		type: "First Name",
    		origin: "Georgia",
    		continent: "Europe",
    		clean_name: "Tsiala",
    		description: "Georgian first name.",
    		bio: "",
    		search_term: "",
    		diameter: "16.5",
    		center_lat: 2.9,
    		center_long: 100
    	},
    	{
    		feature_id: 6289,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Vallija",
    		type: "First Name",
    		origin: "Latvia",
    		continent: "Europe",
    		clean_name: "Vallija",
    		description: "Latvian first name.",
    		bio: "",
    		search_term: "",
    		diameter: "15.2",
    		center_lat: 26.3,
    		center_long: 120
    	},
    	{
    		feature_id: 6360,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Veronica",
    		type: "First Name",
    		origin: "Latin",
    		continent: "Europe",
    		clean_name: "Veronica",
    		description: "First name from Latin.",
    		bio: "",
    		search_term: "",
    		diameter: "17.9",
    		center_lat: -38.1,
    		center_long: 124.6
    	},
    	{
    		feature_id: 6402,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Virginia",
    		type: "First Name",
    		origin: "Latin",
    		continent: "Europe",
    		clean_name: "Virginia",
    		description: "First name from Latin.",
    		bio: "",
    		search_term: "",
    		diameter: "18.5",
    		center_lat: -52.9,
    		center_long: 185.9
    	},
    	{
    		feature_id: 6408,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Virve",
    		type: "First Name",
    		origin: "Estonia",
    		continent: "Europe",
    		clean_name: "Virve",
    		description: "Estonian first name.",
    		bio: "",
    		search_term: "",
    		diameter: "18.0",
    		center_lat: -5.1,
    		center_long: 346.9
    	},
    	{
    		feature_id: 6689,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Yvonne",
    		type: "First Name",
    		origin: "France",
    		continent: "Europe",
    		clean_name: "Yvonne",
    		description: "French first name.",
    		bio: "",
    		search_term: "",
    		diameter: "14.5",
    		center_lat: -56,
    		center_long: 298.4
    	},
    	{
    		feature_id: 6736,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Zija",
    		type: "First Name",
    		origin: "Azerbaijan",
    		continent: "Europe",
    		clean_name: "Zija",
    		description: "Azeri first name.",
    		bio: "",
    		search_term: "",
    		diameter: "16.8",
    		center_lat: -3.5,
    		center_long: 265
    	},
    	{
    		feature_id: 24,
    		year: 1994,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Abundia Corona",
    		type: "Goddess",
    		origin: "Norse",
    		continent: "Europe",
    		clean_name: "Abundia",
    		description: "Norse goddess of giving.",
    		bio: "In ancient Roman religion, Abundantia, also called Abundita or Copia, was a divine personification of abundance and prosperity. The name Abundantia means plenty or riches.",
    		search_term: "Abundantia",
    		diameter: "250.0",
    		center_lat: 18.5,
    		center_long: 125
    	},
    	{
    		feature_id: 62,
    		year: 1994,
    		feature: "Farrum",
    		feature_plural: "Farra",
    		name: "Aegina Farrum",
    		type: "Goddess",
    		origin: "Greek",
    		continent: "Europe",
    		clean_name: "Aegina",
    		description: "Greek river nymph.",
    		bio: "Aegina was a figure of Greek mythology, the nymph of the island that bears her name. She is the mother of the hero Aeacus, who was born on the island and became its king. Through him, Aegina was the great-grandmother of Achilles.",
    		search_term: "Aegina (mythology)",
    		diameter: "60.0",
    		center_lat: 35.5,
    		center_long: 20.9
    	},
    	{
    		feature_id: 67,
    		year: 1994,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Aeracura Corona",
    		type: "Goddess",
    		origin: "Celtic",
    		continent: "Europe",
    		clean_name: "Aeracura",
    		description: "Celtic earth goddess.",
    		bio: "Erecura or Aerecura (also found as Herecura or Eracura) was a goddess worshipped in ancient times, often thought to be Celtic in origin, mostly represented with the attributes of Proserpina and associated with the Roman underworld god Dis Pater, as on an altar from Sulzbach.",
    		search_term: "Erecura",
    		diameter: "250.0",
    		center_lat: -19,
    		center_long: 238.5
    	},
    	{
    		feature_id: 90,
    		year: 1994,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Agraulos Corona",
    		type: "Goddess",
    		origin: "Greek",
    		continent: "Europe",
    		clean_name: "Agraulos",
    		description: "Greek fertility goddess.",
    		bio: "In Greek mythology, Aglaurus was an Athenian princess. Aglaurus was the daughter of King Cecrops and another Aglaurus, daughter of King Actaeus. She was the sister of Herse, Pandrosus and possibly, Erysichthon.",
    		search_term: "Aglaurus, daughter of Cecrops",
    		diameter: "170.0",
    		center_lat: -27.7,
    		center_long: 165.8
    	},
    	{
    		feature_id: 401,
    		year: 1994,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Artemis Corona",
    		type: "Goddess",
    		origin: "Greek",
    		continent: "Europe",
    		clean_name: "Artemis",
    		description: "Named from associated chasma.",
    		bio: "In ancient Greek mythology and religion, Artemis (; Greek: Ἄρτεμις) is the goddess of the hunt, the wilderness, wild animals, nature, vegetation, childbirth, care of children, and chastity. She was heavily identified with Selene, the Moon, and Hecate, another Moon goddess, and was thus regarded as one of the most prominent lunar deities in mythology, alongside the aforementioned two. She would often roam the forests of Greece, attended by her large entourage, mostly made up of nymphs, some mortals, and hunters.",
    		search_term: "Artemis",
    		diameter: "2,600.0",
    		center_lat: -35,
    		center_long: 135
    	},
    	{
    		feature_id: 467,
    		year: 1994,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Audhumla Corona",
    		type: "Goddess",
    		origin: "Norse",
    		continent: "Europe",
    		clean_name: "Audhumla",
    		description: "Norse primordial nourisher.",
    		bio: "In Norse mythology, Auðumbla is a primeval cow. The primordial frost jötunn Ymir fed from her milk, and over the course of three days she licked away the salty rime rocks and revealed Búri, grandfather of the gods and brothers Odin, Vili and Vé.",
    		search_term: "Auðumbla",
    		diameter: "225.0",
    		center_lat: 45.5,
    		center_long: 12
    	},
    	{
    		feature_id: 508,
    		year: 1994,
    		feature: "Vallis",
    		feature_plural: "Valles",
    		name: "Avfruvva Vallis",
    		type: "Goddess",
    		origin: "Finland",
    		continent: "Europe",
    		clean_name: "Avfruvva",
    		description: "Saami (Lapp) river goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "70.0",
    		center_lat: 2,
    		center_long: 70
    	},
    	{
    		feature_id: 665,
    		year: 1994,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Beiwe Corona",
    		type: "Goddess",
    		origin: "Finland",
    		continent: "Europe",
    		clean_name: "Beiwe",
    		description: "Saami (Lapp) fertility goddess.",
    		bio: "Beiwe is the Sami Sun-deity. The Sami Sun-deity is usually depicted as female, but sometimes as male. In Sápmi, north of the Polar circle, where the sun does not even reach the horizon in winter, the sun was widely venerated and played a major role in the cultic coherence. Beiwe is goddess of the sun, spring, and sanity, associated with the fertility of plants and animals, particularly reindeer.",
    		search_term: "Beiwe",
    		diameter: "600.0",
    		center_lat: 52.6,
    		center_long: 306.5
    	},
    	{
    		feature_id: 671,
    		year: 1994,
    		feature: "Vallis",
    		feature_plural: "Valles",
    		name: "Belisama Vallis",
    		type: "Goddess",
    		origin: "England",
    		continent: "Europe",
    		clean_name: "Belisama",
    		description: "English Celtic river goddess.",
    		bio: "Belisama is a Celtic goddess. The Gaulish theonym Belesama has been traditionally interpreted as meaning 'the Very Bright'.",
    		search_term: "Belisama",
    		diameter: "220.0",
    		center_lat: 50,
    		center_long: 22.5
    	},
    	{
    		feature_id: 766,
    		year: 1994,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Blai Corona",
    		type: "Goddess",
    		origin: "Celtic",
    		continent: "Europe",
    		clean_name: "Blai",
    		description: "Celtic fertility goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "125.0",
    		center_lat: -0.4,
    		center_long: 134.5
    	},
    	{
    		feature_id: 772,
    		year: 1994,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Blathnat Corona",
    		type: "Goddess",
    		origin: "Celtic",
    		continent: "Europe",
    		clean_name: "Blathnat",
    		description: "Celtic fertility goddess.",
    		bio: "Bláthnat (\"Little flower\"), sometimes Bláthíne, is a character in early Irish literature, a king's daughter, wife of the warrior Cú Roí and the lover of his rival Cú Chulainn.",
    		search_term: "Blathnat",
    		diameter: "300.0",
    		center_lat: 35,
    		center_long: 293.8
    	},
    	{
    		feature_id: 785,
    		year: 1994,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Boann Corona",
    		type: "Goddess",
    		origin: "Ireland",
    		continent: "Europe",
    		clean_name: "Boann",
    		description: "Irish fertility goddess.",
    		bio: "Boann or Boand is the Irish goddess of the River Boyne, a river in Ireland's historical fifth province. Her name is interpreted as \"white cow\".",
    		search_term: "Boann",
    		diameter: "300.0",
    		center_lat: 27,
    		center_long: 136.5
    	},
    	{
    		feature_id: 810,
    		year: 1994,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Bona Corona",
    		type: "Goddess",
    		origin: "Roman",
    		continent: "Europe",
    		clean_name: "Bona",
    		description: "Roman virgin/fertility goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "275.0",
    		center_lat: -24,
    		center_long: 157.5
    	},
    	{
    		feature_id: 885,
    		year: 1994,
    		feature: "Chasma",
    		feature_plural: "Chasmata",
    		name: "Britomartis Chasma",
    		type: "Goddess",
    		origin: "Greek",
    		continent: "Europe",
    		clean_name: "Britomartis",
    		description: "Greek/Cretan goddess of the hunt.",
    		bio: "Britomartis was a Greek goddess of mountains and hunting, who was primarily worshipped on the island of Crete. She was sometimes believed to be an oread, or a mountain nymph, but she was often conflated or syncretized with Artemis and Aphaea, the \"invisible\" patroness of Aegina. She is also known as Dictynna (Δίκτυννα; derived by Hellenistic writers as from δίκτυα [diktya], \"hunting nets\").",
    		search_term: "Britomartis",
    		diameter: "1,000.0",
    		center_lat: -33,
    		center_long: 130
    	},
    	{
    		feature_id: 959,
    		year: 1994,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Cailleach Corona",
    		type: "Goddess",
    		origin: "Scotland",
    		continent: "Europe",
    		clean_name: "Cailleach",
    		description: "Scottish Celtic fertility goddess.",
    		bio: "In Gaelic myth, the Cailleach is a divine hag and ancestor, associated with the creation of the landscape and with the weather, especially storms and winter. She displays several traits befitting the personification of winter: she herds deer, she fights spring, and her staff freezes the ground",
    		search_term: "Cailleach",
    		diameter: "125.0",
    		center_lat: -48,
    		center_long: 88.3
    	},
    	{
    		feature_id: 1021,
    		year: 1994,
    		feature: "Farrum",
    		feature_plural: "Farra",
    		name: "Carmenta Farra",
    		type: "Goddess",
    		origin: "Romania (Rumania)",
    		continent: "Europe",
    		clean_name: "Carmenta",
    		description: "Roman goddess of springs.",
    		bio: "In ancient Roman religion and myth, Carmenta was a goddess of childbirth and prophecy, associated with technological innovation as well as the protection of mothers and children and a patron of midwives. She was also said to have invented the Latin alphabet. The name Carmenta is derived from Latin carmen, meaning a magic spell, oracle or song, and also the root of the English word charm.",
    		search_term: "Carmenta",
    		diameter: "180.0",
    		center_lat: 12.4,
    		center_long: 8
    	},
    	{
    		feature_id: 1027,
    		year: 1994,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Carpo Corona",
    		type: "Goddess",
    		origin: "Greek",
    		continent: "Europe",
    		clean_name: "Carpo",
    		description: "Greek fertility goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "215.0",
    		center_lat: -37.5,
    		center_long: 3
    	},
    	{
    		feature_id: 1110,
    		year: 1994,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Ceres Corona",
    		type: "Goddess",
    		origin: "Roman",
    		continent: "Europe",
    		clean_name: "Ceres",
    		description: "Roman harvest goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "675.0",
    		center_lat: -16,
    		center_long: 151.5
    	},
    	{
    		feature_id: 1268,
    		year: 1994,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Colijnsplaat Corona",
    		type: "Goddess",
    		origin: "Teutonic",
    		continent: "Europe",
    		clean_name: "Colijnsplaat",
    		description: "Teutonic fertility goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "350.0",
    		center_lat: -32,
    		center_long: 151
    	},
    	{
    		feature_id: 1298,
    		year: 1994,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Copia Corona",
    		type: "Goddess",
    		origin: "Roman",
    		continent: "Europe",
    		clean_name: "Copia",
    		description: "Roman goddess of plenty.",
    		bio: "",
    		search_term: "",
    		diameter: "500.0",
    		center_lat: -42.5,
    		center_long: 75.5
    	},
    	{
    		feature_id: 1730,
    		year: 1994,
    		feature: "Farrum",
    		feature_plural: "Farra",
    		name: "Egeria Farrum",
    		type: "Goddess",
    		origin: "Romania (Rumania)",
    		continent: "Europe",
    		clean_name: "Egeria",
    		description: "Roman water nymph.",
    		bio: "",
    		search_term: "",
    		diameter: "40.0",
    		center_lat: 43.6,
    		center_long: 7.5
    	},
    	{
    		feature_id: 1736,
    		year: 1994,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Eigin Corona",
    		type: "Goddess",
    		origin: "Celtic",
    		continent: "Europe",
    		clean_name: "Eigin",
    		description: "Celtic fertility goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "200.0",
    		center_lat: -5,
    		center_long: 175
    	},
    	{
    		feature_id: 1818,
    		year: 1994,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Epona Corona",
    		type: "Goddess",
    		origin: "Celtic",
    		continent: "Europe",
    		clean_name: "Epona",
    		description: "Celtic horse/fertility goddess.",
    		bio: "In Gallo-Roman religion, Epona was a protector of horses, ponies, donkeys, and mules. She was particularly a goddess of fertility, as shown by her attributes of a patera, cornucopia, ears of grain and the presence of foals in some sculptures. She and her horses might also have been leaders of the soul in the after-life ride, with later literary parallels in Rhiannon of the Mabinogion.",
    		search_term: "Epona",
    		diameter: "225.0",
    		center_lat: -28,
    		center_long: 208.5
    	},
    	{
    		feature_id: 1834,
    		year: 1994,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Erkir Corona",
    		type: "Goddess",
    		origin: "Armenia",
    		continent: "Europe",
    		clean_name: "Erkir",
    		description: "Armenian earth goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "275.0",
    		center_lat: -16.3,
    		center_long: 233.7
    	},
    	{
    		feature_id: 1877,
    		year: 1994,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Eurynome Corona",
    		type: "Goddess",
    		origin: "Greek",
    		continent: "Europe",
    		clean_name: "Eurynome",
    		description: "Greek mother earth goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "200.0",
    		center_lat: 26.5,
    		center_long: 94.5
    	},
    	{
    		feature_id: 1917,
    		year: 1994,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Fatua Corona",
    		type: "Goddess",
    		origin: "Roman",
    		continent: "Europe",
    		clean_name: "Fatua",
    		description: "Roman goddess of fertility.",
    		bio: "",
    		search_term: "",
    		diameter: "400.0",
    		center_lat: -16.3,
    		center_long: 17.7
    	},
    	{
    		feature_id: 1985,
    		year: 1994,
    		feature: "Farrum",
    		feature_plural: "Farra",
    		name: "Flosshilde Farra",
    		type: "Goddess",
    		origin: "Germany",
    		continent: "Europe",
    		clean_name: "Flosshilde",
    		description: "German water nymph.",
    		bio: "The Rhinemaidens are the three water-nymphs who appear in Richard Wagner's opera cycle \"Der Ring des Nibelungen.\" Their individual names are Woglinde, Wellgunde and Flosshilde (Floßhilde), although they are generally treated as a single entity and they act together accordingly. Wagner created his Rhinemaidens from other legends and myths. It is reported that Wagner played the Rhinemaidens' lament at the piano on the night before he died in Venice, in 1883.",
    		search_term: "Flosshilde",
    		diameter: "75.0",
    		center_lat: 10.5,
    		center_long: 279.4
    	},
    	{
    		feature_id: 2000,
    		year: 1994,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Fotla Corona",
    		type: "Goddess",
    		origin: "Celtic",
    		continent: "Europe",
    		clean_name: "Fotla",
    		description: "Celtic fertility goddess.",
    		bio: "In Irish mythology, Fódla or Fótla (modern spelling: Fódhla, Fodhla or Fóla), daughter of Delbáeth and Ernmas of the Tuatha Dé Danann, was one of the tutelary giantesses of Ireland. Her husband was Mac Cecht. With her sisters, Banba and Ériu, she was part of an important triumvirate of goddesses.",
    		search_term: "Fotla",
    		diameter: "150.0",
    		center_lat: -58.5,
    		center_long: 163.5
    	},
    	{
    		feature_id: 2059,
    		year: 1994,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Gaia Corona",
    		type: "Goddess",
    		origin: "Greek",
    		continent: "Europe",
    		clean_name: "Gaia",
    		description: "Greek earth/fertility goddess.",
    		bio: "In Greek mythology, Gaia is the personification of the Earth and one of the Greek primordial deities. Gaia is the ancestral mother—sometimes parthenogenic—of all life. She is the mother of Uranus (the sky), from whose sexual union she bore the Titans (themselves parents of many of the Olympian gods), the Cyclopes, and the Giants; as well as of Pontus (the sea), from whose union she bore the primordial sea gods.",
    		search_term: "Gaia",
    		diameter: "400.0",
    		center_lat: 6,
    		center_long: 21.5
    	},
    	{
    		feature_id: 2130,
    		year: 1994,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Gefjun Corona",
    		type: "Goddess",
    		origin: "Norse",
    		continent: "Europe",
    		clean_name: "Gefjun",
    		description: "Norse fertility goddess.",
    		bio: "In Norse mythology, Gefjon is a goddess associated with ploughing, the Danish island of Zealand, the legendary Swedish king Gylfi, the legendary Danish king Skjöldr, foreknowledge, her oxen children, and virginity. The Prose Edda and Heimskringla both report that Gefjon plowed away what is now lake Mälaren, Sweden, and with this land formed the island of Zealand, Denmark.",
    		search_term: "Gefjun",
    		diameter: "300.0",
    		center_lat: -33.5,
    		center_long: 98.5
    	},
    	{
    		feature_id: 2307,
    		year: 1994,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Habonde Corona",
    		type: "Goddess",
    		origin: "Denmark",
    		continent: "Europe",
    		clean_name: "Habonde",
    		description: "Danish goddess of abundance.",
    		bio: "",
    		search_term: "",
    		diameter: "125.0",
    		center_lat: 3,
    		center_long: 81.8
    	},
    	{
    		feature_id: 2454,
    		year: 1994,
    		feature: "Fluctus",
    		feature_plural: "Fluctūs",
    		name: "Henwen Fluctus",
    		type: "Goddess",
    		origin: "England",
    		continent: "Europe",
    		clean_name: "Henwen",
    		description: "British Celtic sow-goddess.",
    		bio: "Henwen, meaning \"Old White\", is in Welsh legend a sow (female pig) which according to the Welsh Triads gave birth to Cath Palug, a monstrous cat depicted as combating with either Cai (Sir Kay) or King Arthur of Arthurian Legends.",
    		search_term: "Henwen",
    		diameter: "485.0",
    		center_lat: -20.5,
    		center_long: 179.9
    	},
    	{
    		feature_id: 2538,
    		year: 1994,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Holde Corona",
    		type: "Goddess",
    		origin: "Germany",
    		continent: "Europe",
    		clean_name: "Holde",
    		description: "German fertility goddess.",
    		bio: "Frau Holle",
    		search_term: "Holde",
    		diameter: "200.0",
    		center_lat: 53.5,
    		center_long: 155.8
    	},
    	{
    		feature_id: 2651,
    		year: 1994,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Idem-Kuva Corona",
    		type: "Goddess",
    		origin: "Finland",
    		continent: "Europe",
    		clean_name: "Idem-Kuva",
    		description: "Finno-Ugraic harvest spirit.",
    		bio: "",
    		search_term: "",
    		diameter: "230.0",
    		center_lat: 25,
    		center_long: 358
    	},
    	{
    		feature_id: 2653,
    		year: 1994,
    		feature: "Mons",
    		feature_plural: "Montes",
    		name: "Idunn Mons",
    		type: "Goddess",
    		origin: "Norse",
    		continent: "Europe",
    		clean_name: "Idunn",
    		description: "Norse goddess.",
    		bio: "In Norse mythology, Iðunn is a goddess associated with apples and youth. She is described as the wife of the skaldic god Bragi, and in the Prose Edda, also as a keeper of apples and granter of eternal youthfulness.",
    		search_term: "Idunn",
    		diameter: "250.0",
    		center_lat: -46.5,
    		center_long: 214.5
    	},
    	{
    		feature_id: 2665,
    		year: 1994,
    		feature: "Mons",
    		feature_plural: "Montes",
    		name: "Ilithyia Mons",
    		type: "Goddess",
    		origin: "Greek",
    		continent: "Europe",
    		clean_name: "Ilithyia",
    		description: "Greek goddess of childbirth.",
    		bio: "Ilithyia was the Greek goddess of childbirth and midwifery, and the daughter of Zeus and Hera. As the primary goddess of childbirth along with Artemis, Eileithyia had numerous shrines in many locations in Greece dating from Neolithic to Roman times, indicating that she was extremely important to pregnant women and their families. People would pray for and leave offerings for aid in fertility, safe childbirth, or give appreciation for a successful birth.",
    		search_term: "Ilithyia",
    		diameter: "90.0",
    		center_lat: -13.5,
    		center_long: 315.5
    	},
    	{
    		feature_id: 2764,
    		year: 1994,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Iweridd Corona",
    		type: "Goddess",
    		origin: "England",
    		continent: "Europe",
    		clean_name: "Iweridd",
    		description: "Brythonic (English Celtic) earth goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "500.0",
    		center_lat: -21,
    		center_long: 310
    	},
    	{
    		feature_id: 2812,
    		year: 1994,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Javine Corona",
    		type: "Goddess",
    		origin: "Lithuania",
    		continent: "Europe",
    		clean_name: "Javine",
    		description: "Lithuanian harvest goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "450.0",
    		center_lat: -5.5,
    		center_long: 251.2
    	},
    	{
    		feature_id: 2844,
    		year: 1994,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Jord Corona",
    		type: "Goddess",
    		origin: "Norse",
    		continent: "Europe",
    		clean_name: "Jord",
    		description: "Norse earth goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "130.0",
    		center_lat: -58.5,
    		center_long: 349.5
    	},
    	{
    		feature_id: 3126,
    		year: 1994,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Krumine Corona",
    		type: "Goddess",
    		origin: "Lithuania",
    		continent: "Europe",
    		clean_name: "Krumine",
    		description: "Lithuanian food goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "300.0",
    		center_lat: -5,
    		center_long: 261.5
    	},
    	{
    		feature_id: 3159,
    		year: 1994,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Kunhild Corona",
    		type: "Goddess",
    		origin: "Germany",
    		continent: "Europe",
    		clean_name: "Kunhild",
    		description: "German fertility maiden.",
    		bio: "",
    		search_term: "",
    		diameter: "200.0",
    		center_lat: 19.3,
    		center_long: 80.1
    	},
    	{
    		feature_id: 3384,
    		year: 1994,
    		feature: "Farrum",
    		feature_plural: "Farra",
    		name: "Liban Farra",
    		type: "Goddess",
    		origin: "Ireland",
    		continent: "Europe",
    		clean_name: "Liban",
    		description: "Irish water goddess.",
    		bio: "Lí Ban or Liban, in the legend surrounding the formation of Lough Neagh, was a woman turned mermaid who inhabited the area before the great lake gushed up on dry land. Her family was drowned, but she survived in an underwater chamber in the lake for a year, after which she was transformed into a being who was half-human, half-salmon. She forfeited 300 years of longevity for a Christian soul.",
    		search_term: "Lí Ban (mermaid)",
    		diameter: "100.0",
    		center_lat: -23.9,
    		center_long: 353.5
    	},
    	{
    		feature_id: 3386,
    		year: 1994,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Libera Corona",
    		type: "Goddess",
    		origin: "Roman",
    		continent: "Europe",
    		clean_name: "Libera",
    		description: "Roman fertility goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "350.0",
    		center_lat: 12.5,
    		center_long: 24
    	},
    	{
    		feature_id: 3547,
    		year: 1994,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Maa-Ema Corona",
    		type: "Goddess",
    		origin: "Estonia",
    		continent: "Europe",
    		clean_name: "Maa-Ema",
    		description: "Estonian harvest goddess.",
    		bio: "Akka is a female spirit in Sami shamanism, and Finnish and Estonian mythology. Her worship is common and took the forms of sacrifice, prayer and various other rituals. Some Sámi believe she lived under their tents.",
    		search_term: "Maa-Ema",
    		diameter: "300.0",
    		center_lat: 40.8,
    		center_long: 102.5
    	},
    	{
    		feature_id: 3704,
    		year: 1994,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Mari Corona",
    		type: "Goddess",
    		origin: "Greek",
    		continent: "Europe",
    		clean_name: "Mari",
    		description: "Cretan goddess of plenty.",
    		bio: "",
    		search_term: "",
    		diameter: "200.0",
    		center_lat: 54,
    		center_long: 151
    	},
    	{
    		feature_id: 3832,
    		year: 1994,
    		feature: "Collis",
    		feature_plural: "Colles",
    		name: "Mena Colles",
    		type: "Goddess",
    		origin: "Roman",
    		continent: "Europe",
    		clean_name: "Mena",
    		description: "Roman goddess of menses.",
    		bio: "",
    		search_term: "",
    		diameter: "850.0",
    		center_lat: -52.5,
    		center_long: 160
    	},
    	{
    		feature_id: 3865,
    		year: 1994,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Mesca Corona",
    		type: "Goddess",
    		origin: "Ireland",
    		continent: "Europe",
    		clean_name: "Mesca",
    		description: "Irish fertility goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "190.0",
    		center_lat: 27,
    		center_long: 342.6
    	},
    	{
    		feature_id: 4193,
    		year: 1994,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Nehalennia Corona",
    		type: "Goddess",
    		origin: "Teutonic",
    		continent: "Europe",
    		clean_name: "Nehalennia",
    		description: "Teutonic fertility goddess.",
    		bio: "Nehalennia (spelled variously) is a goddess of unclear origin, perhaps Germanic or Celtic. Nehalennia is almost always depicted with marine symbols and a large, benign-looking dog at her feet. She must have been a Celtic or Germanic deity, who was attributed power over trading, shipping, and possible horticulture and fertility.",
    		search_term: "Nehalennia",
    		diameter: "345.0",
    		center_lat: 14,
    		center_long: 10
    	},
    	{
    		feature_id: 4383,
    		year: 1994,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Oanuava Coronae",
    		type: "Goddess",
    		origin: "France",
    		continent: "Europe",
    		clean_name: "Oanuava",
    		description: "Gaulish Celtic earth goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "375.0",
    		center_lat: -32.5,
    		center_long: 255.5
    	},
    	{
    		feature_id: 4448,
    		year: 1994,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Olwen Corona",
    		type: "Goddess",
    		origin: "Celtic",
    		continent: "Europe",
    		clean_name: "Olwen",
    		description: "Brythonic goddess of spring growth.",
    		bio: "In Welsh mythology, Olwen (or Olwyn) is the daughter of the giant Ysbaddaden and cousin of Goreu. She is the heroine of the story Culhwch and Olwen in the Mabinogion. Her father is fated to die if she ever marries, so when Culhwch (sometimes spelled as Kilhwch) comes to court her, he is given a series of immensely difficult tasks which he must complete before he can win her hand.",
    		search_term: "Olwen",
    		diameter: "175.0",
    		center_lat: 37.5,
    		center_long: 67.5
    	},
    	{
    		feature_id: 4652,
    		year: 1994,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Perchta Corona",
    		type: "Goddess",
    		origin: "Germany",
    		continent: "Europe",
    		clean_name: "Perchta",
    		description: "German fertility goddess.",
    		bio: "Perchta was once known as a goddess in Alpine paganism in the Upper German and Austrian regions of the Alps. In some descriptions, Perchta has two forms; she may appear either as beautiful and white as snow like her name, or as elderly and haggard. In many old descriptions, Perchta had one large foot, sometimes called a goose foot or swan foot. Grimm thought the strange foot symbolized her being a higher being who could shapeshift to animal form.",
    		search_term: "Perchta",
    		diameter: "500.0",
    		center_lat: 17,
    		center_long: 234.5
    	},
    	{
    		feature_id: 4890,
    		year: 1994,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Pölöznitsa Corona",
    		type: "Goddess",
    		origin: "Finland",
    		continent: "Europe",
    		clean_name: "Pölöznitsa",
    		description: "Finno-Ugric grain goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "675.0",
    		center_lat: 0.5,
    		center_long: 302
    	},
    	{
    		feature_id: 5190,
    		year: 1994,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Rosmerta Corona",
    		type: "Goddess",
    		origin: "Celtic",
    		continent: "Europe",
    		clean_name: "Rosmerta",
    		description: "Celtic fertility/luck goddess.",
    		bio: "In Gallo-Roman religion, Rosmerta was a goddess of fertility and abundance, her attributes being those of plenty such as the cornucopia. Rosmerta is attested by statues and by inscriptions. In Gaul she was often depicted with the Roman god Mercury as her consort, but is sometimes found independently.",
    		search_term: "Rosmerta",
    		diameter: "300.0",
    		center_lat: 0,
    		center_long: 124.5
    	},
    	{
    		feature_id: 5340,
    		year: 1994,
    		feature: "Dorsum",
    		feature_plural: "Dorsa",
    		name: "Saule Dorsa",
    		type: "Goddess",
    		origin: "Lithuania",
    		continent: "Europe",
    		clean_name: "Saule",
    		description: "Lithuanian and Latvian sun goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "1,375.0",
    		center_lat: -58,
    		center_long: 206
    	},
    	{
    		feature_id: 5409,
    		year: 1994,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Seia Corona",
    		type: "Goddess",
    		origin: "Roman",
    		continent: "Europe",
    		clean_name: "Seia",
    		description: "Roman grain goddess.",
    		bio: "Seia is the goddess who protects the seed once sown in the earth; also known as Fructesea, compounded with fructus, \"produce, fruit\".",
    		search_term: "List of Roman agricultural deities",
    		diameter: "225.0",
    		center_lat: -3,
    		center_long: 153
    	},
    	{
    		feature_id: 5584,
    		year: 1994,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Sith Corona",
    		type: "Goddess",
    		origin: "Norse",
    		continent: "Europe",
    		clean_name: "Sith",
    		description: "Norse harvest goddess.",
    		bio: "In Norse mythology, Sif (or Sith) is a golden-haired goddess associated with earth. Scholars have proposed that Sif's hair may represent fields of golden wheat, that she may be associated with fertility, family, wedlock and/or that she is connected to rowan, and that there may be an allusion to her role or possibly her name in the Old English poem Beowulf.",
    		search_term: "Sif",
    		diameter: "350.0",
    		center_lat: -10.2,
    		center_long: 176.5
    	},
    	{
    		feature_id: 5590,
    		year: 1994,
    		feature: "Mons",
    		feature_plural: "Montes",
    		name: "Skadi Mons",
    		type: "Goddess",
    		origin: "Norse",
    		continent: "Europe",
    		clean_name: "Skadi",
    		description: "Norse mountain goddess.",
    		bio: "In Norse mythology, Skaði is a jötunn and goddess associated with bowhunting, skiing, winter, and mountains. Skaði may have once been a personification of the geographical region of Scandinavia or associated with the underworld.",
    		search_term: "Skadi",
    		diameter: "40.0",
    		center_lat: 64,
    		center_long: 4
    	},
    	{
    		feature_id: 5844,
    		year: 1994,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Tamfana Corona",
    		type: "Goddess",
    		origin: "Norse",
    		continent: "Europe",
    		clean_name: "Tamfana",
    		description: "Norse fertility goddess.",
    		bio: "In Germanic paganism, Tamfana is a goddess. The destruction of a temple dedicated to the goddess is recorded by Roman senator Tacitus to have occurred during a massacre of the Germanic Marsi by forces led by Roman general Germanicus.",
    		search_term: "Tamfana",
    		diameter: "400.0",
    		center_lat: -36.3,
    		center_long: 6
    	},
    	{
    		feature_id: 6156,
    		year: 1994,
    		feature: "Mons",
    		feature_plural: "Montes",
    		name: "Tuulikki Mons",
    		type: "Goddess",
    		origin: "Finland",
    		continent: "Europe",
    		clean_name: "Tuulikki",
    		description: "Finnish wood goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "520.0",
    		center_lat: 10.3,
    		center_long: 274.7
    	},
    	{
    		feature_id: 6272,
    		year: 1994,
    		feature: "Dorsum",
    		feature_plural: "Dorsa",
    		name: "Vaiva Dorsum",
    		type: "Goddess",
    		origin: "Lithuania",
    		continent: "Europe",
    		clean_name: "Vaiva",
    		description: "Lithaunian rainbow goddess.",
    		bio: "Vaiva is a Lithuanian female given name of Baltic origin. It is a shortening of vaivorykštė (English rainbow). A rainbow was considered one of the manifestations of the Pagan destiny goddess Laima.",
    		search_term: "Vaiva",
    		diameter: "520.0",
    		center_lat: -53.2,
    		center_long: 204
    	},
    	{
    		feature_id: 6352,
    		year: 1994,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Verdandi Corona",
    		type: "Goddess",
    		origin: "Norse",
    		continent: "Europe",
    		clean_name: "Verdandi",
    		description: "Norse bestower of blessings.",
    		bio: "In Norse mythology, Verðandi (Old Norse, meaning possibly \"happening\" or \"present\") is one of the norns. Along with Urðr (Old Norse \"fate\") and Skuld (possibly \"debt\" or \"future\"), Verðandi makes up a trio of Norns that are described as deciding the fates (wyrd) of people.",
    		search_term: "Verdandi",
    		diameter: "180.0",
    		center_lat: -5.5,
    		center_long: 65.2
    	},
    	{
    		feature_id: 6944,
    		year: 1994,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Žemina Corona",
    		type: "Goddess",
    		origin: "Lithuania",
    		continent: "Europe",
    		clean_name: "Žemina",
    		description: "Lithuanian fertility goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "530.0",
    		center_lat: -11.7,
    		center_long: 186
    	},
    	{
    		feature_id: 6745,
    		year: 1994,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Zisa Corona",
    		type: "Goddess",
    		origin: "Germany",
    		continent: "Europe",
    		clean_name: "Zisa",
    		description: "German harvest goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "850.0",
    		center_lat: 12,
    		center_long: 221
    	},
    	{
    		feature_id: 6014,
    		year: 1994,
    		feature: "Planitia",
    		feature_plural: "Planitiae",
    		name: "Tinatin Planitia",
    		type: "Heroine",
    		origin: "Georgia",
    		continent: "Europe",
    		clean_name: "Tinatin ",
    		description: "Georgian epic heroine.",
    		bio: "Tinatin is a character in \"The Knight in the Panther's Skin\", a Georgian medieval epic poem written in the 12th or 13th century. The King of Arabia, Rostevan, has no sons and confers the kingship on his only daughter, the beautiful and wise Tinatin.",
    		search_term: "The Knight in the Panther's Skin",
    		diameter: "2,500.0",
    		center_lat: -2,
    		center_long: 16
    	},
    	{
    		feature_id: 2899,
    		year: 1994,
    		feature: "Vallis",
    		feature_plural: "Valles",
    		name: "Kallistos Vallis",
    		type: "Other",
    		origin: "Greek",
    		continent: "Europe",
    		clean_name: "Kallistos ",
    		description: "Ancient Greek name for planet Venus.",
    		bio: "",
    		search_term: "",
    		diameter: "900.0",
    		center_lat: -51.1,
    		center_long: 21.5
    	},
    	{
    		feature_id: 5551,
    		year: 1994,
    		feature: "Vallis",
    		feature_plural: "Valles",
    		name: "Sinann Vallis",
    		type: "Other",
    		origin: "Ireland",
    		continent: "Europe",
    		clean_name: "Sinann ",
    		description: "Irish river goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "425.0",
    		center_lat: -49,
    		center_long: 270
    	},
    	{
    		feature_id: 6274,
    		year: 1994,
    		feature: "Vallis",
    		feature_plural: "Valles",
    		name: "Vakarine Vallis",
    		type: "Other",
    		origin: "Lithuania",
    		continent: "Europe",
    		clean_name: "Vakarine ",
    		description: "Lithuanian word for planet Venus.",
    		bio: "",
    		search_term: "",
    		diameter: "625.0",
    		center_lat: 5,
    		center_long: 336.4
    	},
    	{
    		feature_id: 5275,
    		year: 1994,
    		feature: "Vallis",
    		feature_plural: "Valles",
    		name: "Saga Vallis",
    		type: "Other",
    		origin: "Norse",
    		continent: "Europe",
    		clean_name: "Saga ",
    		description: "Norse goddess in the form of a waterfall.",
    		bio: "",
    		search_term: "",
    		diameter: "450.0",
    		center_lat: 76.1,
    		center_long: 340.6
    	},
    	{
    		feature_id: 1277,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Comnena",
    		type: "Famous Woman",
    		origin: "Byzantine",
    		continent: "Multiple",
    		clean_name: "Comnena",
    		description: "Anna; Byzantine princess, physician, writer (1083-1148).",
    		bio: "Anna Komnene (Greek: Ἄννα Κομνηνή, romanized: Ánna Komnēnḗ; 1 December 1083 – 1153), commonly Latinized as Anna Comnena, was a Byzantine princess and author of the Alexiad, an account of the reign of her father, the Byzantine emperor, Alexios I Komnenos. The Alexiad is the most important primary source of Byzantine history of the late 11th and early 12th centuries. Although she is best known as the author of the Alexiad, Anna played an important part in the politics of the time and attempted to depose her brother, John II Komnenos, as emperor and seize the throne herself.",
    		search_term: "Anna Komnene",
    		diameter: "19.5",
    		center_lat: 1.2,
    		center_long: 343.7
    	},
    	{
    		feature_id: 1862,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Eudocia",
    		type: "Famous Woman",
    		origin: "Byzantine",
    		continent: "Multiple",
    		clean_name: "Eudocia",
    		description: "Byzantine empress (c. 401-460).",
    		bio: "Aelia Eudocia Augusta (; Greek: Αιλία Ευδοκία Αυγούστα; c. 401 – 460 AD), also called Saint Eudocia, was an Eastern Roman empress by marriage to Emperor Theodosius II (r. 408–450), and a prominent Greek historical figure in understanding the rise of Christianity during the beginning of the Byzantine Empire.",
    		search_term: "Aelia Eudocia",
    		diameter: "27.5",
    		center_lat: -59.1,
    		center_long: 202
    	},
    	{
    		feature_id: 1916,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Fatima",
    		type: "First Name",
    		origin: "Semitic",
    		continent: "Multiple",
    		clean_name: "Fatima",
    		description: "Arabic first name.",
    		bio: "",
    		search_term: "",
    		diameter: "14.5",
    		center_lat: -17.8,
    		center_long: 31.9
    	},
    	{
    		feature_id: 3337,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Leila",
    		type: "First Name",
    		origin: "Semitic",
    		continent: "Multiple",
    		clean_name: "Leila",
    		description: "First name from Arabic.",
    		bio: "",
    		search_term: "",
    		diameter: "18.8",
    		center_lat: -44.2,
    		center_long: 86.8
    	},
    	{
    		feature_id: 5289,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Samantha",
    		type: "First Name",
    		origin: "Semitic",
    		continent: "Multiple",
    		clean_name: "Samantha",
    		description: "First name from Aramaic.",
    		bio: "",
    		search_term: "",
    		diameter: "16.9",
    		center_lat: 45.6,
    		center_long: 281.7
    	},
    	{
    		feature_id: 6366,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Vesna",
    		type: "First Name",
    		origin: "Slavic",
    		continent: "Multiple",
    		clean_name: "Vesna",
    		description: "Slavic first name.",
    		bio: "",
    		search_term: "",
    		diameter: "14.9",
    		center_lat: -60.3,
    		center_long: 220.5
    	},
    	{
    		feature_id: 1494,
    		year: 1994,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Derceto Corona",
    		type: "Goddess",
    		origin: "Semitic",
    		continent: "Multiple",
    		clean_name: "Derceto",
    		description: "Phillistine fertility goddess.",
    		bio: "Atargatis was the chief goddess of northern Syria in Classical antiquity. Ctesias also used the name Derketo (Koinē Greek: Δερκετὼ) for her, and the Romans called her Dea Syria, or in one word Deasura. Primarily she was a fertility goddess, but, as the baalat (\"mistress\") of her city and people she was also responsible for their protection and well-being.",
    		search_term: "Derceto",
    		diameter: "200.0",
    		center_lat: -46.8,
    		center_long: 20.2
    	},
    	{
    		feature_id: 2683,
    		year: 1994,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Inanna Corona",
    		type: "Goddess",
    		origin: "Semitic",
    		continent: "Multiple",
    		clean_name: "Inanna",
    		description: "Semitic fertility goddess.",
    		bio: "Inanna is an ancient Mesopotamian goddess of love, war, and fertility. She is also associated with beauty, sex, divine justice, and political power. She was originally worshiped in Sumer under the name \"Inanna\", and later by the Akkadians, Babylonians, and Assyrians under the name Ishtar. he was associated with the planet Venus and her most prominent symbols included the lion and the eight-pointed star. ",
    		search_term: "Inanna",
    		diameter: "350.0",
    		center_lat: -37,
    		center_long: 35.9
    	},
    	{
    		feature_id: 6752,
    		year: 1994,
    		feature: "Tholus",
    		feature_plural: "Tholi",
    		name: "Zorya Tholus",
    		type: "Goddess",
    		origin: "Slavic",
    		continent: "Multiple",
    		clean_name: "Zorya",
    		description: "Slavic dawn goddess.",
    		bio: "Zorya is a figure in Slavic folklore, a feminine personification of dawn, possibly goddess. She is often depicted as the sister of the Sun, the Moon, and Zvezda, the Morning Star with which she is sometimes identified. She lives in the Palace of the Sun, opens the gate for him in the morning so that he can set off on a journey through the sky, guards his white horses, she is also described as a virgin.",
    		search_term: "Zorya",
    		diameter: "22.0",
    		center_lat: -9.4,
    		center_long: 335.3
    	},
    	{
    		feature_id: 50,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Addams",
    		type: "Famous Woman",
    		origin: "United States",
    		continent: "North America",
    		clean_name: "Addams",
    		description: "Jane; American social reformer (1860-1935).",
    		bio: "Laura Jane Addams (September 6, 1860 – May 21, 1935) was an American settlement activist, reformer, social worker, sociologist, public administrator, and author. She was an important leader in the history of social work and women's suffrage in the United States and advocated for world peace. She co-founded Chicago's Hull House, one of America's most famous settlement houses.",
    		search_term: "Jane Addams",
    		diameter: "87.0",
    		center_lat: -56.2,
    		center_long: 98.9
    	},
    	{
    		feature_id: 118,
    		year: 1994,
    		feature: "Patera",
    		feature_plural: "Paterae",
    		name: "Aitchison Patera",
    		type: "Famous Woman",
    		origin: "United States",
    		continent: "North America",
    		clean_name: "Aitchison",
    		description: "Alison; American geographer.",
    		bio: "",
    		search_term: "",
    		diameter: "28.0",
    		center_lat: -16.7,
    		center_long: 349.4
    	},
    	{
    		feature_id: 126,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Akeley",
    		type: "Famous Woman",
    		origin: "United States",
    		continent: "North America",
    		clean_name: "Akeley",
    		description: "Delia; American explorer (1875-1970).",
    		bio: "Delia Julia 'Mickie' Akeley (née Denning, formerly Reiss, later Howe; December 5, 1869 – May 22, 1970) was an American explorer. She was one of the first westerners to explore the desert between Kenya and Ethiopia, and she explored the Tana River in a dugout canoe, entering it from the Indian Ocean. She also lived for several months with the pygmies of the Ituri Forest, Zaire.",
    		search_term: "Delia Akeley",
    		diameter: "23.4",
    		center_lat: 8,
    		center_long: 244.5
    	},
    	{
    		feature_id: 564,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Baker",
    		type: "Famous Woman",
    		origin: "United States",
    		continent: "North America",
    		clean_name: "Baker",
    		description: "Josephine; American expatriate dancer, singer (1906-1975).",
    		bio: "Josephine Baker (born Freda Josephine McDonald; naturalised French Joséphine Baker; 3 June 1906 – 12 April 1975) was an American-born French dancer, singer and actress. Her career was centered primarily in Europe, mostly in her adopted France. She was the first black woman to star in a major motion picture, the 1927 silent film Siren of the Tropics, directed by Mario Nalpas and Henri Étiévant. During her early career, Baker was among the most celebrated performers to headline the revues of the Folies Bergère in Paris.",
    		search_term: "Josephine Baker",
    		diameter: "109.0",
    		center_lat: 62.5,
    		center_long: 40.3
    	},
    	{
    		feature_id: 572,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Balch",
    		type: "Famous Woman",
    		origin: "United States",
    		continent: "North America",
    		clean_name: "Balch",
    		description: "Emily; American economist, Nobel laureate (1867-1961).",
    		bio: "Emily Greene Balch (January 8, 1867 – January 9, 1961) was an American economist, sociologist and pacifist. Balch combined an academic career at Wellesley College with a long-standing interest in social issues such as poverty, child labor, and immigration, as well as settlement work to uplift poor immigrants and reduce juvenile delinquency. She moved into the peace movement at the start of World War I in 1914, and began collaborating with Jane Addams of Chicago.",
    		search_term: "Emily Greene Balch",
    		diameter: "40.0",
    		center_lat: 29.9,
    		center_long: 282.9
    	},
    	{
    		feature_id: 618,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Barrymore",
    		type: "Famous Woman",
    		origin: "United States",
    		continent: "North America",
    		clean_name: "Barrymore",
    		description: "Ethel; American actress (1879-1959).",
    		bio: "Ethel Barrymore (born Ethel Mae Blythe; August 15, 1879 – June 18, 1959) was an American actress and a member of the Barrymore family of actors. Barrymore was a stage, screen and radio actress whose career spanned six decades, and was regarded as 'The First Lady of the American Theatre'. She received four nominations for the Academy Award for Best Supporting Actress, winning for None but the Lonely Heart (1944).",
    		search_term: "Ethel Barrymore",
    		diameter: "56.6",
    		center_lat: -52.3,
    		center_long: 195.7
    	},
    	{
    		feature_id: 626,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Bascom",
    		type: "Famous Woman",
    		origin: "United States",
    		continent: "North America",
    		clean_name: "Bascom",
    		description: "Florence; American geologist (1862-1945).",
    		bio: "Florence Bascom (July 14, 1862 – June 18, 1945) was an American pioneer for women as a geologist and educator. Bascom became an anomaly in the 19th century when she earned two bachelor's degrees. Earning a Bachelor of Arts in 1882, and a Bachelor of Science in 1884 both at the University of Wisconsin.",
    		search_term: "Florence Bascom",
    		diameter: "34.6",
    		center_lat: -10.4,
    		center_long: 302.2
    	},
    	{
    		feature_id: 657,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Beecher",
    		type: "Famous Woman",
    		origin: "United States",
    		continent: "North America",
    		clean_name: "Beecher",
    		description: "Catherine; American educator, author (1800-1878).",
    		bio: "Catharine Esther Beecher (September 6, 1800 – May 12, 1878) was an American educator known for her forthright opinions on female education as well as her vehement support of the many benefits of the incorporation of kindergarten into children's education. She published the advice manual The American Woman's Home with her sister Harriet Beecher Stowe in 1869.",
    		search_term: "Catherine Beecher",
    		diameter: "40.4",
    		center_lat: 13,
    		center_long: 253.4
    	},
    	{
    		feature_id: 738,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Bickerdyke",
    		type: "Famous Woman",
    		origin: "United States",
    		continent: "North America",
    		clean_name: "Bickerdyke",
    		description: "Mary; American Civil War nurse (1817-1901).",
    		bio: "Mary Ann Bickerdyke (July 19, 1817 – November 8, 1901), also known as Mother Bickerdyke, was a hospital administrator for Union soldiers during the American Civil War and a lifelong advocate for veterans. She was responsible for establishing 300 field hospitals during the war and served as a lawyer assisting veterans and their families with obtaining pensions after the war.",
    		search_term: "Mary Ann Bickerdyke",
    		diameter: "36.3",
    		center_lat: -82,
    		center_long: 171.3
    	},
    	{
    		feature_id: 782,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Bly",
    		type: "Famous Woman",
    		origin: "United States",
    		continent: "North America",
    		clean_name: "Bly",
    		description: "Nellie; American journalist (1867-1892).",
    		bio: "Elizabeth Cochran Seaman (born Elizabeth Jane Cochran; May 5, 1864 – January 27, 1922), better known by her pen name Nellie Bly, was an American journalist, industrialist, inventor, and charity worker who was widely known for her record-breaking trip around the world in 72 days, in emulation of Jules Verne's fictional character Phileas Fogg, and an exposé in which she worked undercover to report on a mental institution from within. She was a pioneer in her field and launched a new kind of investigative journalism.",
    		search_term: "Nellie Bly",
    		diameter: "18.7",
    		center_lat: 37.7,
    		center_long: 305.5
    	},
    	{
    		feature_id: 816,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Bonnin",
    		type: "Famous Woman",
    		origin: "United States",
    		continent: "North America",
    		clean_name: "Bonnin",
    		description: "Bonnin, Gertrude Simmons; Dakota reformer, writer (1875-1938).",
    		bio: "Zitkala-Ša (Lakota: Zitkála-Šá, meaning Red Bird) (February 22, 1876 – January 26, 1938), also known by her missionary and married name, Gertrude Simmons Bonnin, was a Yankton Dakota writer, editor, translator, musician, educator, and political activist. She wrote several works chronicling her struggles with cultural identity, and the pull between the majority culture in which she was educated, and the Dakota culture into which she was born and raised. Her later books were among the first works to bring traditional Native American stories to a widespread white English-speaking readership.",
    		search_term: "Zitkala-Sa",
    		diameter: "28.5",
    		center_lat: -6.3,
    		center_long: 117.6
    	},
    	{
    		feature_id: 849,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Boyd",
    		type: "Famous Woman",
    		origin: "United States",
    		continent: "North America",
    		clean_name: "Boyd",
    		description: "Louise; American explorer (1887-1972).",
    		bio: "Louise Arner Boyd (September 16, 1887 – September 14, 1972) was an American explorer of Greenland and the Arctic, who wrote extensively of her scientific expeditions, and became the first woman to fly over the North Pole in 1955, after privately chartering a DC-4 and crew that included aviation pioneers Thor Solberg and Paul Mlinar.",
    		search_term: "Louise Arner Boyd",
    		diameter: "22.0",
    		center_lat: -39.4,
    		center_long: 221.4
    	},
    	{
    		feature_id: 856,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Bradstreet",
    		type: "Famous Woman",
    		origin: "United States",
    		continent: "North America",
    		clean_name: "Bradstreet",
    		description: "Anne; American poet (c. 1612-1672).",
    		bio: "Anne Bradstreet (née Dudley; March 20, 1612 – September 16, 1672) was the most prominent of early English poets of North America and first writer in England's North American colonies to be published. She is the first Puritan figure in American Literature and notable for her large corpus of poetry, as well as personal writings published posthumously.",
    		search_term: "Anne Bradstreet",
    		diameter: "36.0",
    		center_lat: 16.5,
    		center_long: 47.7
    	},
    	{
    		feature_id: 971,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Caldwell",
    		type: "Famous Woman",
    		origin: "United States",
    		continent: "North America",
    		clean_name: "Caldwell",
    		description: "Taylor; American author (1900-1985).",
    		bio: "Janet Miriam Caldwell (September 7, 1900 – August 30, 1985) was a British-born American novelist and prolific author of popular fiction under the pen names Taylor Caldwell, Marcus Holland and Max Reiner. As a writer Caldwell was praised for her intricately plotted and suspenseful stories, which depicted family tensions and the development of the U.S. from an agrarian society into the leading industrial state of the world.",
    		search_term: "Taylor Caldwell",
    		diameter: "51.0",
    		center_lat: 23.6,
    		center_long: 112.4
    	},
    	{
    		feature_id: 1028,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Carr",
    		type: "Famous Woman",
    		origin: "Canada",
    		continent: "North America",
    		clean_name: "Carr",
    		description: "Emily; Canadian artist (1871-1945).",
    		bio: "Emily Carr (or M. Emily Carr as she sometimes signed her work) (December 13, 1871 – March 2, 1945) was a Canadian artist and writer who was inspired by the Indigenous peoples of the Pacific Northwest Coast. One of the first painters in Canada to adopt a Modernist and Post-Impressionist style, Carr did not receive widespread recognition for her work until she changed her subject matter from Aboriginal themes to landscapes — forest scenes in particular, evoking primeval grandeur. As a writer Carr was one of the earliest chroniclers of life in British Columbia.",
    		search_term: "Emily Carr",
    		diameter: "31.9",
    		center_lat: -24,
    		center_long: 295.7
    	},
    	{
    		feature_id: 1036,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Carter",
    		type: "Famous Woman",
    		origin: "United States",
    		continent: "North America",
    		clean_name: "Carter",
    		description: "Maybelle; American singer, songwriter (1909-1978).",
    		bio: "Mother' Maybelle Carter (born Maybelle Addington; May 10, 1909 – October 23, 1978) was an American country musician and 'was among the first' to use the Carter scratch, with which she 'helped to turn the guitar into a lead instrument'. It was named after her. She was a member of the original Carter Family act from the late 1920s until the early 1940s, and was a member of the Carter Sisters and Mother Maybelle.",
    		search_term: "Maybelle Carter",
    		diameter: "17.5",
    		center_lat: 5.3,
    		center_long: 67.3
    	},
    	{
    		feature_id: 1244,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Cline",
    		type: "Famous Woman",
    		origin: "United States",
    		continent: "North America",
    		clean_name: "Cline",
    		description: "Patsy; American singer (1932-1963).",
    		bio: "Patsy Cline (born Virginia Patterson Hensley; September 8, 1932 – March 5, 1963) was an American singer. She is considered one of the most influential vocalists of the 20th century and was one of the first country music artists to cross over into pop music. Cline had several major hits during her eight-year recording career, including two number-one hits on the Billboard Hot Country and Western Sides chart.",
    		search_term: "Patsy Cline",
    		diameter: "38.0",
    		center_lat: -21.8,
    		center_long: 317.1
    	},
    	{
    		feature_id: 1423,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Datsolalee",
    		type: "Famous Woman",
    		origin: "United States",
    		continent: "North America",
    		clean_name: "Datsolalee",
    		description: "Washo Indian artist, basket maker (1835-1925).",
    		bio: "Louisa Keyser, or Dat So La Lee (ca. 1829 - December 6, 1925) was a celebrated Native American basket weaver. A member of the Washoe people in northwestern Nevada, her basketry came to national prominence during the Arts and Crafts movement and the 'basket craze' of the early 20th century.",
    		search_term: "Dat So La Lee",
    		diameter: "17.5",
    		center_lat: 38.3,
    		center_long: 171.8
    	},
    	{
    		feature_id: 1450,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "De Witt",
    		type: "Famous Woman",
    		origin: "United States",
    		continent: "North America",
    		clean_name: "De Witt",
    		description: "Lydia; American pathologist (1859-1928).",
    		bio: "Lydia Maria DeWitt (née Adams; February 1, 1859 – March 10, 1928) was an American pathologist and anatomist. Lydia Maria Adams was born in Flint, Michigan to Oscar and Elizabeth (née Walton) Adams, the second of three children. Her father was an attorney.",
    		search_term: "Lydia DeWitt",
    		diameter: "20.7",
    		center_lat: -6.5,
    		center_long: 275.6
    	},
    	{
    		feature_id: 1551,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Dix",
    		type: "Famous Woman",
    		origin: "United States",
    		continent: "North America",
    		clean_name: "Dix",
    		description: "Dorothea; American nurse, reformer (1802-1887).",
    		bio: "Dorothea Lynde Dix (April 4, 1802 – July 17, 1887) was an American advocate on behalf of the indigent mentally ill who, through a vigorous and sustained program of lobbying state legislatures and the United States Congress, created the first generation of American mental asylums. During the Civil War, she served as a Superintendent of Army Nurses. Born in the town of Hampden, Maine, she grew up in Worcester, Massachusetts among her parents' relatives.",
    		search_term: "Dorothea Dix",
    		diameter: "63.3",
    		center_lat: -37,
    		center_long: 329
    	},
    	{
    		feature_id: 1671,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Durant",
    		type: "Famous Woman",
    		origin: "United States",
    		continent: "North America",
    		clean_name: "Durant",
    		description: "Ariel; American writer (1898-1981).",
    		bio: "Ariel Durant (; May 10, 1898 – October 25, 1981) was a Russian-born American researcher and writer. She was the coauthor of The Story of Civilization with her husband, Will Durant. They were awarded the Pulitzer Prize for General Non-Fiction.",
    		search_term: "Ariel Durant",
    		diameter: "21.1",
    		center_lat: -62.3,
    		center_long: 227.7
    	},
    	{
    		feature_id: 1722,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Edinger",
    		type: "Famous Woman",
    		origin: "United States",
    		continent: "North America",
    		clean_name: "Edinger",
    		description: "Tilly; American geologist (1897-1967).",
    		bio: "Johanna Gabrielle Ottilie 'Tilly' Edinger (13 November 1897 – 27 May 1967) was a German-American paleontologist and the founder of paleoneurology. = = Tilly Edinger was born to a wealthy Jewish family in 1897. Her father, Ludwig Edinger, founded Frankfurt's first neurological research institute, providing Edinger with multiple contacts in the scientific community that helped drive her career.",
    		search_term: "Tilly Edinger",
    		diameter: "33.3",
    		center_lat: -68.8,
    		center_long: 208.5
    	},
    	{
    		feature_id: 1998,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Fossey",
    		type: "Famous Woman",
    		origin: "United States",
    		continent: "North America",
    		clean_name: "Fossey",
    		description: "Dian; American zoologist, conservationist (1932-1985).",
    		bio: "Dian Fossey (, January 16, 1932 – c. December 26, 1985) was an American primatologist and conservationist known for undertaking an extensive study of mountain gorilla groups from 1966 until her murder in 1985. She studied them daily in the mountain forests of Rwanda, initially encouraged to work there by paleoanthropologist Louis Leakey. Gorillas in the Mist, a book published two years before her death, is Fossey's account of her scientific study of the gorillas at Karisoke Research Center and prior career.",
    		search_term: "Dian Fossey",
    		diameter: "30.4",
    		center_lat: 2,
    		center_long: 188.7
    	},
    	{
    		feature_id: 2183,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Glaspell",
    		type: "Famous Woman",
    		origin: "United States",
    		continent: "North America",
    		clean_name: "Glaspell",
    		description: "Susan; American playwright, novelist (c. 1876-1948).",
    		bio: "Susan Keating Glaspell (July 1, 1876 – July 28, 1948) was an American playwright, novelist, journalist and actress. With her husband George Cram Cook, she founded the Provincetown Players, the first modern American theatre company.First known for her short stories (fifty were published), Glaspell also wrote nine novels, fifteen plays, and a biography. Often set in her native Midwest, these semi-autobiographical tales typically explore contemporary social issues, such as gender, ethics, and dissent, while featuring deep, sympathetic characters who make principled stands.",
    		search_term: "Susan Glaspell",
    		diameter: "26.3",
    		center_lat: -58.4,
    		center_long: 269.6
    	},
    	{
    		feature_id: 2253,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Grimke",
    		type: "Famous Woman",
    		origin: "United States",
    		continent: "North America",
    		clean_name: "Grimke",
    		description: "Sarah; American abolitionist (1792-1873).",
    		bio: "Sarah Moore Grimké (November 26, 1792 – December 23, 1873) was an American abolitionist, widely held to be the mother of the women's suffrage movement.: xxi Born and reared in South Carolina to a prominent, wealthy planter family, she moved to Philadelphia, Pennsylvania, in the 1820s and became a Quaker, as did her younger sister Angelina. The sisters began to speak on the abolitionist lecture circuit, joining a tradition of women who had been speaking in public on political issues since colonial days, including Susanna Wright, Hannah Griffitts, Susan B. Anthony, Elizabeth Cady Stanton, and Anna Dickinson. They recounted their knowledge of slavery firsthand, urged abolition, and also became activists for women's rights.",
    		search_term: "Sarah Moore Grimké",
    		diameter: "34.8",
    		center_lat: 17.2,
    		center_long: 215.3
    	},
    	{
    		feature_id: 2352,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Hansberry",
    		type: "Famous Woman",
    		origin: "Mandan",
    		continent: "North America",
    		clean_name: "Hansberry",
    		description: "Lorraine; American playwright (1930-1965).",
    		bio: "Lorraine Vivian Hansberry (May 19, 1930 – January 12, 1965) was a playwright and writer. She was the first African-American female author to have a play performed on Broadway. Her best-known work, the play A Raisin in the Sun, highlights the lives of black Americans in Chicago living under racial segregation.",
    		search_term: "Lorraine Hansberry",
    		diameter: "26.6",
    		center_lat: -22.7,
    		center_long: 324.1
    	},
    	{
    		feature_id: 2499,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Higgins",
    		type: "Famous Woman",
    		origin: "United States",
    		continent: "North America",
    		clean_name: "Higgins",
    		description: "Marguerite; American journalist (1920-1966).",
    		bio: "Marguerite Higgins Hall (September 3, 1920 – January 3, 1966) was an American reporter and war correspondent. Higgins covered World War II, the Korean War, and the Vietnam War, and in the process advanced the cause of equal access for female war correspondents. She had a long career with the New York Herald Tribune (1942–1963), and later, as a syndicated columnist for Newsday (1963–1965).",
    		search_term: "Marguerite Higgins",
    		diameter: "40.0",
    		center_lat: 8.1,
    		center_long: 241.3
    	},
    	{
    		feature_id: 2564,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Howe",
    		type: "Famous Woman",
    		origin: "United States",
    		continent: "North America",
    		clean_name: "Howe",
    		description: "Julia; American biographer, poet (1819-1910).",
    		bio: "Julia Ward Howe (; May 27, 1819 – October 17, 1910) was an American author and poet, known for writing the 'Battle Hymn of the Republic' and the original 1870 pacifist Mother's Day Proclamation. She was also an advocate for abolitionism and a social activist, particularly for women's suffrage. Julia Ward was born in New York City.",
    		search_term: "Julia Ward Howe",
    		diameter: "38.6",
    		center_lat: -45.7,
    		center_long: 174.8
    	},
    	{
    		feature_id: 2578,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Hull",
    		type: "Famous Woman",
    		origin: "United States",
    		continent: "North America",
    		clean_name: "Hull",
    		description: "Peggy; American war correspondent (1889-1967).",
    		bio: "Peggy Hull (December 30, 1889 – June 19, 1967), was the pen name of Henrietta Eleanor Goodnough Deuell, an American journalist who covered World War I and World War II. She was the first female correspondent accredited by the U. S. War Department. Henrietta Goodnough was born in Bennington, Kansas. Her first newspaper job was at the Junction City Daily Sentinel in Junction City, Kansas.",
    		search_term: "Peggy Hull",
    		diameter: "47.3",
    		center_lat: 59.4,
    		center_long: 263.6
    	},
    	{
    		feature_id: 2589,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Hurston",
    		type: "Famous Woman",
    		origin: "United States",
    		continent: "North America",
    		clean_name: "Hurston",
    		description: "Zora; American writer, anthropologist (1891-1960).",
    		bio: "Zora Neale Hurston (January 7, 1891: 17 : 5 – January 28, 1960) was an American author, anthropologist, and filmmaker. She portrayed racial struggles in the early-1900s American South and published research on hoodoo. The most popular of her four novels is Their Eyes Were Watching God, published in 1937.",
    		search_term: "Zora Neale Hurston",
    		diameter: "52.4",
    		center_lat: -77.6,
    		center_long: 94.7
    	},
    	{
    		feature_id: 2886,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Kahlo",
    		type: "Famous Woman",
    		origin: "Mexico",
    		continent: "North America",
    		clean_name: "Kahlo",
    		description: "Frida; Mexican artist (1910-1954).",
    		bio: "Magdalena Carmen Frida Kahlo y Calderón (Spanish pronunciation: [ˈfɾiða ˈkalo]; 6 July 1907 – 13 July 1954) was a Mexican painter known for her many portraits, self-portraits, and works inspired by the nature and artifacts of Mexico. Inspired by the country's popular culture, she employed a naïve folk art style to explore questions of identity, postcolonialism, gender, class, and race in Mexican society. Her paintings often had strong autobiographical elements and mixed realism with fantasy.",
    		search_term: "Frida Kahlo",
    		diameter: "35.6",
    		center_lat: -59.9,
    		center_long: 178.9
    	},
    	{
    		feature_id: 2887,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Kaikilani",
    		type: "Famous Woman",
    		origin: "Hawaii",
    		continent: "North America",
    		clean_name: "Kaikilani",
    		description: "First female ruler of Hawaii (c. 1555).",
    		bio: "Kaikilani (16th-century-17th-century), was a High Chiefess and ruler Aliʻi Nui of Hawaiʻi island. She was a legendary figure in Hawaiian native oral tradition who dates to around the 16th century in the western calendar. She was married to Lonoikamakahiki (not to be confused with the god Lono) who was heir to the throne of the main island, the moiship.",
    		search_term: "Kaikilani",
    		diameter: "19.9",
    		center_lat: -32.8,
    		center_long: 163.2
    	},
    	{
    		feature_id: 2981,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Kelea",
    		type: "Famous Woman",
    		origin: "Hawaii",
    		continent: "North America",
    		clean_name: "Kelea",
    		description: "Chieftess of Maui (c. 1450).",
    		bio: "Keleanohoanaapiapi, short name Kelea, was an ancient Hawaiian noblewoman who is mentioned in ancient legends, and her genealogy is given in chants. She was a Princess (Hawaiian language: Aliʻi) of Maui, one of the Hawaiian Islands. She was a High Chiefess, but not of the highest known rank.",
    		search_term: "Keleanohoanaapiapi",
    		diameter: "24.5",
    		center_lat: 8.9,
    		center_long: 25.6
    	},
    	{
    		feature_id: 3309,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Lazarus",
    		type: "Famous Woman",
    		origin: "United States",
    		continent: "North America",
    		clean_name: "Lazarus",
    		description: "Emma; American poet (1849-1887).",
    		bio: "Emma Lazarus (July 22, 1849 – November 19, 1887) was an American author of poetry, prose, and translations, as well as an activist for Jewish and Georgist causes. She is remembered for writing the sonnet 'The New Colossus', which was inspired by the Statue of Liberty, in 1883. Its lines appear inscribed on a bronze plaque, installed in 1903, on the pedestal of the Statue of Liberty.",
    		search_term: "Emma Lazarus",
    		diameter: "24.2",
    		center_lat: -52.9,
    		center_long: 127.2
    	},
    	{
    		feature_id: 3351,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Leonard",
    		type: "Famous Woman",
    		origin: "United States",
    		continent: "North America",
    		clean_name: "Leonard",
    		description: "Wrexie Louise; American assistant to Percival Lowell (1867-1937).",
    		bio: "Wrexie Leonard (September 15, 1867 – November 9, 1937), also known as Louise Leonard, was an American astronomer who worked as an assistant to Percival Lowell and published her observations of Mars. A crater on Venus is named for her. Wrexie Louise Leonard was raised in Troy, Pennsylvania, and later moved to Boston.",
    		search_term: "Wrexie Leonard",
    		diameter: "31.7",
    		center_lat: -73.8,
    		center_long: 185.2
    	},
    	{
    		feature_id: 3442,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Lockwood",
    		type: "Famous Woman",
    		origin: "United States",
    		continent: "North America",
    		clean_name: "Lockwood",
    		description: "Belva; American lawyer, feminist (1830-1917).",
    		bio: "Belva Ann Bennett Lockwood (October 24, 1830 – May 19, 1917) was an American attorney, politician, educator, and author. She was active in working for women's rights, including women's suffrage. Lockwood overcame many social and personal obstacles related to gender restrictions.",
    		search_term: "Belva Lockwood",
    		diameter: "22.0",
    		center_lat: -32.9,
    		center_long: 51.6
    	},
    	{
    		feature_id: 3536,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Lyon",
    		type: "Famous Woman",
    		origin: "United States",
    		continent: "North America",
    		clean_name: "Lyon",
    		description: "Mary; American educator, college president (1797-1849).",
    		bio: "Mary Mason Lyon (; February 28, 1797 – March 5, 1849) was an American pioneer in women's education. She established the Wheaton Female Seminary in Norton, Massachusetts, (now Wheaton College) in 1834. She then established Mount Holyoke Female Seminary (now Mount Holyoke College) in South Hadley, Massachusetts, in 1837 and served as its first president (or 'principal') for 12 years.",
    		search_term: "Mary Lyon",
    		diameter: "12.4",
    		center_lat: -66.5,
    		center_long: 270.6
    	},
    	{
    		feature_id: 3611,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Maltby",
    		type: "Famous Woman",
    		origin: "United States",
    		continent: "North America",
    		clean_name: "Maltby",
    		description: "Margaret; American physicist (1860-1944).",
    		bio: "Margaret Eliza Maltby (10 December 1860 – 3 May 1944) was an American physicist notable for measurement of high electrolytic resistances and conductivity of very dilute solutions. Maltby was the first woman to be awarded a Bachelors of Science (B.S.) degree from MIT, where she had to enroll as a 'special' student, because the institution did not accept female students. Maltby was also the first woman to be awarded a PhD in Physics from the University of Göttingen in 1895.Maltby was also a great advocate for physics, teaching physics courses specially tailored for non-physicists.",
    		search_term: "Margaret Eliza Maltby",
    		diameter: "36.6",
    		center_lat: -23.3,
    		center_long: 119.7
    	},
    	{
    		feature_id: 3727,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Martinez",
    		type: "Famous Woman",
    		origin: "Pueblo",
    		continent: "North America",
    		clean_name: "Martinez",
    		description: "Maria; Pueblo artist, potter (1886-1980).",
    		bio: "Maria Montoya Martinez (1887, San Ildefonso Pueblo, New Mexico – July 20, 1980, San Ildefonso Pueblo) was a Native American artist who created internationally known pottery. Martinez (born Maria Poveka Montoya), her husband Julian, and other family members, including her son Popovi Da, examined traditional Pueblo pottery styles and techniques to create pieces which reflect the Pueblo people's legacy of fine artwork and crafts. The works of Maria Martinez, and especially her black ware pottery, survive in many museums, including the Smithsonian, the Metropolitan Museum of Art, the Denver Art Museum, and more.",
    		search_term: "Maria Martinez",
    		diameter: "23.5",
    		center_lat: -11.7,
    		center_long: 174.7
    	},
    	{
    		feature_id: 4027,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Moore",
    		type: "Famous Woman",
    		origin: "United States",
    		continent: "North America",
    		clean_name: "Moore",
    		description: "Marianne; American poet, editor (1887-1972).",
    		bio: "Marianne Craig Moore (November 15, 1887 – February 5, 1972) was an American modernist poet, critic, translator, and editor. Her poetry is noted for formal innovation, precise diction, irony, and wit. Moore was born in Kirkwood, Missouri, in the manse of the Presbyterian church where her maternal grandfather, John Riddle Warner, served as pastor.",
    		search_term: "Marianne Moore",
    		diameter: "21.1",
    		center_lat: -30.4,
    		center_long: 248.4
    	},
    	{
    		feature_id: 4056,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Mowatt",
    		type: "Famous Woman",
    		origin: "United States",
    		continent: "North America",
    		clean_name: "Mowatt",
    		description: "Anna; American actress, playwright, author (1819-1870).",
    		bio: "Anna Cora Mowatt Ritchie (née, Ogden; after first marriage, Mowatt; after second marriage, Ritchie; pseudonyms, Isabel, Henry C. Browning, and Helen Berkley; March 5, 1819 – July 21, 1870) was a French-born American author, playwright, public reader, actress, and preservationist. Her best known work was the play Fashion, published in 1845. Following her critical success as a playwright, she enjoyed a successful career on stage as an actress.",
    		search_term: "Anna Cora Mowatt",
    		diameter: "38.4",
    		center_lat: -14.6,
    		center_long: 292.3
    	},
    	{
    		feature_id: 4227,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Nevelson",
    		type: "Famous Woman",
    		origin: "United States",
    		continent: "North America",
    		clean_name: "Nevelson",
    		description: "Louise; American artist (1899-1988).",
    		bio: "Louise Nevelson (September 23, 1899 – April 17, 1988) was an American sculptor known for her monumental, monochromatic, wooden wall pieces and outdoor sculptures. Born in the Poltava Governorate of the Russian Empire (present-day Kyiv Oblast, Ukraine), she emigrated with her family to the United States in the early 20th century. Nevelson learned English at school, as she spoke Yiddish at home.",
    		search_term: "Louise Nevelson",
    		diameter: "69.8",
    		center_lat: -35.3,
    		center_long: 307.8
    	},
    	{
    		feature_id: 4541,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "O'Keeffe",
    		type: "Famous Woman",
    		origin: "United States",
    		continent: "North America",
    		clean_name: "O'Keeffe",
    		description: "Georgia; American artist (1887-1986).",
    		bio: "Georgia Totto O'Keeffe (November 15, 1887 – March 6, 1986) was an American modernist artist. She was known for her paintings of enlarged flowers, New York skyscrapers, and New Mexico landscapes. O'Keeffe has been called the 'Mother of American modernism'.In 1905, O'Keeffe began art training at the School of the Art Institute of Chicago and then the Art Students League of New York.",
    		search_term: "Georgia O'Keeffe",
    		diameter: "76.9",
    		center_lat: 24.5,
    		center_long: 228.8
    	},
    	{
    		feature_id: 4382,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Oakley",
    		type: "Famous Woman",
    		origin: "United States",
    		continent: "North America",
    		clean_name: "Oakley",
    		description: "Annie; American sharpshooter, entertainer (1860-1926).",
    		bio: "Annie Oakley (born Phoebe Ann Mosey; August 13, 1860 – November 3, 1926) was an American sharpshooter who starred in Buffalo Bill's Wild West show. Oakley developed hunting skills as a child to provide for her impoverished family in western Ohio. At age 15, she won a shooting contest against an experienced marksman, Frank E. Butler, whom she later married in 1876.",
    		search_term: "Annie Oakley",
    		diameter: "18.4",
    		center_lat: -29.3,
    		center_long: 310.5
    	},
    	{
    		feature_id: 4629,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Peck",
    		type: "Famous Woman",
    		origin: "United States",
    		continent: "North America",
    		clean_name: "Peck",
    		description: "Annie; American mountaineer, educator (1850-1935).",
    		bio: "Annie Smith Peck (October 19, 1850 – July 18, 1935) was an American mountaineer and adventurer. The northern peak of the Peruvian Cordillera Blanca mountain chain, Huascarán was named Cumbre Aña Peck in Peck's honor. She was an ardent suffragist and noted speaker.",
    		search_term: "Annie Peck",
    		diameter: "30.4",
    		center_lat: -28.9,
    		center_long: 294.3
    	},
    	{
    		feature_id: 4679,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Peña",
    		type: "Famous Woman",
    		origin: "United States",
    		continent: "North America",
    		clean_name: "Peña",
    		description: "Tonita (Quah Ah); Pueblo artist (1895-1949).",
    		bio: "Tonita Peña (born May 10, 1893 in San Ildefonso – died September 9, 1949 in Santo Domingo Pueblo) born as Quah Ah (meaning white coral beads) but also used the name Tonita Vigil Peña and María Antonia Tonita Peña. Peña was a renowned Pueblo artist, specializing in pen and ink on paper embellished with watercolor. She was a well-known and influential Native American artist and art teacher of the early 1920s and 1930s.",
    		search_term: "Tonita Peña",
    		diameter: "29.6",
    		center_lat: -23.6,
    		center_long: 190.6
    	},
    	{
    		feature_id: 4796,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Ponselle",
    		type: "Famous Woman",
    		origin: "United States",
    		continent: "North America",
    		clean_name: "Ponselle",
    		description: "Rosa; American opera singer (1897-1981).",
    		bio: "Rosa Melba Ponzillo, known as Rosa Ponselle (January 22, 1897 – May 25, 1981) was an American operatic soprano. She sang mainly at the New York Metropolitan Opera and is generally considered to have been one of the greatest sopranos of the 20th century. She was born Rosa Ponzillo on January 22, 1897, in Meriden, Connecticut, the youngest of three children.",
    		search_term: "Rosa Ponselle",
    		diameter: "57.7",
    		center_lat: -63,
    		center_long: 289.1
    	},
    	{
    		feature_id: 4944,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Rand",
    		type: "Famous Woman",
    		origin: "United States",
    		continent: "North America",
    		clean_name: "Rand",
    		description: "Ayn; American writer (1905-1982).",
    		bio: "Alice O'Connor (born Alisa Zinovyevna Rosenbaum; February 2 [O.S. January 20], 1905 – March 6, 1982), better known by her pen name Ayn Rand (), was a Russian-born American writer and philosopher. She is known for her fiction and for developing a philosophical system she named Objectivism. Born and educated in Russia, she moved to the United States in 1926.",
    		search_term: "Ayn Rand",
    		diameter: "24.3",
    		center_lat: -63.8,
    		center_long: 59.5
    	},
    	{
    		feature_id: 5026,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Richards",
    		type: "Famous Woman",
    		origin: "United States",
    		continent: "North America",
    		clean_name: "Richards",
    		description: "Ellen; founder of science of ecology (1842-1911).",
    		bio: "Ellen Henrietta Swallow Richards (December 3, 1842 – March 30, 1911) was an American industrial and safety engineer, environmental chemist, and university faculty member in the United States during the 19th century. Her pioneering work in sanitary engineering, and experimental research in domestic science, laid a foundation for the new science of home economics. She was the founder of the home economics movement characterized by the application of science to the home, and the first to apply chemistry to the study of nutrition.Richards graduated from Westford Academy (second oldest secondary school in Massachusetts) in 1862.",
    		search_term: "Ellen Swallow Richards",
    		diameter: "25.0",
    		center_lat: 2.5,
    		center_long: 196.1
    	},
    	{
    		feature_id: 5257,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Sabin",
    		type: "Famous Woman",
    		origin: "United States",
    		continent: "North America",
    		clean_name: "Sabin",
    		description: "Florence; American medical researcher (1871-1953).",
    		bio: "Florence Rena Sabin (November 9, 1871 – October 3, 1953) was an American medical scientist. She was a pioneer for women in science; she was the first woman to hold a full professorship at Johns Hopkins School of Medicine, the first woman elected to the National Academy of Sciences, and the first woman to head a department at the Rockefeller Institute for Medical Research. During her years of retirement, she pursued a second career as a public health activist in Colorado, and in 1951 received the Albert Lasker Public Service Award for this work.",
    		search_term: "Florence R. Sabin",
    		diameter: "33.1",
    		center_lat: -38.5,
    		center_long: 274.7
    	},
    	{
    		feature_id: 5307,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Sanger",
    		type: "Famous Woman",
    		origin: "United States",
    		continent: "North America",
    		clean_name: "Sanger",
    		description: "Margaret; American medical researcher (1883-1966).",
    		bio: "Margaret Higgins Sanger (born Margaret Louise Higgins; September 14, 1879 – September 6, 1966), also known as Margaret Sanger Slee, was an American birth control activist, sex educator, writer, and nurse. Sanger popularized the term 'birth control', opened the first birth control clinic in the United States, and established organizations that evolved into the Planned Parenthood Federation of America.Sanger used her writings and speeches primarily to promote her way of thinking. She was prosecuted for her book Family Limitation under the Comstock Act in 1914.",
    		search_term: "Margaret Sanger",
    		diameter: "83.6",
    		center_lat: 33.8,
    		center_long: 288.6
    	},
    	{
    		feature_id: 5682,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Stanton",
    		type: "Famous Woman",
    		origin: "United States",
    		continent: "North America",
    		clean_name: "Stanton",
    		description: "Elizabeth C.; American suffragist (1815-1902).",
    		bio: "Elizabeth Cady Stanton (November 12, 1815 – October 26, 1902) was an American writer and activist who was a leader of the women's rights movement in the U.S. during the mid- to late-19th century. She was the main force behind the 1848 Seneca Falls Convention, the first convention to be called for the sole purpose of discussing women's rights, and was the primary author of its Declaration of Sentiments. Her demand for women's right to vote generated a controversy at the convention but quickly became a central tenet of the women's movement.",
    		search_term: "Elizabeth Cady Stanton",
    		diameter: "107.0",
    		center_lat: -23.3,
    		center_long: 199.3
    	},
    	{
    		feature_id: 5720,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Stowe",
    		type: "Famous Woman",
    		origin: "United States",
    		continent: "North America",
    		clean_name: "Stowe",
    		description: "Harriet B.; American novelist (1811-1896).",
    		bio: "Harriet Elisabeth Beecher Stowe (; June 14, 1811 – July 1, 1896) was an American author and abolitionist. She came from the Beecher family, a religious family, and became best known for her novel Uncle Tom's Cabin (1852), which depicts the harsh conditions experienced by enslaved African Americans. The book reached an audience of millions as a novel and play, and became influential in the United States and in Great Britain, energizing anti-slavery forces in the American North, while provoking widespread anger in the South.",
    		search_term: "Harriet Beecher Stowe",
    		diameter: "80.0",
    		center_lat: -43.2,
    		center_long: 233.2
    	},
    	{
    		feature_id: 5756,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Sullivan",
    		type: "Famous Woman",
    		origin: "United States",
    		continent: "North America",
    		clean_name: "Sullivan",
    		description: "Anne; American teacher of Helen Keller (1866-1936).",
    		bio: "Anne Sullivan Macy (born as Johanna Mansfield Sullivan; April 14, 1866 – October 20, 1936) was an American teacher best known for being the instructor and lifelong companion of Helen Keller.At the age of five, Sullivan contracted trachoma, an eye disease, which left her partially blind and without reading or writing skills. She received her education as a student of the Perkins School for the Blind. Soon after graduation at age 20, she became a teacher to Keller.",
    		search_term: "Anne Sullivan",
    		diameter: "32.0",
    		center_lat: -1.4,
    		center_long: 110.9
    	},
    	{
    		feature_id: 5869,
    		year: 1994,
    		feature: "Patera",
    		feature_plural: "Paterae",
    		name: "Tarbell Patera",
    		type: "Famous Woman",
    		origin: "United States",
    		continent: "North America",
    		clean_name: "Tarbell",
    		description: "Ida; American author, editor (1857-1944).",
    		bio: "Ida Minerva Tarbell (November 5, 1857 – January 6, 1944) was an American writer, investigative journalist, biographer and lecturer. She was one of the leading muckrakers of the Progressive Era of the late 19th and early 20th centuries and pioneered investigative journalism.Born in Pennsylvania at the beginning of the oil boom, Tarbell is best known for her 1904 book The History of the Standard Oil Company. The book was published as a series of articles in McClure's Magazine from 1902 to 1904.",
    		search_term: "Ida Tarbell",
    		diameter: "80.0",
    		center_lat: -58.2,
    		center_long: 351.5
    	},
    	{
    		feature_id: 5883,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Taussig",
    		type: "Famous Woman",
    		origin: "United States",
    		continent: "North America",
    		clean_name: "Taussig",
    		description: "Helen; American pediatrician, heart researcher (1898-1986).",
    		bio: "Helen Brooke Taussig (May 24, 1898 – May 20, 1986) was an American cardiologist, working in Baltimore and Boston, who founded the field of pediatric cardiology. She is credited with developing the concept for a procedure that would extend the lives of children born with Tetralogy of Fallot (the most common cause of blue baby syndrome). This concept was applied in practice as a procedure known as the Blalock-Thomas-Taussig shunt.",
    		search_term: "Helen Taussig",
    		diameter: "25.8",
    		center_lat: -9.2,
    		center_long: 229
    	},
    	{
    		feature_id: 5892,
    		year: 1994,
    		feature: "Patera",
    		feature_plural: "Paterae",
    		name: "Teasdale Patera",
    		type: "Famous Woman",
    		origin: "United States",
    		continent: "North America",
    		clean_name: "Teasdale",
    		description: "Sara; American poet (1884- 1933).",
    		bio: "Sara Teasdale (August 8, 1884 – January 29, 1933) was an American lyric poet. She was born Sarah Trevor Teasdale in St. Louis, Missouri, and used the name Sara Teasdale Filsinger after her marriage in 1914.In 1918 she won a Pulitzer Prize for her 1917 poetry collection Love Songs.",
    		search_term: "Sara Teasdale",
    		diameter: "75.0",
    		center_lat: -67.6,
    		center_long: 189.1
    	},
    	{
    		feature_id: 5976,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Thomas",
    		type: "Famous Woman",
    		origin: "United States",
    		continent: "North America",
    		clean_name: "Thomas",
    		description: "Martha; American college president (1857-1935).",
    		bio: "Martha Carey Thomas (January 2, 1857 – December 2, 1935) was an American educator, suffragist, and linguist. She was the second president of Bryn Mawr College, a women's liberal arts college in Bryn Mawr, Pennsylvania. = = Carey Thomas, as she preferred to be called later in life (she was known as Minnie to her family as a child), was born in Baltimore, Maryland on January 2, 1857.",
    		search_term: "M. Carey Thomas",
    		diameter: "25.2",
    		center_lat: -13,
    		center_long: 272.5
    	},
    	{
    		feature_id: 6046,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Toklas",
    		type: "Famous Woman",
    		origin: "United States",
    		continent: "North America",
    		clean_name: "Toklas",
    		description: "Alice; American writer, art patron (1877-1967).",
    		bio: "Alice Babette Toklas (April 30, 1877 – March 7, 1967) was an American-born member of the Parisian avant-garde of the early 20th century, and the life partner of American writer Gertrude Stein. Alice B. Toklas was born in San Francisco into a middle-class Polish Jewish family. Her paternal grandfather was a rabbi, whose son Feivel (usually known as Ferdinand) Toklas moved to San Francisco in 1863.",
    		search_term: "Alice Toklas",
    		diameter: "17.5",
    		center_lat: 0.7,
    		center_long: 273.1
    	},
    	{
    		feature_id: 6099,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Truth",
    		type: "Famous Woman",
    		origin: "United States",
    		continent: "North America",
    		clean_name: "Truth",
    		description: "Sojourner; American abolitionist (1797-1883).",
    		bio: "Sojourner Truth (; born Isabella Baumfree; c. 1797 – November 26, 1883) was an American abolitionist of New York Dutch heritage and a women's rights activist. Truth was born into slavery in Swartekill, New York, but escaped with her infant daughter to freedom in 1826. After going to court to recover her son in 1828, she became the first black woman to win such a case against a white man.",
    		search_term: "Sojourner Truth",
    		diameter: "47.3",
    		center_lat: 28.7,
    		center_long: 287.8
    	},
    	{
    		feature_id: 6122,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Tubman",
    		type: "Famous Woman",
    		origin: "United States",
    		continent: "North America",
    		clean_name: "Tubman",
    		description: "Harriet; American abolitionist (1820-1913).",
    		bio: "Harriet Tubman (born Araminta Ross, c. March 1822 – March 10, 1913) was an American abolitionist and social activist. Born into slavery, Tubman escaped and subsequently made some 13 missions to rescue approximately 70 slaves, including family and friends, using the network of antislavery activists and safe houses known as the Underground Railroad. During the American Civil War, she served as an armed scout and spy for the Union Army.",
    		search_term: "Harriet Tubman",
    		diameter: "42.9",
    		center_lat: 23.6,
    		center_long: 204.6
    	},
    	{
    		feature_id: 6492,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Warren",
    		type: "Famous Woman",
    		origin: "United States",
    		continent: "North America",
    		clean_name: "Warren",
    		description: "Mercy; American colonial poet, playwright, historian (1728-1814).",
    		bio: "Mercy Otis Warren (September 14, [September 25, New Style] 1728 – October 19, 1814) was an American activist poet, playwright, and pamphleteer during the American Revolution. During the years before the Revolution, she had published poems and plays that attacked royal authority in Massachusetts and urged colonists to resist British infringements on colonial rights and liberties. She was married to James Warren, who was likewise heavily active in the independence movement.",
    		search_term: "Mercy Otis Warren",
    		diameter: "50.9",
    		center_lat: -11.7,
    		center_long: 176.5
    	},
    	{
    		feature_id: 6532,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Wheatley",
    		type: "Famous Woman",
    		origin: "United States",
    		continent: "North America",
    		clean_name: "Wheatley",
    		description: "Phillis; first black writer of note in America (1753-1784).",
    		bio: "Phillis Wheatley Peters, also spelled Phyllis and Wheatly (c. 1753 – December 5, 1784) was an American author who is considered the first African-American author of a published book of poetry. Born in West Africa, she was kidnapped and subsequently sold into enslavement at the age of seven or eight and transported to North America, where she was bought by the Wheatley family of Boston. After she learned to read and write, they encouraged her poetry when they saw her talent.",
    		search_term: "Phillis Wheatley",
    		diameter: "74.8",
    		center_lat: 16.6,
    		center_long: 268
    	},
    	{
    		feature_id: 6535,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Whiting",
    		type: "Famous Woman",
    		origin: "United States",
    		continent: "North America",
    		clean_name: "Whiting",
    		description: "Sarah; American physicist, astronomer (1847-1927).",
    		bio: "Sarah M. Whiting (born 1964) is an American architect, critic, and educator. Whiting is currently Dean and Josep Lluís Sert Professor of Architecture at the Harvard University Graduate School of Design, in addition to being a founding partner of WW Architecture, along with her husband, Ron Witte. She previously served as Dean and William Ward Watkin Professor of Architecture at Rice University School of Architecture.",
    		search_term: "Sarah Whiting",
    		diameter: "35.7",
    		center_lat: -6.1,
    		center_long: 128
    	},
    	{
    		feature_id: 6537,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Whitney",
    		type: "Famous Woman",
    		origin: "United States",
    		continent: "North America",
    		clean_name: "Whitney",
    		description: "Mary; American astronomer (1847-1921).",
    		bio: "Mary Watson Whitney (September 11, 1847 – January 20, 1921) was an American astronomer and for 22 years the head of the Vassar Observatory where 102 scientific papers were published under her guidance. Whitney was born on September 11, 1847, in Waltham, Massachusetts. Her mother was Mary Watson Crehore and her father was Samuel Buttrick Whitney.",
    		search_term: "Mary Watson Whitney",
    		diameter: "42.5",
    		center_lat: -30.2,
    		center_long: 151.3
    	},
    	{
    		feature_id: 6550,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Willard",
    		type: "Famous Woman",
    		origin: "United States",
    		continent: "North America",
    		clean_name: "Willard",
    		description: "Emma; American educator (1787-1870).",
    		bio: "Emma Hart Willard (February 23, 1787 – April 15, 1870) was an American woman's education activist who dedicated her life to education. She worked in several schools and founded the first school for women's higher education, the Troy Female Seminary in Troy, New York. With the success of her school, Willard was able to travel across the country and abroad, to promote education for women.",
    		search_term: "Emma Willard",
    		diameter: "48.4",
    		center_lat: -24.6,
    		center_long: 296.1
    	},
    	{
    		feature_id: 6558,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Winema",
    		type: "Famous Woman",
    		origin: "United States",
    		continent: "North America",
    		clean_name: "Winema",
    		description: "Modoc Indian heroine, peacemaker (c. 1848-1932).",
    		bio: "Toby 'Winema' Riddle (1848–1920) was a Modoc woman who served as an interpreter in negotiations between the Native American Modoc tribe and the United States Army during the Modoc War (also called the Lava Beds War). She warned the peace commission of a possible Modoc attack, and she saved the life of the chairman Alfred B. Meacham when the 1873 attack took place. She and her family toured with Meacham after the war, starring in his lecture-play 'Tragedy of the Lava Beds', to inform American people about the war.",
    		search_term: "Toby Riddle",
    		diameter: "21.7",
    		center_lat: 3,
    		center_long: 168.6
    	},
    	{
    		feature_id: 6562,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Winnemucca",
    		type: "Famous Woman",
    		origin: "United States",
    		continent: "North America",
    		clean_name: "Winnemucca",
    		description: "Sarah; Piute interpreter, activist (c. 1844-1891).",
    		bio: "Sarah Winnemucca Hopkins (born Thocmentony, meaning 'Shell Flower; also seen as 'Tocmetone' in Northern Paiute; c. 1844 – October 17, 1891) was a Northern Paiute author, activist (lecturer) and educator (school organizer). Her maiden name is Winnemucca. Sarah Winnemucca was born near Humboldt Lake, Nevada, into an influential Paiute family who led their community in pursuing friendly relations with the arriving groups of Anglo-American settlers.",
    		search_term: "Sarah Winnemucca",
    		diameter: "30.3",
    		center_lat: -15.4,
    		center_long: 121.1
    	},
    	{
    		feature_id: 6578,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Workman",
    		type: "Famous Woman",
    		origin: "United States",
    		continent: "North America",
    		clean_name: "Workman",
    		description: "Fanny; American mountaineer, author (1859-1925).",
    		bio: "Fanny Bullock Workman (January 8, 1859 – January 22, 1925) was an American geographer, cartographer, explorer, travel writer, and mountaineer, notably in the Himalayas. She was one of the first female professional mountaineers; she not only explored but also wrote about her adventures. She set several women's altitude records, published eight travel books with her husband, and championed women's rights and women's suffrage.",
    		search_term: "Fanny Bullock Workman",
    		diameter: "17.4",
    		center_lat: -12.9,
    		center_long: 299.9
    	},
    	{
    		feature_id: 6630,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Yale",
    		type: "Famous Woman",
    		origin: "United States",
    		continent: "North America",
    		clean_name: "Yale",
    		description: "Caroline; American educator of the deaf (1848-1933).",
    		bio: "Caroline Ardelia Yale (September 29, 1848 – July 2, 1933) was an American educator who revolutionized the teaching of hearing-impaired students. Caroline Ardelia Yale was born September 29, 1848, in Charlotte, Vermont, where she lived until the age of ten. She then moved to Williston, Vermont, and was educated at home by tutors with the support of her parents.",
    		search_term: "Caroline Yale",
    		diameter: "18.5",
    		center_lat: -13.4,
    		center_long: 271.2
    	},
    	{
    		feature_id: 3299,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Laulani",
    		type: "First Name",
    		origin: "Hawaii",
    		continent: "North America",
    		clean_name: "Laulani",
    		description: "Hawaiian first name.",
    		bio: "",
    		search_term: "",
    		diameter: "12.4",
    		center_lat: -68.2,
    		center_long: 121.2
    	},
    	{
    		feature_id: 3591,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Mahina",
    		type: "First Name",
    		origin: "Hawaii",
    		continent: "North America",
    		clean_name: "Mahina",
    		description: "Hawaiian first name.",
    		bio: "",
    		search_term: "",
    		diameter: "15.4",
    		center_lat: -2,
    		center_long: 182.2
    	},
    	{
    		feature_id: 3601,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Makola",
    		type: "First Name",
    		origin: "Hawaii",
    		continent: "North America",
    		clean_name: "Makola",
    		description: "Hawaiian first name.",
    		bio: "",
    		search_term: "",
    		diameter: "16.6",
    		center_lat: -3.8,
    		center_long: 106.7
    	},
    	{
    		feature_id: 462,
    		year: 1994,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Atse Estsan Corona",
    		type: "Goddess",
    		origin: "Navajo",
    		continent: "North America",
    		clean_name: "Atse Estsan",
    		description: "Navajo fertility goddess.",
    		bio: "Asdzą́ą́ Nádleehé (also spelled Ahsonnutli), meaning \"the woman who changes\", is one of the creation spirits of the Navajo. According to the Navajos, she created the Navajo people by taking old skin from her body and using her mountain soil bundle (a bag made of four pieces of buckskin, brought by her father from the underworld) to create four couples, who are the ancestors of the four original Navajo clans. She helped create the sky and the earth.",
    		search_term: "Asdzą́ą́ Nádleehé",
    		diameter: "150.0",
    		center_lat: 8.5,
    		center_long: 92
    	},
    	{
    		feature_id: 968,
    		year: 1994,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Calakomana Corona",
    		type: "Goddess",
    		origin: "Pueblo",
    		continent: "North America",
    		clean_name: "Calakomana",
    		description: "Pueblo Indian corn goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "575.0",
    		center_lat: 6.5,
    		center_long: 43.5
    	},
    	{
    		feature_id: 2617,
    		year: 1994,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "H'uraru Corona",
    		type: "Goddess",
    		origin: "Pawnee",
    		continent: "North America",
    		clean_name: "H'uraru",
    		description: "Pawnee earth mother.",
    		bio: "",
    		search_term: "",
    		diameter: "150.0",
    		center_lat: 9,
    		center_long: 68
    	},
    	{
    		feature_id: 3769,
    		year: 1994,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Mayauel Corona",
    		type: "Goddess",
    		origin: "Mexico",
    		continent: "North America",
    		clean_name: "Mayauel",
    		description: "Mexican goddess of plenty.",
    		bio: "",
    		search_term: "",
    		diameter: "200.0",
    		center_lat: -27.5,
    		center_long: 154
    	},
    	{
    		feature_id: 4459,
    		year: 1994,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Omeciuatl Corona",
    		type: "Goddess",
    		origin: "Aztec",
    		continent: "North America",
    		clean_name: "Omeciuatl",
    		description: "Aztec generative power.",
    		bio: "In Aztec mythology, Omeciuatl, also known as Tōnacācihuātl, was a creator and goddess of fertility, worshiped for peopling the earth and making it fruitful.",
    		search_term: "Tōnacācihuātl",
    		diameter: "175.0",
    		center_lat: 16.5,
    		center_long: 119
    	},
    	{
    		feature_id: 5421,
    		year: 1994,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Selu Corona",
    		type: "Goddess",
    		origin: "United States",
    		continent: "North America",
    		clean_name: "Selu",
    		description: "Cherokee corn goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "300.0",
    		center_lat: -42.5,
    		center_long: 6
    	},
    	{
    		feature_id: 5493,
    		year: 1994,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Shiwanokia Corona",
    		type: "Goddess",
    		origin: "Pueblo",
    		continent: "North America",
    		clean_name: "Shiwanokia",
    		description: "Zuni fertility goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "500.0",
    		center_lat: -42,
    		center_long: 279.8
    	},
    	{
    		feature_id: 5815,
    		year: 1994,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Tacoma Corona",
    		type: "Goddess",
    		origin: "United States",
    		continent: "North America",
    		clean_name: "Tacoma",
    		description: "Earth goddess of Salish, Puyallup and Yakima Indians.",
    		bio: "",
    		search_term: "",
    		diameter: "500.0",
    		center_lat: -37,
    		center_long: 288
    	},
    	{
    		feature_id: 5833,
    		year: 1994,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Takus Mana Corona",
    		type: "Goddess",
    		origin: "Hopi",
    		continent: "North America",
    		clean_name: "Takus Mana",
    		description: "Hopi (USA) fertility goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "125.0",
    		center_lat: -19.6,
    		center_long: 345.3
    	},
    	{
    		feature_id: 5835,
    		year: 1994,
    		feature: "Mons",
    		feature_plural: "Montes",
    		name: "Talakin Mons",
    		type: "Goddess",
    		origin: "Navajo",
    		continent: "North America",
    		clean_name: "Talakin",
    		description: "Navajo (USA) goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "175.0",
    		center_lat: -11,
    		center_long: 355.4
    	},
    	{
    		feature_id: 5937,
    		year: 1994,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Teteoinnan Corona",
    		type: "Goddess",
    		origin: "Aztec",
    		continent: "North America",
    		clean_name: "Teteoinnan",
    		description: "Aztec fertility goddess.",
    		bio: "Coatlicue, also known as Teteoinnan, is the Aztec goddess who gave birth to the moon, stars, and Huītzilōpōchtli, the god of the sun and war. Coatlicue is represented as a woman wearing a skirt of writhing snakes and a necklace made of human hearts, hands, and skulls. Her feet and hands are adorned with claws and her breasts are depicted as hanging flaccid from pregnancy.",
    		search_term: "Teteoinnan",
    		diameter: "125.0",
    		center_lat: -38.5,
    		center_long: 149.5
    	},
    	{
    		feature_id: 6127,
    		year: 1994,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Tumas Corona",
    		type: "Goddess",
    		origin: "Hopi",
    		continent: "North America",
    		clean_name: "Tumas",
    		description: "Hopi (USA) fertility goddess.",
    		bio: "In Hopi mythology, Angwusnasomtaka, also known as Tümas, is a kachina (a spirit represented by a masked doll). She is a wuya, one of the chief kachinas and is considered the mother of all the hú and all the kachinas. In English, she is known as Crow Mother.",
    		search_term: "Angwusnasomtaka",
    		diameter: "200.0",
    		center_lat: -16.3,
    		center_long: 351.2
    	},
    	{
    		feature_id: 6615,
    		year: 1994,
    		feature: "Mons",
    		feature_plural: "Montes",
    		name: "Xochiquetzal Mons",
    		type: "Goddess",
    		origin: "Mexico",
    		continent: "North America",
    		clean_name: "Xochiquetzal",
    		description: "Aztec goddess of flowers.",
    		bio: "In Aztec mythology, Xochiquetzal was a goddess associated with fertility, beauty, and love, serving as a protector of young mothers and a patroness of pregnancy, childbirth, and the crafts practiced by women such as weaving and embroidery.",
    		search_term: "Xochiquetzal",
    		diameter: "80.0",
    		center_lat: 3.5,
    		center_long: 270
    	},
    	{
    		feature_id: 1223,
    		year: 1994,
    		feature: "Vallis",
    		feature_plural: "Valles",
    		name: "Citlalpul Vallis",
    		type: "Other",
    		origin: "Mexico",
    		continent: "North America",
    		clean_name: "Citlalpul ",
    		description: "Aztec name for planet Venus. Name changed from Citlalpul Valles.",
    		bio: "",
    		search_term: "",
    		diameter: "3,160.0",
    		center_lat: -51.8,
    		center_long: 187
    	},
    	{
    		feature_id: 902,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Bryce",
    		type: "Famous Woman",
    		origin: "Australia",
    		continent: "Oceania",
    		clean_name: "Bryce",
    		description: "Lucy; Australian medical pioneer (1897-1968).",
    		bio: "Lucy Meredith Bryce (12 June 1897 – 30 July 1968) was an Australian haematologist and medical researcher, who worked with the Australian Red Cross Society to establish the first blood transfusion service in Australia. Her work involved planning how donors should be screened, and how blood should be typed and stored, and supervising the establishment of a blood reserve in case of major disaster.",
    		search_term: "Lucy Meredith Bryce",
    		diameter: "23.9",
    		center_lat: -62.5,
    		center_long: 197
    	},
    	{
    		feature_id: 1264,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Cohn",
    		type: "Famous Woman",
    		origin: "Australia",
    		continent: "Oceania",
    		clean_name: "Cohn",
    		description: "Carola; Australian artist (1892-1964).",
    		bio: "Ola Cohn (born Carola Cohn; 25 April 1892 – 23 December 1964) was an Australian artist, author and philanthropist best known for her work in sculpture in a modernist style and famous for her Fairies Tree in the Fitzroy Gardens, Melbourne. Cohn was born in Bendigo, Victoria. She went to school at Girton College in Bendigo and then studied drawing and sculpture at the Bendigo School of Mines.",
    		search_term: "Carola Cohn",
    		diameter: "18.3",
    		center_lat: -33.3,
    		center_long: 208.1
    	},
    	{
    		feature_id: 2166,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Gilmore",
    		type: "Famous Woman",
    		origin: "Australia",
    		continent: "Oceania",
    		clean_name: "Gilmore",
    		description: "Mary; Australian poet (1865-1962).",
    		bio: "Dame Mary Jean Gilmore (née Cameron; 16 August 1865 – 3 December 1962) was an Australian writer and journalist known for her prolific contributions to Australian literature and the broader national discourse. She wrote both prose and poetry. Gilmore was born in rural New South Wales, and spent her childhood in and around the Riverina, living both in small bush settlements and in larger country towns like Wagga Wagga.",
    		search_term: "Mary Gilmore",
    		diameter: "21.3",
    		center_lat: -6.7,
    		center_long: 132.8
    	},
    	{
    		feature_id: 2836,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Johnson",
    		type: "Famous Woman",
    		origin: "Australia",
    		continent: "Oceania",
    		clean_name: "Johnson",
    		description: "Amy; Australian aviator (1903-1941).",
    		bio: "Amy Johnson (born 1 July 1903 – disappeared 5 January 1941) was a pioneering English pilot who was the first woman to fly solo from London to Australia. Flying solo or with her husband, Jim Mollison, she set many long-distance records during the 1930s. She flew in the Second World War as a part of the Air Transport Auxiliary and disappeared during a ferry flight.",
    		search_term: "Amy Johnson",
    		diameter: "24.5",
    		center_lat: 51.8,
    		center_long: 254.6
    	},
    	{
    		feature_id: 2989,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Kenny",
    		type: "Famous Woman",
    		origin: "Australia",
    		continent: "Oceania",
    		clean_name: "Kenny",
    		description: "Elizabeth; Australian nurse, therapist (1886-1952).",
    		bio: "Sister Elizabeth Kenny (20 September 1880 – 30 November 1952) was a self-trained Australian bush nurse who developed an approach to treating polio that was controversial at the time. Her method, promoted internationally while working in Australia, Europe and the United States, differed from the conventional one of placing affected limbs in plaster casts. Instead she applied hot compresses, followed by passive movement of the areas to reduce what she called 'spasm'.",
    		search_term: "Elizabeth Kenny",
    		diameter: "52.7",
    		center_lat: -44.4,
    		center_long: 271.1
    	},
    	{
    		feature_id: 3816,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Melba",
    		type: "Famous Woman",
    		origin: "Australia",
    		continent: "Oceania",
    		clean_name: "Melba",
    		description: "Nellie; Australian opera singer (1861-1931).",
    		bio: "Dame Nellie Melba (born Helen Porter Mitchell; 19 May 1861 – 23 February 1931) was an Australian operatic soprano. She became one of the most famous singers of the late Victorian era and the early 20th century, and was the first Australian to achieve international recognition as a classical musician. She took the pseudonym 'Melba' from Melbourne, her home town.",
    		search_term: "Nellie Melba",
    		diameter: "21.8",
    		center_lat: 4.7,
    		center_long: 193.5
    	},
    	{
    		feature_id: 2386,
    		year: 1994,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Haumea Corona",
    		type: "Goddess",
    		origin: "Polynesia",
    		continent: "Oceania",
    		clean_name: "Haumea",
    		description: "Polynesian fertility goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "375.0",
    		center_lat: 54,
    		center_long: 21.8
    	},
    	{
    		feature_id: 2867,
    		year: 1994,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Junkgowa Corona",
    		type: "Goddess",
    		origin: "Australia",
    		continent: "Oceania",
    		clean_name: "Junkgowa",
    		description: "Yulengor (Australia) fertility goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "280.0",
    		center_lat: 37,
    		center_long: 257
    	},
    	{
    		feature_id: 3593,
    		year: 1994,
    		feature: "Tholus",
    		feature_plural: "Tholi",
    		name: "Mahuea Tholus",
    		type: "Goddess",
    		origin: "New Zealand",
    		continent: "Oceania",
    		clean_name: "Mahuea",
    		description: "Māori fire goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "110.0",
    		center_lat: -37.5,
    		center_long: 164.7
    	},
    	{
    		feature_id: 3920,
    		year: 1994,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Miralaidji Corona",
    		type: "Goddess",
    		origin: "Australia",
    		continent: "Oceania",
    		clean_name: "Miralaidji",
    		description: "Aborigine fertility goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "300.0",
    		center_lat: -14,
    		center_long: 163.8
    	},
    	{
    		feature_id: 4578,
    		year: 1994,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Pani Corona",
    		type: "Goddess",
    		origin: "New Zealand",
    		continent: "Oceania",
    		clean_name: "Pani",
    		description: "Māori fertility goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "320.0",
    		center_lat: 19.9,
    		center_long: 231.5
    	},
    	{
    		feature_id: 5866,
    		year: 1994,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Taranga Corona",
    		type: "Goddess",
    		origin: "Society Island",
    		continent: "Oceania",
    		clean_name: "Taranga",
    		description: "Polynesian fertility goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "525.0",
    		center_lat: 16.5,
    		center_long: 251.5
    	},
    	{
    		feature_id: 5891,
    		year: 1994,
    		feature: "Vallis",
    		feature_plural: "Valles",
    		name: "Ta'urua Vallis",
    		type: "Other",
    		origin: "Society Island",
    		continent: "Oceania",
    		clean_name: "Ta'urua ",
    		description: "Tahitian word for the planet Venus.",
    		bio: "",
    		search_term: "",
    		diameter: "525.0",
    		center_lat: -80.2,
    		center_long: 247.5
    	},
    	{
    		feature_id: 5719,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Storni",
    		type: "Famous Woman",
    		origin: "Argentina",
    		continent: "South America",
    		clean_name: "Storni",
    		description: "Alfonsina; Argentine poet (1892-1938).",
    		bio: "Alfonsina Storni (22 May 1892 – 25 October 1938) was an Argentine poet and playwright of the modernist period. Storni was born on May 29, 1892 in Sala Capriasca, Switzerland. Her parents were Alfonso Storni and Paola Martignoni, who were of Italian-Swiss descent.",
    		search_term: "Alfonsina Storni",
    		diameter: "21.7",
    		center_lat: -9.8,
    		center_long: 245.6
    	},
    	{
    		feature_id: 6699,
    		year: 1994,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Zamudio",
    		type: "Famous Woman",
    		origin: "Bolivia",
    		continent: "South America",
    		clean_name: "Zamudio",
    		description: "Adela; Bolivian poet (1854-1928).",
    		bio: "Paz Juana Plácida Adela Rafaela Zamudio Rivero, or more popularly known as Adela Zamudio (1854–1928) was a Bolivian poet, feminist, and educator. She is considered the most famous Bolivian poet, and is credited as founding the country's feminist movement. In her writing, she also used the pen-name Soledad.",
    		search_term: "Adela Zamudio",
    		diameter: "19.0",
    		center_lat: 9.6,
    		center_long: 189.3
    	},
    	{
    		feature_id: 3615,
    		year: 1994,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Mama-Allpa Corona",
    		type: "Goddess",
    		origin: "Peru",
    		continent: "South America",
    		clean_name: "Mama-Allpa",
    		description: "Peruvian harvest goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "300.0",
    		center_lat: -27,
    		center_long: 31
    	},
    	{
    		feature_id: 5514,
    		year: 1994,
    		feature: "Fluctus",
    		feature_plural: "Fluctūs",
    		name: "Sicasica Fluctus",
    		type: "Goddess",
    		origin: "Bolivia",
    		continent: "South America",
    		clean_name: "Sicasica",
    		description: "Aymara (Bolivia) mountain goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "175.0",
    		center_lat: -52,
    		center_long: 180.4
    	},
    	{
    		feature_id: 4377,
    		year: 1997,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Nzingha Corona",
    		type: "Famous Woman",
    		origin: "Angola",
    		continent: "Africa",
    		clean_name: "Nzingha",
    		description: "(Ann Zingha) queen, head of Amazon band (1582-1663). Name changed from Nzingha Patera.",
    		bio: "Nzinga Ana de Sousa Mbande (c. 1583 – 1663) was a Southwest African ruler who served as queen of the Ambundu Kingdoms of Ndongo (1624–1663) and Matamba (1631–1663), located in present-day northern Angola. Born into the ruling family of Ndongo, Nzinga received military and political training as a child, and she demonstrated an aptitude for defusing political crises as an ambassador to the Portuguese Empire. She later assumed power over Ndongo after the death of her father and brother, who both served as kings, and would go on to conquer Matamba.",
    		search_term: "Nzingha",
    		diameter: "140.0",
    		center_lat: 68.7,
    		center_long: 205.7
    	},
    	{
    		feature_id: 20,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Abra",
    		type: "First Name",
    		origin: "Ghana",
    		continent: "Africa",
    		clean_name: "Abra",
    		description: "Ewe first name.",
    		bio: "",
    		search_term: "",
    		diameter: "7.2",
    		center_lat: 6.2,
    		center_long: 97.4
    	},
    	{
    		feature_id: 61,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Adzoba",
    		type: "First Name",
    		origin: "Ghana",
    		continent: "Africa",
    		clean_name: "Adzoba",
    		description: "Ewe (Ghana) first name.",
    		bio: "",
    		search_term: "",
    		diameter: "10.0",
    		center_lat: 12.8,
    		center_long: 117
    	},
    	{
    		feature_id: 73,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Afiba",
    		type: "First Name",
    		origin: "Ghana",
    		continent: "Africa",
    		clean_name: "Afiba",
    		description: "Ewe first name.",
    		bio: "",
    		search_term: "",
    		diameter: "9.5",
    		center_lat: -47.1,
    		center_long: 102.7
    	},
    	{
    		feature_id: 74,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Afiruwa",
    		type: "First Name",
    		origin: "Nigeria",
    		continent: "Africa",
    		clean_name: "Afiruwa",
    		description: "Hausa first name.",
    		bio: "",
    		search_term: "",
    		diameter: "5.2",
    		center_lat: 4.3,
    		center_long: 3.8
    	},
    	{
    		feature_id: 78,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Afua",
    		type: "First Name",
    		origin: "Ghana",
    		continent: "Africa",
    		clean_name: "Afua",
    		description: "Akan (Ghana) first name.",
    		bio: "",
    		search_term: "",
    		diameter: "10.0",
    		center_lat: 15.5,
    		center_long: 124
    	},
    	{
    		feature_id: 89,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Agoe",
    		type: "First Name",
    		origin: "Ghana",
    		continent: "Africa",
    		clean_name: "Agoe",
    		description: "Eve first name.",
    		bio: "",
    		search_term: "",
    		diameter: "6.3",
    		center_lat: 13.1,
    		center_long: 4.3
    	},
    	{
    		feature_id: 137,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Akosua",
    		type: "First Name",
    		origin: "Ghana",
    		continent: "Africa",
    		clean_name: "Akosua",
    		description: "Akan first name.",
    		bio: "",
    		search_term: "",
    		diameter: "6.2",
    		center_lat: -58.6,
    		center_long: 18.1
    	},
    	{
    		feature_id: 141,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Akuba",
    		type: "First Name",
    		origin: "Ghana",
    		continent: "Africa",
    		clean_name: "Akuba",
    		description: "Eve first name.",
    		bio: "",
    		search_term: "",
    		diameter: "5.5",
    		center_lat: 9.6,
    		center_long: 23
    	},
    	{
    		feature_id: 233,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Aminata",
    		type: "First Name",
    		origin: "Mali",
    		continent: "Africa",
    		clean_name: "Aminata",
    		description: "Mandingo first name.",
    		bio: "",
    		search_term: "",
    		diameter: "9.7",
    		center_lat: 6.6,
    		center_long: 25.2
    	},
    	{
    		feature_id: 502,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Avene",
    		type: "First Name",
    		origin: "Ghana",
    		continent: "Africa",
    		clean_name: "Avene",
    		description: "Akan (Ghana) first name.",
    		bio: "",
    		search_term: "",
    		diameter: "10.0",
    		center_lat: 40.4,
    		center_long: 149.4
    	},
    	{
    		feature_id: 519,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Ayashe",
    		type: "First Name",
    		origin: "Nigeria",
    		continent: "Africa",
    		clean_name: "Ayashe",
    		description: "Hausa first name.",
    		bio: "",
    		search_term: "",
    		diameter: "6.7",
    		center_lat: 22.7,
    		center_long: 31.4
    	},
    	{
    		feature_id: 520,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Ayisatu",
    		type: "First Name",
    		origin: "Mali",
    		continent: "Africa",
    		clean_name: "Ayisatu",
    		description: "Fulbe first name.",
    		bio: "",
    		search_term: "",
    		diameter: "7.0",
    		center_lat: 34.6,
    		center_long: 5.5
    	},
    	{
    		feature_id: 538,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Bachira",
    		type: "First Name",
    		origin: "Algeria",
    		continent: "Africa",
    		clean_name: "Bachira",
    		description: "Algerian first name.",
    		bio: "",
    		search_term: "",
    		diameter: "7.3",
    		center_lat: 26.5,
    		center_long: 10
    	},
    	{
    		feature_id: 603,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Barauka",
    		type: "First Name",
    		origin: "Nigeria",
    		continent: "Africa",
    		clean_name: "Barauka",
    		description: "Hausa (Nigeria) first name.",
    		bio: "",
    		search_term: "",
    		diameter: "12.9",
    		center_lat: 10.6,
    		center_long: 346.3
    	},
    	{
    		feature_id: 748,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Bineta",
    		type: "First Name",
    		origin: "Mali",
    		continent: "Africa",
    		clean_name: "Bineta",
    		description: "Mandingo (W. Africa, Mali) first name.",
    		bio: "",
    		search_term: "",
    		diameter: "10.7",
    		center_lat: 57.3,
    		center_long: 144.1
    	},
    	{
    		feature_id: 1209,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Chubado",
    		type: "First Name",
    		origin: "Mali",
    		continent: "Africa",
    		clean_name: "Chubado",
    		description: "Fulbe first name.",
    		bio: "",
    		search_term: "",
    		diameter: "7.0",
    		center_lat: 45.3,
    		center_long: 5.6
    	},
    	{
    		feature_id: 1379,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Dado",
    		type: "First Name",
    		origin: "Guinea",
    		continent: "Africa",
    		clean_name: "Dado",
    		description: "Fulbe first name.",
    		bio: "",
    		search_term: "",
    		diameter: "11.2",
    		center_lat: -13.9,
    		center_long: 87.6
    	},
    	{
    		feature_id: 1457,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Defa",
    		type: "First Name",
    		origin: "Senegal",
    		continent: "Africa",
    		clean_name: "Defa",
    		description: "Fulbe first name.",
    		bio: "",
    		search_term: "",
    		diameter: "8.5",
    		center_lat: 32.2,
    		center_long: 11.3
    	},
    	{
    		feature_id: 2326,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Halima",
    		type: "First Name",
    		origin: "Nigeria",
    		continent: "Africa",
    		clean_name: "Halima",
    		description: "Hausa first name.",
    		bio: "",
    		search_term: "",
    		diameter: "8.9",
    		center_lat: 28.5,
    		center_long: 14.6
    	},
    	{
    		feature_id: 2883,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Kafutchi",
    		type: "First Name",
    		origin: "Zaire",
    		continent: "Africa",
    		clean_name: "Kafutchi",
    		description: "Bantu first name.",
    		bio: "",
    		search_term: "",
    		diameter: "7.1",
    		center_lat: 26.7,
    		center_long: 16.4
    	},
    	{
    		feature_id: 2901,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Kalombo",
    		type: "First Name",
    		origin: "Zaire",
    		continent: "Africa",
    		clean_name: "Kalombo",
    		description: "Bantu first name.",
    		bio: "",
    		search_term: "",
    		diameter: "9.6",
    		center_lat: -30.5,
    		center_long: 34
    	},
    	{
    		feature_id: 3069,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Kodu",
    		type: "First Name",
    		origin: "Senegal",
    		continent: "Africa",
    		clean_name: "Kodu",
    		description: "Wolof (W. Africa, Senegal) first name.",
    		bio: "",
    		search_term: "",
    		diameter: "10.5",
    		center_lat: 0.9,
    		center_long: 338.7
    	},
    	{
    		feature_id: 3080,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Kollado",
    		type: "First Name",
    		origin: "Mali",
    		continent: "Africa",
    		clean_name: "Kollado",
    		description: "Fulbe first name.",
    		bio: "",
    		search_term: "",
    		diameter: "5.5",
    		center_lat: -61,
    		center_long: 53.4
    	},
    	{
    		feature_id: 3095,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Kosi",
    		type: "First Name",
    		origin: "Ghana",
    		continent: "Africa",
    		clean_name: "Kosi",
    		description: "Ewe first name.",
    		bio: "",
    		search_term: "",
    		diameter: "7.7",
    		center_lat: -43.9,
    		center_long: 54.9
    	},
    	{
    		feature_id: 3152,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Kumba",
    		type: "First Name",
    		origin: "Guinea",
    		continent: "Africa",
    		clean_name: "Kumba",
    		description: "Fulbe (W. Africa, Guinea) first name.",
    		bio: "",
    		search_term: "",
    		diameter: "11.4",
    		center_lat: 26.3,
    		center_long: 332.7
    	},
    	{
    		feature_id: 3168,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Kuro",
    		type: "First Name",
    		origin: "Senegal",
    		continent: "Africa",
    		clean_name: "Kuro",
    		description: "Fulbe first name.",
    		bio: "",
    		search_term: "",
    		diameter: "8.8",
    		center_lat: 7.8,
    		center_long: 57.6
    	},
    	{
    		feature_id: 3176,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Kyen",
    		type: "First Name",
    		origin: "Zaire",
    		continent: "Africa",
    		clean_name: "Kyen",
    		description: "Bantu first name.",
    		bio: "",
    		search_term: "",
    		diameter: "5.2",
    		center_lat: -6.2,
    		center_long: 64.7
    	},
    	{
    		feature_id: 3635,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Mansa",
    		type: "First Name",
    		origin: "Ghana",
    		continent: "Africa",
    		clean_name: "Mansa",
    		description: "Akan first name.",
    		bio: "",
    		search_term: "",
    		diameter: "8.1",
    		center_lat: -33.9,
    		center_long: 63.4
    	},
    	{
    		feature_id: 3775,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Mbul'di",
    		type: "First Name",
    		origin: "Niger",
    		continent: "Africa",
    		clean_name: "Mbul'di",
    		description: "Fulbe/Wodabi first name.",
    		bio: "",
    		search_term: "",
    		diameter: "6.0",
    		center_lat: 23.8,
    		center_long: 74.7
    	},
    	{
    		feature_id: 4047,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Mosaido",
    		type: "First Name",
    		origin: "Niger",
    		continent: "Africa",
    		clean_name: "Mosaido",
    		description: "Fulbe/Wodabi first name.",
    		bio: "",
    		search_term: "",
    		diameter: "7.4",
    		center_lat: 17.3,
    		center_long: 75.2
    	},
    	{
    		feature_id: 4176,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Ndella",
    		type: "First Name",
    		origin: "Senegal",
    		continent: "Africa",
    		clean_name: "Ndella",
    		description: "Wolof first name.",
    		bio: "",
    		search_term: "",
    		diameter: "5.9",
    		center_lat: -15.9,
    		center_long: 60.7
    	},
    	{
    		feature_id: 4240,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Ngone",
    		type: "First Name",
    		origin: "Senegal",
    		continent: "Africa",
    		clean_name: "Ngone",
    		description: "Wolof (W. Africa, Senegal) first name.",
    		bio: "",
    		search_term: "",
    		diameter: "12.2",
    		center_lat: 6,
    		center_long: 331.9
    	},
    	{
    		feature_id: 4348,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Nsele",
    		type: "First Name",
    		origin: "Mali",
    		continent: "Africa",
    		clean_name: "Nsele",
    		description: "Mandingo first name.",
    		bio: "",
    		search_term: "",
    		diameter: "5.1",
    		center_lat: 6.7,
    		center_long: 64.2
    	},
    	{
    		feature_id: 4370,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Nyal'ga",
    		type: "First Name",
    		origin: "Niger",
    		continent: "Africa",
    		clean_name: "Nyal'ga",
    		description: "Fulbe/Wodabi first name.",
    		bio: "",
    		search_term: "",
    		diameter: "5.5",
    		center_lat: 17,
    		center_long: 64.5
    	},
    	{
    		feature_id: 4373,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Nyele",
    		type: "First Name",
    		origin: "Mali",
    		continent: "Africa",
    		clean_name: "Nyele",
    		description: "Mandingo (W. Africa, Mali) first name.",
    		bio: "",
    		search_term: "",
    		diameter: "11.9",
    		center_lat: -22.7,
    		center_long: 318.4
    	},
    	{
    		feature_id: 4374,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Nyogari",
    		type: "First Name",
    		origin: "Ghana",
    		continent: "Africa",
    		clean_name: "Nyogari",
    		description: "Ewe (W. Africa, Ghana) first name.",
    		bio: "",
    		search_term: "",
    		diameter: "13.0",
    		center_lat: -46.4,
    		center_long: 306.4
    	},
    	{
    		feature_id: 4932,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Raki",
    		type: "First Name",
    		origin: "Senegal",
    		continent: "Africa",
    		clean_name: "Raki",
    		description: "Fulbe first name.",
    		bio: "",
    		search_term: "",
    		diameter: "7.5",
    		center_lat: -49.4,
    		center_long: 70
    	},
    	{
    		feature_id: 5832,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Tako",
    		type: "First Name",
    		origin: "Guinea",
    		continent: "Africa",
    		clean_name: "Tako",
    		description: "Fulbe first name.",
    		bio: "",
    		search_term: "",
    		diameter: "10.7",
    		center_lat: 25.1,
    		center_long: 285.3
    	},
    	{
    		feature_id: 6502,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Wazata",
    		type: "First Name",
    		origin: "Nigeria",
    		continent: "Africa",
    		clean_name: "Wazata",
    		description: "Hausa (Nigeria) first name.",
    		bio: "",
    		search_term: "",
    		diameter: "13.9",
    		center_lat: 33.6,
    		center_long: 298.3
    	},
    	{
    		feature_id: 6676,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Ytunde",
    		type: "First Name",
    		origin: "Nigeria",
    		continent: "Africa",
    		clean_name: "Ytunde",
    		description: "Yoruba first name.",
    		bio: "",
    		search_term: "",
    		diameter: "6.1",
    		center_lat: 49.9,
    		center_long: 81.1
    	},
    	{
    		feature_id: 32,
    		year: 1997,
    		feature: "Dorsum",
    		feature_plural: "Dorsa",
    		name: "Achek Dorsa",
    		type: "Goddess",
    		origin: "Sudan",
    		continent: "Africa",
    		clean_name: "Achek",
    		description: "Dinka (Sudan) wife of rain god Deng.",
    		bio: "",
    		search_term: "",
    		diameter: "1,000.0",
    		center_lat: -37.2,
    		center_long: 230
    	},
    	{
    		feature_id: 211,
    		year: 1997,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Ama Corona",
    		type: "Goddess",
    		origin: "Nigeria",
    		continent: "Africa",
    		clean_name: "Ama",
    		description: "Jukun (Central Nigeria) goddess of childbirth, personification of earth.",
    		bio: "",
    		search_term: "",
    		diameter: "300.0",
    		center_lat: -45.7,
    		center_long: 278.2
    	},
    	{
    		feature_id: 445,
    		year: 1997,
    		feature: "Mons",
    		feature_plural: "Montes",
    		name: "Atai Mons",
    		type: "Goddess",
    		origin: "Ghana",
    		continent: "Africa",
    		clean_name: "Atai",
    		description: "Efik (Ghana) wife of sky god Abassi.",
    		bio: "",
    		search_term: "",
    		diameter: "250.0",
    		center_lat: -22,
    		center_long: 291
    	},
    	{
    		feature_id: 650,
    		year: 1997,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Ba'het Corona",
    		type: "Goddess",
    		origin: "Egypt",
    		continent: "Africa",
    		clean_name: "Ba'het",
    		description: "Egyptian goddess of wealth and abundance.",
    		bio: "",
    		search_term: "",
    		diameter: "145.0",
    		center_lat: 48.4,
    		center_long: 0.1
    	},
    	{
    		feature_id: 784,
    		year: 1997,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Boala Corona",
    		type: "Goddess",
    		origin: "Zaire",
    		continent: "Africa",
    		clean_name: "Boala",
    		description: "Mongo-Nkundo (Bantu group, Zaire) the first woman, ancestor of people.",
    		bio: "",
    		search_term: "",
    		diameter: "220.0",
    		center_lat: -70,
    		center_long: 359
    	},
    	{
    		feature_id: 1485,
    		year: 1997,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Demvamvit Corona",
    		type: "Goddess",
    		origin: "Ethiopia",
    		continent: "Africa",
    		clean_name: "Demvamvit",
    		description: "Gurage (SW Ethiopia) women's goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "370.0",
    		center_lat: -65.5,
    		center_long: 38
    	},
    	{
    		feature_id: 1912,
    		year: 1997,
    		feature: "Mons",
    		feature_plural: "Montes",
    		name: "Faravari Mons",
    		type: "Goddess",
    		origin: "Madagascar",
    		continent: "Africa",
    		clean_name: "Faravari",
    		description: "Malagasy (Madagascar) water goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "500.0",
    		center_lat: -43.5,
    		center_long: 309
    	},
    	{
    		feature_id: 2126,
    		year: 1997,
    		feature: "Tessera",
    		feature_plural: "Tesserae",
    		name: "Gbadu Tessera",
    		type: "Goddess",
    		origin: "Benin",
    		continent: "Africa",
    		clean_name: "Gbadu",
    		description: "Fon (Benin) goddess of guessing.",
    		bio: "Gbadu is a god in the Dahomey mythology of the Fon people, who are now based in Benin, Nigeria, and Togo. She is one of Mawu-Lisa’s daughters, and just like her parents, consists of both a female and male aspect though she is mostly referred to with female pronouns. Gbadu is described as the female counterpart to Fa. According to certain accounts, Gbadu is considered the goddess of fate in Dahomey mythology.",
    		search_term: "Gbadu",
    		diameter: "700.0",
    		center_lat: -1,
    		center_long: 38
    	},
    	{
    		feature_id: 2956,
    		year: 1997,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Katieleo Corona",
    		type: "Goddess",
    		origin: "Burkina Faso (Upper Volta)",
    		continent: "Africa",
    		clean_name: "Katieleo",
    		description: "Senufo (Burkina Faso) creator goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "210.0",
    		center_lat: -12.5,
    		center_long: 327.5
    	},
    	{
    		feature_id: 3342,
    		year: 1997,
    		feature: "Dorsum",
    		feature_plural: "Dorsa",
    		name: "Lemkechen Dorsa",
    		type: "Goddess",
    		origin: "Berber",
    		continent: "Africa",
    		clean_name: "Lemkechen",
    		description: "Berber pole star goddess, holds camel motionless to milk it.",
    		bio: "",
    		search_term: "",
    		diameter: "2,000.0",
    		center_lat: 18.5,
    		center_long: 68.5
    	},
    	{
    		feature_id: 3864,
    		year: 1997,
    		feature: "Mons",
    		feature_plural: "Montes",
    		name: "Mertseger Mons",
    		type: "Goddess",
    		origin: "Egypt",
    		continent: "Africa",
    		clean_name: "Mertseger",
    		description: "Snake goddess of the Theban necropolis.",
    		bio: "Meretseger (also known as Mersegrit' or Mertseger) was a Theban cobra-goddess in ancient Egyptian religion, in charge with guarding and protecting the vast Theban Necropolis — on the west bank of the Nile, in front of Thebes — and especially the heavily guarded Valley of the Kings. Her cult was typical of the New Kingdom of Egypt (1550–1070 BC). Meretseger's name means \"She Who Loves Silence\", in reference to the silence of the desert cemetery area she kept or, according to another interpretation, \"Beloved of Him Who Makes Silence (Osiris)\".",
    		search_term: "Mertseger",
    		diameter: "450.0",
    		center_lat: -38.1,
    		center_long: 270.3
    	},
    	{
    		feature_id: 4025,
    		year: 1997,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Moombi Corona",
    		type: "Goddess",
    		origin: "Kenya",
    		continent: "Africa",
    		clean_name: "Moombi",
    		description: "Gikuyu (Kenya), the first woman, ancestor of nine tribes.",
    		bio: "",
    		search_term: "",
    		diameter: "100.0",
    		center_lat: -64.5,
    		center_long: 235.5
    	},
    	{
    		feature_id: 4111,
    		year: 1997,
    		feature: "Collis",
    		feature_plural: "Colles",
    		name: "Nahete Colles",
    		type: "Goddess",
    		origin: "Benin",
    		continent: "Africa",
    		clean_name: "Nahete",
    		description: "Fon (Benin) wife of sea god Agbe.",
    		bio: "",
    		search_term: "",
    		diameter: "400.0",
    		center_lat: 38,
    		center_long: 241
    	},
    	{
    		feature_id: 4114,
    		year: 1997,
    		feature: "Fossa",
    		feature_plural: "Fossae",
    		name: "Naijok Fossae",
    		type: "Goddess",
    		origin: "Sudan",
    		continent: "Africa",
    		clean_name: "Naijok",
    		description: "Dinka (Sudan) evil deity.",
    		bio: "",
    		search_term: "",
    		diameter: "450.0",
    		center_lat: -70.2,
    		center_long: 337
    	},
    	{
    		feature_id: 4122,
    		year: 1997,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Nalwanga Corona",
    		type: "Goddess",
    		origin: "Uganda",
    		continent: "Africa",
    		clean_name: "Nalwanga",
    		description: "Ganda (Uganda) goddess of childbirth.",
    		bio: "",
    		search_term: "",
    		diameter: "380.0",
    		center_lat: 48.7,
    		center_long: 247
    	},
    	{
    		feature_id: 4127,
    		year: 1997,
    		feature: "Fluctus",
    		feature_plural: "Fluctūs",
    		name: "Nambubi Fluctus",
    		type: "Goddess",
    		origin: "Uganda",
    		continent: "Africa",
    		clean_name: "Nambubi",
    		description: "Ganda goddess, mother of god Mukasa.",
    		bio: "",
    		search_term: "",
    		diameter: "850.0",
    		center_lat: -61,
    		center_long: 135
    	},
    	{
    		feature_id: 4171,
    		year: 1997,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Navolga Corona",
    		type: "Goddess",
    		origin: "Uganda",
    		continent: "Africa",
    		clean_name: "Navolga",
    		description: "Ganda (Uganda) goddess of childbirth.",
    		bio: "",
    		search_term: "",
    		diameter: "170.0",
    		center_lat: -48.6,
    		center_long: 296.5
    	},
    	{
    		feature_id: 4200,
    		year: 1997,
    		feature: "Fluctus",
    		feature_plural: "Fluctūs",
    		name: "Nekhebet Fluctus",
    		type: "Goddess",
    		origin: "Egypt",
    		continent: "Africa",
    		clean_name: "Nekhebet",
    		description: "Egyptian vulture goddess.",
    		bio: "Nekhbet is an early predynastic local goddess in Egyptian mythology, who was the patron of the city of Nekheb (her name meaning of Nekheb). Ultimately, she became the patron of Upper Egypt and one of the two patron deities for all of Ancient Egypt when it was unified. Nekhbet was the tutelary deity of Upper Egypt. Nekhbet and her Lower Egyptian counterpart Wadjet often appeared together as the \"Two Ladies\". In art, Nekhbet was depicted as a vulture.",
    		search_term: "Nekhebet",
    		diameter: "400.0",
    		center_lat: 0,
    		center_long: 35
    	},
    	{
    		feature_id: 4369,
    		year: 1997,
    		feature: "Vallis",
    		feature_plural: "Valles",
    		name: "Nyakaio Vallis",
    		type: "Goddess",
    		origin: "Sudan",
    		continent: "Africa",
    		clean_name: "Nyakaio",
    		description: "Shilluk (Sudan) semi-crocodile river deity.",
    		bio: "",
    		search_term: "",
    		diameter: "150.0",
    		center_lat: 47.5,
    		center_long: 339
    	},
    	{
    		feature_id: 4376,
    		year: 1997,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Nzambi Corona",
    		type: "Goddess",
    		origin: "Bantu",
    		continent: "Africa",
    		clean_name: "Nzambi",
    		description: "Congo (Bantu) ancestor goddess, mother of all beings.",
    		bio: "",
    		search_term: "",
    		diameter: "225.0",
    		center_lat: -45,
    		center_long: 287.5
    	},
    	{
    		feature_id: 4386,
    		year: 1997,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Obasi-Nsi Corona",
    		type: "Goddess",
    		origin: "Nigeria",
    		continent: "Africa",
    		clean_name: "Obasi-Nsi",
    		description: "Ekoi (S. Nigeria) earth/fertility goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "230.0",
    		center_lat: -53.5,
    		center_long: 291
    	},
    	{
    		feature_id: 4388,
    		year: 1997,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Obiemi Corona",
    		type: "Goddess",
    		origin: "Nigeria",
    		continent: "Africa",
    		clean_name: "Obiemi",
    		description: "Bini (Nigeria) childbirth goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "300.0",
    		center_lat: -31.9,
    		center_long: 276.6
    	},
    	{
    		feature_id: 4431,
    		year: 1997,
    		feature: "Chasma",
    		feature_plural: "Chasmata",
    		name: "Olapa Chasma",
    		type: "Goddess",
    		origin: "Kenya",
    		continent: "Africa",
    		clean_name: "Olapa",
    		description: "Massai (Kenya, Tanzania) moon goddess.",
    		bio: "Olapa, goddess of the moon, is married to Enkai (Ngai), god of the sun in Maasai mythology. The two fought one day, and Olapa, being a short tempered woman, inflicted Enkai with a wound. To hide his shame, he took to shining very brightly, so that no one could look straight at him.",
    		search_term: "Olapa",
    		diameter: "650.0",
    		center_lat: -42,
    		center_long: 208.5
    	},
    	{
    		feature_id: 4443,
    		year: 1997,
    		feature: "Vallis",
    		feature_plural: "Valles",
    		name: "Olokun Vallis",
    		type: "Goddess",
    		origin: "Nigeria",
    		continent: "Africa",
    		clean_name: "Olokun",
    		description: "Bini sea and river goddess (also known as a god).",
    		bio: "Olokun (Yoruba: Olókun) is an orisha spirit in Yoruba religion. Olokun is believed to be the parent of Aje, the orisha of great wealth and of the bottom of the ocean. Olokun is revered as the ruler of all bodies of water and for the authority over other water deities.",
    		search_term: "Olokun",
    		diameter: "150.0",
    		center_lat: 81.5,
    		center_long: 269
    	},
    	{
    		feature_id: 4445,
    		year: 1997,
    		feature: "Collis",
    		feature_plural: "Colles",
    		name: "Olosa Colles",
    		type: "Goddess",
    		origin: "Nigeria",
    		continent: "Africa",
    		clean_name: "Olosa",
    		description: "Yoruba (Nigeria) lagoon goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "200.0",
    		center_lat: 18,
    		center_long: 353.3
    	},
    	{
    		feature_id: 4505,
    		year: 1997,
    		feature: "Dorsum",
    		feature_plural: "Dorsa",
    		name: "Oshumare Dorsa",
    		type: "Goddess",
    		origin: "Nigeria",
    		continent: "Africa",
    		clean_name: "Oshumare",
    		description: "Yoruba rainbow deity.",
    		bio: "Oshunmare (known as Ochumaré or Oxumaré in Latin America) is an Orisha. Osumare is the spirit of the rainbow, and Osumare also means rainbow in the Yoruba language.",
    		search_term: "Oshumare",
    		diameter: "550.0",
    		center_lat: -58.5,
    		center_long: 79
    	},
    	{
    		feature_id: 4923,
    		year: 1997,
    		feature: "Fluctus",
    		feature_plural: "Fluctūs",
    		name: "Rafara Fluctus",
    		type: "Goddess",
    		origin: "Madagascar",
    		continent: "Africa",
    		clean_name: "Rafara",
    		description: "Malagasy (Madagascar) water goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "700.0",
    		center_lat: -65,
    		center_long: 159
    	},
    	{
    		feature_id: 4931,
    		year: 1997,
    		feature: "Mons",
    		feature_plural: "Montes",
    		name: "Rakapila Mons",
    		type: "Goddess",
    		origin: "Madagascar",
    		continent: "Africa",
    		clean_name: "Rakapila",
    		description: "Malagasy (Madagascar) sacred trees deity.",
    		bio: "",
    		search_term: "",
    		diameter: "130.0",
    		center_lat: -43.7,
    		center_long: 321.5
    	},
    	{
    		feature_id: 5448,
    		year: 1997,
    		feature: "Vallis",
    		feature_plural: "Valles",
    		name: "Sezibwa Vallis",
    		type: "Goddess",
    		origin: "Uganda",
    		continent: "Africa",
    		clean_name: "Sezibwa",
    		description: "Ganda river spirit.",
    		bio: "According to legend, the Ssezibwa River is not a natural phenomenon, but the progeny of a pregnant woman called Nakangu, who lived many hundreds of years ago and belonged to the Achibe (ox) clan. she was expected to give birth to twins, but instead what poured from her womb was a twin river, one that split into two distinct streams around an island immediately below the waterfall. The spirits of Nakangu's unborn children - Ssezibwa and Mobeya - each inhabit one of these streams.",
    		search_term: "Sezibwa",
    		diameter: "300.0",
    		center_lat: -44,
    		center_long: 37
    	},
    	{
    		feature_id: 5454,
    		year: 1997,
    		feature: "Tessera",
    		feature_plural: "Tesserae",
    		name: "Shait Tessera",
    		type: "Goddess",
    		origin: "Egypt",
    		continent: "Africa",
    		clean_name: "Shait",
    		description: "Egyptian human destiny goddess.",
    		bio: "Shai was the deification of the concept of fate in Egyptian mythology. As a concept, with no particular reason for associating one gender over another, Shai was sometimes considered female, rather than the more usual understanding of being male, in which circumstance Shai was referred to as Shait (simply the feminine form of the name). As the god of fate, it was said that he/she determined the span of each man's life, and was present at the judgement of the soul of the deceased in the Duat.",
    		search_term: "Shai",
    		diameter: "220.0",
    		center_lat: -54,
    		center_long: 173.5
    	},
    	{
    		feature_id: 5618,
    		year: 1997,
    		feature: "Dorsum",
    		feature_plural: "Dorsa",
    		name: "Sogbo Dorsa",
    		type: "Goddess",
    		origin: "Benin",
    		continent: "Africa",
    		clean_name: "Sogbo",
    		description: "Fon (Benin) thunder goddess/god.",
    		bio: "",
    		search_term: "",
    		diameter: "900.0",
    		center_lat: -40,
    		center_long: 237
    	},
    	{
    		feature_id: 5648,
    		year: 1997,
    		feature: "Tessera",
    		feature_plural: "Tesserae",
    		name: "Sopdet Tesserae",
    		type: "Goddess",
    		origin: "Egypt",
    		continent: "Africa",
    		clean_name: "Sopdet",
    		description: "Egyptian goddess of Sirius star and the forthcoming year.",
    		bio: "Sopdet is the ancient Egyptian name of the star Sirius and its personification as an Egyptian goddess. Known to the Greeks as Sothis, she was conflated with Isis as a goddess and Anubis as a god. The exact pronunciation of ancient Egyptian is uncertain, as vowels were not recorded until a very late period.",
    		search_term: "Sopdet",
    		diameter: "500.0",
    		center_lat: -45,
    		center_long: 243
    	},
    	{
    		feature_id: 5854,
    		year: 1997,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Tangba Corona",
    		type: "Goddess",
    		origin: "Burkina Faso (Upper Volta)",
    		continent: "Africa",
    		clean_name: "Tangba",
    		description: "Lobi (Burkina Faso) earth goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "200.0",
    		center_lat: -47,
    		center_long: 258
    	},
    	{
    		feature_id: 6016,
    		year: 1997,
    		feature: "Vallis",
    		feature_plural: "Valles",
    		name: "Tingoi Vallis",
    		type: "Goddess",
    		origin: "Mande",
    		continent: "Africa",
    		clean_name: "Tingoi",
    		description: "Mande (Sierra Leone) river spirit.",
    		bio: "",
    		search_term: "",
    		diameter: "250.0",
    		center_lat: 6,
    		center_long: 318.6
    	},
    	{
    		feature_id: 6181,
    		year: 1997,
    		feature: "Fluctus",
    		feature_plural: "Fluctūs",
    		name: "Ubastet Fluctus",
    		type: "Goddess",
    		origin: "Egypt",
    		continent: "Africa",
    		clean_name: "Ubastet",
    		description: "Egyptian cat goddess.",
    		bio: "Bastet or Bast was a goddess of ancient Egyptian religion, worshipped as early as the Second Dynasty (2890 BCE). Bastet was worshipped in Bubastis in Lower Egypt, originally as a lioness goddess, a role shared by other deities such as Sekhmet. Eventually Bastet and Sekhmet were characterized as two aspects of the same goddess, with Sekhmet representing the powerful warrior and protector aspect and Bastet, who increasingly was depicted as a cat, representing a gentler aspect.",
    		search_term: "Ubastet",
    		diameter: "550.0",
    		center_lat: -48,
    		center_long: 27
    	},
    	{
    		feature_id: 5619,
    		year: 1997,
    		feature: "Planitia",
    		feature_plural: "Planitiae",
    		name: "Sogolon Planitia",
    		type: "Heroine",
    		origin: "Mali",
    		continent: "Africa",
    		clean_name: "Sogolon ",
    		description: "Mandingo (Mali) epic heroine, buffalo-woman, mother of giant.",
    		bio: "Sunjata is an epic poem of the Malinke people that tells the story of the founding of the Mali Empire. Sogolon first appears in the Sunjata as a prophecy by a soothsayer to King Naré Maghan, which said she would be the one to bear him a son who will rule a united Mali. Described as having a hunchback; her name has since come to mean “hunchbacked” in West Africa.",
    		search_term: "Epic of Sundiata",
    		diameter: "1,600.0",
    		center_lat: 8,
    		center_long: 107
    	},
    	{
    		feature_id: 3150,
    		year: 1997,
    		feature: "Vallis",
    		feature_plural: "Valles",
    		name: "Kumanyefie Vallis",
    		type: "Other",
    		origin: "Ghana",
    		continent: "Africa",
    		clean_name: "Kumanyefie ",
    		description: "Ewe name for planet Venus.",
    		bio: "",
    		search_term: "",
    		diameter: "600.0",
    		center_lat: -80.5,
    		center_long: 335
    	},
    	{
    		feature_id: 4241,
    		year: 1997,
    		feature: "Vallis",
    		feature_plural: "Valles",
    		name: "Ngyandu Vallis",
    		type: "Other",
    		origin: "Bantu",
    		continent: "Africa",
    		clean_name: "Ngyandu ",
    		description: "Swahili name for planet Venus.",
    		bio: "",
    		search_term: "",
    		diameter: "500.0",
    		center_lat: -62,
    		center_long: 12
    	},
    	{
    		feature_id: 2659,
    		year: 1997,
    		feature: "Vallis",
    		feature_plural: "Valles",
    		name: "Ikhwezi Vallis",
    		type: "Other",
    		origin: "Zulu",
    		continent: "Africa",
    		clean_name: "Ikhwezi ",
    		description: "Zulu name for planet Venus.",
    		bio: "",
    		search_term: "",
    		diameter: "1,700.0",
    		center_lat: 16,
    		center_long: 147.8
    	},
    	{
    		feature_id: 3164,
    		year: 1997,
    		feature: "Patera",
    		feature_plural: "Paterae",
    		name: "Kupo Patera",
    		type: "Famous Woman",
    		origin: "Israel",
    		continent: "Asia",
    		clean_name: "Kupo",
    		description: "Irena; Israelite astronomer (1929-1978).",
    		bio: "",
    		search_term: "",
    		diameter: "100.0",
    		center_lat: -41.9,
    		center_long: 195.5
    	},
    	{
    		feature_id: 97,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Ahava",
    		type: "First Name",
    		origin: "Hebrew",
    		continent: "Asia",
    		clean_name: "Ahava",
    		description: "Hebrew first name.",
    		bio: "",
    		search_term: "",
    		diameter: "10.4",
    		center_lat: 53.6,
    		center_long: 187.3
    	},
    	{
    		feature_id: 108,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Aigul",
    		type: "First Name",
    		origin: "Kalmyk",
    		continent: "Asia",
    		clean_name: "Aigul",
    		description: "Kalmyk first name.",
    		bio: "",
    		search_term: "",
    		diameter: "6.0",
    		center_lat: 38.2,
    		center_long: 280.4
    	},
    	{
    		feature_id: 110,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Ailar",
    		type: "First Name",
    		origin: "Turkmenistan",
    		continent: "Asia",
    		clean_name: "Ailar",
    		description: "Turkman first name.",
    		bio: "",
    		search_term: "",
    		diameter: "8.2",
    		center_lat: -15.8,
    		center_long: 68.4
    	},
    	{
    		feature_id: 116,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Aisha",
    		type: "First Name",
    		origin: "Kyrgyzstan",
    		continent: "Asia",
    		clean_name: "Aisha",
    		description: "Kyrgyz first name.",
    		bio: "",
    		search_term: "",
    		diameter: "10.6",
    		center_lat: 39.3,
    		center_long: 53.3
    	},
    	{
    		feature_id: 207,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Altana",
    		type: "First Name",
    		origin: "Kalmyk",
    		continent: "Asia",
    		clean_name: "Altana",
    		description: "Kalmyk first name.",
    		bio: "",
    		search_term: "",
    		diameter: "6.0",
    		center_lat: 1.4,
    		center_long: 69.9
    	},
    	{
    		feature_id: 559,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Bahriyat",
    		type: "First Name",
    		origin: "Caucasus",
    		continent: "Asia",
    		clean_name: "Bahriyat",
    		description: "Kumyk (Daghestan) first name.",
    		bio: "",
    		search_term: "",
    		diameter: "5.0",
    		center_lat: 50.3,
    		center_long: 357.5
    	},
    	{
    		feature_id: 567,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Bakisat",
    		type: "First Name",
    		origin: "Caucasus",
    		continent: "Asia",
    		clean_name: "Bakisat",
    		description: "Chechen first name.",
    		bio: "",
    		search_term: "",
    		diameter: "7.4",
    		center_lat: 26,
    		center_long: 356.8
    	},
    	{
    		feature_id: 640,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Batya",
    		type: "First Name",
    		origin: "Hebrew",
    		continent: "Asia",
    		clean_name: "Batya",
    		description: "Hebrew first name.",
    		bio: "",
    		search_term: "",
    		diameter: "9.3",
    		center_lat: 72.7,
    		center_long: 235.4
    	},
    	{
    		feature_id: 1168,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Chechek",
    		type: "First Name",
    		origin: "Tuva",
    		continent: "Asia",
    		clean_name: "Chechek",
    		description: "Tuva (Siberia) first name.",
    		bio: "",
    		search_term: "",
    		diameter: "7.2",
    		center_lat: -2.6,
    		center_long: 272.3
    	},
    	{
    		feature_id: 1194,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Cholpon",
    		type: "First Name",
    		origin: "Kyrgyzstan",
    		continent: "Asia",
    		clean_name: "Cholpon",
    		description: "Kyrgyz first name.",
    		bio: "",
    		search_term: "",
    		diameter: "6.3",
    		center_lat: 40,
    		center_long: 290
    	},
    	{
    		feature_id: 1453,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Deborah",
    		type: "First Name",
    		origin: "Hebrew",
    		continent: "Asia",
    		clean_name: "Deborah",
    		description: "Hebrew first name.",
    		bio: "",
    		search_term: "",
    		diameter: "9.7",
    		center_lat: -37.3,
    		center_long: 10.6
    	},
    	{
    		feature_id: 1459,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Degu",
    		type: "First Name",
    		origin: "Caucasus",
    		continent: "Asia",
    		clean_name: "Degu",
    		description: "Adygan (N. Caucasus) first name.",
    		bio: "",
    		search_term: "",
    		diameter: "5.5",
    		center_lat: 27.3,
    		center_long: 289.9
    	},
    	{
    		feature_id: 1663,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Dunghe",
    		type: "First Name",
    		origin: "Kalmyk",
    		continent: "Asia",
    		clean_name: "Dunghe",
    		description: "Kalmyk first name.",
    		bio: "",
    		search_term: "",
    		diameter: "5.5",
    		center_lat: -56.2,
    		center_long: 295.3
    	},
    	{
    		feature_id: 1681,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Dyasya",
    		type: "First Name",
    		origin: "Siberia",
    		continent: "Asia",
    		clean_name: "Dyasya",
    		description: "Nganasan (Samoyed) first name.",
    		bio: "",
    		search_term: "",
    		diameter: "7.8",
    		center_lat: 5.1,
    		center_long: 297.6
    	},
    	{
    		feature_id: 1767,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Elizabeth",
    		type: "First Name",
    		origin: "Hebrew",
    		continent: "Asia",
    		clean_name: "Elizabeth",
    		description: "Hebrew first name.",
    		bio: "",
    		search_term: "",
    		diameter: "10.5",
    		center_lat: 59.1,
    		center_long: 215.4
    	},
    	{
    		feature_id: 1833,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Erkeley",
    		type: "First Name",
    		origin: "Altai",
    		continent: "Asia",
    		clean_name: "Erkeley",
    		description: "Altai first name.",
    		bio: "",
    		search_term: "",
    		diameter: "8.0",
    		center_lat: 43.9,
    		center_long: 103.3
    	},
    	{
    		feature_id: 1892,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Ezraela",
    		type: "First Name",
    		origin: "Hebrew",
    		continent: "Asia",
    		clean_name: "Ezraela",
    		description: "Hebrew first name.",
    		bio: "",
    		search_term: "",
    		diameter: "7.8",
    		center_lat: 57,
    		center_long: 186.8
    	},
    	{
    		feature_id: 1900,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Faina",
    		type: "First Name",
    		origin: "Turkey",
    		continent: "Asia",
    		clean_name: "Faina",
    		description: "Turkish first name.",
    		bio: "",
    		search_term: "",
    		diameter: "10.0",
    		center_lat: 71.1,
    		center_long: 100.7
    	},
    	{
    		feature_id: 1921,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Fava",
    		type: "First Name",
    		origin: "Kyrgyzstan",
    		continent: "Asia",
    		clean_name: "Fava",
    		description: "Dunghan (Kyrgyzstan) first name.",
    		bio: "",
    		search_term: "",
    		diameter: "9.7",
    		center_lat: -0.7,
    		center_long: 87.4
    	},
    	{
    		feature_id: 1923,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Fazu",
    		type: "First Name",
    		origin: "Caucasus",
    		continent: "Asia",
    		clean_name: "Fazu",
    		description: "Avarian (Daghestan) first name.",
    		bio: "",
    		search_term: "",
    		diameter: "6.1",
    		center_lat: 32.4,
    		center_long: 106
    	},
    	{
    		feature_id: 1965,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Firuza",
    		type: "First Name",
    		origin: "Persian",
    		continent: "Asia",
    		clean_name: "Firuza",
    		description: "Persian first name.",
    		bio: "",
    		search_term: "",
    		diameter: "6.0",
    		center_lat: 51.8,
    		center_long: 108
    	},
    	{
    		feature_id: 2279,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Gulchatay",
    		type: "First Name",
    		origin: "Arabian",
    		continent: "Asia",
    		clean_name: "Gulchatay",
    		description: "Arabic first name.",
    		bio: "",
    		search_term: "",
    		diameter: "9.0",
    		center_lat: 20.5,
    		center_long: 295.5
    	},
    	{
    		feature_id: 2281,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Gulnara",
    		type: "First Name",
    		origin: "Uzbekistan",
    		continent: "Asia",
    		clean_name: "Gulnara",
    		description: "Uzbek first name.",
    		bio: "",
    		search_term: "",
    		diameter: "5.0",
    		center_lat: -23.7,
    		center_long: 174
    	},
    	{
    		feature_id: 2293,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Guzel",
    		type: "First Name",
    		origin: "Arabian",
    		continent: "Asia",
    		clean_name: "Guzel",
    		description: "Arabic first name.",
    		bio: "",
    		search_term: "",
    		diameter: "7.3",
    		center_lat: -57.6,
    		center_long: 298.7
    	},
    	{
    		feature_id: 2308,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Hadisha",
    		type: "First Name",
    		origin: "Kazakhstan",
    		continent: "Asia",
    		clean_name: "Hadisha",
    		description: "Kazakh first name.",
    		bio: "",
    		search_term: "",
    		diameter: "8.9",
    		center_lat: -39,
    		center_long: 97.2
    	},
    	{
    		feature_id: 2522,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Hiromi",
    		type: "First Name",
    		origin: "Japan",
    		continent: "Asia",
    		clean_name: "Hiromi",
    		description: "Japanese first name.",
    		bio: "",
    		search_term: "",
    		diameter: "6.0",
    		center_lat: 35.2,
    		center_long: 287.3
    	},
    	{
    		feature_id: 2643,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Icheko",
    		type: "First Name",
    		origin: "Siberia",
    		continent: "Asia",
    		clean_name: "Icheko",
    		description: "Evenk/Tungu first name.",
    		bio: "",
    		search_term: "",
    		diameter: "5.9",
    		center_lat: 6.6,
    		center_long: 97.9
    	},
    	{
    		feature_id: 2674,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Imagmi",
    		type: "First Name",
    		origin: "Siberia",
    		continent: "Asia",
    		clean_name: "Imagmi",
    		description: "Eskimo (Chukotka) first name.",
    		bio: "",
    		search_term: "",
    		diameter: "7.6",
    		center_lat: -48.4,
    		center_long: 100.7
    	},
    	{
    		feature_id: 2706,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Iondra",
    		type: "First Name",
    		origin: "Siberia",
    		continent: "Asia",
    		clean_name: "Iondra",
    		description: "Selkup (Samoyed) first name.",
    		bio: "",
    		search_term: "",
    		diameter: "7.9",
    		center_lat: 10.5,
    		center_long: 286.5
    	},
    	{
    		feature_id: 2747,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Istadoy",
    		type: "First Name",
    		origin: "Tajik",
    		continent: "Asia",
    		clean_name: "Istadoy",
    		description: "Tajik first name.",
    		bio: "",
    		search_term: "",
    		diameter: "5.4",
    		center_lat: -51.8,
    		center_long: 132.6
    	},
    	{
    		feature_id: 2763,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Ivne",
    		type: "First Name",
    		origin: "Siberia",
    		continent: "Asia",
    		clean_name: "Ivne",
    		description: "Koryak (Kamchatka) first name.",
    		bio: "",
    		search_term: "",
    		diameter: "9.0",
    		center_lat: -27,
    		center_long: 132.8
    	},
    	{
    		feature_id: 2772,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Izakay",
    		type: "First Name",
    		origin: "Mari",
    		continent: "Asia",
    		clean_name: "Izakay",
    		description: "Mari first name.",
    		bio: "",
    		search_term: "",
    		diameter: "10.2",
    		center_lat: -12.3,
    		center_long: 210.8
    	},
    	{
    		feature_id: 2777,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Izudyr",
    		type: "First Name",
    		origin: "Mari",
    		continent: "Asia",
    		clean_name: "Izudyr",
    		description: "Mari (Volga Finn) first name.",
    		bio: "",
    		search_term: "",
    		diameter: "6.6",
    		center_lat: -53.9,
    		center_long: 135.2
    	},
    	{
    		feature_id: 2788,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Jalgurik",
    		type: "First Name",
    		origin: "Siberia",
    		continent: "Asia",
    		clean_name: "Jalgurik",
    		description: "Evenk/Tungu first name.",
    		bio: "",
    		search_term: "",
    		diameter: "7.5",
    		center_lat: -42.3,
    		center_long: 125.1
    	},
    	{
    		feature_id: 2791,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Jamila",
    		type: "First Name",
    		origin: "Afghanistan",
    		continent: "Asia",
    		clean_name: "Jamila",
    		description: "Afghan first name.",
    		bio: "",
    		search_term: "",
    		diameter: "7.9",
    		center_lat: 45.8,
    		center_long: 134.8
    	},
    	{
    		feature_id: 2795,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Jane",
    		type: "First Name",
    		origin: "Hebrew",
    		continent: "Asia",
    		clean_name: "Jane",
    		description: "Hebrew first name.",
    		bio: "",
    		search_term: "",
    		diameter: "10.2",
    		center_lat: -60.5,
    		center_long: 304.8
    	},
    	{
    		feature_id: 2803,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Janyl",
    		type: "First Name",
    		origin: "Kyrgyzstan",
    		continent: "Asia",
    		clean_name: "Janyl",
    		description: "Kyrgyz first name.",
    		bio: "",
    		search_term: "",
    		diameter: "5.6",
    		center_lat: -28,
    		center_long: 138.8
    	},
    	{
    		feature_id: 2861,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Jumaisat",
    		type: "First Name",
    		origin: "Caucasus",
    		continent: "Asia",
    		clean_name: "Jumaisat",
    		description: "Kumyk (Daghestan) first name.",
    		bio: "",
    		search_term: "",
    		diameter: "7.5",
    		center_lat: -15.1,
    		center_long: 135.6
    	},
    	{
    		feature_id: 2949,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Kastusha",
    		type: "First Name",
    		origin: "Mordvinian",
    		continent: "Asia",
    		clean_name: "Kastusha",
    		description: "Mordovian (Volga River Finn, Russia) first name.",
    		bio: "",
    		search_term: "",
    		diameter: "13.0",
    		center_lat: -28.6,
    		center_long: 59.9
    	},
    	{
    		feature_id: 2966,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Kavtora",
    		type: "First Name",
    		origin: "Afghanistan",
    		continent: "Asia",
    		clean_name: "Kavtora",
    		description: "Afghan first name.",
    		bio: "",
    		search_term: "",
    		diameter: "9.8",
    		center_lat: 59,
    		center_long: 23.3
    	},
    	{
    		feature_id: 2982,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Kelila",
    		type: "First Name",
    		origin: "Hebrew",
    		continent: "Asia",
    		clean_name: "Kelila",
    		description: "Hebrew first name.",
    		bio: "",
    		search_term: "",
    		diameter: "5.0",
    		center_lat: 52.6,
    		center_long: 191.8
    	},
    	{
    		feature_id: 2994,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Ketzia",
    		type: "First Name",
    		origin: "Hebrew",
    		continent: "Asia",
    		clean_name: "Ketzia",
    		description: "Hebrew first name.",
    		bio: "",
    		search_term: "",
    		diameter: "14.6",
    		center_lat: 3.9,
    		center_long: 300.5
    	},
    	{
    		feature_id: 2998,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Khadako",
    		type: "First Name",
    		origin: "Siberia",
    		continent: "Asia",
    		clean_name: "Khadako",
    		description: "Nenets (Samoyed) first name.",
    		bio: "",
    		search_term: "",
    		diameter: "7.4",
    		center_lat: 54.2,
    		center_long: 139.3
    	},
    	{
    		feature_id: 3001,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Khafiza",
    		type: "First Name",
    		origin: "Arabian",
    		continent: "Asia",
    		clean_name: "Khafiza",
    		description: "Arabic first name.",
    		bio: "",
    		search_term: "",
    		diameter: "7.0",
    		center_lat: 6,
    		center_long: 299.2
    	},
    	{
    		feature_id: 3074,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Koinyt",
    		type: "First Name",
    		origin: "Siberia",
    		continent: "Asia",
    		clean_name: "Koinyt",
    		description: "Nivkhi (E. Siberia) first name.",
    		bio: "",
    		search_term: "",
    		diameter: "11.7",
    		center_lat: -30.9,
    		center_long: 293.2
    	},
    	{
    		feature_id: 3154,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Kumudu",
    		type: "First Name",
    		origin: "Sri Lanka",
    		continent: "Asia",
    		clean_name: "Kumudu",
    		description: "Singalese first name.",
    		bio: "",
    		search_term: "",
    		diameter: "4.4",
    		center_lat: 61.3,
    		center_long: 154.1
    	},
    	{
    		feature_id: 3376,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Lhagva",
    		type: "First Name",
    		origin: "Mongolia",
    		continent: "Asia",
    		clean_name: "Lhagva",
    		description: "Mongolian first name.",
    		bio: "",
    		search_term: "",
    		diameter: "7.9",
    		center_lat: -75.8,
    		center_long: 300.1
    	},
    	{
    		feature_id: 3438,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Loan",
    		type: "First Name",
    		origin: "Vietnam",
    		continent: "Asia",
    		clean_name: "Loan",
    		description: "Vietnamese first name.",
    		bio: "",
    		search_term: "",
    		diameter: "7.4",
    		center_lat: 28.3,
    		center_long: 60
    	},
    	{
    		feature_id: 3497,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Lu Zhi",
    		type: "First Name",
    		origin: "China",
    		continent: "Asia",
    		clean_name: "Lu Zhi",
    		description: "Chinese first name.",
    		bio: "",
    		search_term: "",
    		diameter: "8.3",
    		center_lat: -42.6,
    		center_long: 303.4
    	},
    	{
    		feature_id: 3566,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Madina",
    		type: "First Name",
    		origin: "Caucasus",
    		continent: "Asia",
    		clean_name: "Madina",
    		description: "Kabarda first name.",
    		bio: "",
    		search_term: "",
    		diameter: "6.3",
    		center_lat: 22.7,
    		center_long: 58
    	},
    	{
    		feature_id: 3577,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Magdalena",
    		type: "First Name",
    		origin: "Hebrew",
    		continent: "Asia",
    		clean_name: "Magdalena",
    		description: "Spanish form of Hebrew first name.",
    		bio: "",
    		search_term: "",
    		diameter: "11.5",
    		center_lat: -11.2,
    		center_long: 48.7
    	},
    	{
    		feature_id: 3616,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Mamajan",
    		type: "First Name",
    		origin: "Turkmenistan",
    		continent: "Asia",
    		clean_name: "Mamajan",
    		description: "Turkman first name.",
    		bio: "",
    		search_term: "",
    		diameter: "2.0",
    		center_lat: -65.1,
    		center_long: 257.3
    	},
    	{
    		feature_id: 3709,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Mariko",
    		type: "First Name",
    		origin: "Japan",
    		continent: "Asia",
    		clean_name: "Mariko",
    		description: "Japanese first name.",
    		bio: "",
    		search_term: "",
    		diameter: "12.9",
    		center_lat: -23.3,
    		center_long: 132.9
    	},
    	{
    		feature_id: 4121,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Nalkuta",
    		type: "First Name",
    		origin: "Caucasus",
    		continent: "Asia",
    		clean_name: "Nalkuta",
    		description: "Ossetian (N. Caucasus) first name.",
    		bio: "",
    		search_term: "",
    		diameter: "6.5",
    		center_lat: 30.1,
    		center_long: 307.8
    	},
    	{
    		feature_id: 4128,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Namiko",
    		type: "First Name",
    		origin: "Japan",
    		continent: "Asia",
    		clean_name: "Namiko",
    		description: "Japanese first name.",
    		bio: "",
    		search_term: "",
    		diameter: "13.0",
    		center_lat: 43.4,
    		center_long: 56.2
    	},
    	{
    		feature_id: 4186,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Nedko",
    		type: "First Name",
    		origin: "Siberia",
    		continent: "Asia",
    		clean_name: "Nedko",
    		description: "Nenets (Samoyed) first name.",
    		bio: "",
    		search_term: "",
    		diameter: "8.5",
    		center_lat: -8.8,
    		center_long: 317.6
    	},
    	{
    		feature_id: 4201,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Nelike",
    		type: "First Name",
    		origin: "Nanai",
    		continent: "Asia",
    		clean_name: "Nelike",
    		description: "Nanay (E. Siberia) first name.",
    		bio: "",
    		search_term: "",
    		diameter: "6.3",
    		center_lat: -26.8,
    		center_long: 329.2
    	},
    	{
    		feature_id: 4269,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Nilanti",
    		type: "First Name",
    		origin: "Sri Lanka",
    		continent: "Asia",
    		clean_name: "Nilanti",
    		description: "Singalese first name.",
    		bio: "",
    		search_term: "",
    		diameter: "9.2",
    		center_lat: -38.2,
    		center_long: 331.4
    	},
    	{
    		feature_id: 4302,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Ninzi",
    		type: "First Name",
    		origin: "Myanmar",
    		continent: "Asia",
    		clean_name: "Ninzi",
    		description: "Burma (Myanmar) first name.",
    		bio: "",
    		search_term: "",
    		diameter: "7.1",
    		center_lat: 15.9,
    		center_long: 331.7
    	},
    	{
    		feature_id: 4360,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Nuon",
    		type: "First Name",
    		origin: "Cambodia",
    		continent: "Asia",
    		clean_name: "Nuon",
    		description: "Khmer first name.",
    		bio: "",
    		search_term: "",
    		diameter: "6.5",
    		center_lat: 78.6,
    		center_long: 336.6
    	},
    	{
    		feature_id: 4402,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Odikha",
    		type: "First Name",
    		origin: "Uzbekistan",
    		continent: "Asia",
    		clean_name: "Odikha",
    		description: "Uzbek first name.",
    		bio: "",
    		search_term: "",
    		diameter: "10.6",
    		center_lat: -41.6,
    		center_long: 238.1
    	},
    	{
    		feature_id: 4414,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Ogulbek",
    		type: "First Name",
    		origin: "Turkmenistan",
    		continent: "Asia",
    		clean_name: "Ogulbek",
    		description: "Turkman first name.",
    		bio: "",
    		search_term: "",
    		diameter: "6.5",
    		center_lat: 2.4,
    		center_long: 145
    	},
    	{
    		feature_id: 4479,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Opika",
    		type: "First Name",
    		origin: "Chuvash",
    		continent: "Asia",
    		clean_name: "Opika",
    		description: "Chuvash (Volga area) first name.",
    		bio: "",
    		search_term: "",
    		diameter: "9.8",
    		center_lat: -57.1,
    		center_long: 151.9
    	},
    	{
    		feature_id: 4490,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Orguk",
    		type: "First Name",
    		origin: "Siberia",
    		continent: "Asia",
    		clean_name: "Orguk",
    		description: "Nivkhi (Amur River area, E. Siberia) first name.",
    		bio: "",
    		search_term: "",
    		diameter: "11.7",
    		center_lat: -23.5,
    		center_long: 198.2
    	},
    	{
    		feature_id: 4504,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Oshalche",
    		type: "First Name",
    		origin: "Mari",
    		continent: "Asia",
    		clean_name: "Oshalche",
    		description: "Mari (Volga Finn) first name.",
    		bio: "",
    		search_term: "",
    		diameter: "8.3",
    		center_lat: 29.7,
    		center_long: 155.5
    	},
    	{
    		feature_id: 4589,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Parishan",
    		type: "First Name",
    		origin: "Turkey",
    		continent: "Asia",
    		clean_name: "Parishan",
    		description: "Kurdian first name.",
    		bio: "",
    		search_term: "",
    		diameter: "6.8",
    		center_lat: -0.2,
    		center_long: 146.5
    	},
    	{
    		feature_id: 4598,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Parvina",
    		type: "First Name",
    		origin: "Tajik",
    		continent: "Asia",
    		clean_name: "Parvina",
    		description: "Tajik first name.",
    		bio: "",
    		search_term: "",
    		diameter: "7.0",
    		center_lat: -62.2,
    		center_long: 153
    	},
    	{
    		feature_id: 4609,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Patimat",
    		type: "First Name",
    		origin: "Caucasus",
    		continent: "Asia",
    		clean_name: "Patimat",
    		description: "Avarian (Daghestan) first name.",
    		bio: "",
    		search_term: "",
    		diameter: "5.1",
    		center_lat: -1.3,
    		center_long: 156.5
    	},
    	{
    		feature_id: 4874,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Purev",
    		type: "First Name",
    		origin: "Mongolia",
    		continent: "Asia",
    		clean_name: "Purev",
    		description: "Mongolian first name.",
    		bio: "",
    		search_term: "",
    		diameter: "11.6",
    		center_lat: -31.1,
    		center_long: 46.4
    	},
    	{
    		feature_id: 4879,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Pychik",
    		type: "First Name",
    		origin: "Siberia",
    		continent: "Asia",
    		clean_name: "Pychik",
    		description: "Chukcha (NE Siberia) first name.",
    		bio: "",
    		search_term: "",
    		diameter: "10.1",
    		center_lat: -62.4,
    		center_long: 33.8
    	},
    	{
    		feature_id: 4892,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Qarlygha",
    		type: "First Name",
    		origin: "Kazakhstan",
    		continent: "Asia",
    		clean_name: "Qarlygha",
    		description: "Kazakh first name.",
    		bio: "",
    		search_term: "",
    		diameter: "9.3",
    		center_lat: -33,
    		center_long: 162.9
    	},
    	{
    		feature_id: 4904,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Qulzhan",
    		type: "First Name",
    		origin: "Kazakhstan",
    		continent: "Asia",
    		clean_name: "Qulzhan",
    		description: "Kazakh first name.",
    		bio: "",
    		search_term: "",
    		diameter: "7.9",
    		center_lat: 23.5,
    		center_long: 165.4
    	},
    	{
    		feature_id: 4906,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Quslu",
    		type: "First Name",
    		origin: "Kazakhstan",
    		continent: "Asia",
    		clean_name: "Quslu",
    		description: "Kazakh first name.",
    		bio: "",
    		search_term: "",
    		diameter: "8.7",
    		center_lat: 6.2,
    		center_long: 166.8
    	},
    	{
    		feature_id: 4918,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Radhika",
    		type: "First Name",
    		origin: "Sri Lanka",
    		continent: "Asia",
    		clean_name: "Radhika",
    		description: "Tamil first name.",
    		bio: "",
    		search_term: "",
    		diameter: "7.9",
    		center_lat: -30.3,
    		center_long: 166.4
    	},
    	{
    		feature_id: 4922,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Rae",
    		type: "First Name",
    		origin: "Hebrew",
    		continent: "Asia",
    		clean_name: "Rae",
    		description: "From Rachel, Hebrew first name.",
    		bio: "",
    		search_term: "",
    		diameter: "5.5",
    		center_lat: -8.9,
    		center_long: 58.4
    	},
    	{
    		feature_id: 4938,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Rampyari",
    		type: "First Name",
    		origin: "India",
    		continent: "Asia",
    		clean_name: "Rampyari",
    		description: "Hindu first name.",
    		bio: "",
    		search_term: "",
    		diameter: "7.7",
    		center_lat: 50.6,
    		center_long: 179.3
    	},
    	{
    		feature_id: 4972,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Rebecca",
    		type: "First Name",
    		origin: "Hebrew",
    		continent: "Asia",
    		clean_name: "Rebecca",
    		description: "Hebrew first name.",
    		bio: "",
    		search_term: "",
    		diameter: "9.5",
    		center_lat: -12.1,
    		center_long: 5.4
    	},
    	{
    		feature_id: 4984,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Reiko",
    		type: "First Name",
    		origin: "Japan",
    		continent: "Asia",
    		clean_name: "Reiko",
    		description: "Japanese first name.",
    		bio: "",
    		search_term: "",
    		diameter: "9.7",
    		center_lat: 22.6,
    		center_long: 192.1
    	},
    	{
    		feature_id: 5005,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Retno",
    		type: "First Name",
    		origin: "Indonesia",
    		continent: "Asia",
    		clean_name: "Retno",
    		description: "Indonesian first name.",
    		bio: "",
    		search_term: "",
    		diameter: "7.2",
    		center_lat: -52.9,
    		center_long: 192.3
    	},
    	{
    		feature_id: 5185,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Roptyna",
    		type: "First Name",
    		origin: "Siberia",
    		continent: "Asia",
    		clean_name: "Roptyna",
    		description: "Chukcha (NE Siberia) first name.",
    		bio: "",
    		search_term: "",
    		diameter: "11.5",
    		center_lat: 62.2,
    		center_long: 28.9
    	},
    	{
    		feature_id: 5206,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Royle",
    		type: "First Name",
    		origin: "Bashkir",
    		continent: "Asia",
    		clean_name: "Royle",
    		description: "Bashkir first name.",
    		bio: "",
    		search_term: "",
    		diameter: "6.1",
    		center_lat: -32.7,
    		center_long: 193.7
    	},
    	{
    		feature_id: 5222,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Runak",
    		type: "First Name",
    		origin: "Turkey",
    		continent: "Asia",
    		clean_name: "Runak",
    		description: "Kurdian first name.",
    		bio: "",
    		search_term: "",
    		diameter: "7.6",
    		center_lat: -58.5,
    		center_long: 196.3
    	},
    	{
    		feature_id: 5273,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Safarmo",
    		type: "First Name",
    		origin: "Tajik",
    		continent: "Asia",
    		clean_name: "Safarmo",
    		description: "Tajik first name.",
    		bio: "",
    		search_term: "",
    		diameter: "7.4",
    		center_lat: -10.8,
    		center_long: 161.4
    	},
    	{
    		feature_id: 5278,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Saida",
    		type: "First Name",
    		origin: "Arabian",
    		continent: "Asia",
    		clean_name: "Saida",
    		description: "Arabic first name.",
    		bio: "",
    		search_term: "",
    		diameter: "9.5",
    		center_lat: 28.2,
    		center_long: 302
    	},
    	{
    		feature_id: 5304,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Sandugach",
    		type: "First Name",
    		origin: "Tartar",
    		continent: "Asia",
    		clean_name: "Sandugach",
    		description: "Tartar first name.",
    		bio: "",
    		search_term: "",
    		diameter: "10.0",
    		center_lat: 59.9,
    		center_long: 143.5
    	},
    	{
    		feature_id: 5351,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Sayligul",
    		type: "First Name",
    		origin: "Tajik",
    		continent: "Asia",
    		clean_name: "Sayligul",
    		description: "Tajik first name.",
    		bio: "",
    		search_term: "",
    		diameter: "4.3",
    		center_lat: 73.6,
    		center_long: 172.9
    	},
    	{
    		feature_id: 5438,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Seseg",
    		type: "First Name",
    		origin: "Buriat",
    		continent: "Asia",
    		clean_name: "Seseg",
    		description: "Buryat (Siberia) first name.",
    		bio: "",
    		search_term: "",
    		diameter: "9.8",
    		center_lat: -36.3,
    		center_long: 312.6
    	},
    	{
    		feature_id: 5475,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Shasenem",
    		type: "First Name",
    		origin: "Turkmenistan",
    		continent: "Asia",
    		clean_name: "Shasenem",
    		description: "Turkman first name.",
    		bio: "",
    		search_term: "",
    		diameter: "9.0",
    		center_lat: -44,
    		center_long: 258.9
    	},
    	{
    		feature_id: 5537,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Simbya",
    		type: "First Name",
    		origin: "Siberia",
    		continent: "Asia",
    		clean_name: "Simbya",
    		description: "Nganasan (Samoyed) first name.",
    		bio: "",
    		search_term: "",
    		diameter: "4.0",
    		center_lat: -74.4,
    		center_long: 130
    	},
    	{
    		feature_id: 6023,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Tinyl",
    		type: "First Name",
    		origin: "Siberia",
    		continent: "Asia",
    		clean_name: "Tinyl",
    		description: "Chukcha (NE Siberia) first name.",
    		bio: "",
    		search_term: "",
    		diameter: "12.8",
    		center_lat: 9.7,
    		center_long: 132.1
    	},
    	{
    		feature_id: 6050,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Tolgonay",
    		type: "First Name",
    		origin: "Kyrgyzstan",
    		continent: "Asia",
    		clean_name: "Tolgonay",
    		description: "Kyrgyz first name.",
    		bio: "",
    		search_term: "",
    		diameter: "4.6",
    		center_lat: 68.8,
    		center_long: 271.1
    	},
    	{
    		feature_id: 6105,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Tsetsa",
    		type: "First Name",
    		origin: "Mordvinian",
    		continent: "Asia",
    		clean_name: "Tsetsa",
    		description: "Mordovian (Volga Finn) first name.",
    		bio: "",
    		search_term: "",
    		diameter: "9.9",
    		center_lat: 31.3,
    		center_long: 317.7
    	},
    	{
    		feature_id: 6115,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Tsyrma",
    		type: "First Name",
    		origin: "Buriat",
    		continent: "Asia",
    		clean_name: "Tsyrma",
    		description: "Buryat (Siberia) first name.",
    		bio: "",
    		search_term: "",
    		diameter: "7.8",
    		center_lat: -14.1,
    		center_long: 318.5
    	},
    	{
    		feature_id: 6148,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Tursunoy",
    		type: "First Name",
    		origin: "Uzbekistan",
    		continent: "Asia",
    		clean_name: "Tursunoy",
    		description: "Uzbek first name.",
    		bio: "",
    		search_term: "",
    		diameter: "4.7",
    		center_lat: 80.9,
    		center_long: 229.3
    	},
    	{
    		feature_id: 6157,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Tuyara",
    		type: "First Name",
    		origin: "Yakutian",
    		continent: "Asia",
    		clean_name: "Tuyara",
    		description: "Yakut first name.",
    		bio: "",
    		search_term: "",
    		diameter: "13.2",
    		center_lat: -62.9,
    		center_long: 15.5
    	},
    	{
    		feature_id: 6180,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Ualinka",
    		type: "First Name",
    		origin: "Caucasus",
    		continent: "Asia",
    		clean_name: "Ualinka",
    		description: "Ossetian (N. Caucasus) first name.",
    		bio: "",
    		search_term: "",
    		diameter: "8.1",
    		center_lat: 13.2,
    		center_long: 168.6
    	},
    	{
    		feature_id: 6184,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Udagan",
    		type: "First Name",
    		origin: "Yakutian",
    		continent: "Asia",
    		clean_name: "Udagan",
    		description: "Yakut first name.",
    		bio: "",
    		search_term: "",
    		diameter: "11.5",
    		center_lat: 10.7,
    		center_long: 206.9
    	},
    	{
    		feature_id: 6186,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Udyaka",
    		type: "First Name",
    		origin: "Siberia",
    		continent: "Asia",
    		clean_name: "Udyaka",
    		description: "Orochi (Amur River) first name.",
    		bio: "",
    		search_term: "",
    		diameter: "7.7",
    		center_lat: 30.9,
    		center_long: 172.9
    	},
    	{
    		feature_id: 6197,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Uleken",
    		type: "First Name",
    		origin: "Nanai",
    		continent: "Asia",
    		clean_name: "Uleken",
    		description: "Nanay (Amur River area, E. Siberia) first name.",
    		bio: "",
    		search_term: "",
    		diameter: "10.9",
    		center_lat: 33.7,
    		center_long: 185.1
    	},
    	{
    		feature_id: 6208,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Uluk",
    		type: "First Name",
    		origin: "Neghidhian",
    		continent: "Asia",
    		clean_name: "Uluk",
    		description: "Neghidalian (Amur River area, E. Siberia) first name.",
    		bio: "",
    		search_term: "",
    		diameter: "10.3",
    		center_lat: -62.2,
    		center_long: 178.6
    	},
    	{
    		feature_id: 6215,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Umaima",
    		type: "First Name",
    		origin: "Arabian",
    		continent: "Asia",
    		clean_name: "Umaima",
    		description: "Arabic first name.",
    		bio: "",
    		search_term: "",
    		diameter: "6.9",
    		center_lat: -23.3,
    		center_long: 195.4
    	},
    	{
    		feature_id: 6219,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Umkana",
    		type: "First Name",
    		origin: "Siberia",
    		continent: "Asia",
    		clean_name: "Umkana",
    		description: "Eskimo (Chukotka) first name.",
    		bio: "",
    		search_term: "",
    		diameter: "6.2",
    		center_lat: -53.3,
    		center_long: 198.6
    	},
    	{
    		feature_id: 6221,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Unay",
    		type: "First Name",
    		origin: "Mari",
    		continent: "Asia",
    		clean_name: "Unay",
    		description: "Mari first name.",
    		bio: "",
    		search_term: "",
    		diameter: "11.4",
    		center_lat: 53.5,
    		center_long: 172.7
    	},
    	{
    		feature_id: 6227,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Unitkak",
    		type: "First Name",
    		origin: "Siberia",
    		continent: "Asia",
    		clean_name: "Unitkak",
    		description: "Eskimo (Chukotka) first name.",
    		bio: "",
    		search_term: "",
    		diameter: "8.0",
    		center_lat: 40.8,
    		center_long: 199.5
    	},
    	{
    		feature_id: 6239,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Urazbike",
    		type: "First Name",
    		origin: "Tartar",
    		continent: "Asia",
    		clean_name: "Urazbike",
    		description: "Tartar first name.",
    		bio: "",
    		search_term: "",
    		diameter: "7.0",
    		center_lat: -9,
    		center_long: 202.5
    	},
    	{
    		feature_id: 6265,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Uyengimi",
    		type: "First Name",
    		origin: "Siberia",
    		continent: "Asia",
    		clean_name: "Uyengimi",
    		description: "Khanty, Mansi (Ob River Finn) first name.",
    		bio: "",
    		search_term: "",
    		diameter: "8.9",
    		center_lat: -76.9,
    		center_long: 204.9
    	},
    	{
    		feature_id: 6608,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Xi Wang",
    		type: "First Name",
    		origin: "China",
    		continent: "Asia",
    		clean_name: "Xi Wang",
    		description: "Chinese first name.",
    		bio: "",
    		search_term: "",
    		diameter: "7.7",
    		center_lat: 14,
    		center_long: 208
    	},
    	{
    		feature_id: 6627,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Yakyt",
    		type: "First Name",
    		origin: "Uzbekistan",
    		continent: "Asia",
    		clean_name: "Yakyt",
    		description: "Karakalpak first name.",
    		bio: "",
    		search_term: "",
    		diameter: "13.8",
    		center_lat: 2.1,
    		center_long: 170.2
    	},
    	{
    		feature_id: 6635,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Yambika",
    		type: "First Name",
    		origin: "Mari",
    		continent: "Asia",
    		clean_name: "Yambika",
    		description: "Mari (Volga Finn) first name.",
    		bio: "",
    		search_term: "",
    		diameter: "6.5",
    		center_lat: 32.6,
    		center_long: 208.7
    	},
    	{
    		feature_id: 6643,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Yasuko",
    		type: "First Name",
    		origin: "Japan",
    		continent: "Asia",
    		clean_name: "Yasuko",
    		description: "Japanese first name.",
    		bio: "",
    		search_term: "",
    		diameter: "10.6",
    		center_lat: -26.1,
    		center_long: 169
    	},
    	{
    		feature_id: 6646,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Yazruk",
    		type: "First Name",
    		origin: "Siberia",
    		continent: "Asia",
    		clean_name: "Yazruk",
    		description: "Nivkhi (Amur River area, E. Siberia) first name.",
    		bio: "",
    		search_term: "",
    		diameter: "10.5",
    		center_lat: 21.2,
    		center_long: 160.2
    	},
    	{
    		feature_id: 6652,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Yelya",
    		type: "First Name",
    		origin: "Siberia",
    		continent: "Asia",
    		clean_name: "Yelya",
    		description: "Nenets (Samoyed) first name.",
    		bio: "",
    		search_term: "",
    		diameter: "8.6",
    		center_lat: -47.5,
    		center_long: 211.7
    	},
    	{
    		feature_id: 6653,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Yemysh",
    		type: "First Name",
    		origin: "Mari",
    		continent: "Asia",
    		clean_name: "Yemysh",
    		description: "Mari (Volga Finn) first name.",
    		bio: "",
    		search_term: "",
    		diameter: "6.0",
    		center_lat: 11.9,
    		center_long: 214.7
    	},
    	{
    		feature_id: 6656,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Yenlik",
    		type: "First Name",
    		origin: "Kazakhstan",
    		continent: "Asia",
    		clean_name: "Yenlik",
    		description: "Kazakh first name.",
    		bio: "",
    		search_term: "",
    		diameter: "8.6",
    		center_lat: -16,
    		center_long: 225.4
    	},
    	{
    		feature_id: 6657,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Yerguk",
    		type: "First Name",
    		origin: "Neghidhian",
    		continent: "Asia",
    		clean_name: "Yerguk",
    		description: "Neghidalian (Amur River) first name.",
    		bio: "",
    		search_term: "",
    		diameter: "6.3",
    		center_lat: 42.7,
    		center_long: 226.8
    	},
    	{
    		feature_id: 6659,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Yeska",
    		type: "First Name",
    		origin: "Siberia",
    		continent: "Asia",
    		clean_name: "Yeska",
    		description: "Selkup (Samoyed) first name.",
    		bio: "",
    		search_term: "",
    		diameter: "9.1",
    		center_lat: 27.4,
    		center_long: 230.1
    	},
    	{
    		feature_id: 6663,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Yokhtik",
    		type: "First Name",
    		origin: "Siberia",
    		continent: "Asia",
    		clean_name: "Yokhtik",
    		description: "Nivkhi (Amur River area, E. Siberia) first name.",
    		bio: "",
    		search_term: "",
    		diameter: "11.4",
    		center_lat: -50.1,
    		center_long: 158.1
    	},
    	{
    		feature_id: 6664,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Yoko",
    		type: "First Name",
    		origin: "Japan",
    		continent: "Asia",
    		clean_name: "Yoko",
    		description: "Japanese first name.",
    		bio: "",
    		search_term: "",
    		diameter: "5.0",
    		center_lat: -5.7,
    		center_long: 232
    	},
    	{
    		feature_id: 6667,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Yomile",
    		type: "First Name",
    		origin: "Bashkir",
    		continent: "Asia",
    		clean_name: "Yomile",
    		description: "Bashkir first name.",
    		bio: "",
    		search_term: "",
    		diameter: "13.6",
    		center_lat: -27.3,
    		center_long: 138.7
    	},
    	{
    		feature_id: 6669,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Yonok",
    		type: "First Name",
    		origin: "Korea",
    		continent: "Asia",
    		clean_name: "Yonok",
    		description: "Korean first name.",
    		bio: "",
    		search_term: "",
    		diameter: "9.5",
    		center_lat: -65.1,
    		center_long: 234.1
    	},
    	{
    		feature_id: 6670,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Yonsuk",
    		type: "First Name",
    		origin: "Korea",
    		continent: "Asia",
    		clean_name: "Yonsuk",
    		description: "Korean first name.",
    		bio: "",
    		search_term: "",
    		diameter: "8.5",
    		center_lat: -34,
    		center_long: 234.8
    	},
    	{
    		feature_id: 6693,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Zakiya",
    		type: "First Name",
    		origin: "Arabian",
    		continent: "Asia",
    		clean_name: "Zakiya",
    		description: "Arabic first name.",
    		bio: "",
    		search_term: "",
    		diameter: "7.5",
    		center_lat: -66.5,
    		center_long: 234.1
    	},
    	{
    		feature_id: 6703,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Zarema",
    		type: "First Name",
    		origin: "Caucasus",
    		continent: "Asia",
    		clean_name: "Zarema",
    		description: "Avarian (Daghestan) first name.",
    		bio: "",
    		search_term: "",
    		diameter: "5.0",
    		center_lat: 16.8,
    		center_long: 235.2
    	},
    	{
    		feature_id: 6712,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Zeinab",
    		type: "First Name",
    		origin: "Persian",
    		continent: "Asia",
    		clean_name: "Zeinab",
    		description: "Persian first name.",
    		bio: "",
    		search_term: "",
    		diameter: "12.5",
    		center_lat: -2.2,
    		center_long: 159.6
    	},
    	{
    		feature_id: 6723,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Zerine",
    		type: "First Name",
    		origin: "Persian",
    		continent: "Asia",
    		clean_name: "Zerine",
    		description: "Persian first name.",
    		bio: "",
    		search_term: "",
    		diameter: "6.5",
    		center_lat: -29.6,
    		center_long: 258.6
    	},
    	{
    		feature_id: 6758,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Zuhrah",
    		type: "First Name",
    		origin: "Arabian",
    		continent: "Asia",
    		clean_name: "Zuhrah",
    		description: "Arabic first name.",
    		bio: "",
    		search_term: "",
    		diameter: "5.8",
    		center_lat: 34.7,
    		center_long: 357
    	},
    	{
    		feature_id: 6759,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Zula",
    		type: "First Name",
    		origin: "Caucasus",
    		continent: "Asia",
    		clean_name: "Zula",
    		description: "Chechen first name.",
    		bio: "",
    		search_term: "",
    		diameter: "5.0",
    		center_lat: 7.3,
    		center_long: 282
    	},
    	{
    		feature_id: 6760,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Zulfiya",
    		type: "First Name",
    		origin: "Uzbekistan",
    		continent: "Asia",
    		clean_name: "Zulfiya",
    		description: "Uzbek first name.",
    		bio: "",
    		search_term: "",
    		diameter: "12.9",
    		center_lat: 18.4,
    		center_long: 101.9
    	},
    	{
    		feature_id: 6763,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Zumrad",
    		type: "First Name",
    		origin: "Uzbekistan",
    		continent: "Asia",
    		clean_name: "Zumrad",
    		description: "Uzbek first name.",
    		bio: "",
    		search_term: "",
    		diameter: "12.9",
    		center_lat: 32.1,
    		center_long: 94.8
    	},
    	{
    		feature_id: 51,
    		year: 1997,
    		feature: "Dorsum",
    		feature_plural: "Dorsa",
    		name: "Aditi Dorsa",
    		type: "Goddess",
    		origin: "India",
    		continent: "Asia",
    		clean_name: "Aditi",
    		description: "Indian sky goddess.",
    		bio: "Aditi is an important Vedic goddess in Hinduism. She is the personification of the sprawling infinite and vast cosmos. She is the goddess of motherhood, consciousness, unconsciousness, the past, the future, and fertility. She is the mother of the celestial deities known as the adityas, and is referred to as the mother of many deities.",
    		search_term: "Aditi",
    		diameter: "1,200.0",
    		center_lat: -30,
    		center_long: 189
    	},
    	{
    		feature_id: 109,
    		year: 1997,
    		feature: "Chasma",
    		feature_plural: "Chasmata",
    		name: "Aikhylu Chasma",
    		type: "Goddess",
    		origin: "Bashkir",
    		continent: "Asia",
    		clean_name: "Aikhylu",
    		description: "Bashkir myth's moon daughter.",
    		bio: "",
    		search_term: "",
    		diameter: "300.0",
    		center_lat: 32,
    		center_long: 292
    	},
    	{
    		feature_id: 122,
    		year: 1997,
    		feature: "Fossa",
    		feature_plural: "Fossae",
    		name: "Ajina Fossae",
    		type: "Goddess",
    		origin: "Tajik",
    		continent: "Asia",
    		clean_name: "Ajina",
    		description: "Tajik evil spirit.",
    		bio: "",
    		search_term: "",
    		diameter: "300.0",
    		center_lat: -45,
    		center_long: 258
    	},
    	{
    		feature_id: 140,
    		year: 1997,
    		feature: "Dorsum",
    		feature_plural: "Dorsa",
    		name: "Akuanda Dorsa",
    		type: "Goddess",
    		origin: "Caucasus",
    		continent: "Asia",
    		clean_name: "Akuanda",
    		description: "Adygan light deity.",
    		bio: "",
    		search_term: "",
    		diameter: "800.0",
    		center_lat: 63.5,
    		center_long: 232
    	},
    	{
    		feature_id: 161,
    		year: 1997,
    		feature: "Fossa",
    		feature_plural: "Fossae",
    		name: "Albasty Fossae",
    		type: "Goddess",
    		origin: "Tartar",
    		continent: "Asia",
    		clean_name: "Albasty",
    		description: "Tartar evil spirit.",
    		bio: "In Caucasian Folklore, an almas, alma or almasty, is a cryptid, folk creature or deity said to inhabit the Caucasus, Tian Shan and Pamir Mountains of Central Asia and the Altai Mountains of western Mongolia. It is known as kung-guressu (\"man-beast\").",
    		search_term: "Albasty",
    		diameter: "500.0",
    		center_lat: -9,
    		center_long: 336.5
    	},
    	{
    		feature_id: 167,
    		year: 1997,
    		feature: "Vallis",
    		feature_plural: "Valles",
    		name: "Albys Vallis",
    		type: "Goddess",
    		origin: "Tuva",
    		continent: "Asia",
    		clean_name: "Albys",
    		description: "Tuva/Altay river deity.",
    		bio: "",
    		search_term: "",
    		diameter: "240.0",
    		center_lat: -39.5,
    		center_long: 30.5
    	},
    	{
    		feature_id: 201,
    		year: 1997,
    		feature: "Fluctus",
    		feature_plural: "Fluctūs",
    		name: "Alpan Fluctus",
    		type: "Goddess",
    		origin: "Caucasus",
    		continent: "Asia",
    		clean_name: "Alpan",
    		description: "Lezghin (Daghestan) fire goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "500.0",
    		center_lat: -7.5,
    		center_long: 349
    	},
    	{
    		feature_id: 222,
    		year: 1997,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Ambar-ona Corona",
    		type: "Goddess",
    		origin: "Uzbekistan",
    		continent: "Asia",
    		clean_name: "Ambar-ona",
    		description: "Uzbek women's and fertility goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "550.0",
    		center_lat: -70,
    		center_long: 82.5
    	},
    	{
    		feature_id: 249,
    		year: 1997,
    		feature: "Mons",
    		feature_plural: "Montes",
    		name: "Anala Mons",
    		type: "Goddess",
    		origin: "India",
    		continent: "Asia",
    		clean_name: "Anala",
    		description: "Hindu fertility goddess. Name changed from Anala Corona.",
    		bio: "In Hinduism, Anala (\"fire\" in Sanskrit) is one of the Vasus, gods of the material world. He is equated with Agni, and is essentially the name usually used for Agni when listed among the Vasus.",
    		search_term: "Anala",
    		diameter: "525.0",
    		center_lat: 11,
    		center_long: 14.1
    	},
    	{
    		feature_id: 366,
    		year: 1997,
    		feature: "Fluctus",
    		feature_plural: "Fluctūs",
    		name: "Argimpasa Fluctus",
    		type: "Goddess",
    		origin: "Scythia",
    		continent: "Asia",
    		clean_name: "Argimpasa",
    		description: "Scythian goddess of love.",
    		bio: "Artimpasa (Ancient Greek: Αρτιμπασα Artimpasa; Latin: Artimpasa) was a complex androgynous Scythian goddess of fertility who possessed power over sovereignty and the priestly force. Artimpasa was a goddess of warfare, sovereignty, priestly force, fecundity, vegetation and fertility.",
    		search_term: "Artimpasa",
    		diameter: "950.0",
    		center_lat: 0,
    		center_long: 175.5
    	},
    	{
    		feature_id: 463,
    		year: 1997,
    		feature: "Mons",
    		feature_plural: "Montes",
    		name: "Atsyrkhus Mons",
    		type: "Goddess",
    		origin: "Caucasus",
    		continent: "Asia",
    		clean_name: "Atsyrkhus",
    		description: "Ossetian, daughter of sun god Khur.",
    		bio: "",
    		search_term: "",
    		diameter: "170.0",
    		center_lat: -78.5,
    		center_long: 227
    	},
    	{
    		feature_id: 635,
    		year: 1997,
    		feature: "Tessera",
    		feature_plural: "Tesserae",
    		name: "Bathkol Tessera",
    		type: "Goddess",
    		origin: "Israel",
    		continent: "Asia",
    		clean_name: "Bathkol",
    		description: "Israeli goddess of fate.",
    		bio: "",
    		search_term: "",
    		diameter: "1,485.0",
    		center_lat: 61,
    		center_long: 200
    	},
    	{
    		feature_id: 736,
    		year: 1997,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Bibi-Patma Corona",
    		type: "Goddess",
    		origin: "Turkmenistan",
    		continent: "Asia",
    		clean_name: "Bibi-Patma",
    		description: "Turkman goddess of women.",
    		bio: "",
    		search_term: "",
    		diameter: "450.0",
    		center_lat: -47,
    		center_long: 302
    	},
    	{
    		feature_id: 746,
    		year: 1997,
    		feature: "Dorsum",
    		feature_plural: "Dorsa",
    		name: "Biliku Dorsa",
    		type: "Goddess",
    		origin: "India",
    		continent: "Asia",
    		clean_name: "Biliku",
    		description: "Andaman Isl. monsoon deity.",
    		bio: "",
    		search_term: "",
    		diameter: "600.0",
    		center_lat: -47,
    		center_long: 138
    	},
    	{
    		feature_id: 1134,
    		year: 1997,
    		feature: "Chasma",
    		feature_plural: "Chasmata",
    		name: "Chang Xi Chasmata",
    		type: "Goddess",
    		origin: "China",
    		continent: "Asia",
    		clean_name: "Chang Xi",
    		description: "Chinese, gave birth to twelve moons.",
    		bio: "Changxi or Changyi is a Chinese lunar goddess worshiped in the traditional Chinese pantheon. Known from ancient times, the earliest historical information on Changxi can be traced back to the Classic of Mountains and Seas (Shan-hai Ching). She is the wife of Di Jun and the mother of twelve moons.",
    		search_term: "Chang Xi",
    		diameter: "220.0",
    		center_lat: -59,
    		center_long: 17
    	},
    	{
    		feature_id: 1158,
    		year: 1997,
    		feature: "Dorsum",
    		feature_plural: "Dorsa",
    		name: "Charykh-Keyok Dorsa",
    		type: "Goddess",
    		origin: "Siberia",
    		continent: "Asia",
    		clean_name: "Charykh-Keyok",
    		description: "Khakasian (S. Siberia) magic bird.",
    		bio: "",
    		search_term: "",
    		diameter: "550.0",
    		center_lat: 54.5,
    		center_long: 285
    	},
    	{
    		feature_id: 1519,
    		year: 1997,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Dhorani Corona",
    		type: "Goddess",
    		origin: "Thailand",
    		continent: "Asia",
    		clean_name: "Dhorani",
    		description: "Thai earth and love goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "200.0",
    		center_lat: -8,
    		center_long: 243
    	},
    	{
    		feature_id: 1556,
    		year: 1997,
    		feature: "Fluctus",
    		feature_plural: "Fluctūs",
    		name: "Djata Fluctus",
    		type: "Goddess",
    		origin: "Indonesia",
    		continent: "Asia",
    		clean_name: "Djata",
    		description: "Ngadju (Kalimantan Isl., Indonesia) water goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "280.0",
    		center_lat: 66.5,
    		center_long: 307.5
    	},
    	{
    		feature_id: 1627,
    		year: 1997,
    		feature: "Fluctus",
    		feature_plural: "Fluctūs",
    		name: "Dotetem Fluctus",
    		type: "Goddess",
    		origin: "Siberia",
    		continent: "Asia",
    		clean_name: "Dotetem",
    		description: "Ketian (Yenisey R.) evil spirit.",
    		bio: "",
    		search_term: "",
    		diameter: "530.0",
    		center_lat: -6,
    		center_long: 177.5
    	},
    	{
    		feature_id: 1628,
    		year: 1997,
    		feature: "Tessera",
    		feature_plural: "Tesserae",
    		name: "Dou-Mu Tesserae",
    		type: "Goddess",
    		origin: "China",
    		continent: "Asia",
    		clean_name: "Dou-Mu",
    		description: "Chinese life/death ruling goddess.",
    		bio: "Dǒumǔ is a goddess in Chinese religion and Taoism. She is the feminine aspect of the cosmic God of Heaven. The seven stars of the Big Dipper, in addition to two not visible to the naked eye, are conceived as her sons.",
    		search_term: "Dou-Mu",
    		diameter: "400.0",
    		center_lat: -60,
    		center_long: 244
    	},
    	{
    		feature_id: 1666,
    		year: 1997,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Dunne-Musun Corona",
    		type: "Goddess",
    		origin: "Siberia",
    		continent: "Asia",
    		clean_name: "Dunne-Musun",
    		description: "Evenk (Tungu) earth and taiga mistress.",
    		bio: "",
    		search_term: "",
    		diameter: "630.0",
    		center_lat: -60,
    		center_long: 85
    	},
    	{
    		feature_id: 1679,
    		year: 1997,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Dyamenyuo Corona",
    		type: "Goddess",
    		origin: "Siberia",
    		continent: "Asia",
    		clean_name: "Dyamenyuo",
    		description: "Enets (Samoyed) women's and childbirth deity.",
    		bio: "",
    		search_term: "",
    		diameter: "200.0",
    		center_lat: -57.5,
    		center_long: 42.5
    	},
    	{
    		feature_id: 1682,
    		year: 1997,
    		feature: "Dorsum",
    		feature_plural: "Dorsa",
    		name: "Dylacha Dorsa",
    		type: "Goddess",
    		origin: "Tungu",
    		continent: "Asia",
    		clean_name: "Dylacha",
    		description: "Evenk/Tungu (Siberia) sun goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "650.0",
    		center_lat: -19,
    		center_long: 76
    	},
    	{
    		feature_id: 1751,
    		year: 1997,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Ekhe-Burkhan Corona",
    		type: "Goddess",
    		origin: "Buriat",
    		continent: "Asia",
    		clean_name: "Ekhe-Burkhan",
    		description: "Buryatian creator goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "600.0",
    		center_lat: -50,
    		center_long: 40
    	},
    	{
    		feature_id: 1791,
    		year: 1997,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Emegen Corona",
    		type: "Goddess",
    		origin: "Tuva",
    		continent: "Asia",
    		clean_name: "Emegen",
    		description: "Tuva (S. Siberia) childcare goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "180.0",
    		center_lat: 37.5,
    		center_long: 290.5
    	},
    	{
    		feature_id: 1800,
    		year: 1997,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Enekeler Corona",
    		type: "Goddess",
    		origin: "Altai",
    		continent: "Asia",
    		clean_name: "Enekeler",
    		description: "Altay childbirth goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "350.0",
    		center_lat: -46,
    		center_long: 264
    	},
    	{
    		feature_id: 2035,
    		year: 1997,
    		feature: "Vallis",
    		feature_plural: "Valles",
    		name: "Fufei Vallis",
    		type: "Goddess",
    		origin: "China",
    		continent: "Asia",
    		clean_name: "Fufei",
    		description: "Chinese goddess of Lo River.",
    		bio: "",
    		search_term: "",
    		diameter: "170.0",
    		center_lat: 46,
    		center_long: 341
    	},
    	{
    		feature_id: 2042,
    		year: 1997,
    		feature: "Tholus",
    		feature_plural: "Tholi",
    		name: "Furki Tholus",
    		type: "Goddess",
    		origin: "Caucasus",
    		continent: "Asia",
    		clean_name: "Furki",
    		description: "Chechen and Ingush (Caucasus) goddess, wife of thunder god Sela. Name changed from Furki Mons.",
    		bio: "",
    		search_term: "",
    		diameter: "79.0",
    		center_lat: 35.9,
    		center_long: 236.4
    	},
    	{
    		feature_id: 2087,
    		year: 1997,
    		feature: "Chasma",
    		feature_plural: "Chasmata",
    		name: "Gamsilg Chasma",
    		type: "Goddess",
    		origin: "Caucasus",
    		continent: "Asia",
    		clean_name: "Gamsilg",
    		description: "Chechen and Ingush evil forest deity.",
    		bio: "",
    		search_term: "",
    		diameter: "600.0",
    		center_lat: -46,
    		center_long: 64
    	},
    	{
    		feature_id: 2269,
    		year: 1997,
    		feature: "Chasma",
    		feature_plural: "Chasmata",
    		name: "Gui Ye Chasma",
    		type: "Goddess",
    		origin: "China",
    		continent: "Asia",
    		clean_name: "Gui Ye",
    		description: "Chinese moon fairy.",
    		bio: "",
    		search_term: "",
    		diameter: "210.0",
    		center_lat: -9,
    		center_long: 337.1
    	},
    	{
    		feature_id: 2277,
    		year: 1997,
    		feature: "Fossa",
    		feature_plural: "Fossae",
    		name: "Gulaim Fossae",
    		type: "Goddess",
    		origin: "Uzbekistan",
    		continent: "Asia",
    		clean_name: "Gulaim",
    		description: "Karakalpak amazon leader.",
    		bio: "",
    		search_term: "",
    		diameter: "800.0",
    		center_lat: -5,
    		center_long: 329
    	},
    	{
    		feature_id: 2288,
    		year: 1997,
    		feature: "Mons",
    		feature_plural: "Montes",
    		name: "Gurshi Mons",
    		type: "Goddess",
    		origin: "Buriat",
    		continent: "Asia",
    		clean_name: "Gurshi",
    		description: "Buryatian fishing deity.",
    		bio: "",
    		search_term: "",
    		diameter: "210.0",
    		center_lat: -47.5,
    		center_long: 58.5
    	},
    	{
    		feature_id: 2440,
    		year: 1997,
    		feature: "Vallis",
    		feature_plural: "Valles",
    		name: "Helmud Vallis",
    		type: "Goddess",
    		origin: "Afghanistan",
    		continent: "Asia",
    		clean_name: "Helmud",
    		description: "Afghanistan river goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "280.0",
    		center_lat: -33.9,
    		center_long: 171.3
    	},
    	{
    		feature_id: 2529,
    		year: 1997,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Hlineu Corona",
    		type: "Goddess",
    		origin: "Myanmar",
    		continent: "Asia",
    		clean_name: "Hlineu",
    		description: "Chin/Kieng (Burma/Myanmar, Bangladesh) ancestor goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "150.0",
    		center_lat: -38.7,
    		center_long: 241
    	},
    	{
    		feature_id: 2579,
    		year: 1997,
    		feature: "Tessera",
    		feature_plural: "Tesserae",
    		name: "Humai Tessera",
    		type: "Goddess",
    		origin: "Iran",
    		continent: "Asia",
    		clean_name: "Humai",
    		description: "Iranian happiness bird.",
    		bio: "The Huma also Homa, is a mythical bird of Iranian legends and fables, and continuing as a common motif in Sufi and Diwan poetry. Although there are many legends of the creature, common to all is that the bird is said never to alight on the ground, and instead to live its entire life flying invisibly high above the earth.",
    		search_term: "Huma bird",
    		diameter: "350.0",
    		center_lat: -53,
    		center_long: 250
    	},
    	{
    		feature_id: 2628,
    		year: 1997,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Iang-Mdiye Corona",
    		type: "Goddess",
    		origin: "Vietnam",
    		continent: "Asia",
    		clean_name: "Iang-Mdiye",
    		description: "Ede (Vietnam) goddess of rice.",
    		bio: "",
    		search_term: "",
    		diameter: "300.0",
    		center_lat: -47,
    		center_long: 86
    	},
    	{
    		feature_id: 2721,
    		year: 1997,
    		feature: "Mons",
    		feature_plural: "Montes",
    		name: "Irnini Mons",
    		type: "Goddess",
    		origin: "Assyro-Babylonian",
    		continent: "Asia",
    		clean_name: "Irnini",
    		description: "Assyro-Babylonian goddess of cedar-tree mountains.",
    		bio: "",
    		search_term: "",
    		diameter: "525.0",
    		center_lat: 14.6,
    		center_long: 16
    	},
    	{
    		feature_id: 2728,
    		year: 1997,
    		feature: "Mons",
    		feature_plural: "Montes",
    		name: "Iseghey Mons",
    		type: "Goddess",
    		origin: "Yakutian",
    		continent: "Asia",
    		clean_name: "Iseghey",
    		description: "Yakutian/Saha goddess of cows.",
    		bio: "",
    		search_term: "",
    		diameter: "500.0",
    		center_lat: 9,
    		center_long: 171
    	},
    	{
    		feature_id: 2896,
    		year: 1997,
    		feature: "Mons",
    		feature_plural: "Montes",
    		name: "Kali Mons",
    		type: "Goddess",
    		origin: "India",
    		continent: "Asia",
    		clean_name: "Kali",
    		description: "Hindu goddess, mother of death.",
    		bio: "Kali, also referred to as Mahakali, Bhadrakali, and Kalika, is a Hindu goddess who is considered to be the goddess of ultimate power, time, destruction and change in Shaktism. In this tradition, she is considered as a ferocious form of goddess Mahadevi, the supreme of all powers, or the ultimate reality.",
    		search_term: "Kali",
    		diameter: "325.0",
    		center_lat: 9.4,
    		center_long: 29.2
    	},
    	{
    		feature_id: 2900,
    		year: 1997,
    		feature: "Dorsum",
    		feature_plural: "Dorsa",
    		name: "Kalm Dorsa",
    		type: "Goddess",
    		origin: "Siberia",
    		continent: "Asia",
    		clean_name: "Kalm",
    		description: "Mansi (Ob River Ugra) winged messenger from gods to humans.",
    		bio: "",
    		search_term: "",
    		diameter: "300.0",
    		center_lat: 18,
    		center_long: 309
    	},
    	{
    		feature_id: 2902,
    		year: 1997,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Kaltash Corona",
    		type: "Goddess",
    		origin: "Siberia",
    		continent: "Asia",
    		clean_name: "Kaltash",
    		description: "Mansi (Ob River Ugra) mother goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "450.0",
    		center_lat: 0.5,
    		center_long: 75
    	},
    	{
    		feature_id: 2957,
    		year: 1997,
    		feature: "Mons",
    		feature_plural: "Montes",
    		name: "Katl-Imi Mons",
    		type: "Goddess",
    		origin: "Siberia",
    		continent: "Asia",
    		clean_name: "Katl-Imi",
    		description: "Khanty (Ob River Ugra) sun goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "120.0",
    		center_lat: -69,
    		center_long: 126
    	},
    	{
    		feature_id: 2999,
    		year: 1997,
    		feature: "Dorsum",
    		feature_plural: "Dorsa",
    		name: "Khadne Dorsa",
    		type: "Goddess",
    		origin: "Siberia",
    		continent: "Asia",
    		clean_name: "Khadne",
    		description: "Nenets (Samoyed) snowstorm maiden.",
    		bio: "",
    		search_term: "",
    		diameter: "220.0",
    		center_lat: -14,
    		center_long: 334.5
    	},
    	{
    		feature_id: 3013,
    		year: 1997,
    		feature: "Fossa",
    		feature_plural: "Fossae",
    		name: "Khosedem Fossae",
    		type: "Goddess",
    		origin: "Siberia",
    		continent: "Asia",
    		clean_name: "Khosedem",
    		description: "Ketian (Yenisey R.) main evil goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "1,800.0",
    		center_lat: -13,
    		center_long: 303
    	},
    	{
    		feature_id: 3014,
    		year: 1997,
    		feature: "Tholus",
    		feature_plural: "Tholi",
    		name: "Khotal-Ekva Tholi",
    		type: "Goddess",
    		origin: "Siberia",
    		continent: "Asia",
    		clean_name: "Khotal-Ekva",
    		description: "Mansi (Ob River Ugra) sun goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "50.0",
    		center_lat: -9.1,
    		center_long: 177.8
    	},
    	{
    		feature_id: 3019,
    		year: 1997,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Ki Corona",
    		type: "Goddess",
    		origin: "Sumerian",
    		continent: "Asia",
    		clean_name: "Ki",
    		description: "Sumerian earth goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "300.0",
    		center_lat: 43.2,
    		center_long: 227.8
    	},
    	{
    		feature_id: 3043,
    		year: 1997,
    		feature: "Vallis",
    		feature_plural: "Valles",
    		name: "Kinsei Vallis",
    		type: "Goddess",
    		origin: "Japan",
    		continent: "Asia",
    		clean_name: "Kinsei",
    		description: "Japanese name for planet Venus.",
    		bio: "",
    		search_term: "",
    		diameter: "375.0",
    		center_lat: 13.8,
    		center_long: 140.2
    	},
    	{
    		feature_id: 3103,
    		year: 1997,
    		feature: "Chasma",
    		feature_plural: "Chasmata",
    		name: "Kov-Ava Chasma",
    		type: "Goddess",
    		origin: "Mordvinian",
    		continent: "Asia",
    		clean_name: "Kov-Ava",
    		description: "Mordovian (Volga River Finn) forest mistress.",
    		bio: "",
    		search_term: "",
    		diameter: "470.0",
    		center_lat: -58.8,
    		center_long: 21.8
    	},
    	{
    		feature_id: 3130,
    		year: 1997,
    		feature: "Mons",
    		feature_plural: "Montes",
    		name: "Kshumay Mons",
    		type: "Goddess",
    		origin: "Afghanistan",
    		continent: "Asia",
    		clean_name: "Kshumay",
    		description: "Nuristan (NE Afghanistan) vegetation goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "250.0",
    		center_lat: -54.9,
    		center_long: 58
    	},
    	{
    		feature_id: 3142,
    		year: 1997,
    		feature: "Dorsum",
    		feature_plural: "Dorsa",
    		name: "Kuldurok Dorsa",
    		type: "Goddess",
    		origin: "Uzbekistan",
    		continent: "Asia",
    		clean_name: "Kuldurok",
    		description: "Uzbek thunder and lightning goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "1,100.0",
    		center_lat: -50.4,
    		center_long: 61
    	},
    	{
    		feature_id: 3175,
    		year: 1997,
    		feature: "Tholus",
    		feature_plural: "Tholi",
    		name: "Kwannon Tholus",
    		type: "Goddess",
    		origin: "Japan",
    		continent: "Asia",
    		clean_name: "Kwannon",
    		description: "Japanese Buddhist goddess of mercy.",
    		bio: "Guanyin is a Bodhisattva associated with compassion, also known as Kwannon or Kannon. She is the East Asian representation of Avalokiteśvara and has been adopted by other Eastern religions, including Chinese folk religion. She was first given the appellation of \"Goddess of Mercy\" or \"Mercy Goddess\" by Jesuit missionaries in China.",
    		search_term: "Kwannon",
    		diameter: "135.0",
    		center_lat: -26.3,
    		center_long: 296.8
    	},
    	{
    		feature_id: 3275,
    		year: 1997,
    		feature: "Mons",
    		feature_plural: "Montes",
    		name: "Lanig Mons",
    		type: "Goddess",
    		origin: "Malaysia",
    		continent: "Asia",
    		clean_name: "Lanig",
    		description: "Semang (Malay Peninsula) creator goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "400.0",
    		center_lat: -68.5,
    		center_long: 91
    	},
    	{
    		feature_id: 3295,
    		year: 1997,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Latta Corona",
    		type: "Goddess",
    		origin: "Caucasus",
    		continent: "Asia",
    		clean_name: "Latta",
    		description: "Chechen/Ingush (N. Caucasus, Russia) earth goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "225.0",
    		center_lat: -38.6,
    		center_long: 287
    	},
    	{
    		feature_id: 3377,
    		year: 1997,
    		feature: "Tessera",
    		feature_plural: "Tesserae",
    		name: "Lhamo Tessera",
    		type: "Goddess",
    		origin: "Tibet",
    		continent: "Asia",
    		clean_name: "Lhamo",
    		description: "Tibetan time and fate goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "800.0",
    		center_lat: -51,
    		center_long: 15
    	},
    	{
    		feature_id: 3516,
    		year: 1997,
    		feature: "Dorsum",
    		feature_plural: "Dorsa",
    		name: "Lumo Dorsa",
    		type: "Goddess",
    		origin: "Tibet",
    		continent: "Asia",
    		clean_name: "Lumo",
    		description: "Tibetan goddess of sky, rain, and mist.",
    		bio: "",
    		search_term: "",
    		diameter: "500.0",
    		center_lat: 24.5,
    		center_long: 149
    	},
    	{
    		feature_id: 3520,
    		year: 1997,
    		feature: "Vallis",
    		feature_plural: "Valles",
    		name: "Lunang Vallis",
    		type: "Goddess",
    		origin: "Afghanistan",
    		continent: "Asia",
    		clean_name: "Lunang",
    		description: "Nuristan goddess of Parun River.",
    		bio: "",
    		search_term: "",
    		diameter: "250.0",
    		center_lat: 68.2,
    		center_long: 310
    	},
    	{
    		feature_id: 3544,
    		year: 1997,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Ma Corona",
    		type: "Goddess",
    		origin: "Babylon",
    		continent: "Asia",
    		clean_name: "Ma",
    		description: "Fertility goddess from Asia Minor.",
    		bio: "",
    		search_term: "",
    		diameter: "420.0",
    		center_lat: -22.5,
    		center_long: 57
    	},
    	{
    		feature_id: 3584,
    		year: 1997,
    		feature: "Tessera",
    		feature_plural: "Tesserae",
    		name: "Mago-Halmi Tesserae",
    		type: "Goddess",
    		origin: "Korea",
    		continent: "Asia",
    		clean_name: "Mago-Halmi",
    		description: "Korean helping goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "400.0",
    		center_lat: 70,
    		center_long: 157
    	},
    	{
    		feature_id: 3585,
    		year: 1997,
    		feature: "Tessera",
    		feature_plural: "Tesserae",
    		name: "Magu Tessera",
    		type: "Goddess",
    		origin: "China",
    		continent: "Asia",
    		clean_name: "Magu",
    		description: "Chinese goddess of immortality.",
    		bio: "",
    		search_term: "",
    		diameter: "300.0",
    		center_lat: -52,
    		center_long: 305
    	},
    	{
    		feature_id: 3619,
    		year: 1997,
    		feature: "Tessera",
    		feature_plural: "Tesserae",
    		name: "Mamitu Tesserae",
    		type: "Goddess",
    		origin: "Akkadian (Accadian)",
    		continent: "Asia",
    		clean_name: "Mamitu",
    		description: "Akkadian destiny goddess.",
    		bio: "Mammitum, Mammitu or Mammi was a Mesopotamian goddess viewed as the wife of Nergal, the god of death. Mammitum's name might mean “oath” or “frost” (based on similarity to the Akkadian word mammû, 'ice' or 'frost'). ",
    		search_term: "Mamitu",
    		diameter: "900.0",
    		center_lat: 22,
    		center_long: 44
    	},
    	{
    		feature_id: 3649,
    		year: 1997,
    		feature: "Collis",
    		feature_plural: "Colles",
    		name: "Marake Colles",
    		type: "Goddess",
    		origin: "Siberia",
    		continent: "Asia",
    		clean_name: "Marake",
    		description: "Mansi (Ob River Ugra) sea mistress.",
    		bio: "",
    		search_term: "",
    		diameter: "150.0",
    		center_lat: 55.7,
    		center_long: 217.8
    	},
    	{
    		feature_id: 3728,
    		year: 1997,
    		feature: "Vallis",
    		feature_plural: "Valles",
    		name: "Martuv Vallis",
    		type: "Goddess",
    		origin: "Kyrgyzstan",
    		continent: "Asia",
    		clean_name: "Martuv",
    		description: "Kyrgyz river deity.",
    		bio: "",
    		search_term: "",
    		diameter: "250.0",
    		center_lat: 23,
    		center_long: 156
    	},
    	{
    		feature_id: 3767,
    		year: 1997,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "May-Enensi Corona",
    		type: "Goddess",
    		origin: "Altai",
    		continent: "Asia",
    		clean_name: "May-Enensi",
    		description: "Teleutan (S. Altay) fertility goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "330.0",
    		center_lat: -42.5,
    		center_long: 68
    	},
    	{
    		feature_id: 3848,
    		year: 1997,
    		feature: "Vallis",
    		feature_plural: "Valles",
    		name: "Merak Vallis",
    		type: "Goddess",
    		origin: "Pakistan",
    		continent: "Asia",
    		clean_name: "Merak",
    		description: "Balochi (Pakistan) river deity.",
    		bio: "",
    		search_term: "",
    		diameter: "200.0",
    		center_lat: -63.5,
    		center_long: 162
    	},
    	{
    		feature_id: 3916,
    		year: 1997,
    		feature: "Tessera",
    		feature_plural: "Tesserae",
    		name: "Minu-Anni Tessera",
    		type: "Goddess",
    		origin: "Assyrian",
    		continent: "Asia",
    		clean_name: "Minu-Anni",
    		description: "Assyrian fate goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "1,300.0",
    		center_lat: -20,
    		center_long: 30
    	},
    	{
    		feature_id: 4053,
    		year: 1997,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Mou-nyamy Corona",
    		type: "Goddess",
    		origin: "Siberia",
    		continent: "Asia",
    		clean_name: "Mou-nyamy",
    		description: "Nganasan (Samoyed) life bringing goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "200.0",
    		center_lat: -49.5,
    		center_long: 59
    	},
    	{
    		feature_id: 4064,
    		year: 1997,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Mukylchin Corona",
    		type: "Goddess",
    		origin: "Udmurtian",
    		continent: "Asia",
    		clean_name: "Mukylchin",
    		description: "Udmurt (Urals Finn, Russia) fertility goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "525.0",
    		center_lat: -12.5,
    		center_long: 46
    	},
    	{
    		feature_id: 4084,
    		year: 1997,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Muzamuza Corona",
    		type: "Goddess",
    		origin: "India",
    		continent: "Asia",
    		clean_name: "Muzamuza",
    		description: "Indian earth goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "163.0",
    		center_lat: 65.6,
    		center_long: 205.4
    	},
    	{
    		feature_id: 4086,
    		year: 1997,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Mykh-Imi Corona",
    		type: "Goddess",
    		origin: "Siberia",
    		continent: "Asia",
    		clean_name: "Mykh-Imi",
    		description: "Khanty (Ob River Ugra) earth goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "150.0",
    		center_lat: -73,
    		center_long: 99
    	},
    	{
    		feature_id: 4139,
    		year: 1997,
    		feature: "Chasma",
    		feature_plural: "Chasmata",
    		name: "Nang-byon Chasma",
    		type: "Goddess",
    		origin: "Vietnam",
    		continent: "Asia",
    		clean_name: "Nang-byon",
    		description: "Thaichang/White Thai (Vietnam) moon goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "450.0",
    		center_lat: 4,
    		center_long: 316.5
    	},
    	{
    		feature_id: 4151,
    		year: 1997,
    		feature: "Dorsum",
    		feature_plural: "Dorsa",
    		name: "Naran Dorsa",
    		type: "Goddess",
    		origin: "Mongolia",
    		continent: "Asia",
    		clean_name: "Naran",
    		description: "Mongolian sun goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "600.0",
    		center_lat: -54,
    		center_long: 238
    	},
    	{
    		feature_id: 4156,
    		year: 1997,
    		feature: "Fossa",
    		feature_plural: "Fossae",
    		name: "Narundi Fossae",
    		type: "Goddess",
    		origin: "Elamite",
    		continent: "Asia",
    		clean_name: "Narundi",
    		description: "Elam goddess of victory.",
    		bio: "Narundi or Narunde was an Elamite goddess worshiped in Susa. She is attested there roughly between 2250 BCE and 1800 BCE. Multiple inscriptions mention her, and it assumed she was a popular deity at the time.",
    		search_term: "Narundi",
    		diameter: "700.0",
    		center_lat: -66.5,
    		center_long: 329
    	},
    	{
    		feature_id: 4162,
    		year: 1997,
    		feature: "Dorsum",
    		feature_plural: "Dorsa",
    		name: "Natami Dorsa",
    		type: "Goddess",
    		origin: "Myanmar",
    		continent: "Asia",
    		clean_name: "Natami",
    		description: "Mon (Burma/Myanmar) beauty fairy.",
    		bio: "",
    		search_term: "",
    		diameter: "800.0",
    		center_lat: -71.5,
    		center_long: 258
    	},
    	{
    		feature_id: 4175,
    		year: 1997,
    		feature: "Tholus",
    		feature_plural: "Tholi",
    		name: "Ndara Tholus",
    		type: "Goddess",
    		origin: "Indonesia",
    		continent: "Asia",
    		clean_name: "Ndara",
    		description: "Toraji (Sulavesi Isl., Indonesia) underworld and earthquake goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "70.0",
    		center_lat: -57.5,
    		center_long: 16
    	},
    	{
    		feature_id: 4178,
    		year: 1997,
    		feature: "Mons",
    		feature_plural: "Montes",
    		name: "Ne Ngam Mons",
    		type: "Goddess",
    		origin: "Laos",
    		continent: "Asia",
    		clean_name: "Ne Ngam",
    		description: "Lao world creator goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "200.0",
    		center_lat: -43,
    		center_long: 257.5
    	},
    	{
    		feature_id: 4294,
    		year: 1997,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Ninkarraka Corona",
    		type: "Goddess",
    		origin: "Babylon",
    		continent: "Asia",
    		clean_name: "Ninkarraka",
    		description: "Babylonian goddess of childbirth.",
    		bio: "",
    		search_term: "",
    		diameter: "150.0",
    		center_lat: 65.3,
    		center_long: 221
    	},
    	{
    		feature_id: 4423,
    		year: 1997,
    		feature: "Dorsum",
    		feature_plural: "Dorsa",
    		name: "Ojuz Dorsa",
    		type: "Goddess",
    		origin: "Tajik",
    		continent: "Asia",
    		clean_name: "Ojuz",
    		description: "Tajik deity of frost and cold wind.",
    		bio: "",
    		search_term: "",
    		diameter: "400.0",
    		center_lat: 6,
    		center_long: 37
    	},
    	{
    		feature_id: 4425,
    		year: 1997,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Okhin-Tengri Corona",
    		type: "Goddess",
    		origin: "Kalmyk",
    		continent: "Asia",
    		clean_name: "Okhin-Tengri",
    		description: "Kalmykan fertility goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "400.0",
    		center_lat: -70.5,
    		center_long: 40
    	},
    	{
    		feature_id: 4461,
    		year: 1997,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Omosi-Mama Corona",
    		type: "Goddess",
    		origin: "China",
    		continent: "Asia",
    		clean_name: "Omosi-Mama",
    		description: "Manchoo childbirth goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "480.0",
    		center_lat: 64.5,
    		center_long: 306
    	},
    	{
    		feature_id: 4518,
    		year: 1997,
    		feature: "Tholus",
    		feature_plural: "Tholi",
    		name: "Otafuku Tholi",
    		type: "Goddess",
    		origin: "Japan",
    		continent: "Asia",
    		clean_name: "Otafuku",
    		description: "Japanese goddess of joyfulness.",
    		bio: "",
    		search_term: "",
    		diameter: "80.0",
    		center_lat: 28.7,
    		center_long: 46.3
    	},
    	{
    		feature_id: 4606,
    		year: 1997,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Pasu-Ava Corona",
    		type: "Goddess",
    		origin: "Mari",
    		continent: "Asia",
    		clean_name: "Pasu-Ava",
    		description: "Mari (Volga Finn) harvest goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "250.0",
    		center_lat: 29,
    		center_long: 319
    	},
    	{
    		feature_id: 4864,
    		year: 1997,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Pugos Corona",
    		type: "Goddess",
    		origin: "Siberia",
    		continent: "Asia",
    		clean_name: "Pugos",
    		description: "Khanty (Ob River Ugra) life bringing goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "180.0",
    		center_lat: -19,
    		center_long: 335
    	},
    	{
    		feature_id: 4868,
    		year: 1997,
    		feature: "Dorsum",
    		feature_plural: "Dorsa",
    		name: "Pulugu Dorsa",
    		type: "Goddess",
    		origin: "India",
    		continent: "Asia",
    		clean_name: "Pulugu",
    		description: "Andaman Isl. monsoon wind deity.",
    		bio: "",
    		search_term: "",
    		diameter: "650.0",
    		center_lat: -65,
    		center_long: 225
    	},
    	{
    		feature_id: 5171,
    		year: 1997,
    		feature: "Tholus",
    		feature_plural: "Tholi",
    		name: "Rohina Tholus",
    		type: "Goddess",
    		origin: "India",
    		continent: "Asia",
    		clean_name: "Rohina",
    		description: "Hindu cow goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "30.0",
    		center_lat: -40.6,
    		center_long: 295.4
    	},
    	{
    		feature_id: 5332,
    		year: 1997,
    		feature: "Linea",
    		feature_plural: "Lineae",
    		name: "Sarykyz Linea",
    		type: "Goddess",
    		origin: "Uzbekistan",
    		continent: "Asia",
    		clean_name: "Sarykyz",
    		description: "Uzbek evil spirit.",
    		bio: "",
    		search_term: "",
    		diameter: "370.0",
    		center_lat: -77.3,
    		center_long: 200
    	},
    	{
    		feature_id: 5350,
    		year: 1997,
    		feature: "Fossa",
    		feature_plural: "Fossae",
    		name: "Saykal Fossae",
    		type: "Goddess",
    		origin: "Kyrgyzstan",
    		continent: "Asia",
    		clean_name: "Saykal",
    		description: "Kyrgyz warrior maiden.",
    		bio: "",
    		search_term: "",
    		diameter: "300.0",
    		center_lat: 73,
    		center_long: 139
    	},
    	{
    		feature_id: 5425,
    		year: 1997,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Semiramus Corona",
    		type: "Goddess",
    		origin: "Assyrian",
    		continent: "Asia",
    		clean_name: "Semiramus",
    		description: "Assyrian fertility goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "375.0",
    		center_lat: -37,
    		center_long: 293
    	},
    	{
    		feature_id: 5431,
    		year: 1997,
    		feature: "Chasma",
    		feature_plural: "Chasmata",
    		name: "Seo-Ne Chasma",
    		type: "Goddess",
    		origin: "Korea",
    		continent: "Asia",
    		clean_name: "Seo-Ne",
    		description: "Korean moon deity, sun's wife.",
    		bio: "",
    		search_term: "",
    		diameter: "430.0",
    		center_lat: -63.5,
    		center_long: 26
    	},
    	{
    		feature_id: 5505,
    		year: 1997,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Shulamite Corona",
    		type: "Goddess",
    		origin: "Hebrew",
    		continent: "Asia",
    		clean_name: "Shulamite",
    		description: "Hebrew fertility goddess.",
    		bio: "The Hebrew Bible identifies as a Shulamite the swarthy, female protagonist in the Song of Songs (in the King James Version and in other Bibles called the Song of Solomon or the Canticle of Canticles). She is most likely called the Shulammite because she came from an unidentified place called Shulem.",
    		search_term: "Shulamite",
    		diameter: "275.0",
    		center_lat: -38.8,
    		center_long: 284.3
    	},
    	{
    		feature_id: 5510,
    		year: 1997,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Shyv-Amashe Corona",
    		type: "Goddess",
    		origin: "Chuvash",
    		continent: "Asia",
    		clean_name: "Shyv-Amashe",
    		description: "Chuvash (Volga Region) main water goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "410.0",
    		center_lat: -57,
    		center_long: 63
    	},
    	{
    		feature_id: 5521,
    		year: 1997,
    		feature: "Mons",
    		feature_plural: "Montes",
    		name: "Siduri Mons",
    		type: "Goddess",
    		origin: "Babylon",
    		continent: "Asia",
    		clean_name: "Siduri",
    		description: "Babylonian goddess of wine and wisdom.",
    		bio: "Siduri, or more accurately Šiduri (Shiduri), is a character in the Epic of Gilgamesh. She is described as an alewife. When she meets Gilgamesh, who mourns after the death of Enkidu, she suggests that instead of pursuing immortality, he should accept that death is the ultimate fate of mankind and instead enjoy his life on earth and start a family.",
    		search_term: "Siduri",
    		diameter: "105.0",
    		center_lat: -42.3,
    		center_long: 297.3
    	},
    	{
    		feature_id: 5532,
    		year: 1997,
    		feature: "Dorsum",
    		feature_plural: "Dorsa",
    		name: "Siksaup Dorsa",
    		type: "Goddess",
    		origin: "Myanmar",
    		continent: "Asia",
    		clean_name: "Siksaup",
    		description: "Kachin (Burma/Myanmar) sun goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "650.0",
    		center_lat: -73,
    		center_long: 228
    	},
    	{
    		feature_id: 5550,
    		year: 1997,
    		feature: "Dorsum",
    		feature_plural: "Dorsa",
    		name: "Sinanevt Dorsa",
    		type: "Goddess",
    		origin: "Itelmen",
    		continent: "Asia",
    		clean_name: "Sinanevt",
    		description: "Itelmen (Kamchatka) Raven's daughter, wife of sky man.",
    		bio: "",
    		search_term: "",
    		diameter: "1,800.0",
    		center_lat: 66.5,
    		center_long: 171
    	},
    	{
    		feature_id: 5646,
    		year: 1997,
    		feature: "Fluctus",
    		feature_plural: "Fluctūs",
    		name: "Sonmunde Fluctus",
    		type: "Goddess",
    		origin: "Korea",
    		continent: "Asia",
    		clean_name: "Sonmunde",
    		description: "Korean mountain goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "400.0",
    		center_lat: -60,
    		center_long: 120
    	},
    	{
    		feature_id: 5738,
    		year: 1997,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Su-Anasy Corona",
    		type: "Goddess",
    		origin: "Tartar",
    		continent: "Asia",
    		clean_name: "Su-Anasy",
    		description: "Tartar/Kumyk/Karachay mother of water.",
    		bio: "",
    		search_term: "",
    		diameter: "300.0",
    		center_lat: -78,
    		center_long: 39
    	},
    	{
    		feature_id: 5749,
    		year: 1997,
    		feature: "Linea",
    		feature_plural: "Lineae",
    		name: "Sui-ur Linea",
    		type: "Goddess",
    		origin: "Siberia",
    		continent: "Asia",
    		clean_name: "Sui-ur",
    		description: "Mansi (Ob River Ugra) wife of war god.",
    		bio: "",
    		search_term: "",
    		diameter: "700.0",
    		center_lat: -61,
    		center_long: 260
    	},
    	{
    		feature_id: 5772,
    		year: 1997,
    		feature: "Dorsum",
    		feature_plural: "Dorsa",
    		name: "Surupa Dorsa",
    		type: "Goddess",
    		origin: "India",
    		continent: "Asia",
    		clean_name: "Surupa",
    		description: "Hindu sky goddess, bringer of rain.",
    		bio: "",
    		search_term: "",
    		diameter: "981.0",
    		center_lat: 71.7,
    		center_long: 209
    	},
    	{
    		feature_id: 5779,
    		year: 1997,
    		feature: "Chasma",
    		feature_plural: "Chasmata",
    		name: "Sutkatyn Chasmata",
    		type: "Goddess",
    		origin: "Caucasus",
    		continent: "Asia",
    		clean_name: "Sutkatyn",
    		description: "Kumyk (Daghestan) forest spirit.",
    		bio: "",
    		search_term: "",
    		diameter: "350.0",
    		center_lat: -64,
    		center_long: 11
    	},
    	{
    		feature_id: 5862,
    		year: 1997,
    		feature: "Vallis",
    		feature_plural: "Valles",
    		name: "Tapati Vallis",
    		type: "Goddess",
    		origin: "India",
    		continent: "Asia",
    		clean_name: "Tapati",
    		description: "Indian Tapti (Tapi) River goddess.",
    		bio: "Tapati (Sanskrit: तपती, tapatī) is a goddess in Hinduism. She is known also as the goddess of the river Tapati and mother-goddess of the South (home of the sun) where she brings heat to the earth. Tapati's name literally means the \"warming\", \"the hot one\", \"burning one\".",
    		search_term: "Tapati",
    		diameter: "150.0",
    		center_lat: 27,
    		center_long: 304
    	},
    	{
    		feature_id: 6018,
    		year: 1997,
    		feature: "Dorsum",
    		feature_plural: "Dorsa",
    		name: "Tinianavyt Dorsa",
    		type: "Goddess",
    		origin: "Siberia",
    		continent: "Asia",
    		clean_name: "Tinianavyt",
    		description: "Koryak (Kamchatka) wife of sky man.",
    		bio: "",
    		search_term: "",
    		diameter: "1,500.0",
    		center_lat: -51,
    		center_long: 239
    	},
    	{
    		feature_id: 6117,
    		year: 1997,
    		feature: "Mons",
    		feature_plural: "Montes",
    		name: "Ts'an Nu Mons",
    		type: "Goddess",
    		origin: "China",
    		continent: "Asia",
    		clean_name: "Ts'an Nu",
    		description: "Chinese goddess of silkworms.",
    		bio: "",
    		search_term: "",
    		diameter: "310.0",
    		center_lat: -27.2,
    		center_long: 272.9
    	},
    	{
    		feature_id: 6139,
    		year: 1997,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Tureshmat Corona",
    		type: "Goddess",
    		origin: "Japan",
    		continent: "Asia",
    		clean_name: "Tureshmat",
    		description: "Ainu (Japan) creator goddess, created Hokkaido Island.",
    		bio: "",
    		search_term: "",
    		diameter: "150.0",
    		center_lat: -51.5,
    		center_long: 289.5
    	},
    	{
    		feature_id: 6158,
    		year: 1997,
    		feature: "Mons",
    		feature_plural: "Montes",
    		name: "Tuzandi Mons",
    		type: "Goddess",
    		origin: "Myanmar",
    		continent: "Asia",
    		clean_name: "Tuzandi",
    		description: "Palaun (Mon-Khmer of Burma/Myanmar) ancestor deity.",
    		bio: "",
    		search_term: "",
    		diameter: "200.0",
    		center_lat: -42.5,
    		center_long: 41.5
    	},
    	{
    		feature_id: 6217,
    		year: 1997,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Umay-ene Corona",
    		type: "Goddess",
    		origin: "Kazakhstan",
    		continent: "Asia",
    		clean_name: "Umay-ene",
    		description: "Kazakh childcare goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "370.0",
    		center_lat: -27.5,
    		center_long: 50.5
    	},
    	{
    		feature_id: 6229,
    		year: 1997,
    		feature: "Dorsum",
    		feature_plural: "Dorsa",
    		name: "Unuk Dorsa",
    		type: "Goddess",
    		origin: "Siberia",
    		continent: "Asia",
    		clean_name: "Unuk",
    		description: "Eskimo (Chukotka) night maiden.",
    		bio: "",
    		search_term: "",
    		diameter: "400.0",
    		center_lat: -4.5,
    		center_long: 351.5
    	},
    	{
    		feature_id: 6267,
    		year: 1997,
    		feature: "Fluctus",
    		feature_plural: "Fluctūs",
    		name: "Uzume Fluctus",
    		type: "Goddess",
    		origin: "Japan",
    		continent: "Asia",
    		clean_name: "Uzume",
    		description: "Japanese goddess of cheerfulness.",
    		bio: "Ame-no-Uzume-no-Mikoto is the goddess of dawn, mirth, meditation, revelry and the arts in the Shinto religion of Japan, and the wife of fellow-god Sarutahiko Ōkami. She famously relates to the tale of the missing sun deity, Amaterasu Omikami.",
    		search_term: "Uzume",
    		diameter: "700.0",
    		center_lat: 28.6,
    		center_long: 220.3
    	},
    	{
    		feature_id: 6275,
    		year: 1997,
    		feature: "Tessera",
    		feature_plural: "Tesserae",
    		name: "Vako-nana Tesserae",
    		type: "Goddess",
    		origin: "Caucasus",
    		continent: "Asia",
    		clean_name: "Vako-nana",
    		description: "Adygan wise predictor.",
    		bio: "",
    		search_term: "",
    		diameter: "1,200.0",
    		center_lat: 27,
    		center_long: 40
    	},
    	{
    		feature_id: 6337,
    		year: 1997,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Ved-Ava Corona",
    		type: "Goddess",
    		origin: "Mordvinian",
    		continent: "Asia",
    		clean_name: "Ved-Ava",
    		description: "Mordovian (Volga Finn) water mother.",
    		bio: "Ved-ava is a water deity, common to several Finnic peoples traditionally dependent on fishing. She is also sometimes associated with fertility. She is generally depicted as a water creature resembling a mermaid, with long hair, large breasts, and the lower body of a fish complete with tail, and is sometimes said to play or sing, seducing humans with her music.",
    		search_term: "Ved-Ava",
    		diameter: "200.0",
    		center_lat: 33,
    		center_long: 143
    	},
    	{
    		feature_id: 6387,
    		year: 1997,
    		feature: "Tholus",
    		feature_plural: "Tholi",
    		name: "Vilakh Tholus",
    		type: "Goddess",
    		origin: "Caucasus",
    		continent: "Asia",
    		clean_name: "Vilakh",
    		description: "Lakian/Kazikumukhan (Daghestan) fire goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "15.0",
    		center_lat: -6.5,
    		center_long: 176.5
    	},
    	{
    		feature_id: 6457,
    		year: 1997,
    		feature: "Tholus",
    		feature_plural: "Tholi",
    		name: "Vupar Tholus",
    		type: "Goddess",
    		origin: "Chuvash",
    		continent: "Asia",
    		clean_name: "Vupar",
    		description: "Chuvash (Volga area) evil spirit causing lunar and solar eclipses.",
    		bio: "",
    		search_term: "",
    		diameter: "100.0",
    		center_lat: -13.5,
    		center_long: 306
    	},
    	{
    		feature_id: 6609,
    		year: 1997,
    		feature: "Tessera",
    		feature_plural: "Tesserae",
    		name: "Xi Wang-mu Tessera",
    		type: "Goddess",
    		origin: "China",
    		continent: "Asia",
    		clean_name: "Xi Wang-mu",
    		description: "Chinese goddess of west, keeper of medicine for eternal life.",
    		bio: "The Queen Mother of the West, known by various local names, is a mother goddess in Chinese religion and mythology, also worshipped in neighbouring Asian countries, and attested from ancient times. From her name alone some of her most important characteristics are revealed: she is royal, female, and is associated with the west. Her palace is believed to be a perfect and complete paradise.",
    		search_term: "Xi Wang-mu",
    		diameter: "1,300.0",
    		center_lat: -30,
    		center_long: 62
    	},
    	{
    		feature_id: 6633,
    		year: 1997,
    		feature: "Dorsum",
    		feature_plural: "Dorsa",
    		name: "Yalyane Dorsa",
    		type: "Goddess",
    		origin: "Siberia",
    		continent: "Asia",
    		clean_name: "Yalyane",
    		description: "Nenets (Samoyed) maiden of light.",
    		bio: "",
    		search_term: "",
    		diameter: "1,200.0",
    		center_lat: 7,
    		center_long: 177
    	},
    	{
    		feature_id: 6636,
    		year: 1997,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Yanbike Corona",
    		type: "Goddess",
    		origin: "Bashkir",
    		continent: "Asia",
    		clean_name: "Yanbike",
    		description: "Bashkir mythical first woman.",
    		bio: "",
    		search_term: "",
    		diameter: "200.0",
    		center_lat: -1.5,
    		center_long: 328.5
    	},
    	{
    		feature_id: 6655,
    		year: 1997,
    		feature: "Fossa",
    		feature_plural: "Fossae",
    		name: "Yenkhoboy Fossae",
    		type: "Goddess",
    		origin: "Buriat",
    		continent: "Asia",
    		clean_name: "Yenkhoboy",
    		description: "Buryatian warrior sisters.",
    		bio: "",
    		search_term: "",
    		diameter: "900.0",
    		center_lat: -48,
    		center_long: 7
    	},
    	{
    		feature_id: 6678,
    		year: 1997,
    		feature: "Tessera",
    		feature_plural: "Tesserae",
    		name: "Yuki-Onne Tessera",
    		type: "Goddess",
    		origin: "Japan",
    		continent: "Asia",
    		clean_name: "Yuki-Onne",
    		description: "Japanese spirit of death.",
    		bio: "",
    		search_term: "",
    		diameter: "1,200.0",
    		center_lat: 39,
    		center_long: 261
    	},
    	{
    		feature_id: 6686,
    		year: 1997,
    		feature: "Vallis",
    		feature_plural: "Valles",
    		name: "Yuvkha Valles",
    		type: "Goddess",
    		origin: "Turkmenistan",
    		continent: "Asia",
    		clean_name: "Yuvkha",
    		description: "Turkman river spirit.",
    		bio: "",
    		search_term: "",
    		diameter: "200.0",
    		center_lat: 10.5,
    		center_long: 239.5
    	},
    	{
    		feature_id: 6687,
    		year: 1997,
    		feature: "Fossa",
    		feature_plural: "Fossae",
    		name: "Yuzut-Arkh Fossae",
    		type: "Goddess",
    		origin: "Siberia",
    		continent: "Asia",
    		clean_name: "Yuzut-Arkh",
    		description: "Khakas (S. Siberia) evil deity.",
    		bio: "",
    		search_term: "",
    		diameter: "550.0",
    		center_lat: 48,
    		center_long: 224
    	},
    	{
    		feature_id: 6698,
    		year: 1997,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Zamin Corona",
    		type: "Goddess",
    		origin: "Persian",
    		continent: "Asia",
    		clean_name: "Zamin",
    		description: "Persian earth goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "315.0",
    		center_lat: 31.5,
    		center_long: 258.3
    	},
    	{
    		feature_id: 6715,
    		year: 1997,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Zemire Corona",
    		type: "Goddess",
    		origin: "Caucasus",
    		continent: "Asia",
    		clean_name: "Zemire",
    		description: "Kumyk (Daghestan) fertility goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "200.0",
    		center_lat: 31.5,
    		center_long: 312.5
    	},
    	{
    		feature_id: 103,
    		year: 1997,
    		feature: "Planitia",
    		feature_plural: "Planitiae",
    		name: "Aibarchin Planitia",
    		type: "Heroine",
    		origin: "Uzbekistan",
    		continent: "Asia",
    		clean_name: "Aibarchin ",
    		description: "Uzbek “Alpamysh“ epic tale heroine.",
    		bio: "Alpamysh is an ancient Turkic epic or dastan, an ornate oral history, generally set in verse, centering on the eponymous hero and his bride Barchin, with whom he has been engaged since childhood.",
    		search_term: "Alpamysh",
    		diameter: "1,200.0",
    		center_lat: -73,
    		center_long: 25
    	},
    	{
    		feature_id: 195,
    		year: 1997,
    		feature: "Planitia",
    		feature_plural: "Planitiae",
    		name: "Alma-Merghen Planitia",
    		type: "Heroine",
    		origin: "Mongolia",
    		continent: "Asia",
    		clean_name: "Alma-Merghen ",
    		description: "Mongol/Tibet/Buryat “Gheser“ epic tale heroine.",
    		bio: "",
    		search_term: "",
    		diameter: "1,500.0",
    		center_lat: -76,
    		center_long: 100
    	},
    	{
    		feature_id: 1688,
    		year: 1997,
    		feature: "Planitia",
    		feature_plural: "Planitiae",
    		name: "Dzerassa Planitia",
    		type: "Heroine",
    		origin: "Caucasus",
    		continent: "Asia",
    		clean_name: "Dzerassa ",
    		description: "Ossetian epic heroine; golden-haired daughter of water king.",
    		bio: "Dzerassæis a figure in Ossetian mythology best known as the daughter of the water deity Donbettyr and the mother of several Nart saga heroes. She was usually depicted with golden hair, and was able to change her shape into a deer or a fish. After her death, the archangel Uastyrdji revived her and they became lovers in her tomb.",
    		search_term: "Dzerassae",
    		diameter: "2,800.0",
    		center_lat: -15,
    		center_long: 295
    	},
    	{
    		feature_id: 2921,
    		year: 1997,
    		feature: "Planitia",
    		feature_plural: "Planitiae",
    		name: "Kanykey Planitia",
    		type: "Heroine",
    		origin: "Kyrgyzstan",
    		continent: "Asia",
    		clean_name: "Kanykey ",
    		description: "Kyrgyz “Manas“ epic tale heroine, wife of the knight Manas.",
    		bio: "The Epic of Manas, is a traditional epic poem dating to the 18th century but claimed by Kyrgyz tradition to be much older. The plot of Manas revolves around a series of events that coincide with the history of the region in the 9th century, primarily the interaction of the Kyrgyz people with other Turkic and Chinese people.",
    		search_term: "Epic of Manas",
    		diameter: "2,100.0",
    		center_lat: -10,
    		center_long: 350
    	},
    	{
    		feature_id: 4061,
    		year: 1997,
    		feature: "Planitia",
    		feature_plural: "Planitiae",
    		name: "Mugazo Planitia",
    		type: "Heroine",
    		origin: "Vietnam",
    		continent: "Asia",
    		clean_name: "Mugazo ",
    		description: "Vietnamese tale heroine.",
    		bio: "",
    		search_term: "",
    		diameter: "1,500.0",
    		center_lat: -69,
    		center_long: 60
    	},
    	{
    		feature_id: 5823,
    		year: 1997,
    		feature: "Planitia",
    		feature_plural: "Planitiae",
    		name: "Tahmina Planitia",
    		type: "Heroine",
    		origin: "Iran",
    		continent: "Asia",
    		clean_name: "Tahmina ",
    		description: "Iranian (Farsi) epic heroine, wife of knight Rustam.",
    		bio: "Tahmina or Tahmineh is a female character in the story \"Rostam and Sohrab\", part of the 10th-century Persian epic of Shahnameh. Her name is mentioned as the wife of Rostam and as the daughter of Samanganshah, the sovereign of Samangan.",
    		search_term: "Tahmina",
    		diameter: "3,000.0",
    		center_lat: -23,
    		center_long: 80
    	},
    	{
    		feature_id: 6729,
    		year: 1997,
    		feature: "Planitia",
    		feature_plural: "Planitiae",
    		name: "Zhibek Planitia",
    		type: "Heroine",
    		origin: "Kazakhstan",
    		continent: "Asia",
    		clean_name: "Zhibek ",
    		description: "Kazakh “Kyz-Zhibek“ epic tale heroine.",
    		bio: "Kyz-Zhibek is a Kazakh poetic folk legend of the 16th century, tells about the period in the Kazakh nation when the people suffered from bloody feuds. In those times each province of the Kazakh nation had its own Khan and each tried to supersede the other. The love story of Tolegen, the brave warrior, and the beauty Zhibek ends tragically because of inter-family strife.",
    		search_term: "Kyz-Zhibek",
    		diameter: "2,000.0",
    		center_lat: -40,
    		center_long: 157
    	},
    	{
    		feature_id: 5848,
    		year: 1997,
    		feature: "Vallis",
    		feature_plural: "Valles",
    		name: "Tan-yondozo Vallis",
    		type: "Other",
    		origin: "Bashkir",
    		continent: "Asia",
    		clean_name: "Tan-yondozo ",
    		description: "Bashkir name for planet Venus.",
    		bio: "",
    		search_term: "",
    		diameter: "800.0",
    		center_lat: -41.5,
    		center_long: 87
    	},
    	{
    		feature_id: 5825,
    		year: 1997,
    		feature: "Vallis",
    		feature_plural: "Valles",
    		name: "Tai-pe Valles",
    		type: "Other",
    		origin: "China",
    		continent: "Asia",
    		clean_name: "Tai-pe ",
    		description: "Chinese name for planet Venus.",
    		bio: "",
    		search_term: "",
    		diameter: "400.0",
    		center_lat: 11,
    		center_long: 156.5
    	},
    	{
    		feature_id: 3184,
    		year: 1997,
    		feature: "Vallis",
    		feature_plural: "Valles",
    		name: "Kūmsong Vallis",
    		type: "Other",
    		origin: "Korea",
    		continent: "Asia",
    		clean_name: "Kūmsong ",
    		description: "Korean name for planet Venus.",
    		bio: "",
    		search_term: "",
    		diameter: "700.0",
    		center_lat: -59,
    		center_long: 152.5
    	},
    	{
    		feature_id: 6214,
    		year: 1997,
    		feature: "Vallis",
    		feature_plural: "Valles",
    		name: "Umaga Valles",
    		type: "Other",
    		origin: "Philippines",
    		continent: "Asia",
    		clean_name: "Umaga ",
    		description: "Old Tagal name for planet Venus.",
    		bio: "",
    		search_term: "",
    		diameter: "400.0",
    		center_lat: -49,
    		center_long: 152
    	},
    	{
    		feature_id: 4112,
    		year: 1997,
    		feature: "Vallis",
    		feature_plural: "Valles",
    		name: "Nahid Valles",
    		type: "Other",
    		origin: "Persian",
    		continent: "Asia",
    		clean_name: "Nahid ",
    		description: "Persian name for planet Venus.",
    		bio: "",
    		search_term: "",
    		diameter: "500.0",
    		center_lat: -55.1,
    		center_long: 171
    	},
    	{
    		feature_id: 6231,
    		year: 1997,
    		feature: "Vallis",
    		feature_plural: "Valles",
    		name: "Uottakh-sulus Valles",
    		type: "Other",
    		origin: "Yakutian",
    		continent: "Asia",
    		clean_name: "Uottakh-sulus ",
    		description: "Yakutian/Saha name for planet Venus.",
    		bio: "",
    		search_term: "",
    		diameter: "1,100.0",
    		center_lat: 12.5,
    		center_long: 239
    	},
    	{
    		feature_id: 565,
    		year: 1997,
    		feature: "Patera",
    		feature_plural: "Paterae",
    		name: "Bakhtadze Patera",
    		type: "Famous Woman",
    		origin: "Georgia",
    		continent: "Europe",
    		clean_name: "Bakhtadze",
    		description: "Kseniya; Georgian tea geneticist (1899-1978).",
    		bio: "",
    		search_term: "",
    		diameter: "50.0",
    		center_lat: 45.5,
    		center_long: 219.5
    	},
    	{
    		feature_id: 1926,
    		year: 1997,
    		feature: "Patera",
    		feature_plural: "Paterae",
    		name: "Fedchenko Patera",
    		type: "Famous Woman",
    		origin: "Russia",
    		continent: "Europe",
    		clean_name: "Fedchenko",
    		description: "Olga; Russian botanist, explorer of Central Asia (1845-1921).",
    		bio: "Olga Aleksandrovna Fedchenko or Fedtschenko (née Armfeld; 30 October 1845 – 24 April 1921) was a Russian botanist. Rosa fedtschenkoana, which is found in Asia, was named in her honour (with a German transliteration of her name). Ol'ga (Olga) Armfeld was born in Moscow in 1845.",
    		search_term: "Olga Fedchenko",
    		diameter: "75.0",
    		center_lat: -24,
    		center_long: 226.5
    	},
    	{
    		feature_id: 1929,
    		year: 1997,
    		feature: "Patera",
    		feature_plural: "Paterae",
    		name: "Fedosova Patera",
    		type: "Famous Woman",
    		origin: "Russia",
    		continent: "Europe",
    		clean_name: "Fedosova",
    		description: "Irina; Russian folk poet (1831-1899). Changed from Fedosova crater.",
    		bio: "",
    		search_term: "",
    		diameter: "24.0",
    		center_lat: 45,
    		center_long: 171.8
    	},
    	{
    		feature_id: 2256,
    		year: 1997,
    		feature: "Patera",
    		feature_plural: "Paterae",
    		name: "Grizodubova Patera",
    		type: "Famous Woman",
    		origin: "Soviet",
    		continent: "Europe",
    		clean_name: "Grizodubova",
    		description: "Valentina; Soviet aviatrix (1910-1993).",
    		bio: "Valentina Stepanovna Grizodubova (Russian: Валенти́на Степа́новна Гризоду́бова, Ukrainian: Валентина Степанівна Гризодубова Valentyna Stepanivna Hryzodubova; 27 April [O.S. 14 April] 1909 in Kharkov – 28 April 1993 in Moscow) was one of the first female pilots in the Soviet Union awarded the title Hero of the Soviet Union and the only female Hero of the Soviet Union to also be awarded the title Hero of Socialist Labour. == Early life and pre-war career == Born in Kharkiv, in the Kharkov Governorate of the Russian Empire (present-day Ukraine), she was the daughter of Stepan Vasilyevich Grizodubov, a pioneer aircraft-designer. At the age of fourteen, she flew a glider solo.",
    		search_term: "Valentina Grizodubova",
    		diameter: "50.0",
    		center_lat: 16.7,
    		center_long: 299.6
    	},
    	{
    		feature_id: 2811,
    		year: 1997,
    		feature: "Patera",
    		feature_plural: "Paterae",
    		name: "Jaszai Patera",
    		type: "Famous Woman",
    		origin: "Hungary",
    		continent: "Europe",
    		clean_name: "Jaszai",
    		description: "Mary; Hungarian actress (1850-1926).",
    		bio: "Mari Jászai (born Mária Krippel; 24 February 1850, Ászár – 5 October 1926, Budapest) was a Hungarian actress. Mari Jászai 24 February 1850 in Ászár, Komárom county, as a daughter of a carpenter. She worked from age 10 as a maidservant, both in Budapest and Vienna, assisting soldiers as a sutling wench in the Battle of Königgrätz.",
    		search_term: "Mari Jászai",
    		diameter: "70.0",
    		center_lat: 32,
    		center_long: 305
    	},
    	{
    		feature_id: 2847,
    		year: 1997,
    		feature: "Patera",
    		feature_plural: "Paterae",
    		name: "Jotuni Patera",
    		type: "Famous Woman",
    		origin: "Finland",
    		continent: "Europe",
    		clean_name: "Jotuni",
    		description: "Maria; Finnish writer (1880-1943).",
    		bio: "Maria Gustaava Jotuni (Haggrén until 1906, Jotuni-Tarkiainen from 1911, born 9 April 1880 Kuopio, died 30 September 1943 in Helsinki) was a Finnish author and a playwright. Jotuni went to an all-girls school in Kuopio. She graduated in 1900 and planned to become a teacher.",
    		search_term: "Maria Jotuni",
    		diameter: "100.0",
    		center_lat: -6.5,
    		center_long: 214
    	},
    	{
    		feature_id: 3174,
    		year: 1997,
    		feature: "Patera",
    		feature_plural: "Paterae",
    		name: "Kvasha Patera",
    		type: "Famous Woman",
    		origin: "Soviet",
    		continent: "Europe",
    		clean_name: "Kvasha",
    		description: "Lidiya; Soviet mineralogist, meteorite researcher (1909-1977).",
    		bio: "",
    		search_term: "",
    		diameter: "50.0",
    		center_lat: -9.5,
    		center_long: 69
    	},
    	{
    		feature_id: 3805,
    		year: 1997,
    		feature: "Patera",
    		feature_plural: "Paterae",
    		name: "Mehseti Patera",
    		type: "Famous Woman",
    		origin: "Azerbaijan",
    		continent: "Europe",
    		clean_name: "Mehseti",
    		description: "Ganjevi; Azeri/Persian poet (c. 1050-c. 1100).",
    		bio: "",
    		search_term: "",
    		diameter: "60.0",
    		center_lat: 16,
    		center_long: 311
    	},
    	{
    		feature_id: 3890,
    		year: 1997,
    		feature: "Patera",
    		feature_plural: "Paterae",
    		name: "Mikhaylova Patera",
    		type: "Famous Woman",
    		origin: "Russia",
    		continent: "Europe",
    		clean_name: "Mikhaylova",
    		description: "Dariya (better known as Dasha of Sevastopol); Russian nurse (c. 1830-c. 1915).",
    		bio: "Darya Lavrentyevna Mikhailova (Russian: Дарья Лаврентьевна Михайлова) (November 1836 – 1892) was a Russian nurse during the siege of Sevastopol in the 1853-1856 Crimean War, from which she became better known by the name Dasha of Sevastopol (Russian: Даша Севастопольская). She became one of the founders of modern nursing - in parallel to the work of Florence Nightingale. Mikhailova was born in a village near Klyuchischi in the Kazan Governorate.",
    		search_term: "Dasha from Sevastopol",
    		diameter: "70.0",
    		center_lat: -26.8,
    		center_long: 348.2
    	},
    	{
    		feature_id: 4331,
    		year: 1997,
    		feature: "Patera",
    		feature_plural: "Paterae",
    		name: "Nordenflycht Patera",
    		type: "Famous Woman",
    		origin: "Sweden",
    		continent: "Europe",
    		clean_name: "Nordenflycht",
    		description: "Hedwig; Swedish poet (1718-1763).",
    		bio: "Hedvig Charlotta Nordenflycht (Stockholm, Sweden, 28 November 1718 – Stockholm, Sweden, 29 June 1763) was a Swedish poet, feminist and salon hostess. She was the youngest of five children of the wealthy official Anders Andersson Nordbohm (1675–1734) and Christina Rosin. Her father was ennobled as Nordenflycht in 1727.",
    		search_term: "Hedwig Nordenflycht",
    		diameter: "140.0",
    		center_lat: -35,
    		center_long: 266
    	},
    	{
    		feature_id: 4579,
    		year: 1997,
    		feature: "Patera",
    		feature_plural: "Paterae",
    		name: "Panina Patera",
    		type: "Famous Woman",
    		origin: "Russia",
    		continent: "Europe",
    		clean_name: "Panina",
    		description: "Varya; Romani/Russian singer (1872-1911).",
    		bio: "Varvara Vasilyevna Panina (Варва′ра Васи′льевна Па′нина; 1872, Moscow, Russian Empire, - May 28, 1911, Moscow, Russian Empire) was a Russian singer of Romani origins, famous for her deep contralto, one of the Russian popular music stars of the early 20th century. Varvara Vasilyeva (her birth name) was born to the family of Romani horse traders, based in Moscow. She started singing at the age of 14, first in the Romani choir directed by Alexandra Panina, at the Strelna restaurant.",
    		search_term: "Varya Panina",
    		diameter: "50.0",
    		center_lat: -13,
    		center_long: 309.8
    	},
    	{
    		feature_id: 4625,
    		year: 1997,
    		feature: "Patera",
    		feature_plural: "Paterae",
    		name: "Pchilka Patera",
    		type: "Famous Woman",
    		origin: "Ukraine",
    		continent: "Europe",
    		clean_name: "Pchilka",
    		description: "Olena (Olga Kosach); Ukrainian writer and ethnographer (1849-1930).",
    		bio: "Olha Petrivna Kosach (29 June 1849 – 4 October 1930), better known by her pen name Olena Pchilka (Ukrainian: Олена Пчілка), was a Ukrainian publisher, writer, ethnographer, interpreter, and civil activist. She was the sister of Mykhailo Drahomanov and the mother of Lesya Ukrainka, Olha Kosach-Kryvyniuk, Mykhailo Kosach, Oksana Kosach-Shymanovska, Mykola Kosach, Izydora Kosach-Borysova and Yuriy Kosach. Pchilka was born in Hadiach, into the family of a local landowner Petro Drahomanov.",
    		search_term: "Olena Pchilka",
    		diameter: "100.0",
    		center_lat: 26.5,
    		center_long: 234
    	},
    	{
    		feature_id: 5386,
    		year: 1997,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Schumann-Heink Corona",
    		type: "Famous Woman",
    		origin: "Germany",
    		continent: "Europe",
    		clean_name: "Schumann-Heink",
    		description: "Ernestine; German singer (1861-1936). Name changed from Schumann-Heink Patera.",
    		bio: "Ernestine Schumann-Heink (15 June 1861 – 17 November 1936) was a Bohemian-born Austrian-American operatic contralto of German Bohemian descent. She was noted for the flexibility and wide range of her voice. She was born Ernestine Amalie Pauline Rössler on 15 June 1861 to a German-speaking family at Libeň (German: Lieben), Bohemia, Austrian Empire, which is now part of the city of Prague, Czech Republic.",
    		search_term: "Ernestine Schumann-Heink",
    		diameter: "122.0",
    		center_lat: 74.3,
    		center_long: 214.5
    	},
    	{
    		feature_id: 5437,
    		year: 1997,
    		feature: "Patera",
    		feature_plural: "Paterae",
    		name: "Serova Patera",
    		type: "Famous Woman",
    		origin: "Soviet",
    		continent: "Europe",
    		clean_name: "Serova",
    		description: "Valentina (Polovikova); Soviet actress (1918-1975).",
    		bio: "Valentina Vasilyevna Serova (Russian: Валенти́на Васи́льевна Серо́ва; 23 December 1917 – 12 December 1975) was a Soviet film and theatre actress born in Ukraine. Honored Artist of the RSFSR (1946). Winner of the Stalin Prize of the second degree (1947).",
    		search_term: "Valentina Serova",
    		diameter: "60.0",
    		center_lat: 20,
    		center_long: 247
    	},
    	{
    		feature_id: 5482,
    		year: 1997,
    		feature: "Patera",
    		feature_plural: "Paterae",
    		name: "Shelikhova Patera",
    		type: "Famous Woman",
    		origin: "Russia",
    		continent: "Europe",
    		clean_name: "Shelikhova",
    		description: "Natalia; Russian explorer of Alaska (c. 1750-c. 1800).",
    		bio: "Natalia Alekseevna Shelikhova (Russian: Ната́лья Алексе́евна Ше́лихова; 1762-1810), was a Russian businessperson and the spouse of Grigory Shelikhov, founder of Russian Alaska. She was one of the founders of the Russian-American Company and has been referred to as one of the first successful female entrepreneurs in Russia. Natalia Alekseevna Kozhevina was the daughter of a prominent clan of Okhotsk navigators and mapmakers.",
    		search_term: "Natalia Shelikhova",
    		diameter: "60.0",
    		center_lat: -75.7,
    		center_long: 162.5
    	},
    	{
    		feature_id: 5507,
    		year: 1997,
    		feature: "Patera",
    		feature_plural: "Paterae",
    		name: "Shulzhenko Patera",
    		type: "Famous Woman",
    		origin: "Soviet",
    		continent: "Europe",
    		clean_name: "Shulzhenko",
    		description: "Klavdiya; Soviet singer (1906-1984).",
    		bio: "Klavdiya Ivanovna Shulzhenko (Russian: Кла́вдия Ива́новна Шульже́нко, Ukrainian: Клавдія Іванівна Шульженко; March 24 [O.S. March 11] 1906, Kharkiv – June 17, 1984, Moscow) was a Soviet popular female singer and actress. Shulzhenko started singing with jazz and pop bands in the late 1920s. She rose to fame in the late 1930s with her version of Sebastián Iradier's La Paloma.",
    		search_term: "Klavdiya Shulzhenko",
    		diameter: "60.0",
    		center_lat: 6.5,
    		center_long: 264.5
    	},
    	{
    		feature_id: 5518,
    		year: 1997,
    		feature: "Patera",
    		feature_plural: "Paterae",
    		name: "Siddons Patera",
    		type: "Famous Woman",
    		origin: "Great Britain",
    		continent: "Europe",
    		clean_name: "Siddons",
    		description: "Sarah; English actress (1755-1831).",
    		bio: "Sarah Siddons (née Kemble; 5 July 1755 – 8 June 1831) was a Welsh actress, the best-known tragedienne of the 18th century. Contemporaneous critic William Hazlitt dubbed Siddons as 'tragedy personified'.She was the elder sister of John Philip Kemble, Charles Kemble, Stephen Kemble, Ann Hatton, and Elizabeth Whitlock, and the aunt of Fanny Kemble. She was most famous for her portrayal of the Shakespearean character, Lady Macbeth, a character she made her own, as well as for fainting at the sight of the Elgin Marbles in London.The Sarah Siddons Society, founded in 1952, continues to present the Sarah Siddons Award annually in Chicago to a distinguished actress.",
    		search_term: "Sarah Siddons",
    		diameter: "47.0",
    		center_lat: 61.6,
    		center_long: 340.6
    	},
    	{
    		feature_id: 6388,
    		year: 1997,
    		feature: "Patera",
    		feature_plural: "Paterae",
    		name: "Villepreux-Power Patera",
    		type: "Famous Woman",
    		origin: "France",
    		continent: "Europe",
    		clean_name: "Villepreux-Power",
    		description: "Jeannette; French marine biologist (1794-1871).",
    		bio: "",
    		search_term: "",
    		diameter: "100.0",
    		center_lat: -22,
    		center_long: 210
    	},
    	{
    		feature_id: 6452,
    		year: 1997,
    		feature: "Patera",
    		feature_plural: "Paterae",
    		name: "Vovchok Patera",
    		type: "Famous Woman",
    		origin: "Ukraine",
    		continent: "Europe",
    		clean_name: "Vovchok",
    		description: "Marko (Mariya Vilinskaya-Markovich); Ukrainian/Russian writer (1833-1907).",
    		bio: "Marko Vovchok (Ukrainian: Марко́ Вовчо́к, birth name: Mariia Vilinskа, surname by the first marriage: Markovych, surname by the second marriage: Lobach-Zhuchenko, Russian: Мария Александровна Вилинская; 22 December 1833 – 10 August 1907) was a Ukrainian female writer of Russian descent. Her pen name, Marko Vovchok, was invented by Panteleimon Kulish. Her works had an anti-serfdom orientation and described the historical past of Ukraine.",
    		search_term: "Marko Vovchok",
    		diameter: "80.0",
    		center_lat: -38,
    		center_long: 310
    	},
    	{
    		feature_id: 6943,
    		year: 1997,
    		feature: "Patera",
    		feature_plural: "Paterae",
    		name: "Žemaite Patera",
    		type: "Famous Woman",
    		origin: "Lithuania",
    		continent: "Europe",
    		clean_name: "Žemaite",
    		description: "Julia; Lithuanian writer (1845-1921).",
    		bio: "Žemaitė (literally female Samogitian) was the pen name of Julija Beniuševičiūtė-Žymantienė (Polish: Julia z Beniuszewiczów Żymontowa, 4 June [O.S. 23 May] 1845 – 7 December 1921). She was a Lithuanian/Samogitian writer, democrat and educator. Born to impoverished gentry, she became one of the major participants in the Lithuanian National Revival.",
    		search_term: "Žemaitė",
    		diameter: "60.0",
    		center_lat: -35,
    		center_long: 263
    	},
    	{
    		feature_id: 77,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Aftenia",
    		type: "First Name",
    		origin: "Moldova",
    		continent: "Europe",
    		clean_name: "Aftenia",
    		description: "Moldavian first name.",
    		bio: "",
    		search_term: "",
    		diameter: "7.0",
    		center_lat: 50,
    		center_long: 324
    	},
    	{
    		feature_id: 213,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Amanda",
    		type: "First Name",
    		origin: "Latin",
    		continent: "Europe",
    		clean_name: "Amanda",
    		description: "Latin first name. Name changed from Lida.",
    		bio: "",
    		search_term: "",
    		diameter: "12.5",
    		center_lat: -29.2,
    		center_long: 94.5
    	},
    	{
    		feature_id: 707,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Bernice",
    		type: "First Name",
    		origin: "Greek",
    		continent: "Europe",
    		clean_name: "Bernice",
    		description: "Greek first name.",
    		bio: "",
    		search_term: "",
    		diameter: "12.6",
    		center_lat: -40.7,
    		center_long: 14.8
    	},
    	{
    		feature_id: 1245,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Clio",
    		type: "First Name",
    		origin: "Greek",
    		continent: "Europe",
    		clean_name: "Clio",
    		description: "Greek first name.",
    		bio: "",
    		search_term: "",
    		diameter: "11.4",
    		center_lat: 6.3,
    		center_long: 333.5
    	},
    	{
    		feature_id: 1384,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Dafina",
    		type: "First Name",
    		origin: "Albania",
    		continent: "Europe",
    		clean_name: "Dafina",
    		description: "Albanian first name.",
    		bio: "",
    		search_term: "",
    		diameter: "5.5",
    		center_lat: 28.6,
    		center_long: 244.1
    	},
    	{
    		feature_id: 1569,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Domnika",
    		type: "First Name",
    		origin: "Moldova",
    		continent: "Europe",
    		clean_name: "Domnika",
    		description: "Moldavian first name.",
    		bio: "",
    		search_term: "",
    		diameter: "6.7",
    		center_lat: 18.4,
    		center_long: 294.3
    	},
    	{
    		feature_id: 1584,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Dorothy",
    		type: "First Name",
    		origin: "Greek",
    		continent: "Europe",
    		clean_name: "Dorothy",
    		description: "Greek first name.",
    		bio: "",
    		search_term: "",
    		diameter: "8.4",
    		center_lat: -35.4,
    		center_long: 11.3
    	},
    	{
    		feature_id: 1740,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Eila",
    		type: "First Name",
    		origin: "Finland",
    		continent: "Europe",
    		clean_name: "Eila",
    		description: "Finnish first name.",
    		bio: "",
    		search_term: "",
    		diameter: "9.5",
    		center_lat: -75,
    		center_long: 94.6
    	},
    	{
    		feature_id: 1744,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Eini",
    		type: "First Name",
    		origin: "Finland",
    		continent: "Europe",
    		clean_name: "Eini",
    		description: "Finnish first name.",
    		bio: "",
    		search_term: "",
    		diameter: "5.9",
    		center_lat: -41.6,
    		center_long: 96.4
    	},
    	{
    		feature_id: 1768,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Ellen",
    		type: "First Name",
    		origin: "Germany",
    		continent: "Europe",
    		clean_name: "Ellen",
    		description: "German first name.",
    		bio: "",
    		search_term: "",
    		diameter: "14.6",
    		center_lat: -22.8,
    		center_long: 281.3
    	},
    	{
    		feature_id: 1773,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Elma",
    		type: "First Name",
    		origin: "Finland",
    		continent: "Europe",
    		clean_name: "Elma",
    		description: "Finnish first name.",
    		bio: "",
    		search_term: "",
    		diameter: "10.2",
    		center_lat: -10.1,
    		center_long: 91.1
    	},
    	{
    		feature_id: 1792,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Emilia",
    		type: "First Name",
    		origin: "Sweden",
    		continent: "Europe",
    		clean_name: "Emilia",
    		description: "Swedish first name.",
    		bio: "",
    		search_term: "",
    		diameter: "12.5",
    		center_lat: -26.5,
    		center_long: 88.2
    	},
    	{
    		feature_id: 1793,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Emma",
    		type: "First Name",
    		origin: "Germany",
    		continent: "Europe",
    		clean_name: "Emma",
    		description: "German first name.",
    		bio: "",
    		search_term: "",
    		diameter: "11.8",
    		center_lat: -13.7,
    		center_long: 302.3
    	},
    	{
    		feature_id: 1802,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Enid",
    		type: "First Name",
    		origin: "Celtic",
    		continent: "Europe",
    		clean_name: "Enid",
    		description: "Celtic first name.",
    		bio: "",
    		search_term: "",
    		diameter: "9.2",
    		center_lat: 16.4,
    		center_long: 352.1
    	},
    	{
    		feature_id: 1847,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Esmeralda",
    		type: "First Name",
    		origin: "Romani",
    		continent: "Europe",
    		clean_name: "Esmeralda",
    		description: "Romani first name.",
    		bio: "",
    		search_term: "",
    		diameter: "9.8",
    		center_lat: 64.4,
    		center_long: 104.5
    	},
    	{
    		feature_id: 1865,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Eugenia",
    		type: "First Name",
    		origin: "Greek",
    		continent: "Europe",
    		clean_name: "Eugenia",
    		description: "Greek first name.",
    		bio: "",
    		search_term: "",
    		diameter: "6.0",
    		center_lat: 80.6,
    		center_long: 105.4
    	},
    	{
    		feature_id: 1886,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Evelyn",
    		type: "First Name",
    		origin: "Celtic",
    		continent: "Europe",
    		clean_name: "Evelyn",
    		description: "Celtic first name.",
    		bio: "",
    		search_term: "",
    		diameter: "18.0",
    		center_lat: -61.2,
    		center_long: 212.3
    	},
    	{
    		feature_id: 1946,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Feruk",
    		type: "First Name",
    		origin: "Russia",
    		continent: "Europe",
    		clean_name: "Feruk",
    		description: "Nivkhi (Sakhalin Isl.) first name.",
    		bio: "",
    		search_term: "",
    		diameter: "8.3",
    		center_lat: -64,
    		center_long: 107.6
    	},
    	{
    		feature_id: 1983,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Florence",
    		type: "First Name",
    		origin: "England",
    		continent: "Europe",
    		clean_name: "Florence",
    		description: "English first name.",
    		bio: "",
    		search_term: "",
    		diameter: "10.5",
    		center_lat: -15.2,
    		center_long: 85
    	},
    	{
    		feature_id: 1986,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Flutra",
    		type: "First Name",
    		origin: "Albania",
    		continent: "Europe",
    		clean_name: "Flutra",
    		description: "Albanian first name.",
    		bio: "",
    		search_term: "",
    		diameter: "6.0",
    		center_lat: -68.4,
    		center_long: 112
    	},
    	{
    		feature_id: 2032,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Frosya",
    		type: "First Name",
    		origin: "Russia",
    		continent: "Europe",
    		clean_name: "Frosya",
    		description: "Russian first name.",
    		bio: "",
    		search_term: "",
    		diameter: "9.8",
    		center_lat: 29.5,
    		center_long: 113.4
    	},
    	{
    		feature_id: 2142,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Georgina",
    		type: "First Name",
    		origin: "Greek",
    		continent: "Europe",
    		clean_name: "Georgina",
    		description: "Greek first name.",
    		bio: "",
    		search_term: "",
    		diameter: "5.9",
    		center_lat: -20.4,
    		center_long: 58.8
    	},
    	{
    		feature_id: 2177,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Giselle",
    		type: "First Name",
    		origin: "France",
    		continent: "Europe",
    		clean_name: "Giselle",
    		description: "French first name.",
    		bio: "",
    		search_term: "",
    		diameter: "10.4",
    		center_lat: -11.8,
    		center_long: 298
    	},
    	{
    		feature_id: 2348,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Hanka",
    		type: "First Name",
    		origin: "Czechoslovakia",
    		continent: "Europe",
    		clean_name: "Hanka",
    		description: "Czech first name.",
    		bio: "",
    		search_term: "",
    		diameter: "5.0",
    		center_lat: -27.3,
    		center_long: 114.3
    	},
    	{
    		feature_id: 2423,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Helga",
    		type: "First Name",
    		origin: "Norway",
    		continent: "Europe",
    		clean_name: "Helga",
    		description: "Norwegian first name.",
    		bio: "",
    		search_term: "",
    		diameter: "8.8",
    		center_lat: -10.4,
    		center_long: 116.7
    	},
    	{
    		feature_id: 2442,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Helvi",
    		type: "First Name",
    		origin: "Estonia",
    		continent: "Europe",
    		clean_name: "Helvi",
    		description: "Estonian first name.",
    		bio: "",
    		search_term: "",
    		diameter: "12.2",
    		center_lat: 12.4,
    		center_long: 82.7
    	},
    	{
    		feature_id: 2505,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Hilkka",
    		type: "First Name",
    		origin: "Finland",
    		continent: "Europe",
    		clean_name: "Hilkka",
    		description: "Finnish first name.",
    		bio: "",
    		search_term: "",
    		diameter: "10.3",
    		center_lat: -69,
    		center_long: 72
    	},
    	{
    		feature_id: 2689,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Ines",
    		type: "First Name",
    		origin: "Spain",
    		continent: "Europe",
    		clean_name: "Ines",
    		description: "Spanish first name.",
    		bio: "",
    		search_term: "",
    		diameter: "11.2",
    		center_lat: -67.1,
    		center_long: 241.9
    	},
    	{
    		feature_id: 2690,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Inga",
    		type: "First Name",
    		origin: "Denmark",
    		continent: "Europe",
    		clean_name: "Inga",
    		description: "Danish first name.",
    		bio: "",
    		search_term: "",
    		diameter: "10.0",
    		center_lat: 38.1,
    		center_long: 226.6
    	},
    	{
    		feature_id: 2695,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Inkeri",
    		type: "First Name",
    		origin: "Finland",
    		continent: "Europe",
    		clean_name: "Inkeri",
    		description: "Finnish first name.",
    		bio: "",
    		search_term: "",
    		diameter: "10.1",
    		center_lat: -28.3,
    		center_long: 223.9
    	},
    	{
    		feature_id: 2711,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Iraida",
    		type: "First Name",
    		origin: "Greek",
    		continent: "Europe",
    		clean_name: "Iraida",
    		description: "Greek first name.",
    		bio: "",
    		search_term: "",
    		diameter: "6.5",
    		center_lat: 27.8,
    		center_long: 108.1
    	},
    	{
    		feature_id: 2717,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Irinuca",
    		type: "First Name",
    		origin: "Romania (Rumania)",
    		continent: "Europe",
    		clean_name: "Irinuca",
    		description: "Romanian first name.",
    		bio: "",
    		search_term: "",
    		diameter: "8.0",
    		center_lat: 51.4,
    		center_long: 121.9
    	},
    	{
    		feature_id: 2720,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Irma",
    		type: "First Name",
    		origin: "Finland",
    		continent: "Europe",
    		clean_name: "Irma",
    		description: "Finnish first name.",
    		bio: "",
    		search_term: "",
    		diameter: "9.5",
    		center_lat: -50.9,
    		center_long: 122
    	},
    	{
    		feature_id: 2743,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Isolde",
    		type: "First Name",
    		origin: "England",
    		continent: "Europe",
    		clean_name: "Isolde",
    		description: "English first name.",
    		bio: "",
    		search_term: "",
    		diameter: "11.9",
    		center_lat: -74.5,
    		center_long: 211.9
    	},
    	{
    		feature_id: 2780,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Jaantje",
    		type: "First Name",
    		origin: "Netherlands",
    		continent: "Europe",
    		clean_name: "Jaantje",
    		description: "Dutch first name.",
    		bio: "",
    		search_term: "",
    		diameter: "7.8",
    		center_lat: 46.5,
    		center_long: 123
    	},
    	{
    		feature_id: 2796,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Janice",
    		type: "First Name",
    		origin: "England",
    		continent: "Europe",
    		clean_name: "Janice",
    		description: "English first name.",
    		bio: "",
    		search_term: "",
    		diameter: "10.0",
    		center_lat: 87.3,
    		center_long: 261.9
    	},
    	{
    		feature_id: 2797,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Janina",
    		type: "First Name",
    		origin: "Poland",
    		continent: "Europe",
    		clean_name: "Janina",
    		description: "Polish first name.",
    		bio: "",
    		search_term: "",
    		diameter: "9.3",
    		center_lat: -2,
    		center_long: 135.7
    	},
    	{
    		feature_id: 2832,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Jodi",
    		type: "First Name",
    		origin: "England",
    		continent: "Europe",
    		clean_name: "Jodi",
    		description: "English first name.",
    		bio: "",
    		search_term: "",
    		diameter: "10.2",
    		center_lat: -35.7,
    		center_long: 68.7
    	},
    	{
    		feature_id: 2872,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Jutta",
    		type: "First Name",
    		origin: "Finland",
    		continent: "Europe",
    		clean_name: "Jutta",
    		description: "Finnish first name.",
    		bio: "",
    		search_term: "",
    		diameter: "7.0",
    		center_lat: 0,
    		center_long: 142.6
    	},
    	{
    		feature_id: 2888,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Kaisa",
    		type: "First Name",
    		origin: "Finland",
    		continent: "Europe",
    		clean_name: "Kaisa",
    		description: "Finnish first name.",
    		bio: "",
    		search_term: "",
    		diameter: "12.0",
    		center_lat: 13.5,
    		center_long: 293.3
    	},
    	{
    		feature_id: 2927,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Karen",
    		type: "First Name",
    		origin: "Greek",
    		continent: "Europe",
    		clean_name: "Karen",
    		description: "Greek first name.",
    		bio: "",
    		search_term: "",
    		diameter: "10.5",
    		center_lat: -12.4,
    		center_long: 17.7
    	},
    	{
    		feature_id: 2960,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Katrya",
    		type: "First Name",
    		origin: "Ukraine",
    		continent: "Europe",
    		clean_name: "Katrya",
    		description: "Ukranian first name.",
    		bio: "",
    		search_term: "",
    		diameter: "9.2",
    		center_lat: -29.5,
    		center_long: 108.7
    	},
    	{
    		feature_id: 2962,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Katya",
    		type: "First Name",
    		origin: "Russia",
    		continent: "Europe",
    		clean_name: "Katya",
    		description: "Russian first name.",
    		bio: "",
    		search_term: "",
    		diameter: "10.5",
    		center_lat: 57.8,
    		center_long: 285.7
    	},
    	{
    		feature_id: 3123,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Kristina",
    		type: "First Name",
    		origin: "Latin",
    		continent: "Europe",
    		clean_name: "Kristina",
    		description: "Slavonic form of Christiana, Latin first name.",
    		bio: "",
    		search_term: "",
    		diameter: "9.7",
    		center_lat: -65.2,
    		center_long: 315.9
    	},
    	{
    		feature_id: 3177,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Kylli",
    		type: "First Name",
    		origin: "Finland",
    		continent: "Europe",
    		clean_name: "Kylli",
    		description: "Finnish first name.",
    		bio: "",
    		search_term: "",
    		diameter: "13.2",
    		center_lat: 41.1,
    		center_long: 67
    	},
    	{
    		feature_id: 3280,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Lara",
    		type: "First Name",
    		origin: "Latin",
    		continent: "Europe",
    		clean_name: "Lara",
    		description: "Latin first name.",
    		bio: "",
    		search_term: "",
    		diameter: "3.4",
    		center_lat: -4.2,
    		center_long: 2.9
    	},
    	{
    		feature_id: 3359,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Leslie",
    		type: "First Name",
    		origin: "England",
    		continent: "Europe",
    		clean_name: "Leslie",
    		description: "English first name.",
    		bio: "",
    		search_term: "",
    		diameter: "7.2",
    		center_lat: -11.2,
    		center_long: 13.5
    	},
    	{
    		feature_id: 3407,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Linda",
    		type: "First Name",
    		origin: "Latin",
    		continent: "Europe",
    		clean_name: "Linda",
    		description: "Latin first name.",
    		bio: "",
    		search_term: "",
    		diameter: "7.1",
    		center_lat: -12.4,
    		center_long: 2.8
    	},
    	{
    		feature_id: 3429,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Liv",
    		type: "First Name",
    		origin: "Norway",
    		continent: "Europe",
    		clean_name: "Liv",
    		description: "Norwegian first name.",
    		bio: "",
    		search_term: "",
    		diameter: "11.2",
    		center_lat: -21.1,
    		center_long: 303.9
    	},
    	{
    		feature_id: 3541,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Lyuba",
    		type: "First Name",
    		origin: "Russia",
    		continent: "Europe",
    		clean_name: "Lyuba",
    		description: "Russian first name.",
    		bio: "",
    		search_term: "",
    		diameter: "12.4",
    		center_lat: 1.6,
    		center_long: 283.9
    	},
    	{
    		feature_id: 3568,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Mae",
    		type: "First Name",
    		origin: "Greek",
    		continent: "Europe",
    		clean_name: "Mae",
    		description: "From Margaret, Greek first name.",
    		bio: "",
    		search_term: "",
    		diameter: "7.5",
    		center_lat: -40.5,
    		center_long: 345.2
    	},
    	{
    		feature_id: 3697,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Maret",
    		type: "First Name",
    		origin: "Estonia",
    		continent: "Europe",
    		clean_name: "Maret",
    		description: "Estonian first name.",
    		bio: "",
    		search_term: "",
    		diameter: "11.7",
    		center_lat: -33.3,
    		center_long: 280.2
    	},
    	{
    		feature_id: 3706,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Marianne",
    		type: "First Name",
    		origin: "Greek",
    		continent: "Europe",
    		clean_name: "Marianne",
    		description: "From Mary, Greek first name.",
    		bio: "",
    		search_term: "",
    		diameter: "9.0",
    		center_lat: 9.3,
    		center_long: 358
    	},
    	{
    		feature_id: 3732,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Marysya",
    		type: "First Name",
    		origin: "Belarus",
    		continent: "Europe",
    		clean_name: "Marysya",
    		description: "Belorussian first name.",
    		bio: "",
    		search_term: "",
    		diameter: "6.3",
    		center_lat: 53.3,
    		center_long: 75.1
    	},
    	{
    		feature_id: 3738,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Masha",
    		type: "First Name",
    		origin: "Russia",
    		continent: "Europe",
    		clean_name: "Masha",
    		description: "Russian first name.",
    		bio: "",
    		search_term: "",
    		diameter: "6.4",
    		center_lat: 60.7,
    		center_long: 88.5
    	},
    	{
    		feature_id: 3810,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Melanka",
    		type: "First Name",
    		origin: "Ukraine",
    		continent: "Europe",
    		clean_name: "Melanka",
    		description: "Ukranian first name.",
    		bio: "",
    		search_term: "",
    		diameter: "9.0",
    		center_lat: 34.4,
    		center_long: 19.2
    	},
    	{
    		feature_id: 3818,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Melina",
    		type: "First Name",
    		origin: "Greek",
    		continent: "Europe",
    		clean_name: "Melina",
    		description: "Greek first name.",
    		bio: "",
    		search_term: "",
    		diameter: "12.7",
    		center_lat: -69.9,
    		center_long: 319.5
    	},
    	{
    		feature_id: 3851,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Meredith",
    		type: "First Name",
    		origin: "England",
    		continent: "Europe",
    		clean_name: "Meredith",
    		description: "English first name.",
    		bio: "",
    		search_term: "",
    		diameter: "11.4",
    		center_lat: -14.5,
    		center_long: 278.9
    	},
    	{
    		feature_id: 3895,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Mildred",
    		type: "First Name",
    		origin: "England",
    		continent: "Europe",
    		clean_name: "Mildred",
    		description: "English first name.",
    		bio: "",
    		search_term: "",
    		diameter: "12.0",
    		center_lat: -51.7,
    		center_long: 348.3
    	},
    	{
    		feature_id: 4102,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Nadeyka",
    		type: "First Name",
    		origin: "Belarus",
    		continent: "Europe",
    		clean_name: "Nadeyka",
    		description: "Belorussian first name.",
    		bio: "",
    		search_term: "",
    		diameter: "9.3",
    		center_lat: -54.8,
    		center_long: 305.3
    	},
    	{
    		feature_id: 4160,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Nastya",
    		type: "First Name",
    		origin: "Russia",
    		continent: "Europe",
    		clean_name: "Nastya",
    		description: "From Anastasiya, Russian first name.",
    		bio: "",
    		search_term: "",
    		diameter: "12.5",
    		center_lat: -49,
    		center_long: 275.8
    	},
    	{
    		feature_id: 4185,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Neda",
    		type: "First Name",
    		origin: "Macedonian",
    		continent: "Europe",
    		clean_name: "Neda",
    		description: "Macedonian first name.",
    		bio: "",
    		search_term: "",
    		diameter: "7.7",
    		center_lat: 16.7,
    		center_long: 313.5
    	},
    	{
    		feature_id: 4189,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Neeltje",
    		type: "First Name",
    		origin: "Netherlands",
    		continent: "Europe",
    		clean_name: "Neeltje",
    		description: "Dutch first name.",
    		bio: "",
    		search_term: "",
    		diameter: "10.0",
    		center_lat: 12.4,
    		center_long: 124.4
    	},
    	{
    		feature_id: 4252,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Nicole",
    		type: "First Name",
    		origin: "France",
    		continent: "Europe",
    		clean_name: "Nicole",
    		description: "French first name.",
    		bio: "",
    		search_term: "",
    		diameter: "6.4",
    		center_lat: 48.4,
    		center_long: 259.3
    	},
    	{
    		feature_id: 4328,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Nomeda",
    		type: "First Name",
    		origin: "Lithuania",
    		continent: "Europe",
    		clean_name: "Nomeda",
    		description: "Lithuanian first name.",
    		bio: "",
    		search_term: "",
    		diameter: "10.4",
    		center_lat: -49.2,
    		center_long: 55.5
    	},
    	{
    		feature_id: 4366,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Nutsa",
    		type: "First Name",
    		origin: "Georgia",
    		continent: "Europe",
    		clean_name: "Nutsa",
    		description: "Abkhazian (Georgia) first name.",
    		bio: "",
    		search_term: "",
    		diameter: "8.0",
    		center_lat: 27.5,
    		center_long: 341.2
    	},
    	{
    		feature_id: 4400,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Odarka",
    		type: "First Name",
    		origin: "Ukraine",
    		continent: "Europe",
    		clean_name: "Odarka",
    		description: "Ukrainian first name.",
    		bio: "",
    		search_term: "",
    		diameter: "7.0",
    		center_lat: 40.8,
    		center_long: 138.2
    	},
    	{
    		feature_id: 4429,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Oksana",
    		type: "First Name",
    		origin: "Ukraine",
    		continent: "Europe",
    		clean_name: "Oksana",
    		description: "Ukrainian first name.",
    		bio: "",
    		search_term: "",
    		diameter: "7.7",
    		center_lat: 11.9,
    		center_long: 352
    	},
    	{
    		feature_id: 4430,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Oku",
    		type: "First Name",
    		origin: "Karelia",
    		continent: "Europe",
    		clean_name: "Oku",
    		description: "Karelian first name.",
    		bio: "",
    		search_term: "",
    		diameter: "13.3",
    		center_lat: -64.2,
    		center_long: 232.2
    	},
    	{
    		feature_id: 4435,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Olena",
    		type: "First Name",
    		origin: "Ukraine",
    		continent: "Europe",
    		clean_name: "Olena",
    		description: "Ukrainian first name.",
    		bio: "",
    		search_term: "",
    		diameter: "7.0",
    		center_lat: 10.9,
    		center_long: 149
    	},
    	{
    		feature_id: 4438,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Olesya",
    		type: "First Name",
    		origin: "Ukraine",
    		continent: "Europe",
    		clean_name: "Olesya",
    		description: "Ukrainian first name.",
    		bio: "",
    		search_term: "",
    		diameter: "12.0",
    		center_lat: 5.6,
    		center_long: 273.3
    	},
    	{
    		feature_id: 4441,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Olivia",
    		type: "First Name",
    		origin: "Netherlands",
    		continent: "Europe",
    		clean_name: "Olivia",
    		description: "Dutch first name.",
    		bio: "",
    		search_term: "",
    		diameter: "10.2",
    		center_lat: 37.2,
    		center_long: 207.9
    	},
    	{
    		feature_id: 4467,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Onissya",
    		type: "First Name",
    		origin: "Russia",
    		continent: "Europe",
    		clean_name: "Onissya",
    		description: "Komi-Permyak (Urals Finn) first name.",
    		bio: "",
    		search_term: "",
    		diameter: "8.2",
    		center_lat: -25.6,
    		center_long: 150.2
    	},
    	{
    		feature_id: 4492,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Orlette",
    		type: "First Name",
    		origin: "France",
    		continent: "Europe",
    		clean_name: "Orlette",
    		description: "French first name.",
    		bio: "",
    		search_term: "",
    		diameter: "12.5",
    		center_lat: -68.1,
    		center_long: 193.3
    	},
    	{
    		feature_id: 4500,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Ortensia",
    		type: "First Name",
    		origin: "Italy",
    		continent: "Europe",
    		clean_name: "Ortensia",
    		description: "Italian first name.",
    		bio: "",
    		search_term: "",
    		diameter: "7.0",
    		center_lat: 7.6,
    		center_long: 155.7
    	},
    	{
    		feature_id: 4525,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Ottavia",
    		type: "First Name",
    		origin: "Roman",
    		continent: "Europe",
    		clean_name: "Ottavia",
    		description: "Roman first name.",
    		bio: "",
    		search_term: "",
    		diameter: "12.9",
    		center_lat: -47.5,
    		center_long: 187.1
    	},
    	{
    		feature_id: 4529,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Outi",
    		type: "First Name",
    		origin: "Finland",
    		continent: "Europe",
    		clean_name: "Outi",
    		description: "Finnish first name.",
    		bio: "",
    		search_term: "",
    		diameter: "10.5",
    		center_lat: 61.6,
    		center_long: 267.7
    	},
    	{
    		feature_id: 4549,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Paige",
    		type: "First Name",
    		origin: "Italy",
    		continent: "Europe",
    		clean_name: "Paige",
    		description: "Italian first name.",
    		bio: "",
    		search_term: "",
    		diameter: "6.8",
    		center_lat: -1.2,
    		center_long: 24.6
    	},
    	{
    		feature_id: 4601,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Pasha",
    		type: "First Name",
    		origin: "Russia",
    		continent: "Europe",
    		clean_name: "Pasha",
    		description: "Russian first name.",
    		bio: "",
    		search_term: "",
    		diameter: "7.2",
    		center_lat: 42.7,
    		center_long: 156.3
    	},
    	{
    		feature_id: 4607,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Pat",
    		type: "First Name",
    		origin: "England",
    		continent: "Europe",
    		clean_name: "Pat",
    		description: "English first name.",
    		bio: "",
    		search_term: "",
    		diameter: "10.1",
    		center_lat: 2.9,
    		center_long: 262.6
    	},
    	{
    		feature_id: 4615,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Pavlinka",
    		type: "First Name",
    		origin: "Belarus",
    		continent: "Europe",
    		clean_name: "Pavlinka",
    		description: "Belorussian first name.",
    		bio: "",
    		search_term: "",
    		diameter: "7.5",
    		center_lat: -25.5,
    		center_long: 158.7
    	},
    	{
    		feature_id: 4692,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Philomena",
    		type: "First Name",
    		origin: "Greek",
    		continent: "Europe",
    		clean_name: "Philomena",
    		description: "Greek first name.",
    		bio: "",
    		search_term: "",
    		diameter: "14.8",
    		center_lat: -40.7,
    		center_long: 151.9
    	},
    	{
    		feature_id: 4737,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Pirkko",
    		type: "First Name",
    		origin: "Finland",
    		continent: "Europe",
    		clean_name: "Pirkko",
    		description: "Finnish first name.",
    		bio: "",
    		search_term: "",
    		diameter: "12.3",
    		center_lat: 44.8,
    		center_long: 254.6
    	},
    	{
    		feature_id: 4920,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Radmila",
    		type: "First Name",
    		origin: "Croatia",
    		continent: "Europe",
    		clean_name: "Radmila",
    		description: "Serbocroatian first name.",
    		bio: "",
    		search_term: "",
    		diameter: "5.2",
    		center_lat: 69.1,
    		center_long: 167
    	},
    	{
    		feature_id: 4924,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Rafiga",
    		type: "First Name",
    		origin: "Azerbaijan",
    		continent: "Europe",
    		clean_name: "Rafiga",
    		description: "Azeri first name.",
    		bio: "",
    		search_term: "",
    		diameter: "5.7",
    		center_lat: 62.9,
    		center_long: 175.6
    	},
    	{
    		feature_id: 4968,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Raymonde",
    		type: "First Name",
    		origin: "France",
    		continent: "Europe",
    		clean_name: "Raymonde",
    		description: "French first name.",
    		bio: "",
    		search_term: "",
    		diameter: "5.3",
    		center_lat: 48.4,
    		center_long: 191.5
    	},
    	{
    		feature_id: 5218,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Rufina",
    		type: "First Name",
    		origin: "Greek",
    		continent: "Europe",
    		clean_name: "Rufina",
    		description: "Greek first name.",
    		bio: "",
    		search_term: "",
    		diameter: "5.0",
    		center_lat: -74.6,
    		center_long: 195.1
    	},
    	{
    		feature_id: 5302,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Sandi",
    		type: "First Name",
    		origin: "Greek",
    		continent: "Europe",
    		clean_name: "Sandi",
    		description: "From Alexandra, Greek first name.",
    		bio: "",
    		search_term: "",
    		diameter: "12.6",
    		center_lat: -68.1,
    		center_long: 315.1
    	},
    	{
    		feature_id: 5333,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Sasha",
    		type: "First Name",
    		origin: "Russia",
    		continent: "Europe",
    		clean_name: "Sasha",
    		description: "Russian first name.",
    		bio: "",
    		search_term: "",
    		diameter: "4.6",
    		center_lat: 38.3,
    		center_long: 277.3
    	},
    	{
    		feature_id: 5481,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Sheila",
    		type: "First Name",
    		origin: "Ireland",
    		continent: "Europe",
    		clean_name: "Sheila",
    		description: "Irish/Celtic first name.",
    		bio: "",
    		search_term: "",
    		diameter: "5.6",
    		center_lat: 19.9,
    		center_long: 50.2
    	},
    	{
    		feature_id: 5509,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Shushan",
    		type: "First Name",
    		origin: "Armenia",
    		continent: "Europe",
    		clean_name: "Shushan",
    		description: "Armenian first name.",
    		bio: "",
    		search_term: "",
    		diameter: "8.5",
    		center_lat: -43.8,
    		center_long: 70.2
    	},
    	{
    		feature_id: 5841,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Talvikki",
    		type: "First Name",
    		origin: "Finland",
    		continent: "Europe",
    		clean_name: "Talvikki",
    		description: "Finnish first name.",
    		bio: "",
    		search_term: "",
    		diameter: "12.6",
    		center_lat: 41.9,
    		center_long: 22
    	},
    	{
    		feature_id: 5927,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Terhi",
    		type: "First Name",
    		origin: "Finland",
    		continent: "Europe",
    		clean_name: "Terhi",
    		description: "Finnish first name.",
    		bio: "",
    		search_term: "",
    		diameter: "10.7",
    		center_lat: 45.7,
    		center_long: 253.1
    	},
    	{
    		feature_id: 5997,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Tiffany",
    		type: "First Name",
    		origin: "Greek",
    		continent: "Europe",
    		clean_name: "Tiffany",
    		description: "Greek first name.",
    		bio: "",
    		search_term: "",
    		diameter: "7.0",
    		center_lat: -8.7,
    		center_long: 22.9
    	},
    	{
    		feature_id: 6188,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Ugne",
    		type: "First Name",
    		origin: "Lithuania",
    		continent: "Europe",
    		clean_name: "Ugne",
    		description: "Lithuanian first name.",
    		bio: "",
    		search_term: "",
    		diameter: "10.3",
    		center_lat: 34.9,
    		center_long: 205.8
    	},
    	{
    		feature_id: 6213,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Ul'yana",
    		type: "First Name",
    		origin: "Russia",
    		continent: "Europe",
    		clean_name: "Ul'yana",
    		description: "Russian first name.",
    		bio: "",
    		search_term: "",
    		diameter: "12.5",
    		center_lat: 24.3,
    		center_long: 253
    	},
    	{
    		feature_id: 6200,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Ulla",
    		type: "First Name",
    		origin: "Sweden",
    		continent: "Europe",
    		clean_name: "Ulla",
    		description: "Swedish first name.",
    		bio: "",
    		search_term: "",
    		diameter: "10.4",
    		center_lat: -51.5,
    		center_long: 184.5
    	},
    	{
    		feature_id: 6201,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Ulpu",
    		type: "First Name",
    		origin: "Finland",
    		continent: "Europe",
    		clean_name: "Ulpu",
    		description: "Finnish first name.",
    		bio: "",
    		search_term: "",
    		diameter: "7.0",
    		center_lat: -35.7,
    		center_long: 179
    	},
    	{
    		feature_id: 6250,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Ustinya",
    		type: "First Name",
    		origin: "Russia",
    		continent: "Europe",
    		clean_name: "Ustinya",
    		description: "Russian first name.",
    		bio: "",
    		search_term: "",
    		diameter: "11.8",
    		center_lat: -41.2,
    		center_long: 251.6
    	},
    	{
    		feature_id: 6273,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Vaka",
    		type: "First Name",
    		origin: "Bulgaria",
    		continent: "Europe",
    		clean_name: "Vaka",
    		description: "Bulgarian first name.",
    		bio: "",
    		search_term: "",
    		diameter: "11.8",
    		center_lat: -41.4,
    		center_long: 8.9
    	},
    	{
    		feature_id: 6281,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Valerie",
    		type: "First Name",
    		origin: "France",
    		continent: "Europe",
    		clean_name: "Valerie",
    		description: "French first name.",
    		bio: "",
    		search_term: "",
    		diameter: "13.6",
    		center_lat: -6.4,
    		center_long: 30.9
    	},
    	{
    		feature_id: 6319,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Vanessa",
    		type: "First Name",
    		origin: "Greek",
    		continent: "Europe",
    		clean_name: "Vanessa",
    		description: "Greek first name.",
    		bio: "",
    		search_term: "",
    		diameter: "10.0",
    		center_lat: -6,
    		center_long: 1.9
    	},
    	{
    		feature_id: 6322,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Vard",
    		type: "First Name",
    		origin: "Armenia",
    		continent: "Europe",
    		clean_name: "Vard",
    		description: "Armenian first name.",
    		bio: "",
    		search_term: "",
    		diameter: "6.1",
    		center_lat: 17.5,
    		center_long: 314.5
    	},
    	{
    		feature_id: 6325,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Varya",
    		type: "First Name",
    		origin: "Russia",
    		continent: "Europe",
    		clean_name: "Varya",
    		description: "Russian first name.",
    		bio: "",
    		search_term: "",
    		diameter: "14.3",
    		center_lat: 2.8,
    		center_long: 211.8
    	},
    	{
    		feature_id: 6331,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Vasilutsa",
    		type: "First Name",
    		origin: "Moldova",
    		continent: "Europe",
    		clean_name: "Vasilutsa",
    		description: "Moldavian first name.",
    		bio: "",
    		search_term: "",
    		diameter: "5.7",
    		center_lat: 16.5,
    		center_long: 334.4
    	},
    	{
    		feature_id: 6332,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Vassi",
    		type: "First Name",
    		origin: "Karelia",
    		continent: "Europe",
    		clean_name: "Vassi",
    		description: "Karelian first name.",
    		bio: "",
    		search_term: "",
    		diameter: "8.5",
    		center_lat: 34.4,
    		center_long: 346.5
    	},
    	{
    		feature_id: 6355,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Veriko",
    		type: "First Name",
    		origin: "Georgia",
    		continent: "Europe",
    		clean_name: "Veriko",
    		description: "Georgian first name.",
    		bio: "",
    		search_term: "",
    		diameter: "5.2",
    		center_lat: 20.4,
    		center_long: 350.1
    	},
    	{
    		feature_id: 6372,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Veta",
    		type: "First Name",
    		origin: "Romania (Rumania)",
    		continent: "Europe",
    		clean_name: "Veta",
    		description: "Romanian first name.",
    		bio: "",
    		search_term: "",
    		diameter: "6.4",
    		center_lat: 42.6,
    		center_long: 349.5
    	},
    	{
    		feature_id: 6396,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Viola",
    		type: "First Name",
    		origin: "England",
    		continent: "Europe",
    		clean_name: "Viola",
    		description: "English first name.",
    		bio: "",
    		search_term: "",
    		diameter: "10.0",
    		center_lat: -36.1,
    		center_long: 240.5
    	},
    	{
    		feature_id: 6401,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Virga",
    		type: "First Name",
    		origin: "Lithuania",
    		continent: "Europe",
    		clean_name: "Virga",
    		description: "Lithuanian first name.",
    		bio: "",
    		search_term: "",
    		diameter: "10.3",
    		center_lat: -26.9,
    		center_long: 7.7
    	},
    	{
    		feature_id: 6422,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Vlasta",
    		type: "First Name",
    		origin: "Czechoslovakia",
    		continent: "Europe",
    		clean_name: "Vlasta",
    		description: "Czech first name.",
    		bio: "",
    		search_term: "",
    		diameter: "10.7",
    		center_lat: 28.4,
    		center_long: 250.1
    	},
    	{
    		feature_id: 6434,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Volyana",
    		type: "First Name",
    		origin: "Romani",
    		continent: "Europe",
    		clean_name: "Volyana",
    		description: "Romani first name.",
    		bio: "",
    		search_term: "",
    		diameter: "5.3",
    		center_lat: 60.6,
    		center_long: 359.9
    	},
    	{
    		feature_id: 6519,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Wendla",
    		type: "First Name",
    		origin: "Sweden",
    		continent: "Europe",
    		clean_name: "Wendla",
    		description: "Swedish first name.",
    		bio: "",
    		search_term: "",
    		diameter: "5.7",
    		center_lat: 22.5,
    		center_long: 207.6
    	},
    	{
    		feature_id: 6553,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Wilma",
    		type: "First Name",
    		origin: "England",
    		continent: "Europe",
    		clean_name: "Wilma",
    		description: "English first name.",
    		bio: "",
    		search_term: "",
    		diameter: "12.5",
    		center_lat: 36.7,
    		center_long: 1.7
    	},
    	{
    		feature_id: 6592,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Wynne",
    		type: "First Name",
    		origin: "England",
    		continent: "Europe",
    		clean_name: "Wynne",
    		description: "English first name.",
    		bio: "",
    		search_term: "",
    		diameter: "10.0",
    		center_lat: 55,
    		center_long: 53.6
    	},
    	{
    		feature_id: 6605,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Xenia",
    		type: "First Name",
    		origin: "Greek",
    		continent: "Europe",
    		clean_name: "Xenia",
    		description: "Greek first name.",
    		bio: "",
    		search_term: "",
    		diameter: "13.5",
    		center_lat: -30.3,
    		center_long: 249.4
    	},
    	{
    		feature_id: 6613,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Ximena",
    		type: "First Name",
    		origin: "Portugal",
    		continent: "Europe",
    		clean_name: "Ximena",
    		description: "Portuguese first name.",
    		bio: "",
    		search_term: "",
    		diameter: "12.8",
    		center_lat: -68.2,
    		center_long: 243.6
    	},
    	{
    		feature_id: 6660,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Yetta",
    		type: "First Name",
    		origin: "Germany",
    		continent: "Europe",
    		clean_name: "Yetta",
    		description: "From Henrietta, German first name.",
    		bio: "",
    		search_term: "",
    		diameter: "9.0",
    		center_lat: 58.6,
    		center_long: 185.4
    	},
    	{
    		feature_id: 6665,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Yolanda",
    		type: "First Name",
    		origin: "Greek",
    		continent: "Europe",
    		clean_name: "Yolanda",
    		description: "Greek first name.",
    		bio: "",
    		search_term: "",
    		diameter: "11.4",
    		center_lat: 7.8,
    		center_long: 152.7
    	},
    	{
    		feature_id: 6688,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Yvette",
    		type: "First Name",
    		origin: "France",
    		continent: "Europe",
    		clean_name: "Yvette",
    		description: "French first name.",
    		bio: "",
    		search_term: "",
    		diameter: "10.6",
    		center_lat: 7.5,
    		center_long: 249.6
    	},
    	{
    		feature_id: 6714,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Zemfira",
    		type: "First Name",
    		origin: "Romani",
    		continent: "Europe",
    		clean_name: "Zemfira",
    		description: "Romani first name.",
    		bio: "",
    		search_term: "",
    		diameter: "11.4",
    		center_lat: -46.2,
    		center_long: 157.7
    	},
    	{
    		feature_id: 6945,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Živile",
    		type: "First Name",
    		origin: "Lithuania",
    		continent: "Europe",
    		clean_name: "Živile",
    		description: "Lithuanian first name.",
    		bio: "",
    		search_term: "",
    		diameter: "13.5",
    		center_lat: 48.8,
    		center_long: 113.1
    	},
    	{
    		feature_id: 6753,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Zosia",
    		type: "First Name",
    		origin: "Poland",
    		continent: "Europe",
    		clean_name: "Zosia",
    		description: "Polish first name.",
    		bio: "",
    		search_term: "",
    		diameter: "10.5",
    		center_lat: -18.9,
    		center_long: 109.2
    	},
    	{
    		feature_id: 6762,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Zulma",
    		type: "First Name",
    		origin: "Spain",
    		continent: "Europe",
    		clean_name: "Zulma",
    		description: "Spanish first name.",
    		bio: "",
    		search_term: "",
    		diameter: "11.0",
    		center_lat: -7.7,
    		center_long: 102
    	},
    	{
    		feature_id: 6767,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Zurka",
    		type: "First Name",
    		origin: "Romani",
    		continent: "Europe",
    		clean_name: "Zurka",
    		description: "Romani first name.",
    		bio: "",
    		search_term: "",
    		diameter: "5.5",
    		center_lat: -12.8,
    		center_long: 275.2
    	},
    	{
    		feature_id: 15,
    		year: 1997,
    		feature: "Mons",
    		feature_plural: "Montes",
    		name: "Abeona Mons",
    		type: "Goddess",
    		origin: "Roman",
    		continent: "Europe",
    		clean_name: "Abeona",
    		description: "Roman goddess of travelers.",
    		bio: "Abeona is the goddess for outward journeys and safe passage, while her partner Adeona protects travelers on their return home. They have a special focus on children.",
    		search_term: "Abeona",
    		diameter: "375.0",
    		center_lat: -44.8,
    		center_long: 273.1
    	},
    	{
    		feature_id: 57,
    		year: 1997,
    		feature: "Tessera",
    		feature_plural: "Tesserae",
    		name: "Adrasthea Tesserae",
    		type: "Goddess",
    		origin: "Greek",
    		continent: "Europe",
    		clean_name: "Adrasthea",
    		description: "Greek goddess of law.",
    		bio: "",
    		search_term: "",
    		diameter: "750.0",
    		center_lat: 30,
    		center_long: 55
    	},
    	{
    		feature_id: 107,
    		year: 1997,
    		feature: "Fossa",
    		feature_plural: "Fossae",
    		name: "Aife Fossae",
    		type: "Goddess",
    		origin: "Ireland",
    		continent: "Europe",
    		clean_name: "Aife",
    		description: "Irish warrior deity.",
    		bio: "Aífe is a character from the Ulster Cycle of Irish mythology. She appears in the sagas Tochmarc Emire (\"the wooing of Emer\") and Aided Óenfhir Aífe (\"the death of Aífe's only son\"). In Tochmarc Emire she lives east of a land called Alpi, usually understood to mean Alba (Scotland), where she is at war with a rival woman warrior, Scáthach.",
    		search_term: "Aife",
    		diameter: "280.0",
    		center_lat: 67,
    		center_long: 131
    	},
    	{
    		feature_id: 175,
    		year: 1997,
    		feature: "Mons",
    		feature_plural: "Montes",
    		name: "Aleksota Mons",
    		type: "Goddess",
    		origin: "Lithuania",
    		continent: "Europe",
    		clean_name: "Aleksota",
    		description: "Lithuanian goddess of love.",
    		bio: "Aleksota, also known as Milda, is the goddess of love in the Lithuanian mythology. However, her authenticity is debated by scholars.",
    		search_term: "Milda (mythology)",
    		diameter: "250.0",
    		center_lat: -9,
    		center_long: 308.5
    	},
    	{
    		feature_id: 243,
    		year: 1997,
    		feature: "Tholus",
    		feature_plural: "Tholi",
    		name: "Amra Tholus",
    		type: "Goddess",
    		origin: "Georgia",
    		continent: "Europe",
    		clean_name: "Amra",
    		description: "Abkhazian sun deity.",
    		bio: "",
    		search_term: "",
    		diameter: "50.0",
    		center_lat: 53,
    		center_long: 98
    	},
    	{
    		feature_id: 268,
    		year: 1997,
    		feature: "Tholus",
    		feature_plural: "Tholi",
    		name: "Angerona Tholus",
    		type: "Goddess",
    		origin: "Italy",
    		continent: "Europe",
    		clean_name: "Angerona",
    		description: "Italian goddess of silence.",
    		bio: "In Roman religion, Angerona or Angeronia was an old Roman goddess who relieved men from pain and sorrow, or delivered the Romans and their flocks from angina (quinsy).",
    		search_term: "Angerona",
    		diameter: "200.0",
    		center_lat: -29.8,
    		center_long: 287.2
    	},
    	{
    		feature_id: 271,
    		year: 1997,
    		feature: "Tholus",
    		feature_plural: "Tholi",
    		name: "Angrboda Tholus",
    		type: "Goddess",
    		origin: "Norse",
    		continent: "Europe",
    		clean_name: "Angrboda",
    		description: "Norse Titaness, mother of three terrible deities.",
    		bio: "Angrboða is a jötunn in Norse mythology. She is the mate of Loki and the mother of monsters. Her name has been translated as 'the one who brings grief', 'she-who-offers-sorrow', or 'harm-bidder'.",
    		search_term: "Angrboda",
    		diameter: "80.0",
    		center_lat: -73.8,
    		center_long: 116
    	},
    	{
    		feature_id: 354,
    		year: 1997,
    		feature: "Chasma",
    		feature_plural: "Chasmata",
    		name: "Ardwinna Chasma",
    		type: "Goddess",
    		origin: "Celtic",
    		continent: "Europe",
    		clean_name: "Ardwinna",
    		description: "Continental Celtic wildwood goddess.",
    		bio: "In Gallo-Roman religion, Ardwinna was the eponymous tutelary goddess of the Ardennes Forest and region, thought to be represented as a huntress riding a boar. Her cult originated in the Ardennes region of present-day Belgium, Luxembourg, and France. She was identified with the Roman goddess Diana.",
    		search_term: "Ardwinna",
    		diameter: "500.0",
    		center_lat: 21,
    		center_long: 197
    	},
    	{
    		feature_id: 404,
    		year: 1997,
    		feature: "Chasma",
    		feature_plural: "Chasmata",
    		name: "Artio Chasma",
    		type: "Goddess",
    		origin: "Celtic",
    		continent: "Europe",
    		clean_name: "Artio",
    		description: "Celtic wildlife bear-goddess.",
    		bio: "Artio (Dea Artio in the Gallo-Roman religion) is a Celtic bear goddess. Evidence of her worship has notably been found at Bern in Switzerland. Her name is derived from the Gaulish word for 'bear', artos.",
    		search_term: "Artio",
    		diameter: "450.0",
    		center_lat: -35.5,
    		center_long: 39
    	},
    	{
    		feature_id: 407,
    		year: 1997,
    		feature: "Fluctus",
    		feature_plural: "Fluctūs",
    		name: "Arubani Fluctus",
    		type: "Goddess",
    		origin: "Urartu",
    		continent: "Europe",
    		clean_name: "Arubani",
    		description: "Urartu supreme goddess.",
    		bio: "Arubani is the Urartian's goddess of fertility and art. She was also the wife of their supreme god, Khaldi.",
    		search_term: "Arubani",
    		diameter: "620.0",
    		center_lat: -55,
    		center_long: 132
    	},
    	{
    		feature_id: 439,
    		year: 1997,
    		feature: "Planum",
    		feature_plural: "Plana",
    		name: "Astkhik Planum",
    		type: "Goddess",
    		origin: "Armenia",
    		continent: "Europe",
    		clean_name: "Astkhik",
    		description: "Armenian goddess of love.",
    		bio: "",
    		search_term: "",
    		diameter: "2,000.0",
    		center_lat: -45,
    		center_long: 20
    	},
    	{
    		feature_id: 454,
    		year: 1997,
    		feature: "Tessera",
    		feature_plural: "Tesserae",
    		name: "Athena Tessera",
    		type: "Goddess",
    		origin: "Greek",
    		continent: "Europe",
    		clean_name: "Athena",
    		description: "Greek goddess of wisdom.",
    		bio: "Athena or Athene, often given the epithet Pallas, is an ancient Greek goddess associated with wisdom, warfare, and handicraft who was later syncretized with the Roman goddess Minerva. Athena was regarded as the patron and protectress of various cities across Greece, particularly the city of Athens, from which she most likely received her name.",
    		search_term: "Athena",
    		diameter: "1,800.0",
    		center_lat: 35,
    		center_long: 175
    	},
    	{
    		feature_id: 548,
    		year: 1997,
    		feature: "Linea",
    		feature_plural: "Lineae",
    		name: "Badb Linea",
    		type: "Goddess",
    		origin: "Ireland",
    		continent: "Europe",
    		clean_name: "Badb",
    		description: "Irish war goddess.",
    		bio: "In Irish mythology, the Badb is a war goddess who takes the form of a crow, and is thus sometimes known as Badb Catha (\"battle crow\"). She is known to cause fear and confusion among soldiers to move the tide of battle to her favoured side. Badb may also appear prior to a battle to foreshadow the extent of the carnage to come, or to predict the death of a notable person.",
    		search_term: "Badb",
    		diameter: "1,750.0",
    		center_lat: 14,
    		center_long: 15
    	},
    	{
    		feature_id: 554,
    		year: 1997,
    		feature: "Mons",
    		feature_plural: "Montes",
    		name: "Bagbartu Mons",
    		type: "Goddess",
    		origin: "Urartu",
    		continent: "Europe",
    		clean_name: "Bagbartu",
    		description: "Urartu goddess, worshipped at Musasir.",
    		bio: "Bagbartu is an Araratian (Urartian) goddess, and the consort or wife of the chief Urartian god Haldi.",
    		search_term: "Bagbartu",
    		diameter: "600.0",
    		center_lat: 65.5,
    		center_long: 279
    	},
    	{
    		feature_id: 593,
    		year: 1997,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Banba Corona",
    		type: "Goddess",
    		origin: "Ireland",
    		continent: "Europe",
    		clean_name: "Banba",
    		description: "Irish earth goddess.",
    		bio: "In Irish mythology, Banba is a matron goddess of Ireland. She was part of an important triumvirate of matron goddesses, with her sisters, Ériu and Fódla. Initially, she could have been a goddess of war as well as a fertility goddess.",
    		search_term: "Banba",
    		diameter: "110.0",
    		center_lat: -47.2,
    		center_long: 209.2
    	},
    	{
    		feature_id: 604,
    		year: 1997,
    		feature: "Dorsum",
    		feature_plural: "Dorsa",
    		name: "Barbale Dorsa",
    		type: "Goddess",
    		origin: "Georgia",
    		continent: "Europe",
    		clean_name: "Barbale",
    		description: "Georgian sun goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "1,200.0",
    		center_lat: 15,
    		center_long: 143
    	},
    	{
    		feature_id: 903,
    		year: 1997,
    		feature: "Fossa",
    		feature_plural: "Fossae",
    		name: "Brynhild Fossae",
    		type: "Goddess",
    		origin: "Norse",
    		continent: "Europe",
    		clean_name: "Brynhild",
    		description: "Norse warrior maiden.",
    		bio: "Brynhild is a female character from Germanic heroic legend. She may have her origins in the Visigothic princess Brunhilda of Austrasia. In the Norse tradition, Brunhild is a shieldmaiden or valkyrie.",
    		search_term: "Brynhild",
    		diameter: "1,800.0",
    		center_lat: -26,
    		center_long: 18
    	},
    	{
    		feature_id: 1111,
    		year: 1997,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Cerridwen Corona",
    		type: "Goddess",
    		origin: "Celtic",
    		continent: "Europe",
    		clean_name: "Cerridwen",
    		description: "Celtic nature goddess.",
    		bio: "Ceridwen or Cerridwen was an enchantress in Welsh medieval legend. She was the mother of a hideous son, Afagddu, and a beautiful daughter, Creirwy. Ceridwen is regarded by many modern pagans as the Celtic goddess of rebirth, transformation, and inspiration.",
    		search_term: "Cerridwen",
    		diameter: "217.0",
    		center_lat: 49.6,
    		center_long: 201.8
    	},
    	{
    		feature_id: 1172,
    		year: 1997,
    		feature: "Collis",
    		feature_plural: "Colles",
    		name: "Chernava Colles",
    		type: "Goddess",
    		origin: "Russia",
    		continent: "Europe",
    		clean_name: "Chernava",
    		description: "Russian sea maiden, sea czar's daughter.",
    		bio: "In Russian folklore, Chernava is the daughter of the Sea Tsar, spirit and personification of the river of the same name. She is a mermaid. Her head and upper body are human, while the lower body is a fish's tail.",
    		search_term: "Chernava",
    		diameter: "1,000.0",
    		center_lat: -10.5,
    		center_long: 335.5
    	},
    	{
    		feature_id: 1192,
    		year: 1997,
    		feature: "Mons",
    		feature_plural: "Montes",
    		name: "Chloris Mons",
    		type: "Goddess",
    		origin: "Greek",
    		continent: "Europe",
    		clean_name: "Chloris",
    		description: "Greek flower goddess.",
    		bio: "In Greek mythology, Chloris was a nymph/goddess who was associated with spring, flowers and new growth, believed to have dwelt in the Elysian Fields. Chloris was abducted by Zephyrus, the god of the west wind, who transformed her into a deity known as Flora after they were married.",
    		search_term: "Chloris (nymph)",
    		diameter: "180.0",
    		center_lat: -45.4,
    		center_long: 294.6
    	},
    	{
    		feature_id: 1243,
    		year: 1997,
    		feature: "Tessera",
    		feature_plural: "Tesserae",
    		name: "Clidna Tessera",
    		type: "Goddess",
    		origin: "Ireland",
    		continent: "Europe",
    		clean_name: "Clidna",
    		description: "Irish bird goddess of afterlife.",
    		bio: "In Irish mythology, Clíodhna (or Clidna) is a Queen of the Banshees of the Tuatha Dé Danann. Clíodna of Carrigcleena is the potent banshee that rules as queen over the sidheog (fairy women of the hills) of South Munster, or Desmond. In some Irish myths, Clíodhna is a goddess of love and beauty, and the patron of County Cork. She is said to have three brightly coloured birds who eat apples from an otherworldly tree and whose sweet song heals the sick people.",
    		search_term: "Clidna",
    		diameter: "500.0",
    		center_lat: -42,
    		center_long: 29
    	},
    	{
    		feature_id: 1320,
    		year: 1997,
    		feature: "Tholus",
    		feature_plural: "Tholi",
    		name: "Cotis Tholus",
    		type: "Goddess",
    		origin: "Greek",
    		continent: "Europe",
    		clean_name: "Cotis",
    		description: "Thracian goddess, mother of gods, similar to Cybele. Named changed from Cotis Mons.",
    		bio: "",
    		search_term: "",
    		diameter: "62.0",
    		center_lat: 44.3,
    		center_long: 233
    	},
    	{
    		feature_id: 1547,
    		year: 1997,
    		feature: "Linea",
    		feature_plural: "Lineae",
    		name: "Discordia Linea",
    		type: "Goddess",
    		origin: "Roman",
    		continent: "Europe",
    		clean_name: "Discordia",
    		description: "Roman war goddess, close to Bellona.",
    		bio: "Eris is the Greek goddess of strife and discord. Her Roman equivalent is Discordia, which means the same. The most famous tale of Eris recounts her initiating the Trojan War by causing the Judgement of Paris.",
    		search_term: "Discordia",
    		diameter: "800.0",
    		center_lat: -58,
    		center_long: 246.5
    	},
    	{
    		feature_id: 1554,
    		year: 1997,
    		feature: "Fluctus",
    		feature_plural: "Fluctūs",
    		name: "Djabran Fluctus",
    		type: "Goddess",
    		origin: "Georgia",
    		continent: "Europe",
    		clean_name: "Djabran",
    		description: "Abkhazian goddess of goats.",
    		bio: "",
    		search_term: "",
    		diameter: "300.0",
    		center_lat: -43.5,
    		center_long: 183
    	},
    	{
    		feature_id: 1693,
    		year: 1997,
    		feature: "Vallis",
    		feature_plural: "Valles",
    		name: "Dzyzlan Vallis",
    		type: "Goddess",
    		origin: "Georgia",
    		continent: "Europe",
    		clean_name: "Dzyzlan",
    		description: "Abkhazian river goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "250.0",
    		center_lat: -16,
    		center_long: 182
    	},
    	{
    		feature_id: 1731,
    		year: 1997,
    		feature: "Mons",
    		feature_plural: "Montes",
    		name: "Egle Mons",
    		type: "Goddess",
    		origin: "Lithuania",
    		continent: "Europe",
    		clean_name: "Egle",
    		description: "Lithuanian underwater queen.",
    		bio: "",
    		search_term: "",
    		diameter: "110.0",
    		center_lat: -59,
    		center_long: 134
    	},
    	{
    		feature_id: 1828,
    		year: 1997,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Erigone Corona",
    		type: "Goddess",
    		origin: "Greek",
    		continent: "Europe",
    		clean_name: "Erigone",
    		description: "Greek harvest goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "325.0",
    		center_lat: -34.5,
    		center_long: 284
    	},
    	{
    		feature_id: 1855,
    		year: 1997,
    		feature: "Dorsum",
    		feature_plural: "Dorsa",
    		name: "Etain Dorsa",
    		type: "Goddess",
    		origin: "Ireland",
    		continent: "Europe",
    		clean_name: "Etain",
    		description: "Irish sun and horse goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "1,400.0",
    		center_lat: -45,
    		center_long: 199
    	},
    	{
    		feature_id: 1924,
    		year: 1997,
    		feature: "Fossa",
    		feature_plural: "Fossae",
    		name: "Fea Fossae",
    		type: "Goddess",
    		origin: "Celtic",
    		continent: "Europe",
    		clean_name: "Fea",
    		description: "Gaelic war goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "620.0",
    		center_lat: 27.5,
    		center_long: 224
    	},
    	{
    		feature_id: 1980,
    		year: 1997,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Flidais Corona",
    		type: "Goddess",
    		origin: "Celtic",
    		continent: "Europe",
    		clean_name: "Flidais",
    		description: "Irish fertility goddess.",
    		bio: "Flidais is a female figure in Irish Mythology, known by the epithet Foltchaín (\"beautiful hair\"). She is believed to have been a goddess of cattle and fertility.",
    		search_term: "Flidais",
    		diameter: "150.0",
    		center_lat: -24.5,
    		center_long: 177.3
    	},
    	{
    		feature_id: 2131,
    		year: 1997,
    		feature: "Tessera",
    		feature_plural: "Tesserae",
    		name: "Gegute Tessera",
    		type: "Goddess",
    		origin: "Lithuania",
    		continent: "Europe",
    		clean_name: "Gegute",
    		description: "Lithuanian goddess of time.",
    		bio: "",
    		search_term: "",
    		diameter: "1,600.0",
    		center_lat: 17,
    		center_long: 121
    	},
    	{
    		feature_id: 2145,
    		year: 1997,
    		feature: "Tholus",
    		feature_plural: "Tholi",
    		name: "Gerd Tholi",
    		type: "Goddess",
    		origin: "Scotland",
    		continent: "Europe",
    		clean_name: "Gerd",
    		description: "Scandinavian sky maiden.",
    		bio: "",
    		search_term: "",
    		diameter: "50.0",
    		center_lat: -54.5,
    		center_long: 291.5
    	},
    	{
    		feature_id: 2167,
    		year: 1997,
    		feature: "Tessera",
    		feature_plural: "Tesserae",
    		name: "Giltine Tesserae",
    		type: "Goddess",
    		origin: "Lithuania",
    		continent: "Europe",
    		clean_name: "Giltine",
    		description: "Lithuanian bad fate goddess.",
    		bio: "Giltine was the Lithuanian goddess of death, also The Reaper. Other names include Maras (black death or the Plague). Her sacred bird is the owl. Sometimes she was considered to be a sister of Laima (luck).",
    		search_term: "Giltine",
    		diameter: "300.0",
    		center_lat: -39,
    		center_long: 250
    	},
    	{
    		feature_id: 2577,
    		year: 1997,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Hulda Corona",
    		type: "Goddess",
    		origin: "Germany",
    		continent: "Europe",
    		clean_name: "Hulda",
    		description: "German goddess of fruitfulness and marriage.",
    		bio: "",
    		search_term: "",
    		diameter: "230.0",
    		center_lat: 12,
    		center_long: 308.3
    	},
    	{
    		feature_id: 2672,
    		year: 1997,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Ilyana Corona",
    		type: "Goddess",
    		origin: "Moldova",
    		continent: "Europe",
    		clean_name: "Ilyana",
    		description: "Moldavian main female deity.",
    		bio: "",
    		search_term: "",
    		diameter: "300.0",
    		center_lat: -69.5,
    		center_long: 65
    	},
    	{
    		feature_id: 2855,
    		year: 1997,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Juksakka Corona",
    		type: "Goddess",
    		origin: "Sámi",
    		continent: "Europe",
    		clean_name: "Juksakka",
    		description: "Sámi goddess of birth.",
    		bio: "Akka is a female spirit in Sami shamanism, and Finnish and Estonian mythology. Her worship is common and took the forms of sacrifice, prayer and various other rituals. Juksakka, \"akka with an arrow\", was the protector of children.",
    		search_term: "Juksakka",
    		diameter: "320.0",
    		center_lat: -19.5,
    		center_long: 44.5
    	},
    	{
    		feature_id: 2870,
    		year: 1997,
    		feature: "Tholus",
    		feature_plural: "Tholi",
    		name: "Justitia Tholus",
    		type: "Goddess",
    		origin: "Roman",
    		continent: "Europe",
    		clean_name: "Justitia",
    		description: "Roman goddess of justice.",
    		bio: "Lady Justice (Latin: Iustitia) is an allegorical personification of the moral force in judicial systems. Her attributes are scales, a sword and sometimes a blindfold. She often appears as a pair with Prudentia. Justitia was introduced by emperor Augustus, and was thus not a very old deity in the Roman pantheon.",
    		search_term: "Justitia",
    		diameter: "60.0",
    		center_lat: -28.7,
    		center_long: 296.5
    	},
    	{
    		feature_id: 2873,
    		year: 1997,
    		feature: "Fluctus",
    		feature_plural: "Fluctūs",
    		name: "Juturna Fluctus",
    		type: "Goddess",
    		origin: "Roman",
    		continent: "Europe",
    		clean_name: "Juturna",
    		description: "Roman nymph of the brook in Lavinia, wife of Janus, mother of Fons.",
    		bio: "In the myth and religion of ancient Rome, Juturna, or Diuturna, was a goddess of fountains, wells and springs, and the mother of Fontus by Janus. Juturna was an ancient Latin deity of fountains, who in some myths was turned by Jupiter into a water nymph – a Naiad.",
    		search_term: "Juturna",
    		diameter: "900.0",
    		center_lat: -76,
    		center_long: 350
    	},
    	{
    		feature_id: 2935,
    		year: 1997,
    		feature: "Fossa",
    		feature_plural: "Fossae",
    		name: "Karra-māhte Fossae",
    		type: "Goddess",
    		origin: "Latvia",
    		continent: "Europe",
    		clean_name: "Karra-māhte",
    		description: "Latvian warrior goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "1,800.0",
    		center_lat: 28,
    		center_long: 342
    	},
    	{
    		feature_id: 3002,
    		year: 1997,
    		feature: "Vallis",
    		feature_plural: "Valles",
    		name: "Khalanasy Vallis",
    		type: "Goddess",
    		origin: "Azerbaijan",
    		continent: "Europe",
    		clean_name: "Khalanasy",
    		description: "Azeri river mermaid.",
    		bio: "",
    		search_term: "",
    		diameter: "320.0",
    		center_lat: -51,
    		center_long: 168.5
    	},
    	{
    		feature_id: 3293,
    		year: 1997,
    		feature: "Chasma",
    		feature_plural: "Chasmata",
    		name: "Latona Chasma",
    		type: "Goddess",
    		origin: "Roman",
    		continent: "Europe",
    		clean_name: "Latona",
    		description: "Roman moon goddess.",
    		bio: "In ancient Greek mythology and religion, Leto is a goddess and the mother of Apollo, the god of music, and Artemis, the goddess of the hunt. She is the daughter of the Titans Coeus and Phoebe, and the sister of Asteria. In the Olympian scheme, the king of gods Zeus is the father of her twins, Apollo and Artemis, which Leto conceived after her hidden beauty accidentally caught the eye of Zeus.",
    		search_term: "Latona",
    		diameter: "530.0",
    		center_lat: 26,
    		center_long: 267.5
    	},
    	{
    		feature_id: 3305,
    		year: 1997,
    		feature: "Dorsum",
    		feature_plural: "Dorsa",
    		name: "Laverna Dorsa",
    		type: "Goddess",
    		origin: "Roman",
    		continent: "Europe",
    		clean_name: "Laverna",
    		description: "Roman darkness and income goddess.",
    		bio: "In Roman mythology, Laverna was a goddess of thieves, cheats and the underworld. She was propitiated by libations poured with the left hand. The poet Horace and the playwright Plautus call her a goddess of thieves.",
    		search_term: "Laverna",
    		diameter: "1,100.0",
    		center_lat: -50,
    		center_long: 132
    	},
    	{
    		feature_id: 3563,
    		year: 1997,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Madderakka Corona",
    		type: "Goddess",
    		origin: "Sámi",
    		continent: "Europe",
    		clean_name: "Madderakka",
    		description: "Sámi goddess of birth.",
    		bio: "Akka is a female spirit in Sami shamanism, and Finnish and Estonian mythology. Her worship is common and took the forms of sacrifice, prayer and various other rituals. Madderakka, the first akka, was mother of the tribe, goddess of women and children, she who gives humans their bodies. Women and girls belong to her, as do boys until they are declared men. Maderakka is popular among modern Sámi feminists.",
    		search_term: "Madderakka",
    		diameter: "220.0",
    		center_lat: 9,
    		center_long: 315.5
    	},
    	{
    		feature_id: 3790,
    		year: 1997,
    		feature: "Fluctus",
    		feature_plural: "Fluctūs",
    		name: "Medb Fluctus",
    		type: "Goddess",
    		origin: "Ireland",
    		continent: "Europe",
    		clean_name: "Medb",
    		description: "Irish mother of gods, wife of Ailil.",
    		bio: "Medb, often anglicised as Maeve, is queen of Connacht in the Ulster Cycle of Irish mythology. Medb is strong-willed, ambitious, cunning and promiscuous, and is an archetypal warrior queen. She is believed by some to be a manifestation of the sovereignty goddess.",
    		search_term: "Medb",
    		diameter: "350.0",
    		center_lat: -56,
    		center_long: 127
    	},
    	{
    		feature_id: 3806,
    		year: 1997,
    		feature: "Tholus",
    		feature_plural: "Tholi",
    		name: "Meiboia Tholus",
    		type: "Goddess",
    		origin: "Greek",
    		continent: "Europe",
    		clean_name: "Meiboia",
    		description: "Greek bee goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "85.0",
    		center_lat: -44.7,
    		center_long: 281.3
    	},
    	{
    		feature_id: 3843,
    		year: 1997,
    		feature: "Tholus",
    		feature_plural: "Tholi",
    		name: "Mentha Tholus",
    		type: "Goddess",
    		origin: "Roman",
    		continent: "Europe",
    		clean_name: "Mentha",
    		description: "Roman goddess, personification of the human mind. Name changed from Mentha Mons.",
    		bio: "",
    		search_term: "",
    		diameter: "79.0",
    		center_lat: 43,
    		center_long: 237.3
    	},
    	{
    		feature_id: 3887,
    		year: 1997,
    		feature: "Mons",
    		feature_plural: "Montes",
    		name: "Mielikki Mons",
    		type: "Goddess",
    		origin: "Finland",
    		continent: "Europe",
    		clean_name: "Mielikki",
    		description: "Finnish forest goddess.",
    		bio: "Mielikki is the Finnish goddess of forests and the hunt. She is referred to in various tales as either the wife or the daughter-in-law of Tapio, and the mother of Nyyrikki and Tuulikki. She is said to have played a central role in the creation of the bear.",
    		search_term: "Mielikki",
    		diameter: "450.0",
    		center_lat: -27.8,
    		center_long: 280.5
    	},
    	{
    		feature_id: 3928,
    		year: 1997,
    		feature: "Chasma",
    		feature_plural: "Chasmata",
    		name: "Mist Chasma",
    		type: "Goddess",
    		origin: "Norse",
    		continent: "Europe",
    		clean_name: "Mist",
    		description: "Norse Valkyrie. Changed from Mist Fossae.",
    		bio: "In Norse mythology, Mist is a valkyrie. Rudolf Simek says that her name, Mist, is likely related to Old Norse mistr, meaning \"cloud, mist,\" and that this \"reminds us of the way in which valkyries can ride through the air and over water,\"",
    		search_term: "Mist (valkyrie)",
    		diameter: "244.0",
    		center_lat: 39.5,
    		center_long: 247.3
    	},
    	{
    		feature_id: 4076,
    		year: 1997,
    		feature: "Tholus",
    		feature_plural: "Tholi",
    		name: "Muru Tholus",
    		type: "Goddess",
    		origin: "Estonia",
    		continent: "Europe",
    		clean_name: "Muru",
    		description: "Estonian deity of meadows.",
    		bio: "",
    		search_term: "",
    		diameter: "40.0",
    		center_lat: -9,
    		center_long: 305.5
    	},
    	{
    		feature_id: 4146,
    		year: 1997,
    		feature: "Vallis",
    		feature_plural: "Valles",
    		name: "Nantosuelta Vallis",
    		type: "Goddess",
    		origin: "Celtic",
    		continent: "Europe",
    		clean_name: "Nantosuelta",
    		description: "Celtic river goddess.",
    		bio: "In Celtic mythology, Nantosuelta is the goddess of nature, the earth, fire and fertility. Pseudo-historical texts explain how there is an uncanny resemblance between Nantosuelta and what we know of the Irish goddess The Morrígan who was associated with death and war. Nantosuelta is often associated with water and depicted as being surrounded by water.",
    		search_term: "Nantosuelta",
    		diameter: "320.0",
    		center_lat: -61.9,
    		center_long: 193
    	},
    	{
    		feature_id: 4216,
    		year: 1997,
    		feature: "Regio",
    		feature_plural: "Regiones",
    		name: "Neringa Regio",
    		type: "Goddess",
    		origin: "Lithuania",
    		continent: "Europe",
    		clean_name: "Neringa",
    		description: "Lithuanian seacoast giantess.",
    		bio: "",
    		search_term: "",
    		diameter: "1,100.0",
    		center_lat: -65,
    		center_long: 288
    	},
    	{
    		feature_id: 4266,
    		year: 1997,
    		feature: "Mons",
    		feature_plural: "Montes",
    		name: "Nijole Mons",
    		type: "Goddess",
    		origin: "Lithuania",
    		continent: "Europe",
    		clean_name: "Nijole",
    		description: "Lithuanian underworld goddess. Spelling changed from Niola Mons.",
    		bio: "",
    		search_term: "",
    		diameter: "150.0",
    		center_lat: 45,
    		center_long: 185
    	},
    	{
    		feature_id: 4337,
    		year: 1997,
    		feature: "Tessera",
    		feature_plural: "Tesserae",
    		name: "Norna Tesserae",
    		type: "Goddess",
    		origin: "Norse",
    		continent: "Europe",
    		clean_name: "Norna",
    		description: "Norse fate goddess; there are three Nornas weaving fate thread.",
    		bio: "The Norns are deities in Norse mythology responsible for shaping the course of human destinies, twining the thread of fate. In the Völuspá, the three primary Norns draw water from their sacred well to nourish the tree at the center of the cosmos and prevent it from rot. Norns are shadowy, background figures who only really ever reveal their fateful secrets to people as their fates come to pass.",
    		search_term: "Norna",
    		diameter: "700.0",
    		center_lat: -50,
    		center_long: 263
    	},
    	{
    		feature_id: 4344,
    		year: 1997,
    		feature: "Tessera",
    		feature_plural: "Tesserae",
    		name: "Nortia Tesserae",
    		type: "Goddess",
    		origin: "Italy",
    		continent: "Europe",
    		clean_name: "Nortia",
    		description: "Etruscan fate goddess.",
    		bio: "Nortia is the Latinized name of the Etruscan goddess Nurtia (variant manuscript readings include Norcia, Norsia, Nercia, and Nyrtia), whose sphere of influence was time, fate, destiny, and chance. Little or no Etruscan evidence for Nortia survives.",
    		search_term: "Nortia",
    		diameter: "650.0",
    		center_lat: -49,
    		center_long: 160
    	},
    	{
    		feature_id: 4346,
    		year: 1997,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Nott Corona",
    		type: "Goddess",
    		origin: "Scandinavian",
    		continent: "Europe",
    		clean_name: "Nott",
    		description: "Scandinavian earth goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "150.0",
    		center_lat: -32.3,
    		center_long: 202
    	},
    	{
    		feature_id: 4375,
    		year: 1997,
    		feature: "Mons",
    		feature_plural: "Montes",
    		name: "Nyx Mons",
    		type: "Goddess",
    		origin: "Greek",
    		continent: "Europe",
    		clean_name: "Nyx",
    		description: "Greek goddess of night.",
    		bio: "Nyx is the Greek goddess and personification of night. A shadowy figure, Nyx stood at or near the beginning of creation and mothered other personified deities, such as Hypnos (Sleep) and Thanatos (Death), with Erebus (Darkness). She is the first child of Chaos.",
    		search_term: "Nyx",
    		diameter: "875.0",
    		center_lat: 30,
    		center_long: 48.5
    	},
    	{
    		feature_id: 4401,
    		year: 1997,
    		feature: "Tessera",
    		feature_plural: "Tesserae",
    		name: "Oddibjord Tessera",
    		type: "Goddess",
    		origin: "Scandinavian",
    		continent: "Europe",
    		clean_name: "Oddibjord",
    		description: "Scandinavian fortune deity.",
    		bio: "",
    		search_term: "",
    		diameter: "900.0",
    		center_lat: 82,
    		center_long: 85
    	},
    	{
    		feature_id: 4648,
    		year: 1997,
    		feature: "Fossa",
    		feature_plural: "Fossae",
    		name: "Penthesilea Fossa",
    		type: "Goddess",
    		origin: "Greek",
    		continent: "Europe",
    		clean_name: "Penthesilea",
    		description: "Greek amazon queen.",
    		bio: "Penthesilea was an Amazonian queen in Greek mythology, the daughter of Ares and Otrera and the sister of Hippolyta, Antiope and Melanippe. She assisted Troy in the Trojan War, during which she was killed by Achilles.",
    		search_term: "Penthesilea",
    		diameter: "1,700.0",
    		center_lat: -12,
    		center_long: 214
    	},
    	{
    		feature_id: 4819,
    		year: 1997,
    		feature: "Fluctus",
    		feature_plural: "Fluctūs",
    		name: "Praurime Fluctus",
    		type: "Goddess",
    		origin: "Lithuania",
    		continent: "Europe",
    		clean_name: "Praurime",
    		description: "Lithuanian fire goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "750.0",
    		center_lat: 16,
    		center_long: 154
    	},
    	{
    		feature_id: 4925,
    		year: 1997,
    		feature: "Dorsum",
    		feature_plural: "Dorsa",
    		name: "Ragana Dorsa",
    		type: "Goddess",
    		origin: "Latvia",
    		continent: "Europe",
    		clean_name: "Ragana",
    		description: "Latvian witch.",
    		bio: "",
    		search_term: "",
    		diameter: "950.0",
    		center_lat: -69,
    		center_long: 246
    	},
    	{
    		feature_id: 4989,
    		year: 1997,
    		feature: "Chasma",
    		feature_plural: "Chasmata",
    		name: "Reitia Chasma",
    		type: "Goddess",
    		origin: "Italy",
    		continent: "Europe",
    		clean_name: "Reitia",
    		description: "Italian (Venetian) healthcare and hunting goddess.",
    		bio: "Reitia is a goddess, one of the best known deities of the Adriatic Veneti of northeastern Italy. In Venetic, she is given the epithets Śahnate, the Healer, and Pora, the good and kind. She was also a deity of writing.",
    		search_term: "Reitia",
    		diameter: "400.0",
    		center_lat: -51.5,
    		center_long: 100
    	},
    	{
    		feature_id: 5172,
    		year: 1997,
    		feature: "Dorsum",
    		feature_plural: "Dorsa",
    		name: "Rokapi Dorsa",
    		type: "Goddess",
    		origin: "Georgia",
    		continent: "Europe",
    		clean_name: "Rokapi",
    		description: "Georgian main witch.",
    		bio: "",
    		search_term: "",
    		diameter: "2,200.0",
    		center_lat: -55,
    		center_long: 222
    	},
    	{
    		feature_id: 5209,
    		year: 1997,
    		feature: "Collis",
    		feature_plural: "Colles",
    		name: "Ruad Colles",
    		type: "Goddess",
    		origin: "Ireland",
    		continent: "Europe",
    		clean_name: "Ruad",
    		description: "Irish female deity, sank into the sea sleeping in her bronze boat.",
    		bio: "",
    		search_term: "",
    		diameter: "400.0",
    		center_lat: -68,
    		center_long: 118
    	},
    	{
    		feature_id: 5287,
    		year: 1997,
    		feature: "Tessera",
    		feature_plural: "Tesserae",
    		name: "Salus Tessera",
    		type: "Goddess",
    		origin: "Roman",
    		continent: "Europe",
    		clean_name: "Salus",
    		description: "Roman health and prosperity goddess.",
    		bio: "Salus was the Roman goddess of safety and well-being (welfare, health and prosperity) of both the individual and the state. She is sometimes equated with the Greek goddess Hygieia, though their functions differ considerably. Salus is one of the oldest Roman goddesses.",
    		search_term: "Salus",
    		diameter: "850.0",
    		center_lat: -1.5,
    		center_long: 48.5
    	},
    	{
    		feature_id: 5295,
    		year: 1997,
    		feature: "Mons",
    		feature_plural: "Montes",
    		name: "Samodiva Mons",
    		type: "Goddess",
    		origin: "Bulgaria",
    		continent: "Europe",
    		clean_name: "Samodiva",
    		description: "Bulgarian winged water deity.",
    		bio: "",
    		search_term: "",
    		diameter: "200.0",
    		center_lat: 13.6,
    		center_long: 291
    	},
    	{
    		feature_id: 5309,
    		year: 1997,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Santa Corona",
    		type: "Goddess",
    		origin: "Italy",
    		continent: "Europe",
    		clean_name: "Santa",
    		description: "Sabine goddess of fertility and health.",
    		bio: "",
    		search_term: "",
    		diameter: "200.0",
    		center_lat: -34.5,
    		center_long: 288
    	},
    	{
    		feature_id: 5341,
    		year: 1997,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Saunau Corona",
    		type: "Goddess",
    		origin: "Georgia",
    		continent: "Europe",
    		clean_name: "Saunau",
    		description: "Abkhazian goddess of corn milling.",
    		bio: "",
    		search_term: "",
    		diameter: "200.0",
    		center_lat: -1.3,
    		center_long: 173
    	},
    	{
    		feature_id: 5428,
    		year: 1997,
    		feature: "Tessera",
    		feature_plural: "Tesserae",
    		name: "Senectus Tesserae",
    		type: "Goddess",
    		origin: "Roman",
    		continent: "Europe",
    		clean_name: "Senectus",
    		description: "Roman goddess of old age.",
    		bio: "",
    		search_term: "",
    		diameter: "1,400.0",
    		center_lat: 50,
    		center_long: 292
    	},
    	{
    		feature_id: 5536,
    		year: 1997,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Silvia Corona",
    		type: "Goddess",
    		origin: "Roman",
    		continent: "Europe",
    		clean_name: "Silvia",
    		description: "Roman earth goddess.",
    		bio: "In Roman mythology, Silvia is the goddess of the forest.",
    		search_term: "Silvia",
    		diameter: "270.0",
    		center_lat: 12.6,
    		center_long: 355.7
    	},
    	{
    		feature_id: 5576,
    		year: 1997,
    		feature: "Dorsum",
    		feature_plural: "Dorsa",
    		name: "Sirona Dorsa",
    		type: "Goddess",
    		origin: "Celtic",
    		continent: "Europe",
    		clean_name: "Sirona",
    		description: "Celtic sky goddess.",
    		bio: "In Celtic polytheism, Sirona was a goddess worshipped predominantly in East Central Gaul and along the Danubian limes. A healing deity, she was associated with healing springs; her attributes were snakes and eggs.",
    		search_term: "Sirona",
    		diameter: "700.0",
    		center_lat: -43.5,
    		center_long: 193.5
    	},
    	{
    		feature_id: 5612,
    		year: 1997,
    		feature: "Tessera",
    		feature_plural: "Tesserae",
    		name: "Snotra Tesserae",
    		type: "Goddess",
    		origin: "Scandinavian",
    		continent: "Europe",
    		clean_name: "Snotra",
    		description: "Scandinavian goddess of wisdom.",
    		bio: "In Norse mythology, Snotra is a goddess associated with wisdom, described as \"wise and courteous\".",
    		search_term: "Snotra",
    		diameter: "1,000.0",
    		center_lat: 24,
    		center_long: 134
    	},
    	{
    		feature_id: 5667,
    		year: 1997,
    		feature: "Dorsum",
    		feature_plural: "Dorsa",
    		name: "Spidola Dorsa",
    		type: "Goddess",
    		origin: "Latvia",
    		continent: "Europe",
    		clean_name: "Spidola",
    		description: "Latvian witch.",
    		bio: "",
    		search_term: "",
    		diameter: "950.0",
    		center_lat: -73.5,
    		center_long: 325
    	},
    	{
    		feature_id: 5725,
    		year: 1997,
    		feature: "Fluctus",
    		feature_plural: "Fluctūs",
    		name: "Strenia Fluctus",
    		type: "Goddess",
    		origin: "Roman",
    		continent: "Europe",
    		clean_name: "Strenia",
    		description: "Roman goddess of New Year festivities.",
    		bio: "In ancient Roman religion, Strenua or Strenia was a goddess of the new year, purification, and wellbeing. She had a shrine (sacellum) and grove (lucus) at the top of the Via Sacra.",
    		search_term: "Strenia",
    		diameter: "490.0",
    		center_lat: 41,
    		center_long: 250
    	},
    	{
    		feature_id: 5744,
    		year: 1997,
    		feature: "Tessera",
    		feature_plural: "Tesserae",
    		name: "Sudice Tessera",
    		type: "Goddess",
    		origin: "Czechoslovakia",
    		continent: "Europe",
    		clean_name: "Sudice",
    		description: "Czech goddess of fate.",
    		bio: "",
    		search_term: "",
    		diameter: "500.0",
    		center_lat: -37,
    		center_long: 112
    	},
    	{
    		feature_id: 5764,
    		year: 1997,
    		feature: "Dorsum",
    		feature_plural: "Dorsa",
    		name: "Sunna Dorsa",
    		type: "Goddess",
    		origin: "Norse",
    		continent: "Europe",
    		clean_name: "Sunna",
    		description: "Norse sun goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "500.0",
    		center_lat: -53,
    		center_long: 134
    	},
    	{
    		feature_id: 5908,
    		year: 1997,
    		feature: "Chasma",
    		feature_plural: "Chasmata",
    		name: "Tellervo Chasma",
    		type: "Goddess",
    		origin: "Finland",
    		continent: "Europe",
    		clean_name: "Tellervo",
    		description: "Finnish maiden of woods.",
    		bio: "Tellervo is the Finnish goddess of forests. She was the daughter of Tapio, an East Finnish forest spirit.",
    		search_term: "Tellervo",
    		diameter: "600.0",
    		center_lat: -60,
    		center_long: 125
    	},
    	{
    		feature_id: 6040,
    		year: 1997,
    		feature: "Chasma",
    		feature_plural: "Chasmata",
    		name: "Tkashi-mapa Chasma",
    		type: "Goddess",
    		origin: "Georgia",
    		continent: "Europe",
    		clean_name: "Tkashi-mapa",
    		description: "Georgian forest goddess.",
    		bio: "Dali (equivalent to Tkashi-mapa) is a goddess from the mythology of the Georgian people of the Caucasus region. She is a hunting goddess who serves as the patron of hoofed wild mountain animals such as ibexes and deer. Hunters who obeyed her numerous taboos would be assured of success in the hunt; conversely, she would harshly punish any who violated them.",
    		search_term: "Tkashi-mapa",
    		diameter: "1,100.0",
    		center_lat: 13,
    		center_long: 206
    	},
    	{
    		feature_id: 6109,
    		year: 1997,
    		feature: "Dorsum",
    		feature_plural: "Dorsa",
    		name: "Tsovinar Dorsa",
    		type: "Goddess",
    		origin: "Armenia",
    		continent: "Europe",
    		clean_name: "Tsovinar",
    		description: "Armenian lightning deity.",
    		bio: "",
    		search_term: "",
    		diameter: "1,100.0",
    		center_lat: -46,
    		center_long: 254
    	},
    	{
    		feature_id: 6141,
    		year: 1997,
    		feature: "Fluctus",
    		feature_plural: "Fluctūs",
    		name: "Turgmam Fluctus",
    		type: "Goddess",
    		origin: "Russia",
    		continent: "Europe",
    		clean_name: "Turgmam",
    		description: "Nivkhi (Sakhalin Isl.) fire mistress.",
    		bio: "",
    		search_term: "",
    		diameter: "500.0",
    		center_lat: 56,
    		center_long: 220
    	},
    	{
    		feature_id: 6147,
    		year: 1997,
    		feature: "Tholus",
    		feature_plural: "Tholi",
    		name: "Tursa Tholus",
    		type: "Goddess",
    		origin: "Italy",
    		continent: "Europe",
    		clean_name: "Tursa",
    		description: "Italian goddess of terror.",
    		bio: "",
    		search_term: "",
    		diameter: "75.0",
    		center_lat: -35.4,
    		center_long: 205.2
    	},
    	{
    		feature_id: 6155,
    		year: 1997,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Tutelina Corona",
    		type: "Goddess",
    		origin: "Roman",
    		continent: "Europe",
    		clean_name: "Tutelina",
    		description: "Roman harvest goddess.",
    		bio: "In Roman religion, Tutelina was an agricultural goddess who was responsible for protecting crops brought in during harvest time. Tutelina and two other harvesting goddesses, Messia and Secia, had three pillars with altars before them in the Circus Maximus.",
    		search_term: "Tutelina (mythology)",
    		diameter: "180.0",
    		center_lat: 29,
    		center_long: 348
    	},
    	{
    		feature_id: 6162,
    		year: 1997,
    		feature: "Tessera",
    		feature_plural: "Tesserae",
    		name: "Tyche Tessera",
    		type: "Goddess",
    		origin: "Greek",
    		continent: "Europe",
    		clean_name: "Tyche",
    		description: "Greek goddess of fate.",
    		bio: "Tyche was the presiding tutelary deity who governed the fortune and prosperity of a city, its destiny. During the Hellenistic period, with dramatic socio-political changes starting with Alexander the Great, Tyche increasingly embodied the whims of fate (both negative and positive), eclipsing the role of the Olympic gods.",
    		search_term: "Tyche",
    		diameter: "575.0",
    		center_lat: -44,
    		center_long: 14.5
    	},
    	{
    		feature_id: 6240,
    		year: 1997,
    		feature: "Tessera",
    		feature_plural: "Tesserae",
    		name: "Urd Tessera",
    		type: "Goddess",
    		origin: "Norse",
    		continent: "Europe",
    		clean_name: "Urd",
    		description: "Norse fate goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "250.0",
    		center_lat: -40,
    		center_long: 174.5
    	},
    	{
    		feature_id: 6244,
    		year: 1997,
    		feature: "Dorsum",
    		feature_plural: "Dorsa",
    		name: "Urkuk Dorsa",
    		type: "Goddess",
    		origin: "Russia",
    		continent: "Europe",
    		clean_name: "Urkuk",
    		description: "Nivkhi (Sakhalin Isl.) night maiden.",
    		bio: "",
    		search_term: "",
    		diameter: "600.0",
    		center_lat: -12,
    		center_long: 320
    	},
    	{
    		feature_id: 6251,
    		year: 1997,
    		feature: "Tessera",
    		feature_plural: "Tesserae",
    		name: "Ustrecha Tesserae",
    		type: "Goddess",
    		origin: "Russia",
    		continent: "Europe",
    		clean_name: "Ustrecha",
    		description: "Old Russian goddess of chance.",
    		bio: "",
    		search_term: "",
    		diameter: "450.0",
    		center_lat: -43,
    		center_long: 265
    	},
    	{
    		feature_id: 6271,
    		year: 1997,
    		feature: "Rupes",
    		feature_plural: "Rupēs",
    		name: "Vaidilute Rupes",
    		type: "Goddess",
    		origin: "Lithuania",
    		continent: "Europe",
    		clean_name: "Vaidilute",
    		description: "Lithuanian hearth goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "2,000.0",
    		center_lat: -43.5,
    		center_long: 22
    	},
    	{
    		feature_id: 6321,
    		year: 1997,
    		feature: "Mons",
    		feature_plural: "Montes",
    		name: "Var Mons",
    		type: "Goddess",
    		origin: "Scandinavian",
    		continent: "Europe",
    		clean_name: "Var",
    		description: "Scandinavian love goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "1,000.0",
    		center_lat: 1.2,
    		center_long: 316.2
    	},
    	{
    		feature_id: 6330,
    		year: 1997,
    		feature: "Regio",
    		feature_plural: "Regiones",
    		name: "Vasilisa Regio",
    		type: "Goddess",
    		origin: "Russia",
    		continent: "Europe",
    		clean_name: "Vasilisa",
    		description: "Russian tale heroine.",
    		bio: "",
    		search_term: "",
    		diameter: "1,200.0",
    		center_lat: -11,
    		center_long: 332
    	},
    	{
    		feature_id: 6338,
    		year: 1997,
    		feature: "Vallis",
    		feature_plural: "Valles",
    		name: "Veden-Ema Vallis",
    		type: "Goddess",
    		origin: "Finland",
    		continent: "Europe",
    		clean_name: "Veden-Ema",
    		description: "Finnish goddess of fishing.",
    		bio: "",
    		search_term: "",
    		diameter: "300.0",
    		center_lat: -15,
    		center_long: 141
    	},
    	{
    		feature_id: 6342,
    		year: 1997,
    		feature: "Dorsum",
    		feature_plural: "Dorsa",
    		name: "Vejas-mate Dorsa",
    		type: "Goddess",
    		origin: "Latvia",
    		continent: "Europe",
    		clean_name: "Vejas-mate",
    		description: "Latvian “wind mother“.",
    		bio: "",
    		search_term: "",
    		diameter: "1,600.0",
    		center_lat: -70.5,
    		center_long: 245
    	},
    	{
    		feature_id: 6361,
    		year: 1997,
    		feature: "Tessera",
    		feature_plural: "Tesserae",
    		name: "Verpeja Tesserae",
    		type: "Goddess",
    		origin: "Lithuania",
    		continent: "Europe",
    		clean_name: "Verpeja",
    		description: "Lithuanian life thread goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "600.0",
    		center_lat: -58,
    		center_long: 160
    	},
    	{
    		feature_id: 6371,
    		year: 1997,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Vesuna Corona",
    		type: "Goddess",
    		origin: "Italy",
    		continent: "Europe",
    		clean_name: "Vesuna",
    		description: "Italian (Umbrian) vegetation goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "200.0",
    		center_lat: -65.5,
    		center_long: 275
    	},
    	{
    		feature_id: 6407,
    		year: 1997,
    		feature: "Linea",
    		feature_plural: "Lineae",
    		name: "Virtus Linea",
    		type: "Goddess",
    		origin: "Roman",
    		continent: "Europe",
    		clean_name: "Virtus",
    		description: "Roman war goddess.",
    		bio: "Virtus was the god or goddess of military strength, personification of the Roman virtue of the same name. Virtus represents valor, manliness, excellence, courage, character, and worth, perceived as masculine strengths.",
    		search_term: "Virtus",
    		diameter: "500.0",
    		center_lat: 12,
    		center_long: 21
    	},
    	{
    		feature_id: 6451,
    		year: 1997,
    		feature: "Mons",
    		feature_plural: "Montes",
    		name: "Vostrukha Mons",
    		type: "Goddess",
    		origin: "Belarus",
    		continent: "Europe",
    		clean_name: "Vostrukha",
    		description: "Belorussian deity of home.",
    		bio: "",
    		search_term: "",
    		diameter: "180.0",
    		center_lat: -6.3,
    		center_long: 299.4
    	},
    	{
    		feature_id: 6716,
    		year: 1997,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Zemlika Corona",
    		type: "Goddess",
    		origin: "Latvia",
    		continent: "Europe",
    		clean_name: "Zemlika",
    		description: "Latvian earth goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "150.0",
    		center_lat: -33.5,
    		center_long: 50
    	},
    	{
    		feature_id: 6744,
    		year: 1997,
    		feature: "Tessera",
    		feature_plural: "Tesserae",
    		name: "Zirka Tessera",
    		type: "Goddess",
    		origin: "Belarus",
    		continent: "Europe",
    		clean_name: "Zirka",
    		description: "Belorussian happiness goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "450.0",
    		center_lat: 33,
    		center_long: 300
    	},
    	{
    		feature_id: 6947,
    		year: 1997,
    		feature: "Chasma",
    		feature_plural: "Chasmata",
    		name: "Žverine Chasma",
    		type: "Goddess",
    		origin: "Lithuania",
    		continent: "Europe",
    		clean_name: "Žverine",
    		description: "Lithuanian hunting goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "1,300.0",
    		center_lat: 18.5,
    		center_long: 271
    	},
    	{
    		feature_id: 6771,
    		year: 1997,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Zywie Corona",
    		type: "Goddess",
    		origin: "Poland",
    		continent: "Europe",
    		clean_name: "Zywie",
    		description: "Polish goddess of life.",
    		bio: "Zywie is a fertility and love goddess in Slavic mythology. She is a mother goddess of one of the tribes belonging to the Obodritic confederation of the Polabian Slavs.",
    		search_term: "Zywie",
    		diameter: "200.0",
    		center_lat: -38.6,
    		center_long: 291.2
    	},
    	{
    		feature_id: 130,
    		year: 1997,
    		feature: "Planitia",
    		feature_plural: "Planitiae",
    		name: "Akhtamar Planitia",
    		type: "Heroine",
    		origin: "Armenia",
    		continent: "Europe",
    		clean_name: "Akhtamar ",
    		description: "Armenian epic heroine.",
    		bio: "Akdamar Island in Turkey is named after this heroine. According to legend, Tamara, an Armenian princess, lived on the island and was in love with a commoner. This boy would swim from the shore to the island each night, guided by a light she lit for him. Her father learned of the boy's visits. One night, as she waited for her lover to arrive, her father smashed her light, leaving the boy in the middle of the lake without a guide to indicate which direction to swim. He drowned and his body washed ashore and, as the legend concludes, it appeared as if the words \"Akh, Tamara\" (Oh, Tamara) were frozen on his lips.",
    		search_term: "Akdamar Island",
    		diameter: "2,700.0",
    		center_lat: 27,
    		center_long: 65
    	},
    	{
    		feature_id: 433,
    		year: 1997,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Aspasia Corona",
    		type: "Heroine",
    		origin: "Greek",
    		continent: "Europe",
    		clean_name: "Aspasia",
    		description: "One of most outstanding women of ancient Greece (c. 470-429 B.C.).",
    		bio: "Aspasia was an important figure – and the most important woman – in the history of fifth-century Athens. She was portrayed in Old Comedy as a prostitute and madam, and in ancient philosophy as a teacher and rhetorician. From the twentieth century, she has been portrayed as both a sexualised and sexually liberated woman, and as a feminist role model fighting for women's rights in ancient Athens.",
    		search_term: "Aspasia",
    		diameter: "200.0",
    		center_lat: 56.1,
    		center_long: 189.1
    	},
    	{
    		feature_id: 2283,
    		year: 1997,
    		feature: "Planitia",
    		feature_plural: "Planitiae",
    		name: "Gunda Planitia",
    		type: "Heroine",
    		origin: "Georgia",
    		continent: "Europe",
    		clean_name: "Gunda ",
    		description: "Abkhazian epic heroine, beautiful sister of the giant knights.",
    		bio: "",
    		search_term: "",
    		diameter: "1,200.0",
    		center_lat: -16,
    		center_long: 267
    	},
    	{
    		feature_id: 3239,
    		year: 1997,
    		feature: "Planitia",
    		feature_plural: "Planitiae",
    		name: "Laimdota Planitia",
    		type: "Heroine",
    		origin: "Latvia",
    		continent: "Europe",
    		clean_name: "Laimdota ",
    		description: "Latvian myth heroine.",
    		bio: "Laimdota is the wife of Lāčplēsis (\"The Bear-Slayer\"), from the eponymous epic poem by Andrejs Pumpurs, a Latvian poet, who wrote it between 1872 and 1887 based on local legends.",
    		search_term: "Lāčplēsis",
    		diameter: "1,800.0",
    		center_lat: -58,
    		center_long: 117
    	},
    	{
    		feature_id: 3388,
    		year: 1997,
    		feature: "Planitia",
    		feature_plural: "Planitiae",
    		name: "Libuše Planitia",
    		type: "Heroine",
    		origin: "Czechoslovakia",
    		continent: "Europe",
    		clean_name: "Libuše ",
    		description: "Czech tales heroine, wiser of three sisters.",
    		bio: "Libuše is a legendary ancestor of the Czech people. Legend says she came out on a rocky cliff high above the Vltava and prophesied: \"I see a great city whose glory will touch the stars.\" On the site she ordered to build a castle and a town called Prague. Although she proved herself as a wise chieftain, the male part of the tribe was displeased that their ruler was a woman and demanded that she marry, but she had fallen in love with a ploughman, Přemysl.",
    		search_term: "Libuše",
    		diameter: "1,200.0",
    		center_lat: 60,
    		center_long: 290
    	},
    	{
    		feature_id: 6007,
    		year: 1997,
    		feature: "Planitia",
    		feature_plural: "Planitiae",
    		name: "Tilli-Hanum Planitia",
    		type: "Heroine",
    		origin: "Azerbaijan",
    		continent: "Europe",
    		clean_name: "Tilli-Hanum ",
    		description: "Azeri “Ker-ogly“ epic tale heroine.",
    		bio: "",
    		search_term: "",
    		diameter: "2,300.0",
    		center_lat: 54,
    		center_long: 120
    	},
    	{
    		feature_id: 6223,
    		year: 1997,
    		feature: "Planitia",
    		feature_plural: "Planitiae",
    		name: "Undine Planitia",
    		type: "Heroine",
    		origin: "Lithuania",
    		continent: "Europe",
    		clean_name: "Undine ",
    		description: "Lithuanian water nymph, mermaid.",
    		bio: "Undines are a category of elemental beings associated with water, and almost invariably depicted as being female. They are usually found in forest pools and waterfalls, and their beautiful singing voices are sometimes heard over the sound of water. What undines lack, compared to humans, is a soul. Marriage with a human shortens their lives on Earth, but earns them an immortal human soul.",
    		search_term: "Undine",
    		diameter: "2,800.0",
    		center_lat: 13,
    		center_long: 303
    	},
    	{
    		feature_id: 3522,
    		year: 1997,
    		feature: "Vallis",
    		feature_plural: "Valles",
    		name: "Lusaber Vallis",
    		type: "Other",
    		origin: "Armenia",
    		continent: "Europe",
    		clean_name: "Lusaber ",
    		description: "Armenian name for planet Venus.",
    		bio: "",
    		search_term: "",
    		diameter: "500.0",
    		center_lat: -47.5,
    		center_long: 164
    	},
    	{
    		feature_id: 3073,
    		year: 1997,
    		feature: "Vallis",
    		feature_plural: "Valles",
    		name: "Koidutäht Vallis",
    		type: "Other",
    		origin: "Estonia",
    		continent: "Europe",
    		clean_name: "Koidutäht ",
    		description: "Estonian name for planet Venus.",
    		bio: "",
    		search_term: "",
    		diameter: "700.0",
    		center_lat: -76.5,
    		center_long: 130
    	},
    	{
    		feature_id: 492,
    		year: 1997,
    		feature: "Vallis",
    		feature_plural: "Valles",
    		name: "Austrina Vallis",
    		type: "Other",
    		origin: "Latvia",
    		continent: "Europe",
    		clean_name: "Austrina ",
    		description: "Latvian name for planet Venus.",
    		bio: "",
    		search_term: "",
    		diameter: "600.0",
    		center_lat: -49.5,
    		center_long: 177
    	},
    	{
    		feature_id: 6262,
    		year: 1997,
    		feature: "Vallis",
    		feature_plural: "Valles",
    		name: "Utrenitsa Vallis",
    		type: "Other",
    		origin: "Russia",
    		continent: "Europe",
    		clean_name: "Utrenitsa ",
    		description: "Old Russian name for planet Venus.",
    		bio: "",
    		search_term: "",
    		diameter: "700.0",
    		center_lat: 55,
    		center_long: 280
    	},
    	{
    		feature_id: 2871,
    		year: 1997,
    		feature: "Vallis",
    		feature_plural: "Valles",
    		name: "Jutrzenka Vallis",
    		type: "Other",
    		origin: "Poland",
    		continent: "Europe",
    		clean_name: "Jutrzenka ",
    		description: "Polish name for planet Venus.",
    		bio: "",
    		search_term: "",
    		diameter: "970.0",
    		center_lat: 27,
    		center_long: 155.8
    	},
    	{
    		feature_id: 4801,
    		year: 1997,
    		feature: "Vallis",
    		feature_plural: "Valles",
    		name: "Poranica Valles",
    		type: "Other",
    		origin: "Slovenia",
    		continent: "Europe",
    		clean_name: "Poranica ",
    		description: "Slovenian name for planet Venus. Name changed from Poranica Vallis.",
    		bio: "",
    		search_term: "",
    		diameter: "550.0",
    		center_lat: -21,
    		center_long: 178.5
    	},
    	{
    		feature_id: 2829,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Jitka",
    		type: "First Name",
    		origin: "Slavic",
    		continent: "Multiple",
    		clean_name: "Jitka",
    		description: "Slovakian first name.",
    		bio: "",
    		search_term: "",
    		diameter: "13.0",
    		center_lat: -61.9,
    		center_long: 70.9
    	},
    	{
    		feature_id: 4103,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Nadia",
    		type: "First Name",
    		origin: "Slavic",
    		continent: "Multiple",
    		clean_name: "Nadia",
    		description: "Russian first name.",
    		bio: "",
    		search_term: "",
    		diameter: "11.3",
    		center_lat: -27.9,
    		center_long: 0.6
    	},
    	{
    		feature_id: 190,
    		year: 1997,
    		feature: "Dorsum",
    		feature_plural: "Dorsa",
    		name: "Alkonost Dorsa",
    		type: "Goddess",
    		origin: "Slavic",
    		continent: "Multiple",
    		clean_name: "Alkonost",
    		description: "E. Slavic wonder bird with woman's face, lives in Paradise.",
    		bio: "The Alkonost is a legendary woman-headed bird in Slavic folklore. Alkonost makes amazingly beautiful sounds, and those who hear these sounds forget everything they know and want nothing more ever again. She lives in the underworld with her counterpart, the Sirin. When her eggs hatch in the sea, a thunderstorm sets in and the sea becomes so rough that it becomes impossible to traverse.",
    		search_term: "Alkonost",
    		diameter: "730.0",
    		center_lat: -5,
    		center_long: 341
    	},
    	{
    		feature_id: 427,
    		year: 1997,
    		feature: "Dorsum",
    		feature_plural: "Dorsa",
    		name: "Asiaq Dorsa",
    		type: "Goddess",
    		origin: "Inuit/Yupik",
    		continent: "Multiple",
    		clean_name: "Asiaq",
    		description: "Eskimo weather goddess.",
    		bio: "In Inuit mythology, Asiaq is a weather goddess (or, more rarely a god) and was quite frequently invoked by the angakoq for good weather, for instance if spring was late it was important to content her and make sure she would send rain and melt the ice. In Greenland, she is the mother of weather, who decides the quantity and the time for snow to fall.",
    		search_term: "Asiaq",
    		diameter: "400.0",
    		center_lat: -53,
    		center_long: 55
    	},
    	{
    		feature_id: 804,
    		year: 1997,
    		feature: "Fluctus",
    		feature_plural: "Fluctūs",
    		name: "Bolotnitsa Fluctus",
    		type: "Goddess",
    		origin: "Slavic",
    		continent: "Multiple",
    		clean_name: "Bolotnitsa",
    		description: "E. Slavic swamp mermaid.",
    		bio: "",
    		search_term: "",
    		diameter: "1,100.0",
    		center_lat: 50,
    		center_long: 160
    	},
    	{
    		feature_id: 1530,
    		year: 1997,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Didilia Corona",
    		type: "Goddess",
    		origin: "Slavic",
    		continent: "Multiple",
    		clean_name: "Didilia",
    		description: "E. Slavic childbirth goddess.",
    		bio: "Didilia is an alleged Polish goddess, first recognized as the Polish equivalent of the Roman goddess Venus, goddess of marriage. Nowadays, the authenticity of the goddess is rejected by most researchers, and it is believed that the theonym was created by recognizing a fragment of folk songs as a proper name.",
    		search_term: "Didilia",
    		diameter: "320.0",
    		center_lat: 19,
    		center_long: 38
    	},
    	{
    		feature_id: 1568,
    		year: 1997,
    		feature: "Tessera",
    		feature_plural: "Tesserae",
    		name: "Dolya Tessera",
    		type: "Goddess",
    		origin: "Slavic",
    		continent: "Multiple",
    		clean_name: "Dolya",
    		description: "E. Slavic good fate goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "1,100.0",
    		center_lat: -8,
    		center_long: 296
    	},
    	{
    		feature_id: 2590,
    		year: 1997,
    		feature: "Tessera",
    		feature_plural: "Tesserae",
    		name: "Husbishag Tesserae",
    		type: "Goddess",
    		origin: "Semitic",
    		continent: "Multiple",
    		clean_name: "Husbishag",
    		description: "Semitic underworld goddess, kept hour of death records.",
    		bio: "",
    		search_term: "",
    		diameter: "1,100.0",
    		center_lat: -28,
    		center_long: 101
    	},
    	{
    		feature_id: 2882,
    		year: 1997,
    		feature: "Dorsum",
    		feature_plural: "Dorsa",
    		name: "Kadlu Dorsa",
    		type: "Goddess",
    		origin: "Inuit/Yupik",
    		continent: "Multiple",
    		clean_name: "Kadlu",
    		description: "Eskimo thunder deity.",
    		bio: "In Inuit mythology, Kadlu refers to one of the trinity of sisters, the 3 goddesses creating thundery weather. She creates thunder by jumping on hollow ice. Her sister Kweetoo creates lightning by rubbing stones against each other. The third sister, Ignirtoq, who makes lightning by striking two stones together and urinates with profusion which makes rain. The story tells that Kadlu was such a noisy child that her parents command her to play outside. There she invented the described \"stormy game\" with her sisters.",
    		search_term: "Kadlu",
    		diameter: "500.0",
    		center_lat: -69.5,
    		center_long: 188
    	},
    	{
    		feature_id: 3125,
    		year: 1997,
    		feature: "Tessera",
    		feature_plural: "Tesserae",
    		name: "Kruchina Tesserae",
    		type: "Goddess",
    		origin: "Slavic",
    		continent: "Multiple",
    		clean_name: "Kruchina",
    		description: "E. Slavic goddess of sadness.",
    		bio: "",
    		search_term: "",
    		diameter: "1,000.0",
    		center_lat: 36,
    		center_long: 27
    	},
    	{
    		feature_id: 3400,
    		year: 1997,
    		feature: "Tessera",
    		feature_plural: "Tesserae",
    		name: "Likho Tesserae",
    		type: "Goddess",
    		origin: "Slavic",
    		continent: "Multiple",
    		clean_name: "Likho",
    		description: "E. Slavic deity of bad fate.",
    		bio: "Likho is an embodiment of evil fate and misfortune in Slavic mythology, a creature with one eye, often depicted as an old, skinny woman in black  or as an evil male goblin of forests. In Ukrainian folklore, it is sometimes portrayed as type of a bad spirit that can cling to one's neck.",
    		search_term: "Likho",
    		diameter: "1,200.0",
    		center_lat: 40,
    		center_long: 134
    	},
    	{
    		feature_id: 3586,
    		year: 1997,
    		feature: "Fossa",
    		feature_plural: "Fossae",
    		name: "Magura Fossae",
    		type: "Goddess",
    		origin: "Slavic",
    		continent: "Multiple",
    		clean_name: "Magura",
    		description: "E. Slavic winged warrior maiden.",
    		bio: "",
    		search_term: "",
    		diameter: "600.0",
    		center_lat: -12,
    		center_long: 332.5
    	},
    	{
    		feature_id: 3623,
    		year: 1997,
    		feature: "Tessera",
    		feature_plural: "Tesserae",
    		name: "Manatum Tessera",
    		type: "Goddess",
    		origin: "Semitic",
    		continent: "Multiple",
    		clean_name: "Manatum",
    		description: "Semitic goddess of fate.",
    		bio: "",
    		search_term: "",
    		diameter: "3,800.0",
    		center_lat: -4,
    		center_long: 64
    	},
    	{
    		feature_id: 3734,
    		year: 1997,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Marzyana Corona",
    		type: "Goddess",
    		origin: "Slavic",
    		continent: "Multiple",
    		clean_name: "Marzyana",
    		description: "West Slavic grain and fertility goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "550.0",
    		center_lat: -53,
    		center_long: 67.5
    	},
    	{
    		feature_id: 3871,
    		year: 1997,
    		feature: "Dorsum",
    		feature_plural: "Dorsa",
    		name: "Metelitsa Dorsa",
    		type: "Goddess",
    		origin: "Slavic",
    		continent: "Multiple",
    		clean_name: "Metelitsa",
    		description: "E. Slavic snowstorm deity.",
    		bio: "Metelitsa is a popular folk dance from Ukraine, Russia, and Belarus. This dance abounds in swift changes of choreographed figures of a spinning nature, symbolizing a snowstorm. The dance still retains its Khorovod character, the ancient form of group dancing and choral singing with the many figures in a circle form.",
    		search_term: "Metelitsa",
    		diameter: "1,300.0",
    		center_lat: 16,
    		center_long: 31
    	},
    	{
    		feature_id: 4187,
    		year: 1997,
    		feature: "Tessera",
    		feature_plural: "Tesserae",
    		name: "Nedolya Tesserae",
    		type: "Goddess",
    		origin: "Slavic",
    		continent: "Multiple",
    		clean_name: "Nedolya",
    		description: "E. Slavic bad fate goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "1,200.0",
    		center_lat: 5,
    		center_long: 294
    	},
    	{
    		feature_id: 4210,
    		year: 1997,
    		feature: "Vallis",
    		feature_plural: "Valles",
    		name: "Nepra Vallis",
    		type: "Goddess",
    		origin: "Slavic",
    		continent: "Multiple",
    		clean_name: "Nepra",
    		description: "E. Slavic goddess of Dneper River.",
    		bio: "",
    		search_term: "",
    		diameter: "350.0",
    		center_lat: 1.4,
    		center_long: 24.2
    	},
    	{
    		feature_id: 4352,
    		year: 1997,
    		feature: "Collis",
    		feature_plural: "Colles",
    		name: "Nuliayoq Colles",
    		type: "Goddess",
    		origin: "Inuit/Yupik",
    		continent: "Multiple",
    		clean_name: "Nuliayoq",
    		description: "Netsilik Inuit (Hudson Bay Eskimo) sea mistress; similar to Sedna.",
    		bio: "",
    		search_term: "",
    		diameter: "350.0",
    		center_lat: 48,
    		center_long: 224
    	},
    	{
    		feature_id: 4389,
    		year: 1997,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Obilukha Corona",
    		type: "Goddess",
    		origin: "Slavic",
    		continent: "Multiple",
    		clean_name: "Obilukha",
    		description: "E. Slavic crop protection deity.",
    		bio: "",
    		search_term: "",
    		diameter: "220.0",
    		center_lat: -81.5,
    		center_long: 19
    	},
    	{
    		feature_id: 4462,
    		year: 1997,
    		feature: "Vallis",
    		feature_plural: "Valles",
    		name: "Omutnitsa Vallis",
    		type: "Goddess",
    		origin: "Slavic",
    		continent: "Multiple",
    		clean_name: "Omutnitsa",
    		description: "E. Slavic river deity.",
    		bio: "",
    		search_term: "",
    		diameter: "150.0",
    		center_lat: 33,
    		center_long: 292
    	},
    	{
    		feature_id: 4665,
    		year: 1997,
    		feature: "Fossa",
    		feature_plural: "Fossae",
    		name: "Perunitsa Fossae",
    		type: "Goddess",
    		origin: "Slavic",
    		continent: "Multiple",
    		clean_name: "Perunitsa",
    		description: "E. Slavic winged warrior maiden.",
    		bio: "",
    		search_term: "",
    		diameter: "1,300.0",
    		center_lat: -10,
    		center_long: 307
    	},
    	{
    		feature_id: 4733,
    		year: 1997,
    		feature: "Chasma",
    		feature_plural: "Chasmata",
    		name: "Pinga Chasma",
    		type: "Goddess",
    		origin: "Inuit/Yupik",
    		continent: "Multiple",
    		clean_name: "Pinga",
    		description: "Eskimo goddess of hunt; moon god Igaluk is subordinate to her.",
    		bio: "In Inuit religion, Pinga (\"the one who is [up on] high\") is a goddess of the hunt and medicine. She is heavily associated with the sky. In Caribou Inuit communities, Pinga had some authority over caribou herds.",
    		search_term: "Pinga",
    		diameter: "500.0",
    		center_lat: -20,
    		center_long: 287
    	},
    	{
    		feature_id: 4771,
    		year: 1997,
    		feature: "Tholus",
    		feature_plural: "Tholi",
    		name: "Podaga Tholus",
    		type: "Goddess",
    		origin: "Slavic",
    		continent: "Multiple",
    		clean_name: "Podaga",
    		description: "Slavic weather goddess.",
    		bio: "Podaga (also Latin: Pogaga, Pogada) is a Polabian deity who had his statue in a temple in Plön. Mentioned only in Helmold's Chronicle, which does not give a depiction or function of the deity.",
    		search_term: "Podaga",
    		diameter: "40.0",
    		center_lat: -56.3,
    		center_long: 2
    	},
    	{
    		feature_id: 4785,
    		year: 1997,
    		feature: "Dorsum",
    		feature_plural: "Dorsa",
    		name: "Poludnitsa Dorsa",
    		type: "Goddess",
    		origin: "Slavic",
    		continent: "Multiple",
    		clean_name: "Poludnitsa",
    		description: "E. Slavic witch, corn fields deity.",
    		bio: "Poludnitsa is a noon demon in Slavic mythology. She can be referred to in English as \"Lady Midday\", \"Noonwraith\" or \"Noon Witch\". She was usually pictured as a young woman dressed in white that roamed field bounds. She assailed folk working at noon causing heatstrokes and aches in the neck, sometimes she even caused madness.",
    		search_term: "Poludnitsa",
    		diameter: "1,500.0",
    		center_lat: 5,
    		center_long: 179.5
    	},
    	{
    		feature_id: 5492,
    		year: 1997,
    		feature: "Dorsum",
    		feature_plural: "Dorsa",
    		name: "Shishimora Dorsa",
    		type: "Goddess",
    		origin: "Slavic",
    		continent: "Multiple",
    		clean_name: "Shishimora",
    		description: "E. Slavic night and dreams deity.",
    		bio: "",
    		search_term: "",
    		diameter: "800.0",
    		center_lat: 37,
    		center_long: 297
    	},
    	{
    		feature_id: 5743,
    		year: 1997,
    		feature: "Tessera",
    		feature_plural: "Tesserae",
    		name: "Sudenitsa Tesserae",
    		type: "Goddess",
    		origin: "Slavic",
    		continent: "Multiple",
    		clean_name: "Sudenitsa",
    		description: "Slavic fate deities (three sisters).",
    		bio: "",
    		search_term: "",
    		diameter: "4,200.0",
    		center_lat: 33,
    		center_long: 270
    	},
    	{
    		feature_id: 6082,
    		year: 1997,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Triglava Corona",
    		type: "Goddess",
    		origin: "Slavic",
    		continent: "Multiple",
    		clean_name: "Triglava",
    		description: "Ancient Slavic earth goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "400.0",
    		center_lat: -53.5,
    		center_long: 95
    	},
    	{
    		feature_id: 6705,
    		year: 1997,
    		feature: "Dorsum",
    		feature_plural: "Dorsa",
    		name: "Zaryanitsa Dorsa",
    		type: "Goddess",
    		origin: "Slavic",
    		continent: "Multiple",
    		clean_name: "Zaryanitsa",
    		description: "E. Slavic night lightning goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "1,100.0",
    		center_lat: 0,
    		center_long: 170
    	},
    	{
    		feature_id: 6727,
    		year: 1997,
    		feature: "Chasma",
    		feature_plural: "Chasmata",
    		name: "Zewana Chasma",
    		type: "Goddess",
    		origin: "Slavic",
    		continent: "Multiple",
    		clean_name: "Zewana",
    		description: "W. Slavic/Polish hunting goddess.",
    		bio: "Zewana is the goddess of wild nature, forests, hunting and the moon worshiped by the Western Slavs. In Slavic folklore there are devony — female mountain spirits or demons living in the caves, engaged in spinning, related to the forest fleece — who may be a demonized Zewana.",
    		search_term: "Zewana",
    		diameter: "900.0",
    		center_lat: 9,
    		center_long: 212
    	},
    	{
    		feature_id: 6733,
    		year: 1997,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Zhivana Corona",
    		type: "Goddess",
    		origin: "Slavic",
    		continent: "Multiple",
    		clean_name: "Zhivana",
    		description: "Slavic goddess of life.",
    		bio: "",
    		search_term: "",
    		diameter: "180.0",
    		center_lat: 13,
    		center_long: 287.5
    	},
    	{
    		feature_id: 6738,
    		year: 1997,
    		feature: "Dorsum",
    		feature_plural: "Dorsa",
    		name: "Zimcerla Dorsa",
    		type: "Goddess",
    		origin: "Slavic",
    		continent: "Multiple",
    		clean_name: "Zimcerla",
    		description: "W. Slavic dawn goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "850.0",
    		center_lat: -47.5,
    		center_long: 73.5
    	},
    	{
    		feature_id: 2675,
    		year: 1997,
    		feature: "Planitia",
    		feature_plural: "Planitiae",
    		name: "Imapinua Planitia",
    		type: "Heroine",
    		origin: "Inuit/Yupik",
    		continent: "Multiple",
    		clean_name: "Imapinua ",
    		description: "E. Greenland Eskimo sea mistress.",
    		bio: "",
    		search_term: "",
    		diameter: "2,100.0",
    		center_lat: -60,
    		center_long: 142
    	},
    	{
    		feature_id: 688,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Bender",
    		type: "Famous Woman",
    		origin: "United States",
    		continent: "North America",
    		clean_name: "Bender",
    		description: "Heidi Julia; American author and artist (1979-1991).",
    		bio: "Heidi Julia Bender (November 16, 1979 - March 31, 1991), the younger daughter of Randi Laine Bender (nee Anderson) and Howard Jeffrey Bender, was born in Shrub Oak, New York but lived most of her life in University Park, Maryland. Heidi led an average American middle-class life until she was stricken with an inoperable tumor in her brain stem when she was eight years old. From the IAU: 'Heidi is the only child for whom a crater on Venus has been named. While she doesn't have the quantity of substantial works of other authors and artists, the USGS and the IAU recognized that a child who accomplishes so much in such a short time under such duress, and has had such a positive effect on so many people, is famous indeed.'",
    		search_term: "User:Hjbender1/Sandbox",
    		diameter: "39.8",
    		center_lat: -13,
    		center_long: 327.4
    	},
    	{
    		feature_id: 1043,
    		year: 1997,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Cassatt Corona",
    		type: "Famous Woman",
    		origin: "United States",
    		continent: "North America",
    		clean_name: "Cassatt",
    		description: "Mary; American Impressionist painter (1844-1926). Name changed from Cassatt Patera.",
    		bio: "Mary Stevenson Cassatt (; May 22, 1844 – June 14, 1926) was an American painter and printmaker. She was born in Allegheny, Pennsylvania (now part of Pittsburgh's North Side), but lived much of her adult life in France, where she befriended Edgar Degas and exhibited with the Impressionists. Cassatt often created images of the social and private lives of women, with particular emphasis on the intimate bonds between mothers and children.",
    		search_term: "Mary Cassatt",
    		diameter: "152.0",
    		center_lat: 65.6,
    		center_long: 207.6
    	},
    	{
    		feature_id: 2235,
    		year: 1997,
    		feature: "Patera",
    		feature_plural: "Paterae",
    		name: "Graham Patera",
    		type: "Famous Woman",
    		origin: "United States",
    		continent: "North America",
    		clean_name: "Graham",
    		description: "Martha; American dancer, choreographer (1894-1991). Name changed from Graham crater.",
    		bio: "Martha Graham (May 11, 1894 – April 1, 1991) was an American modern dancer and choreographer. Her style, the Graham technique, reshaped American dance and is still taught worldwide.Graham danced and taught for over seventy years. She was the first dancer to perform at the White House, travel abroad as a cultural ambassador, and receive the highest civilian award of the US: the Presidential Medal of Freedom with Distinction.",
    		search_term: "Martha Graham",
    		diameter: "75.0",
    		center_lat: -6,
    		center_long: 6
    	},
    	{
    		feature_id: 3385,
    		year: 1997,
    		feature: "Patera",
    		feature_plural: "Paterae",
    		name: "Libby Patera",
    		type: "Famous Woman",
    		origin: "United States",
    		continent: "North America",
    		clean_name: "Libby",
    		description: "Leona Woods Marshall; American chemist and physicist (1919-1986).",
    		bio: "Leona Harriet Woods (August 9, 1919 – November 10, 1986), later known as Leona Woods Marshall and Leona Woods Marshall Libby, was an American physicist who helped build the first nuclear reactor and the first atomic bomb. At age 23, she was the youngest and only female member of the team which built and experimented with the world's first nuclear reactor (then called a pile), Chicago Pile-1, in a project led by her mentor Enrico Fermi. In particular, Woods was instrumental in the construction and then utilization of geiger counters for analysis during experimentation.",
    		search_term: "Leona Woods Marshall Libby",
    		diameter: "90.0",
    		center_lat: -34.5,
    		center_long: 199.5
    	},
    	{
    		feature_id: 4623,
    		year: 1997,
    		feature: "Patera",
    		feature_plural: "Paterae",
    		name: "Payne-Gaposchkin Patera",
    		type: "Famous Woman",
    		origin: "United States",
    		continent: "North America",
    		clean_name: "Payne-Gaposchkin",
    		description: "Cecilia Helena; American astronomer (1900-1979).",
    		bio: "Cecilia Payne-Gaposchkin (born Cecilia Helena Payne; (1900-05-10)May 10, 1900 – (1979-12-07)December 7, 1979) was a British-born American astronomer and astrophysicist who proposed in her 1925 doctoral thesis that stars were composed primarily of hydrogen and helium. Her groundbreaking conclusion was initially rejected because it contradicted the scientific wisdom of the time, which held that there were no significant elemental differences between the Sun and Earth. Independent observations eventually proved she was correct.",
    		search_term: "Cecilia Payne-Gaposchkin",
    		diameter: "100.0",
    		center_lat: -25.5,
    		center_long: 196
    	},
    	{
    		feature_id: 4902,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Quimby",
    		type: "Famous Woman",
    		origin: "United States",
    		continent: "North America",
    		clean_name: "Quimby",
    		description: "Harriet; American aviatrix (1884-1912).",
    		bio: "Harriet Quimby (May 11, 1875 – July 1, 1912) was an American pioneering aviator, journalist, and film screenwriter. In 1911, she became the first woman in the United States to receive a pilot certificate, issued to her by the Aero Club of America. In 1912, she became the first woman to fly across the English Channel.",
    		search_term: "Harriet Quimby",
    		diameter: "23.2",
    		center_lat: -5.7,
    		center_long: 76.7
    	},
    	{
    		feature_id: 6037,
    		year: 1997,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Tituba Corona",
    		type: "Famous Woman",
    		origin: "United States",
    		continent: "North America",
    		clean_name: "Tituba",
    		description: "Nurse who started Salem witch hunt (c. 1692). Name changed from Tituba Patera.",
    		bio: "Tituba Indian was an enslaved woman who was one of the first to be accused of witchcraft during the Salem witch trials of 1692-1693. She was brought to colonial Massachusetts from Barbados by Samuel Parris, the minister of Salem Village. She was pivotal in the trials because she confessed to witchcraft when examined by the authorities, giving credence to the accusations.",
    		search_term: "Tituba",
    		diameter: "163.0",
    		center_lat: 42.4,
    		center_long: 214.7
    	},
    	{
    		feature_id: 2057,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Gahano",
    		type: "First Name",
    		origin: "North America",
    		continent: "North America",
    		clean_name: "Gahano",
    		description: "Seneca first name.",
    		bio: "",
    		search_term: "",
    		diameter: "4.5",
    		center_lat: -80.2,
    		center_long: 77.4
    	},
    	{
    		feature_id: 2357,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Hapei",
    		type: "First Name",
    		origin: "United States",
    		continent: "North America",
    		clean_name: "Hapei",
    		description: "Cheyenne (Oklahoma) first name.",
    		bio: "",
    		search_term: "",
    		diameter: "4.2",
    		center_lat: 66.1,
    		center_long: 178
    	},
    	{
    		feature_id: 3917,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Miovasu",
    		type: "First Name",
    		origin: "United States",
    		continent: "North America",
    		clean_name: "Miovasu",
    		description: "Cheyenne first name.",
    		bio: "",
    		search_term: "",
    		diameter: "4.5",
    		center_lat: 72.1,
    		center_long: 99.9
    	},
    	{
    		feature_id: 4117,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Nakai",
    		type: "First Name",
    		origin: "United States",
    		continent: "North America",
    		clean_name: "Nakai",
    		description: "Cheyenne first name.",
    		bio: "",
    		search_term: "",
    		diameter: "4.5",
    		center_lat: -61,
    		center_long: 286.2
    	},
    	{
    		feature_id: 4422,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Oivit",
    		type: "First Name",
    		origin: "United States",
    		continent: "North America",
    		clean_name: "Oivit",
    		description: "Cheyenne first name.",
    		bio: "",
    		search_term: "",
    		diameter: "4.8",
    		center_lat: -73.9,
    		center_long: 195.5
    	},
    	{
    		feature_id: 6567,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Wiwi-yokpa",
    		type: "First Name",
    		origin: "Algonquin",
    		continent: "North America",
    		clean_name: "Wiwi-yokpa",
    		description: "Abenaki/Algonquin (Canada) first name.",
    		bio: "",
    		search_term: "",
    		diameter: "4.5",
    		center_lat: -73.8,
    		center_long: 228.4
    	},
    	{
    		feature_id: 105,
    		year: 1997,
    		feature: "Dorsum",
    		feature_plural: "Dorsa",
    		name: "Aida-Wedo Dorsa",
    		type: "Goddess",
    		origin: "Haiti",
    		continent: "North America",
    		clean_name: "Aida-Wedo",
    		description: "Haitian rainbow spirit.",
    		bio: "Ayida-Weddo is a loa, or spirit, of fertility, rainbows, wind, water, fire, and snakes in Vodou, especially in Benin and Haiti. Ayida-Weddo is known as the \"Rainbow Serpent\".",
    		search_term: "Aida-Wedo",
    		diameter: "450.0",
    		center_lat: 73,
    		center_long: 214
    	},
    	{
    		feature_id: 235,
    		year: 1997,
    		feature: "Dorsum",
    		feature_plural: "Dorsa",
    		name: "Amitolane Dorsa",
    		type: "Goddess",
    		origin: "United States",
    		continent: "North America",
    		clean_name: "Amitolane",
    		description: "Zuni (SW USA) name of the rainbow.",
    		bio: "",
    		search_term: "",
    		diameter: "900.0",
    		center_lat: -77,
    		center_long: 335
    	},
    	{
    		feature_id: 286,
    		year: 1997,
    		feature: "Dorsum",
    		feature_plural: "Dorsa",
    		name: "Anpao Dorsa",
    		type: "Goddess",
    		origin: "Dakota",
    		continent: "North America",
    		clean_name: "Anpao",
    		description: "Dakota name of the dawn.",
    		bio: "In Sioux mythology, Anpao, or Anp, is a spirit with two faces that represents the dawn. Anpao dances with Han, a primordial spirit of darkness, to ensure that Wi does not burn up the Earth, resulting in day and night.",
    		search_term: "Anpao",
    		diameter: "550.0",
    		center_lat: 62,
    		center_long: 207
    	},
    	{
    		feature_id: 444,
    		year: 1997,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Atahensik Corona",
    		type: "Goddess",
    		origin: "Iroquois",
    		continent: "North America",
    		clean_name: "Atahensik",
    		description: "Huron/Iroquois goddess, creator of the sun and moon.",
    		bio: "Atahensic is an Iroquois sky goddess. Atahensic is associated with marriage, childbirth, and feminine affairs in general. According to legend, at the time of creation, a tree broke and left a hole in the ground that led to the centre of the Earth. Atahensic fell from the sky, and before falling into the hole left by the tree, she was carried down on the wings of birds.",
    		search_term: "Atahensic",
    		diameter: "700.0",
    		center_lat: -19,
    		center_long: 170
    	},
    	{
    		feature_id: 513,
    		year: 1997,
    		feature: "Mons",
    		feature_plural: "Montes",
    		name: "Awenhai Mons",
    		type: "Goddess",
    		origin: "Iroquois",
    		continent: "North America",
    		clean_name: "Awenhai",
    		description: "Mohawk/Iroquois fertility goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "100.0",
    		center_lat: -60,
    		center_long: 248
    	},
    	{
    		feature_id: 1182,
    		year: 1997,
    		feature: "Tessera",
    		feature_plural: "Tesserae",
    		name: "Chimon-mana Tessera",
    		type: "Goddess",
    		origin: "Hopi",
    		continent: "North America",
    		clean_name: "Chimon-mana",
    		description: "Hopi (SW USA) goddess of insane.",
    		bio: "",
    		search_term: "",
    		diameter: "1,500.0",
    		center_lat: -3,
    		center_long: 270
    	},
    	{
    		feature_id: 1210,
    		year: 1997,
    		feature: "Mons",
    		feature_plural: "Montes",
    		name: "Chuginadak Mons",
    		type: "Goddess",
    		origin: "Aleutian",
    		continent: "North America",
    		clean_name: "Chuginadak",
    		description: "Aleutian volcano goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "450.0",
    		center_lat: -38,
    		center_long: 246
    	},
    	{
    		feature_id: 1218,
    		year: 1997,
    		feature: "Mons",
    		feature_plural: "Montes",
    		name: "Cipactli Mons",
    		type: "Goddess",
    		origin: "Aztec",
    		continent: "North America",
    		clean_name: "Cipactli",
    		description: "Aztec crocodile-like monster-goddess from which the earth was created.",
    		bio: "In Aztec mythology, Cipactli was a primeval sea monster, part crocodilian, part fish, and part toad or frog, with indefinite gender. Always hungry, every joint on its body was adorned with an extra mouth. The deity Tezcatlipoca sacrificed a foot when he used it as bait to draw the monster nearer. He and Quetzalcoatl created the earth from its body.",
    		search_term: "Cipactli",
    		diameter: "200.0",
    		center_lat: -31.5,
    		center_long: 332.5
    	},
    	{
    		feature_id: 1224,
    		year: 1997,
    		feature: "Mons",
    		feature_plural: "Montes",
    		name: "Ciuacoatl Mons",
    		type: "Goddess",
    		origin: "Aztec",
    		continent: "North America",
    		clean_name: "Ciuacoatl",
    		description: "Aztec earth goddess. Changed from Ciuacoatl Corona.",
    		bio: "In Aztec mythology, Cihuacōātl was one of a number of motherhood and fertility goddesses. She was especially associated with midwives, and with the sweatbaths where midwives practiced. Although she was sometimes depicted as a young woman, she is more often shown as a fierce skull-faced old woman carrying the spears and shield of a warrior. Childbirth was sometimes compared to warfare and the women who died in childbirth were honored as fallen warriors.",
    		search_term: "Ciuacoatl",
    		diameter: "100.0",
    		center_lat: 53,
    		center_long: 150.9
    	},
    	{
    		feature_id: 1492,
    		year: 1997,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Deohako Corona",
    		type: "Goddess",
    		origin: "Iroquois",
    		continent: "North America",
    		clean_name: "Deohako",
    		description: "Seneca Iroquois spirit of crops.",
    		bio: "",
    		search_term: "",
    		diameter: "300.0",
    		center_lat: -67.5,
    		center_long: 118
    	},
    	{
    		feature_id: 1648,
    		year: 1997,
    		feature: "Regio",
    		feature_plural: "Regiones",
    		name: "Dsonkwa Regio",
    		type: "Goddess",
    		origin: "United States",
    		continent: "North America",
    		clean_name: "Dsonkwa",
    		description: "Kwakiutl (NW Coast) forest giantess.",
    		bio: "Dzonkwa is a figure in Kwakwakaʼwakw mythology and Nuu-chah-nulth mythology . She is an ancestor of the Namgis clan through her son, Tsilwalagame. She is venerated as a bringer of wealth, but is also greatly feared by children, because she is also known as an ogress who steals children and carries them home in her basket to eat.",
    		search_term: "Dzunukwa",
    		diameter: "1,500.0",
    		center_lat: -53,
    		center_long: 167
    	},
    	{
    		feature_id: 1686,
    		year: 1997,
    		feature: "Mons",
    		feature_plural: "Montes",
    		name: "Dzalarhons Mons",
    		type: "Goddess",
    		origin: "Canada",
    		continent: "North America",
    		clean_name: "Dzalarhons",
    		description: "Haida (NW Coast) volcano goddess.",
    		bio: "Dzelarhons, or Dzalarhons (English: Volcano Woman) is a mountain spirit in the mythology of the Haida people. She rules the earth's creatures and punishes anyone who abuses them.",
    		search_term: "Dzalarhons",
    		diameter: "120.0",
    		center_lat: 0.5,
    		center_long: 34
    	},
    	{
    		feature_id: 1840,
    		year: 1997,
    		feature: "Mons",
    		feature_plural: "Montes",
    		name: "Erzulie Mons",
    		type: "Goddess",
    		origin: "Haiti",
    		continent: "North America",
    		clean_name: "Erzulie",
    		description: "Haitian voodoo goddess of love.",
    		bio: "Erzulie is a family of loa, or spirits, in Vodou. The Erzulie is a family of loa that are often associated with water (fluidity), femininity, and feminine bodies.",
    		search_term: "Erzulie",
    		diameter: "300.0",
    		center_lat: -68,
    		center_long: 8
    	},
    	{
    		feature_id: 2152,
    		year: 1997,
    		feature: "Chasma",
    		feature_plural: "Chasmata",
    		name: "Geyaguga Chasma",
    		type: "Goddess",
    		origin: "United States",
    		continent: "North America",
    		clean_name: "Geyaguga",
    		description: "Cherokee moon deity.",
    		bio: "",
    		search_term: "",
    		diameter: "800.0",
    		center_lat: -56.5,
    		center_long: 70
    	},
    	{
    		feature_id: 2306,
    		year: 1997,
    		feature: "Tessera",
    		feature_plural: "Tesserae",
    		name: "Haasttse-baad Tessera",
    		type: "Goddess",
    		origin: "Navajo",
    		continent: "North America",
    		clean_name: "Haasttse-baad",
    		description: "Navajo good health goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "2,600.0",
    		center_lat: 6,
    		center_long: 127
    	},
    	{
    		feature_id: 2347,
    		year: 1997,
    		feature: "Chasma",
    		feature_plural: "Chasmata",
    		name: "Hanghepiwi Chasma",
    		type: "Goddess",
    		origin: "Dakota",
    		continent: "North America",
    		clean_name: "Hanghepiwi",
    		description: "Dakota name of the moon and night.",
    		bio: "",
    		search_term: "",
    		diameter: "1,100.0",
    		center_lat: -48.5,
    		center_long: 18
    	},
    	{
    		feature_id: 2732,
    		year: 1997,
    		feature: "Regio",
    		feature_plural: "Regiones",
    		name: "Ishkus Regio",
    		type: "Goddess",
    		origin: "United States",
    		continent: "North America",
    		clean_name: "Ishkus",
    		description: "Makah (NW Coast) forest giantess.",
    		bio: "",
    		search_term: "",
    		diameter: "1,000.0",
    		center_lat: -61,
    		center_long: 245
    	},
    	{
    		feature_id: 2769,
    		year: 1997,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Iyatik Corona",
    		type: "Goddess",
    		origin: "Pueblo",
    		continent: "North America",
    		clean_name: "Iyatik",
    		description: "Keresan Pueblo (New Mexico) corn mother.",
    		bio: "",
    		search_term: "",
    		diameter: "200.0",
    		center_lat: -16.5,
    		center_long: 347.5
    	},
    	{
    		feature_id: 2948,
    		year: 1997,
    		feature: "Dorsum",
    		feature_plural: "Dorsa",
    		name: "Kastiatsi Dorsa",
    		type: "Goddess",
    		origin: "United States",
    		continent: "North America",
    		clean_name: "Kastiatsi",
    		description: "Acoma (SW USA) name of the rainbow.",
    		bio: "",
    		search_term: "",
    		diameter: "1,200.0",
    		center_lat: -53,
    		center_long: 245
    	},
    	{
    		feature_id: 3076,
    		year: 1997,
    		feature: "Chasma",
    		feature_plural: "Chasmata",
    		name: "Kokomikeis Chasma",
    		type: "Goddess",
    		origin: "Algonquin",
    		continent: "North America",
    		clean_name: "Kokomikeis",
    		description: "Blackfoot/Algonquin moon goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "1,000.0",
    		center_lat: 0,
    		center_long: 85
    	},
    	{
    		feature_id: 3077,
    		year: 1997,
    		feature: "Mons",
    		feature_plural: "Montes",
    		name: "Kokyanwuti Mons",
    		type: "Goddess",
    		origin: "Hopi",
    		continent: "North America",
    		clean_name: "Kokyanwuti",
    		description: "Hopi earth goddess - “Spider Woman“.",
    		bio: "",
    		search_term: "",
    		diameter: "400.0",
    		center_lat: 35.5,
    		center_long: 212
    	},
    	{
    		feature_id: 3098,
    		year: 1997,
    		feature: "Fluctus",
    		feature_plural: "Fluctūs",
    		name: "Koti Fluctus",
    		type: "Goddess",
    		origin: "United States",
    		continent: "North America",
    		clean_name: "Koti",
    		description: "Creek (SE USA) water-frog, helpful spirit.",
    		bio: "",
    		search_term: "",
    		diameter: "400.0",
    		center_lat: 12.5,
    		center_long: 318
    	},
    	{
    		feature_id: 3099,
    		year: 1997,
    		feature: "Dorsum",
    		feature_plural: "Dorsa",
    		name: "Kotsmanyako Dorsa",
    		type: "Goddess",
    		origin: "Pueblo",
    		continent: "North America",
    		clean_name: "Kotsmanyako",
    		description: "Keresan Pueblo mythological girl who scattered the stars into the sky.",
    		bio: "",
    		search_term: "",
    		diameter: "1,900.0",
    		center_lat: -76,
    		center_long: 242
    	},
    	{
    		feature_id: 3240,
    		year: 1997,
    		feature: "Mons",
    		feature_plural: "Montes",
    		name: "Laka Mons",
    		type: "Goddess",
    		origin: "Hawaii",
    		continent: "North America",
    		clean_name: "Laka",
    		description: "Hawaiian uncultivated area goddess.",
    		bio: "In Hawaiian mythology, Laka is the goddess of forest growth. She is said to be the inspiration a person thinks of while they dance. She is also the goddess of the forest. She has reproductive energy which is said to help the forest grow and thrive.",
    		search_term: "Laka",
    		diameter: "220.0",
    		center_lat: 79.9,
    		center_long: 262
    	},
    	{
    		feature_id: 3468,
    		year: 1997,
    		feature: "Mons",
    		feature_plural: "Montes",
    		name: "Loo-Wit Mons",
    		type: "Goddess",
    		origin: "United States",
    		continent: "North America",
    		clean_name: "Loo-Wit",
    		description: "Multnomah and Klikitat (NW Coast) volcano goddess, embodied in Mt. St. Helens.",
    		bio: "",
    		search_term: "",
    		diameter: "150.0",
    		center_lat: -59.5,
    		center_long: 56
    	},
    	{
    		feature_id: 3751,
    		year: 1997,
    		feature: "Vallis",
    		feature_plural: "Valles",
    		name: "Matlalcue Vallis",
    		type: "Goddess",
    		origin: "Aztec",
    		continent: "North America",
    		clean_name: "Matlalcue",
    		description: "Aztec fresh water goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "300.0",
    		center_lat: -33,
    		center_long: 167.5
    	},
    	{
    		feature_id: 3825,
    		year: 1997,
    		feature: "Mons",
    		feature_plural: "Montes",
    		name: "Mem Loimis Mons",
    		type: "Goddess",
    		origin: "United States",
    		continent: "North America",
    		clean_name: "Mem Loimis",
    		description: "Wintun (California) goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "300.0",
    		center_lat: 9.5,
    		center_long: 209
    	},
    	{
    		feature_id: 4099,
    		year: 1997,
    		feature: "Dorsum",
    		feature_plural: "Dorsa",
    		name: "Naatse-elit Dorsa",
    		type: "Goddess",
    		origin: "Navajo",
    		continent: "North America",
    		clean_name: "Naatse-elit",
    		description: "Navajo rainbow goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "950.0",
    		center_lat: -66,
    		center_long: 249
    	},
    	{
    		feature_id: 4110,
    		year: 1997,
    		feature: "Mons",
    		feature_plural: "Montes",
    		name: "Nahas-tsan Mons",
    		type: "Goddess",
    		origin: "Navajo",
    		continent: "North America",
    		clean_name: "Nahas-tsan",
    		description: "Navajo Mother Earth.",
    		bio: "",
    		search_term: "",
    		diameter: "500.0",
    		center_lat: 14,
    		center_long: 205
    	},
    	{
    		feature_id: 4149,
    		year: 1997,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Naotsete Corona",
    		type: "Goddess",
    		origin: "Pueblo",
    		continent: "North America",
    		clean_name: "Naotsete",
    		description: "Keresan Pueblo ancestor goddess, mother of all foreign (non-Keresan) people.",
    		bio: "",
    		search_term: "",
    		diameter: "200.0",
    		center_lat: -58.3,
    		center_long: 249.5
    	},
    	{
    		feature_id: 4172,
    		year: 1997,
    		feature: "Mons",
    		feature_plural: "Montes",
    		name: "Nayunuwi Montes",
    		type: "Goddess",
    		origin: "Chickasaw",
    		continent: "North America",
    		clean_name: "Nayunuwi",
    		description: "Cherokee stone-clad female monster.",
    		bio: "",
    		search_term: "",
    		diameter: "900.0",
    		center_lat: 2,
    		center_long: 83
    	},
    	{
    		feature_id: 4345,
    		year: 1997,
    		feature: "Dorsum",
    		feature_plural: "Dorsa",
    		name: "Norwan Dorsa",
    		type: "Goddess",
    		origin: "United States",
    		continent: "North America",
    		clean_name: "Norwan",
    		description: "Wintun (California) light goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "450.0",
    		center_lat: 65,
    		center_long: 163
    	},
    	{
    		feature_id: 4367,
    		year: 1997,
    		feature: "Dorsum",
    		feature_plural: "Dorsa",
    		name: "Nuvakchin Dorsa",
    		type: "Goddess",
    		origin: "Hopi",
    		continent: "North America",
    		clean_name: "Nuvakchin",
    		description: "Hopi snow maiden ('kachina').",
    		bio: "",
    		search_term: "",
    		diameter: "2,200.0",
    		center_lat: -53,
    		center_long: 212
    	},
    	{
    		feature_id: 4466,
    		year: 1997,
    		feature: "Mons",
    		feature_plural: "Montes",
    		name: "Ongwuti Mons",
    		type: "Goddess",
    		origin: "Hopi",
    		continent: "North America",
    		clean_name: "Ongwuti",
    		description: "Hopi salt-woman deity, predicts seasons.",
    		bio: "",
    		search_term: "",
    		diameter: "500.0",
    		center_lat: -2,
    		center_long: 194.5
    	},
    	{
    		feature_id: 4548,
    		year: 1997,
    		feature: "Mons",
    		feature_plural: "Montes",
    		name: "Pahto Mons",
    		type: "Goddess",
    		origin: "United States",
    		continent: "North America",
    		clean_name: "Pahto",
    		description: "Yakima/Klickitat (NW Coast) mountain goddess.",
    		bio: "The Native American name for Mount Adams in Washington State. According to Yakama legend, Pahto was one of five wives of the Sun, all of which were other mountains. Because she was the third wife to be greeted by the Sun in the morning, Pahto became jealous. Her jealous actions are thought to explain Mount Adams' squat appearance.",
    		search_term: "Pahto",
    		diameter: "300.0",
    		center_lat: -64.5,
    		center_long: 114.5
    	},
    	{
    		feature_id: 4603,
    		year: 1997,
    		feature: "Tessera",
    		feature_plural: "Tesserae",
    		name: "Pasom-mana Tesserae",
    		type: "Goddess",
    		origin: "Hopi",
    		continent: "North America",
    		clean_name: "Pasom-mana",
    		description: "Hopi goddess of dreams and the insane.",
    		bio: "",
    		search_term: "",
    		diameter: "1,200.0",
    		center_lat: -33,
    		center_long: 49
    	},
    	{
    		feature_id: 4780,
    		year: 1997,
    		feature: "Mons",
    		feature_plural: "Montes",
    		name: "Polik-mana Mons",
    		type: "Goddess",
    		origin: "Hopi",
    		continent: "North America",
    		clean_name: "Polik-mana",
    		description: "Hopi butterfly maiden ('kachina').",
    		bio: "Polik-mana or Butterfly Maiden is a kachina, or spirit being, in Hopi mythology. Every spring she dances from flower to flower, pollinating the fields and flowers and bringing life-giving rain to the Arizona desert. She is represented by a woman dancer at the yearly Butterfly Dance, a traditional initiation rite for Hopi girls.",
    		search_term: "Polik-mana",
    		diameter: "600.0",
    		center_lat: 24.5,
    		center_long: 264
    	},
    	{
    		feature_id: 5018,
    		year: 1997,
    		feature: "Mons",
    		feature_plural: "Montes",
    		name: "Rhpisunt Mons",
    		type: "Goddess",
    		origin: "Canada",
    		continent: "North America",
    		clean_name: "Rhpisunt",
    		description: "Haida (NW Coast) Bear Mother deity.",
    		bio: "",
    		search_term: "",
    		diameter: "250.0",
    		center_lat: 2.5,
    		center_long: 301.5
    	},
    	{
    		feature_id: 5280,
    		year: 1997,
    		feature: "Mons",
    		feature_plural: "Montes",
    		name: "Sakwap-mana Mons",
    		type: "Goddess",
    		origin: "Hopi",
    		continent: "North America",
    		clean_name: "Sakwap-mana",
    		description: "Hopi maiden of blue corn ('kachina').",
    		bio: "",
    		search_term: "",
    		diameter: "500.0",
    		center_lat: 35,
    		center_long: 219.5
    	},
    	{
    		feature_id: 5642,
    		year: 1997,
    		feature: "Mons",
    		feature_plural: "Montes",
    		name: "Somagalags Montes",
    		type: "Goddess",
    		origin: "Canada",
    		continent: "North America",
    		clean_name: "Somagalags",
    		description: "Bella Coola earth mother. Name changed from Somagalags Corona.",
    		bio: "",
    		search_term: "",
    		diameter: "105.0",
    		center_lat: 9.3,
    		center_long: 348.5
    	},
    	{
    		feature_id: 6004,
    		year: 1997,
    		feature: "Dorsum",
    		feature_plural: "Dorsa",
    		name: "Tikoiwuti Dorsa",
    		type: "Goddess",
    		origin: "Hopi",
    		continent: "North America",
    		clean_name: "Tikoiwuti",
    		description: "Hopi goddess of darkness.",
    		bio: "",
    		search_term: "",
    		diameter: "1,000.0",
    		center_lat: 56,
    		center_long: 225
    	},
    	{
    		feature_id: 6041,
    		year: 1997,
    		feature: "Tholus",
    		feature_plural: "Tholi",
    		name: "Toci Tholus",
    		type: "Goddess",
    		origin: "Aztec",
    		continent: "North America",
    		clean_name: "Toci",
    		description: "Aztec earthquake goddess.",
    		bio: "Toci is a deity figuring prominently in the religion and mythology of the pre-Columbian Aztec civilization of Mesoamerica. In Aztec mythology, she is seen as an aspect of the mother goddess Coatlicue or Xochitlicue and is thus labeled “mother of the gods”. She is also called Tlalli Iyollo (“heart of the earth”).",
    		search_term: "Toci",
    		diameter: "300.0",
    		center_lat: 29.5,
    		center_long: 355.1
    	},
    	{
    		feature_id: 6057,
    		year: 1997,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Tonatzin Corona",
    		type: "Goddess",
    		origin: "Aztec",
    		continent: "North America",
    		clean_name: "Tonatzin",
    		description: "Aztec earth and childbirth goddess.",
    		bio: "Mother Earth",
    		search_term: "Tonatzin",
    		diameter: "400.0",
    		center_lat: -53,
    		center_long: 164
    	},
    	{
    		feature_id: 6102,
    		year: 1997,
    		feature: "Chasma",
    		feature_plural: "Chasmata",
    		name: "Tsects Chasma",
    		type: "Goddess",
    		origin: "Canada",
    		continent: "North America",
    		clean_name: "Tsects",
    		description: "Haida (NW Coast) friendly spirit of forest underworld - grandma mouse.",
    		bio: "",
    		search_term: "",
    		diameter: "600.0",
    		center_lat: -61.6,
    		center_long: 35
    	},
    	{
    		feature_id: 6125,
    		year: 1997,
    		feature: "Dorsum",
    		feature_plural: "Dorsa",
    		name: "Tukwunag Dorsa",
    		type: "Goddess",
    		origin: "Hopi",
    		continent: "North America",
    		clean_name: "Tukwunag",
    		description: "Hopi cumulus cloud maiden ('kachina').",
    		bio: "",
    		search_term: "",
    		diameter: "1,000.0",
    		center_lat: -69,
    		center_long: 155
    	},
    	{
    		feature_id: 6190,
    		year: 1997,
    		feature: "Fluctus",
    		feature_plural: "Fluctūs",
    		name: "Uilata Fluctus",
    		type: "Goddess",
    		origin: "Chickasaw",
    		continent: "North America",
    		clean_name: "Uilata",
    		description: "Cherokee stone-clad female monster.",
    		bio: "",
    		search_term: "",
    		diameter: "700.0",
    		center_lat: 17,
    		center_long: 314
    	},
    	{
    		feature_id: 6225,
    		year: 1997,
    		feature: "Dorsum",
    		feature_plural: "Dorsa",
    		name: "Unelanuhi Dorsa",
    		type: "Goddess",
    		origin: "Chickasaw",
    		continent: "North America",
    		clean_name: "Unelanuhi",
    		description: "Cherokee sun goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "2,600.0",
    		center_lat: 12,
    		center_long: 87
    	},
    	{
    		feature_id: 6241,
    		year: 1997,
    		feature: "Mons",
    		feature_plural: "Montes",
    		name: "Uretsete Mons",
    		type: "Goddess",
    		origin: "Pueblo",
    		continent: "North America",
    		clean_name: "Uretsete",
    		description: "Keresan Pueblo ancestor goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "500.0",
    		center_lat: -12,
    		center_long: 261
    	},
    	{
    		feature_id: 6258,
    		year: 1997,
    		feature: "Mons",
    		feature_plural: "Montes",
    		name: "Uti Hiata Mons",
    		type: "Goddess",
    		origin: "Pawnee",
    		continent: "North America",
    		clean_name: "Uti Hiata",
    		description: "Pawnee Mother Corn deity.",
    		bio: "",
    		search_term: "",
    		diameter: "500.0",
    		center_lat: 16,
    		center_long: 69
    	},
    	{
    		feature_id: 6263,
    		year: 1997,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Utset Corona",
    		type: "Goddess",
    		origin: "United States",
    		continent: "North America",
    		clean_name: "Utset",
    		description: "Zia (SW USA) the First Mother.",
    		bio: "",
    		search_term: "",
    		diameter: "150.0",
    		center_lat: -55.5,
    		center_long: 167
    	},
    	{
    		feature_id: 6474,
    		year: 1997,
    		feature: "Dorsum",
    		feature_plural: "Dorsa",
    		name: "Wala Dorsa",
    		type: "Goddess",
    		origin: "United States",
    		continent: "North America",
    		clean_name: "Wala",
    		description: "Fox (US Plains) name of the dawn.",
    		bio: "",
    		search_term: "",
    		diameter: "500.0",
    		center_lat: -17,
    		center_long: 62
    	},
    	{
    		feature_id: 6602,
    		year: 1997,
    		feature: "Chasma",
    		feature_plural: "Chasmata",
    		name: "Xaratanga Chasma",
    		type: "Goddess",
    		origin: "Mexico",
    		continent: "North America",
    		clean_name: "Xaratanga",
    		description: "Tarascan (Mexico) moon goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "1,300.0",
    		center_lat: -54,
    		center_long: 70
    	},
    	{
    		feature_id: 6603,
    		year: 1997,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Xcacau Corona",
    		type: "Goddess",
    		origin: "Guatemala",
    		continent: "North America",
    		clean_name: "Xcacau",
    		description: "Quiche (Guatemala) cacao goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "200.0",
    		center_lat: -56,
    		center_long: 131
    	},
    	{
    		feature_id: 6604,
    		year: 1997,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Xcanil Corona",
    		type: "Goddess",
    		origin: "Aztec",
    		continent: "North America",
    		clean_name: "Xcanil",
    		description: "Aztec and Quiche maize goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "200.0",
    		center_lat: -37,
    		center_long: 43
    	},
    	{
    		feature_id: 6614,
    		year: 1997,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Xmukane Corona",
    		type: "Goddess",
    		origin: "Mayan",
    		continent: "North America",
    		clean_name: "Xmukane",
    		description: "Mayan mother and fertility goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "200.0",
    		center_lat: -28.2,
    		center_long: 269.5
    	},
    	{
    		feature_id: 6666,
    		year: 1997,
    		feature: "Mons",
    		feature_plural: "Montes",
    		name: "Yolkai-Estsan Mons",
    		type: "Goddess",
    		origin: "Navajo",
    		continent: "North America",
    		clean_name: "Yolkai-Estsan",
    		description: "Navajo myth female deity.",
    		bio: "",
    		search_term: "",
    		diameter: "600.0",
    		center_lat: 17,
    		center_long: 194
    	},
    	{
    		feature_id: 6682,
    		year: 1997,
    		feature: "Mons",
    		feature_plural: "Montes",
    		name: "Yunya-mana Mons",
    		type: "Goddess",
    		origin: "Hopi",
    		continent: "North America",
    		clean_name: "Yunya-mana",
    		description: "Hopi prickly pear cactus maiden.",
    		bio: "",
    		search_term: "",
    		diameter: "500.0",
    		center_lat: -18,
    		center_long: 285
    	},
    	{
    		feature_id: 6742,
    		year: 1997,
    		feature: "Fluctus",
    		feature_plural: "Fluctūs",
    		name: "Zipaltonal Fluctus",
    		type: "Goddess",
    		origin: "Nicaragua",
    		continent: "North America",
    		clean_name: "Zipaltonal",
    		description: "Nicaraguan creator goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "290.0",
    		center_lat: 37.7,
    		center_long: 251.3
    	},
    	{
    		feature_id: 3434,
    		year: 1997,
    		feature: "Planitia",
    		feature_plural: "Planitiae",
    		name: "Llorona Planitia",
    		type: "Heroine",
    		origin: "Mexico",
    		continent: "North America",
    		clean_name: "Llorona ",
    		description: "Mexican/Spanish folktale heroine.",
    		bio: "La Llorona (\"The Weeping Woman\" or \"The Wailer\") is a Hispanic-American mythical vengeful ghost who is said to roam near bodies of water mourning her children whom she drowned.",
    		search_term: "La Llorona",
    		diameter: "2,600.0",
    		center_lat: 18,
    		center_long: 145
    	},
    	{
    		feature_id: 4361,
    		year: 1997,
    		feature: "Planitia",
    		feature_plural: "Planitiae",
    		name: "Nuptadi Planitia",
    		type: "Heroine",
    		origin: "Mandan",
    		continent: "North America",
    		clean_name: "Nuptadi ",
    		description: "Mandan (US Plains) folk heroine; had magic shell robe.",
    		bio: "",
    		search_term: "",
    		diameter: "1,200.0",
    		center_lat: -73,
    		center_long: 250
    	},
    	{
    		feature_id: 322,
    		year: 1997,
    		feature: "Vallis",
    		feature_plural: "Valles",
    		name: "Apisuahts Vallis",
    		type: "Other",
    		origin: "Algonquin",
    		continent: "North America",
    		clean_name: "Apisuahts ",
    		description: "Blackfoot/Algonquin name for planet Venus.",
    		bio: "",
    		search_term: "",
    		diameter: "550.0",
    		center_lat: -66.5,
    		center_long: 17
    	},
    	{
    		feature_id: 2535,
    		year: 1997,
    		feature: "Vallis",
    		feature_plural: "Valles",
    		name: "Hoku-ao Vallis",
    		type: "Other",
    		origin: "Hawaii",
    		continent: "North America",
    		clean_name: "Hoku-ao ",
    		description: "Hawaiian name for planet Venus.",
    		bio: "",
    		search_term: "",
    		diameter: "450.0",
    		center_lat: 28,
    		center_long: 166.5
    	},
    	{
    		feature_id: 2139,
    		year: 1997,
    		feature: "Vallis",
    		feature_plural: "Valles",
    		name: "Gendenwitha Vallis",
    		type: "Other",
    		origin: "Iroquois",
    		continent: "North America",
    		clean_name: "Gendenwitha ",
    		description: "Iroquois name for planet Venus.",
    		bio: "",
    		search_term: "",
    		diameter: "900.0",
    		center_lat: -63,
    		center_long: 259
    	},
    	{
    		feature_id: 6620,
    		year: 1997,
    		feature: "Vallis",
    		feature_plural: "Valles",
    		name: "Xulab Vallis",
    		type: "Other",
    		origin: "Mayan",
    		continent: "North America",
    		clean_name: "Xulab ",
    		description: "Mayan name for planet Venus.",
    		bio: "",
    		search_term: "",
    		diameter: "820.0",
    		center_lat: -57.5,
    		center_long: 186
    	},
    	{
    		feature_id: 3637,
    		year: 1997,
    		feature: "Patera",
    		feature_plural: "Paterae",
    		name: "Mansfield Patera",
    		type: "Famous Woman",
    		origin: "New Zealand",
    		continent: "Oceania",
    		clean_name: "Mansfield",
    		description: "Cathrin (Cathleen Beauchamp); New Zealand writer (1888-1923).",
    		bio: "Kathleen Mansfield Murry (née Beauchamp; 14 October 1888 – 9 January 1923) was a New Zealand writer, essayist and journalist, widely considered one of the most influential and important authors of the modernist movement. Her works are celebrated across the world, and have been published in 25 languages.Born and raised in a house on Tinakori Road in the Wellington suburb of Thorndon, Mansfield was the third child in the Beauchamp family. After being raised by her parents and her beloved grandmother, she began school in Karori with her sisters before attending Wellington Girls' College.",
    		search_term: "Katherine Mansfield",
    		diameter: "80.0",
    		center_lat: 29.5,
    		center_long: 227.5
    	},
    	{
    		feature_id: 1918,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Faufau",
    		type: "First Name",
    		origin: "Polynesia",
    		continent: "Oceania",
    		clean_name: "Faufau",
    		description: "Polynesian first name.",
    		bio: "",
    		search_term: "",
    		diameter: "7.8",
    		center_lat: 18.8,
    		center_long: 8.3
    	},
    	{
    		feature_id: 2521,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Hiriata",
    		type: "First Name",
    		origin: "Polynesia",
    		continent: "Oceania",
    		clean_name: "Hiriata",
    		description: "Polynesian first name.",
    		bio: "",
    		search_term: "",
    		diameter: "5.0",
    		center_lat: 15.3,
    		center_long: 23.5
    	},
    	{
    		feature_id: 2572,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Huarei",
    		type: "First Name",
    		origin: "Polynesia",
    		continent: "Oceania",
    		clean_name: "Huarei",
    		description: "Polynesian first name.",
    		bio: "",
    		search_term: "",
    		diameter: "8.5",
    		center_lat: 15,
    		center_long: 32.3
    	},
    	{
    		feature_id: 2930,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Karo",
    		type: "First Name",
    		origin: "New Zealand",
    		continent: "Oceania",
    		clean_name: "Karo",
    		description: "Māori first name.",
    		bio: "",
    		search_term: "",
    		diameter: "7.0",
    		center_lat: 21.9,
    		center_long: 37.2
    	},
    	{
    		feature_id: 3030,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Kimitonga",
    		type: "First Name",
    		origin: "Polynesia",
    		continent: "Oceania",
    		clean_name: "Kimitonga",
    		description: "Polynesian first name.",
    		bio: "",
    		search_term: "",
    		diameter: "5.0",
    		center_lat: -25.1,
    		center_long: 48.3
    	},
    	{
    		feature_id: 3696,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Marere",
    		type: "First Name",
    		origin: "Polynesia",
    		continent: "Oceania",
    		clean_name: "Marere",
    		description: "Polynesian first name.",
    		bio: "",
    		search_term: "",
    		diameter: "6.3",
    		center_lat: 19.6,
    		center_long: 65.8
    	},
    	{
    		feature_id: 3747,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Matahina",
    		type: "First Name",
    		origin: "Polynesia",
    		continent: "Oceania",
    		clean_name: "Matahina",
    		description: "Polynesian first name.",
    		bio: "",
    		search_term: "",
    		diameter: "8.5",
    		center_lat: -72.3,
    		center_long: 65.9
    	},
    	{
    		feature_id: 3759,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Maurea",
    		type: "First Name",
    		origin: "Polynesia",
    		continent: "Oceania",
    		clean_name: "Maurea",
    		description: "Polynesian first name.",
    		bio: "",
    		search_term: "",
    		diameter: "9.9",
    		center_lat: -39.5,
    		center_long: 69.1
    	},
    	{
    		feature_id: 4239,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Ngaio",
    		type: "First Name",
    		origin: "New Zealand",
    		continent: "Oceania",
    		clean_name: "Ngaio",
    		description: "Māori first name.",
    		bio: "",
    		search_term: "",
    		diameter: "9.5",
    		center_lat: -53.3,
    		center_long: 61.8
    	},
    	{
    		feature_id: 4865,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Puhioia",
    		type: "First Name",
    		origin: "New Zealand",
    		continent: "Oceania",
    		clean_name: "Puhioia",
    		description: "Māori first name.",
    		bio: "",
    		search_term: "",
    		diameter: "5.5",
    		center_lat: 20.6,
    		center_long: 69.4
    	},
    	{
    		feature_id: 5219,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Ruit",
    		type: "First Name",
    		origin: "Polynesia",
    		continent: "Oceania",
    		clean_name: "Ruit",
    		description: "Polynesian first name.",
    		bio: "",
    		search_term: "",
    		diameter: "6.4",
    		center_lat: -25.5,
    		center_long: 72.9
    	},
    	{
    		feature_id: 5822,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Tahia",
    		type: "First Name",
    		origin: "Polynesia",
    		continent: "Oceania",
    		clean_name: "Tahia",
    		description: "Polynesian first name.",
    		bio: "",
    		search_term: "",
    		diameter: "6.1",
    		center_lat: 44.3,
    		center_long: 73.7
    	},
    	{
    		feature_id: 5898,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Tehina",
    		type: "First Name",
    		origin: "Polynesia",
    		continent: "Oceania",
    		clean_name: "Tehina",
    		description: "Polynesian first name.",
    		bio: "",
    		search_term: "",
    		diameter: "5.4",
    		center_lat: -30.4,
    		center_long: 76.4
    	},
    	{
    		feature_id: 5903,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Tekarohi",
    		type: "First Name",
    		origin: "Polynesia",
    		continent: "Oceania",
    		clean_name: "Tekarohi",
    		description: "Polynesian first name.",
    		bio: "",
    		search_term: "",
    		diameter: "9.3",
    		center_lat: 21.2,
    		center_long: 76.4
    	},
    	{
    		feature_id: 5911,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Temou",
    		type: "First Name",
    		origin: "Polynesia",
    		continent: "Oceania",
    		clean_name: "Temou",
    		description: "Polynesian first name.",
    		bio: "",
    		search_term: "",
    		diameter: "9.3",
    		center_lat: -10,
    		center_long: 83.4
    	},
    	{
    		feature_id: 5929,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Teroro",
    		type: "First Name",
    		origin: "Polynesia",
    		continent: "Oceania",
    		clean_name: "Teroro",
    		description: "Polynesian first name.",
    		bio: "",
    		search_term: "",
    		diameter: "9.2",
    		center_lat: -75.8,
    		center_long: 88.1
    	},
    	{
    		feature_id: 5940,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Teumere",
    		type: "First Name",
    		origin: "Polynesia",
    		continent: "Oceania",
    		clean_name: "Teumere",
    		description: "Polynesian first name.",
    		bio: "",
    		search_term: "",
    		diameter: "5.4",
    		center_lat: -38.3,
    		center_long: 88.1
    	},
    	{
    		feature_id: 5941,
    		year: 1997,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Teura",
    		type: "First Name",
    		origin: "Polynesia",
    		continent: "Oceania",
    		clean_name: "Teura",
    		description: "Polynesian first name.",
    		bio: "",
    		search_term: "",
    		diameter: "9.3",
    		center_lat: -12.3,
    		center_long: 90.2
    	},
    	{
    		feature_id: 448,
    		year: 1997,
    		feature: "Mons",
    		feature_plural: "Montes",
    		name: "Atanua Mons",
    		type: "Goddess",
    		origin: "Marquesas Islands",
    		continent: "Oceania",
    		clean_name: "Atanua",
    		description: "Dawn goddess from Marquesas Islands.",
    		bio: "Atanua (or Atanea) in Polynesian mythology (specifically: the Marquesas Islands) is the goddess of the dawn and wife of Atea. Their son is the first man, Tu-Mea. She created the seas after having a miscarriage and filling the oceans with her amniotic fluid.",
    		search_term: "Atanua",
    		diameter: "1,000.0",
    		center_lat: 9.5,
    		center_long: 308.9
    	},
    	{
    		feature_id: 1743,
    		year: 1997,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Eingana Corona",
    		type: "Goddess",
    		origin: "Australia",
    		continent: "Oceania",
    		clean_name: "Eingana",
    		description: "Australian aboriginal snake goddess, maker of all beings.",
    		bio: "Eingana is a creator goddess in Australian Aboriginal mythology (specifically: Jawoyn). Otherwise known as the \"Dreamtime Snake\", she is the mother of all water animals and humans. She is a snake goddess of death who lives in the Dreamtime.",
    		search_term: "Eingana",
    		diameter: "375.0",
    		center_lat: 5,
    		center_long: 350
    	},
    	{
    		feature_id: 2501,
    		year: 1997,
    		feature: "Fluctus",
    		feature_plural: "Fluctūs",
    		name: "Hikuleo Fluctus",
    		type: "Goddess",
    		origin: "Tonga",
    		continent: "Oceania",
    		clean_name: "Hikuleo",
    		description: "Tonga (Polynesia) underworld goddess.",
    		bio: "In the mythology of Tonga, Havea Hikuleʻo is the goddess of the world, Pulotu. The islands of Kao, Tofua, Hunga Haʻapai, Hunga Tonga, Late and Fonualei came from stones thrown down from the skies by Hikuleʻo. They are all volcanic islands.",
    		search_term: "Hikuleo",
    		diameter: "600.0",
    		center_lat: 52.5,
    		center_long: 208
    	},
    	{
    		feature_id: 3156,
    		year: 1997,
    		feature: "Mons",
    		feature_plural: "Montes",
    		name: "Kunapipi Mons",
    		type: "Goddess",
    		origin: "Australia",
    		continent: "Oceania",
    		clean_name: "Kunapipi",
    		description: "Australian mother earth goddess. Changed from Kunapipi Corona.",
    		bio: "Kunapipi, also spelled Gunabibi, ('womb') is a mother goddess and the patron deity of many heroes in Australian Aboriginal mythology. Kunapipi gave birth to human beings as well as to most animals and plants.",
    		search_term: "Kunapipi",
    		diameter: "220.0",
    		center_lat: -33.9,
    		center_long: 86
    	},
    	{
    		feature_id: 3235,
    		year: 1997,
    		feature: "Tessera",
    		feature_plural: "Tesserae",
    		name: "Lahevhev Tesserae",
    		type: "Goddess",
    		origin: "Melanesia",
    		continent: "Oceania",
    		clean_name: "Lahevhev",
    		description: "Melanesian dead souls goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "1,300.0",
    		center_lat: 29,
    		center_long: 189
    	},
    	{
    		feature_id: 3292,
    		year: 1997,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Latmikaik Corona",
    		type: "Goddess",
    		origin: "Micronesia",
    		continent: "Oceania",
    		clean_name: "Latmikaik",
    		description: "Palau (Micronesia) fertility and childbirth goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "500.0",
    		center_lat: -64,
    		center_long: 123
    	},
    	{
    		feature_id: 4351,
    		year: 1997,
    		feature: "Tessera",
    		feature_plural: "Tesserae",
    		name: "Nuahine Tessera",
    		type: "Goddess",
    		origin: "Polynesia",
    		continent: "Oceania",
    		clean_name: "Nuahine",
    		description: "Rapanui (Easter Isl.) fate goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "1,000.0",
    		center_lat: -9,
    		center_long: 157
    	},
    	{
    		feature_id: 5285,
    		year: 1997,
    		feature: "Collis",
    		feature_plural: "Colles",
    		name: "Salofa Colles",
    		type: "Goddess",
    		origin: "Samoa",
    		continent: "Oceania",
    		clean_name: "Salofa",
    		description: "Samoan tale's girl/sea turtle.",
    		bio: "",
    		search_term: "",
    		diameter: "250.0",
    		center_lat: -63,
    		center_long: 167
    	},
    	{
    		feature_id: 5616,
    		year: 1997,
    		feature: "Fluctus",
    		feature_plural: "Fluctūs",
    		name: "Sobra Fluctus",
    		type: "Goddess",
    		origin: "Melanesia",
    		continent: "Oceania",
    		clean_name: "Sobra",
    		description: "Marindanim (New Guinea and Melanesia) creator goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "700.0",
    		center_lat: 6,
    		center_long: 248
    	},
    	{
    		feature_id: 6126,
    		year: 1997,
    		feature: "Mons",
    		feature_plural: "Montes",
    		name: "Tuli Mons",
    		type: "Goddess",
    		origin: "Samoa",
    		continent: "Oceania",
    		clean_name: "Tuli",
    		description: "Samoan goddess of creation.",
    		bio: "",
    		search_term: "",
    		diameter: "750.0",
    		center_lat: 13.3,
    		center_long: 314.6
    	},
    	{
    		feature_id: 6178,
    		year: 1997,
    		feature: "Mons",
    		feature_plural: "Montes",
    		name: "Ua-ogrere Mons",
    		type: "Goddess",
    		origin: "New Guinea",
    		continent: "Oceania",
    		clean_name: "Ua-ogrere",
    		description: "Kivai (New Guinea) ancestor deity, old woman who “ever existed.”",
    		bio: "",
    		search_term: "",
    		diameter: "200.0",
    		center_lat: 40.5,
    		center_long: 117
    	},
    	{
    		feature_id: 6187,
    		year: 1997,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Ugatame Corona",
    		type: "Goddess",
    		origin: "Melanesia",
    		continent: "Oceania",
    		clean_name: "Ugatame",
    		description: "Kapauku (Papua/Melanesia) Great Mother goddess.",
    		bio: "Ugatame is the creator of the universe in Kapauku culture, who created \"...because he wanted to do so.\" In Kapauku mythology, Ugatame is held as the creator of humanity spirits, the laws of nature, earth and all transgressions. Ugatame has a dual nature of both masculine and feminine qualities and is referred to as the two entities. Similarly, Ugatame is responsible for both \"evil\" and \"good\", yet is neither themselves.",
    		search_term: "Ugatame",
    		diameter: "370.0",
    		center_lat: -76.5,
    		center_long: 255
    	},
    	{
    		feature_id: 1993,
    		year: 1997,
    		feature: "Planitia",
    		feature_plural: "Planitiae",
    		name: "Fonueha Planitia",
    		type: "Heroine",
    		origin: "Samoa",
    		continent: "Oceania",
    		clean_name: "Fonueha ",
    		description: "Samoan folktale blind old woman who became the shark.",
    		bio: "",
    		search_term: "",
    		diameter: "3,000.0",
    		center_lat: -44,
    		center_long: 48
    	},
    	{
    		feature_id: 2512,
    		year: 1997,
    		feature: "Planitia",
    		feature_plural: "Planitiae",
    		name: "Hinemoa Planitia",
    		type: "Heroine",
    		origin: "New Zealand",
    		continent: "Oceania",
    		clean_name: "Hinemoa ",
    		description: "Māori tale heroine; swam across Rotorua Lake to her friend.",
    		bio: "The legend of Hinemoa and Tūtānekai takes place in Mokoia Island, New Zealand. According to legend, the two lovers were forbidden to marry, and Hinemoa's father Umukaria, a chief from the shores of the lake, ordered that she not be allowed to travel by canoe to Tūtānekai's tribal village on the island. Hinemoa decided to swim 3.2 kilometres across the lake to the island, guided by the sound of Tūtānekai's flute-playing.",
    		search_term: "Mokoia Island",
    		diameter: "3,700.0",
    		center_lat: 5,
    		center_long: 265
    	},
    	{
    		feature_id: 3491,
    		year: 1997,
    		feature: "Planitia",
    		feature_plural: "Planitiae",
    		name: "Lowana Planitia",
    		type: "Heroine",
    		origin: "Australia",
    		continent: "Oceania",
    		clean_name: "Lowana ",
    		description: "Australian aboriginal tale heroine; lived alone by the sea weaving baskets.",
    		bio: "",
    		search_term: "",
    		diameter: "2,700.0",
    		center_lat: 43,
    		center_long: 98
    	},
    	{
    		feature_id: 6500,
    		year: 1997,
    		feature: "Planitia",
    		feature_plural: "Planitiae",
    		name: "Wawalag Planitia",
    		type: "Heroine",
    		origin: "Australia",
    		continent: "Oceania",
    		clean_name: "Wawalag ",
    		description: "Yulengor (Arnhemland) tale heroines, two sisters who evolved language.",
    		bio: "The Wawalag sisters are ancestral creator beings whose story is part of \"the most widespread\" sacred rituals in the Aboriginal culture from Arnhem land, Northern Territory, Australia. Their story takes place in Dreamtime, a period of time in Aboriginal belief where ancestral beings created the land as well as the social and linguistic structures in it. The sisters are said to have helped draw linguistic and social differences amongst the clans in Arnhem Land, but the ceremonies associated with their stories create cultural unity.",
    		search_term: "Wawalag",
    		diameter: "2,600.0",
    		center_lat: -30,
    		center_long: 217
    	},
    	{
    		feature_id: 598,
    		year: 1997,
    		feature: "Vallis",
    		feature_plural: "Valles",
    		name: "Banumbirr Vallis",
    		type: "Other",
    		origin: "Australia",
    		continent: "Oceania",
    		clean_name: "Banumbirr ",
    		description: "Arnhemland word for planet Venus.",
    		bio: "",
    		search_term: "",
    		diameter: "400.0",
    		center_lat: -7,
    		center_long: 4
    	},
    	{
    		feature_id: 5885,
    		year: 1997,
    		feature: "Vallis",
    		feature_plural: "Valles",
    		name: "Tawera Vallis",
    		type: "Other",
    		origin: "New Zealand",
    		continent: "Oceania",
    		clean_name: "Tawera ",
    		description: "Māori name for planet Venus.",
    		bio: "",
    		search_term: "",
    		diameter: "500.0",
    		center_lat: -11.6,
    		center_long: 67.5
    	},
    	{
    		feature_id: 1951,
    		year: 1997,
    		feature: "Vallis",
    		feature_plural: "Valles",
    		name: "Fetu-ao Vallis",
    		type: "Other",
    		origin: "Samoa",
    		continent: "Oceania",
    		clean_name: "Fetu-ao ",
    		description: "Samoan name for planet Venus.",
    		bio: "",
    		search_term: "",
    		diameter: "400.0",
    		center_lat: -61,
    		center_long: 254.7
    	},
    	{
    		feature_id: 11,
    		year: 1997,
    		feature: "Dorsum",
    		feature_plural: "Dorsa",
    		name: "Abe Mango Dorsa",
    		type: "Goddess",
    		origin: "Brazil",
    		continent: "South America",
    		clean_name: "Abe Mango",
    		description: "Tukano (Brazil) daughter of sun god.",
    		bio: "",
    		search_term: "",
    		diameter: "800.0",
    		center_lat: 47,
    		center_long: 212
    	},
    	{
    		feature_id: 127,
    		year: 1997,
    		feature: "Dorsum",
    		feature_plural: "Dorsa",
    		name: "Akewa Dorsa",
    		type: "Goddess",
    		origin: "Argentina",
    		continent: "South America",
    		clean_name: "Akewa",
    		description: "Toba (Argentina) sun goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "900.0",
    		center_lat: 45.5,
    		center_long: 184
    	},
    	{
    		feature_id: 1090,
    		year: 1997,
    		feature: "Fluctus",
    		feature_plural: "Fluctūs",
    		name: "Cavillaca Fluctus",
    		type: "Goddess",
    		origin: "Peru",
    		continent: "South America",
    		clean_name: "Cavillaca",
    		description: "Huarochiri (Peru) virgin goddess, turned herself into a rock.",
    		bio: "Cavillaca was a virgin goddess who ate a fruit, which was actually the sperm of Coniraya, the moon god. When she gave birth to a son, she demanded that the father step forward. No one did, so she put the baby on the ground and it crawled towards Coniraya. She was ashamed because of Coniraya's low stature among the gods, and ran to the coast of Peru, where she changed herself and her son into rocks.",
    		search_term: "Cavillaca",
    		diameter: "800.0",
    		center_lat: -72,
    		center_long: 340
    	},
    	{
    		feature_id: 1262,
    		year: 1997,
    		feature: "Tessera",
    		feature_plural: "Tesserae",
    		name: "Cocomama Tessera",
    		type: "Goddess",
    		origin: "Peru",
    		continent: "South America",
    		clean_name: "Cocomama",
    		description: "Quechua (Peru) happiness goddess.",
    		bio: "Mama Koka (Mother of coca leaves) was the goddess of health and happiness in Inca mythology. She was originally a promiscuous woman who was torn in half by several jealous lovers. After her death, one of her parts would originate the coca plant, widely consumed by the Andean people, according to their mentality, these plants gave health and happiness.",
    		search_term: "Cocomama",
    		diameter: "1,600.0",
    		center_lat: -62,
    		center_long: 23
    	},
    	{
    		feature_id: 1263,
    		year: 1997,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Codidon Corona",
    		type: "Goddess",
    		origin: "Colombia",
    		continent: "South America",
    		clean_name: "Codidon",
    		description: "Arauakan (Colombia) great mother goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "250.0",
    		center_lat: -46,
    		center_long: 56
    	},
    	{
    		feature_id: 1881,
    		year: 1997,
    		feature: "Tholus",
    		feature_plural: "Tholi",
    		name: "Evaki Tholus",
    		type: "Goddess",
    		origin: "Brazil",
    		continent: "South America",
    		clean_name: "Evaki",
    		description: "Amazonian sleep goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "200.0",
    		center_lat: 37.6,
    		center_long: 342.2
    	},
    	{
    		feature_id: 2346,
    		year: 1997,
    		feature: "Fossa",
    		feature_plural: "Fossae",
    		name: "Hanekasa Fossae",
    		type: "Goddess",
    		origin: "Venezuela",
    		continent: "South America",
    		clean_name: "Hanekasa",
    		description: "Sanema (Venezuela) amazon warrior.",
    		bio: "",
    		search_term: "",
    		diameter: "700.0",
    		center_lat: 29,
    		center_long: 148.5
    	},
    	{
    		feature_id: 2753,
    		year: 1997,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Ituana Corona",
    		type: "Goddess",
    		origin: "Brazil",
    		continent: "South America",
    		clean_name: "Ituana",
    		description: "Amazon River goddess, “Mother Scorpion“, afterworld ruler.",
    		bio: "",
    		search_term: "",
    		diameter: "220.0",
    		center_lat: 19.5,
    		center_long: 153.5
    	},
    	{
    		feature_id: 3617,
    		year: 1997,
    		feature: "Fluctus",
    		feature_plural: "Fluctūs",
    		name: "Mamapacha Fluctus",
    		type: "Goddess",
    		origin: "Peru",
    		continent: "South America",
    		clean_name: "Mamapacha",
    		description: "Inca earthquake goddess.",
    		bio: "Pachamama is a goddess revered by the indigenous peoples of the Andes. In Inca mythology she is an \"Earth Mother\" type goddess, and a fertility goddess who presides over planting and harvesting, embodies the mountains, and causes earthquakes. She is also an ever-present and independent deity who has her own creative power to sustain life on this earth.",
    		search_term: "Mamapacha",
    		diameter: "900.0",
    		center_lat: 60,
    		center_long: 185
    	},
    	{
    		feature_id: 4358,
    		year: 1997,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Nungui Corona",
    		type: "Goddess",
    		origin: "Peru",
    		continent: "South America",
    		clean_name: "Nungui",
    		description: "Hibaro (Peru/Equador) fertility goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "150.0",
    		center_lat: -42.5,
    		center_long: 245.2
    	},
    	{
    		feature_id: 4543,
    		year: 1997,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Pachamama Corona",
    		type: "Goddess",
    		origin: "Inca",
    		continent: "South America",
    		clean_name: "Pachamama",
    		description: "Incan earth goddess.",
    		bio: "Pachamama is a goddess revered by the indigenous peoples of the Andes. In Inca mythology she is an \"Earth Mother\" type goddess, and a fertility goddess who presides over planting and harvesting, embodies the mountains, and causes earthquakes. She is also an ever-present and independent deity who has her own creative power to sustain life on this earth.",
    		search_term: "Pachamama",
    		diameter: "130.0",
    		center_lat: -36,
    		center_long: 21.8
    	},
    	{
    		feature_id: 5177,
    		year: 1997,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Romi-Kumi Corona",
    		type: "Goddess",
    		origin: "Colombia",
    		continent: "South America",
    		clean_name: "Romi-Kumi",
    		description: "Tukano (Colombia) great mother goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "150.0",
    		center_lat: -81.2,
    		center_long: 180
    	},
    	{
    		feature_id: 5413,
    		year: 1997,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Seiusi Corona",
    		type: "Goddess",
    		origin: "Bolivia",
    		continent: "South America",
    		clean_name: "Seiusi",
    		description: "Tupi/Guarani (Bolivia) fertility goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "150.0",
    		center_lat: -62,
    		center_long: 241
    	},
    	{
    		feature_id: 6112,
    		year: 1997,
    		feature: "Fluctus",
    		feature_plural: "Fluctūs",
    		name: "Tsunghi Fluctus",
    		type: "Goddess",
    		origin: "Ecuador",
    		continent: "South America",
    		clean_name: "Tsunghi",
    		description: "Hibaro (Ecuador) water goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "800.0",
    		center_lat: -67,
    		center_long: 130
    	},
    	{
    		feature_id: 1159,
    		year: 1997,
    		feature: "Vallis",
    		feature_plural: "Valles",
    		name: "Chasca Vallis",
    		type: "Other",
    		origin: "Peru",
    		continent: "South America",
    		clean_name: "Chasca ",
    		description: "Quechua name for planet Venus.",
    		bio: "",
    		search_term: "",
    		diameter: "400.0",
    		center_lat: -52.8,
    		center_long: 359
    	},
    	{
    		feature_id: 1211,
    		year: 2000,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Chuku Corona",
    		type: "Goddess",
    		origin: "Nigeria",
    		continent: "Africa",
    		clean_name: "Chuku",
    		description: "Igbo (Nigeria) creator goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "380.0",
    		center_lat: -23.5,
    		center_long: 265.5
    	},
    	{
    		feature_id: 1910,
    		year: 2000,
    		feature: "Vallis",
    		feature_plural: "Valles",
    		name: "Fara Vallis",
    		type: "Goddess",
    		origin: "Madagascar",
    		continent: "Africa",
    		clean_name: "Fara",
    		description: "Malagasy (Madagascar) water goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "260.0",
    		center_lat: -1.2,
    		center_long: 345.5
    	},
    	{
    		feature_id: 3842,
    		year: 2000,
    		feature: "Dorsum",
    		feature_plural: "Dorsa",
    		name: "Menkerot Dorsa",
    		type: "Goddess",
    		origin: "Egypt",
    		continent: "Africa",
    		clean_name: "Menkerot",
    		description: "Ancient Egyptian goddess, mother of the sun.",
    		bio: "",
    		search_term: "",
    		diameter: "770.0",
    		center_lat: -20,
    		center_long: 351.5
    	},
    	{
    		feature_id: 3863,
    		year: 2000,
    		feature: "Fluctus",
    		feature_plural: "Fluctūs",
    		name: "Mert Fluctus",
    		type: "Goddess",
    		origin: "Egypt",
    		continent: "Africa",
    		clean_name: "Mert",
    		description: "Egyptian goddess of music and singing.",
    		bio: "",
    		search_term: "",
    		diameter: "250.0",
    		center_lat: -50.5,
    		center_long: 230.5
    	},
    	{
    		feature_id: 4166,
    		year: 2000,
    		feature: "Fluctus",
    		feature_plural: "Fluctūs",
    		name: "Naunet Fluctus",
    		type: "Goddess",
    		origin: "Egypt",
    		continent: "Africa",
    		clean_name: "Naunet",
    		description: "Ancient Egyptian (Heliopolis) sky goddess.",
    		bio: "Nu (\"Watery One\") or Nun (\"The Inert One\") (Ancient Egyptian: nnw Nānaw; Coptic: Ⲛⲟⲩⲛ Noun), is the personification of the primordial watery abyss which existed at the time of creation and from which the creator sun god Ra arose, in ancient Egyptian religion. Nu is one of the eight deities of the Ogdoad representing ancient Egyptian primordial Chaos from which the primordial mound arose from. Nun can be seen as the first of all the gods and the creator of reality and personification of the cosmos.",
    		search_term: "Naunet",
    		diameter: "200.0",
    		center_lat: -81,
    		center_long: 136
    	},
    	{
    		feature_id: 4329,
    		year: 2000,
    		feature: "Vallis",
    		feature_plural: "Valles",
    		name: "Nommo Valles",
    		type: "Goddess",
    		origin: "Mali",
    		continent: "Africa",
    		clean_name: "Nommo",
    		description: "Dogon (Mali) water deities.",
    		bio: "The Nommo or Nummo are primordial ancestral spirits in Dogon religion and cosmogony (sometimes referred to as demi deities) venerated by the Dogon people of Mali. The word Nommos is derived from a Dogon word meaning \"to make one drink.\" Nommos are usually described as amphibious, hermaphroditic, fish-like creatures. Folk art depictions of Nommos show creatures with humanoid upper torsos, legs/feet, and a fish-like lower torso and tail.",
    		search_term: "Nommo",
    		diameter: "200.0",
    		center_lat: -40.7,
    		center_long: 87.3
    	},
    	{
    		feature_id: 1517,
    		year: 2000,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Dheepa",
    		type: "First Name",
    		origin: "India",
    		continent: "Asia",
    		clean_name: "Dheepa",
    		description: "First name from India.",
    		bio: "",
    		search_term: "",
    		diameter: "4.7",
    		center_lat: -21.6,
    		center_long: 176.3
    	},
    	{
    		feature_id: 2342,
    		year: 2000,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Hamuda",
    		type: "First Name",
    		origin: "Hebrew",
    		continent: "Asia",
    		clean_name: "Hamuda",
    		description: "Hebrew first name.",
    		bio: "",
    		search_term: "",
    		diameter: "15.8",
    		center_lat: 62.9,
    		center_long: 2.5
    	},
    	{
    		feature_id: 2809,
    		year: 2000,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Jasmin",
    		type: "First Name",
    		origin: "Arabian",
    		continent: "Asia",
    		clean_name: "Jasmin",
    		description: "Arabic first name.",
    		bio: "",
    		search_term: "",
    		diameter: "15.1",
    		center_lat: 15.6,
    		center_long: 61.6
    	},
    	{
    		feature_id: 4362,
    		year: 2000,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Nuriet",
    		type: "First Name",
    		origin: "Caucasus",
    		continent: "Asia",
    		clean_name: "Nuriet",
    		description: "Adygan (N. Caucasus) first name.",
    		bio: "",
    		search_term: "",
    		diameter: "17.9",
    		center_lat: 20.6,
    		center_long: 245.6
    	},
    	{
    		feature_id: 5316,
    		year: 2000,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Saodat",
    		type: "First Name",
    		origin: "Uzbekistan",
    		continent: "Asia",
    		clean_name: "Saodat",
    		description: "Uzbek first name.",
    		bio: "",
    		search_term: "",
    		diameter: "3.7",
    		center_lat: -2.9,
    		center_long: 344.6
    	},
    	{
    		feature_id: 5660,
    		year: 2000,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Sovadi",
    		type: "First Name",
    		origin: "Cambodia",
    		continent: "Asia",
    		clean_name: "Sovadi",
    		description: "Khmer (Cambodia) first name.",
    		bio: "",
    		search_term: "",
    		diameter: "12.4",
    		center_lat: -44.8,
    		center_long: 225.5
    	},
    	{
    		feature_id: 155,
    		year: 2000,
    		feature: "Vallis",
    		feature_plural: "Valles",
    		name: "Alajen Vallis",
    		type: "Goddess",
    		origin: "Iran",
    		continent: "Asia",
    		clean_name: "Alajen",
    		description: "Talysh (Caspian Sea, SW coast) river deity.",
    		bio: "",
    		search_term: "",
    		diameter: "200.0",
    		center_lat: -3.3,
    		center_long: 337.1
    	},
    	{
    		feature_id: 633,
    		year: 2000,
    		feature: "Vallis",
    		feature_plural: "Valles",
    		name: "Bastryk Vallis",
    		type: "Goddess",
    		origin: "Caucasus",
    		continent: "Asia",
    		clean_name: "Bastryk",
    		description: "Kumyk (Daghestan) river deity.",
    		bio: "",
    		search_term: "",
    		diameter: "190.0",
    		center_lat: -7.5,
    		center_long: 347.5
    	},
    	{
    		feature_id: 1136,
    		year: 2000,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Changko Corona",
    		type: "Goddess",
    		origin: "Myanmar",
    		continent: "Asia",
    		clean_name: "Changko",
    		description: "Kachin (Burma/Myanmar) mother of all humans.",
    		bio: "",
    		search_term: "",
    		diameter: "200.0",
    		center_lat: 10.9,
    		center_long: 6.2
    	},
    	{
    		feature_id: 1516,
    		year: 2000,
    		feature: "Chasma",
    		feature_plural: "Chasmata",
    		name: "Dewi Ratih Chasma",
    		type: "Goddess",
    		origin: "Indonesia",
    		continent: "Asia",
    		clean_name: "Dewi Ratih",
    		description: "Bali (Indonesia) moon goddess.",
    		bio: "Dewi Ratih, also known as Sang Hyang Ratih or Sang Hyang Semara Ratih, is a Hindu lunar goddess worshipped in Java and Bali. She is well known for her beauty and grace, thus she was also known as the Goddess of Beauty. Her myth is linked to lunar eclipses.",
    		search_term: "Dewi Ratih",
    		diameter: "1,000.0",
    		center_lat: -6.5,
    		center_long: 359.7
    	},
    	{
    		feature_id: 1647,
    		year: 2000,
    		feature: "Tholus",
    		feature_plural: "Tholi",
    		name: "Dröl-ma Tholus",
    		type: "Goddess",
    		origin: "Tibet",
    		continent: "Asia",
    		clean_name: "Dröl-ma",
    		description: "Tibetan goddess of compassion.",
    		bio: "",
    		search_term: "",
    		diameter: "40.0",
    		center_lat: 24.2,
    		center_long: 6.3
    	},
    	{
    		feature_id: 2923,
    		year: 2000,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Kapenopfu Corona",
    		type: "Goddess",
    		origin: "Myanmar",
    		continent: "Asia",
    		clean_name: "Kapenopfu",
    		description: "Angami-Naga (Burma/Myanmar) creator goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "200.0",
    		center_lat: -21.7,
    		center_long: 271
    	},
    	{
    		feature_id: 2997,
    		year: 2000,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Khabuchi Corona",
    		type: "Goddess",
    		origin: "Caucasus",
    		continent: "Asia",
    		clean_name: "Khabuchi",
    		description: "Avarian/Andalalan (Daghestan) childbirth deity.",
    		bio: "",
    		search_term: "",
    		diameter: "285.0",
    		center_lat: -11,
    		center_long: 173
    	},
    	{
    		feature_id: 3160,
    		year: 2000,
    		feature: "Fluctus",
    		feature_plural: "Fluctūs",
    		name: "Kunkubey Fluctus",
    		type: "Goddess",
    		origin: "Yakutian",
    		continent: "Asia",
    		clean_name: "Kunkubey",
    		description: "Yakutian/Sakha goddess, wife of supreme god Yuryung.",
    		bio: "",
    		search_term: "",
    		diameter: "350.0",
    		center_lat: -50,
    		center_long: 207
    	},
    	{
    		feature_id: 3855,
    		year: 2000,
    		feature: "Fluctus",
    		feature_plural: "Fluctūs",
    		name: "Merisa Fluctus",
    		type: "Goddess",
    		origin: "Caucasus",
    		continent: "Asia",
    		clean_name: "Merisa",
    		description: "Adygan (N. Caucasus) beekeeping goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "630.0",
    		center_lat: 20.5,
    		center_long: 9
    	},
    	{
    		feature_id: 3888,
    		year: 2000,
    		feature: "Collis",
    		feature_plural: "Colles",
    		name: "Migazesh Colles",
    		type: "Goddess",
    		origin: "Caucasus",
    		continent: "Asia",
    		clean_name: "Migazesh",
    		description: "Adygan (N. Caucasus) daughter of sea goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "230.0",
    		center_lat: -49,
    		center_long: 198
    	},
    	{
    		feature_id: 3922,
    		year: 2000,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Mirizir Corona",
    		type: "Goddess",
    		origin: "Babylon",
    		continent: "Asia",
    		clean_name: "Mirizir",
    		description: "Kassitan (Babylonia) earth and fertility goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "70.0",
    		center_lat: -66.4,
    		center_long: 185
    	},
    	{
    		feature_id: 3934,
    		year: 2000,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Miti Corona",
    		type: "Goddess",
    		origin: "Siberia",
    		continent: "Asia",
    		clean_name: "Miti",
    		description: "Koryak and Itelmen (Kamchatka) the Raven's (world creator) wife.",
    		bio: "",
    		search_term: "",
    		diameter: "180.0",
    		center_lat: -3.5,
    		center_long: 259.8
    	},
    	{
    		feature_id: 4044,
    		year: 2000,
    		feature: "Fluctus",
    		feature_plural: "Fluctūs",
    		name: "Mortim-Ekva Fluctus",
    		type: "Goddess",
    		origin: "Siberia",
    		continent: "Asia",
    		clean_name: "Mortim-Ekva",
    		description: "Mansi (Ob River Ugra) mistress of “Bird's country“.",
    		bio: "",
    		search_term: "",
    		diameter: "1,250.0",
    		center_lat: 1,
    		center_long: 334
    	},
    	{
    		feature_id: 4129,
    		year: 2000,
    		feature: "Fossa",
    		feature_plural: "Fossae",
    		name: "Namjyalma Fossae",
    		type: "Goddess",
    		origin: "Tibet",
    		continent: "Asia",
    		clean_name: "Namjyalma",
    		description: "Tibetan victorious mother.",
    		bio: "",
    		search_term: "",
    		diameter: "560.0",
    		center_lat: 2.5,
    		center_long: 2.7
    	},
    	{
    		feature_id: 4138,
    		year: 2000,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Nang Pao Corona",
    		type: "Goddess",
    		origin: "Laos",
    		continent: "Asia",
    		clean_name: "Nang Pao",
    		description: "S. Laotian mythical ruler who called for rain, bringing fertility to the rice fields.",
    		bio: "",
    		search_term: "",
    		diameter: "160.0",
    		center_lat: -47,
    		center_long: 204.5
    	},
    	{
    		feature_id: 4237,
    		year: 2000,
    		feature: "Fluctus",
    		feature_plural: "Fluctūs",
    		name: "Ney-Anki Fluctus",
    		type: "Goddess",
    		origin: "Siberia",
    		continent: "Asia",
    		clean_name: "Ney-Anki",
    		description: "Khanty (Ob River Ugra) mother of fire.",
    		bio: "",
    		search_term: "",
    		diameter: "950.0",
    		center_lat: -37,
    		center_long: 105
    	},
    	{
    		feature_id: 4309,
    		year: 2000,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Nirmali Corona",
    		type: "Goddess",
    		origin: "Afghanistan",
    		continent: "Asia",
    		clean_name: "Nirmali",
    		description: "Nuristan (NE Afghanistan) childbirth goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "60.0",
    		center_lat: -6.3,
    		center_long: 172.3
    	},
    	{
    		feature_id: 4339,
    		year: 2000,
    		feature: "Tholus",
    		feature_plural: "Tholi",
    		name: "Norterma Tholus",
    		type: "Goddess",
    		origin: "Tibet",
    		continent: "Asia",
    		clean_name: "Norterma",
    		description: "Tibetan wealth-giving goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "15.0",
    		center_lat: -77,
    		center_long: 188
    	},
    	{
    		feature_id: 4407,
    		year: 2000,
    		feature: "Dorsum",
    		feature_plural: "Dorsa",
    		name: "Odzerchen Dorsa",
    		type: "Goddess",
    		origin: "Tibet",
    		continent: "Asia",
    		clean_name: "Odzerchen",
    		description: "Tibetan goddess of boundless light.",
    		bio: "",
    		search_term: "",
    		diameter: "300.0",
    		center_lat: -72,
    		center_long: 152
    	},
    	{
    		feature_id: 4545,
    		year: 2000,
    		feature: "Tholus",
    		feature_plural: "Tholi",
    		name: "Padma Tholi",
    		type: "Goddess",
    		origin: "India",
    		continent: "Asia",
    		clean_name: "Padma",
    		description: "Hindu lotus goddess.",
    		bio: "Padma (Sanskrit: पद्म, romanized: Padmā, lit. 'Lotus') is one of the four attributes borne by Vishnu in his iconography. It is associated with Vishnu's abode upon water, as well as his role in creation and birth. It is believed that Vishnu's association of the lotus is derived from the flower's presence in the symbolism of his consort, Lakshmi, for whom it represented water and fertility.",
    		search_term: "Padma (Vishnu)",
    		diameter: "100.0",
    		center_lat: -34.7,
    		center_long: 68.3
    	},
    	{
    		feature_id: 4911,
    		year: 2000,
    		feature: "Chasma",
    		feature_plural: "Chasmata",
    		name: "Rabie Chasma",
    		type: "Goddess",
    		origin: "Indonesia",
    		continent: "Asia",
    		clean_name: "Rabie",
    		description: "Wemale (E. Indonesia) moon goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "950.0",
    		center_lat: -10.5,
    		center_long: 267
    	},
    	{
    		feature_id: 4912,
    		year: 2000,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Rabzhima Corona",
    		type: "Goddess",
    		origin: "Tibet",
    		continent: "Asia",
    		clean_name: "Rabzhima",
    		description: "Tibetan great mother goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "100.0",
    		center_lat: 4.9,
    		center_long: 11
    	},
    	{
    		feature_id: 5664,
    		year: 2000,
    		feature: "Mons",
    		feature_plural: "Montes",
    		name: "Spandarmat Mons",
    		type: "Goddess",
    		origin: "Iran",
    		continent: "Asia",
    		clean_name: "Spandarmat",
    		description: "Iranian mother goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "400.0",
    		center_lat: -16.5,
    		center_long: 255
    	},
    	{
    		feature_id: 5775,
    		year: 2000,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Sus-Khotin Corona",
    		type: "Goddess",
    		origin: "Tajik",
    		continent: "Asia",
    		clean_name: "Sus-Khotin",
    		description: "Tajik and Uzbek fertility and rain goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "110.0",
    		center_lat: -54,
    		center_long: 241
    	},
    	{
    		feature_id: 5798,
    		year: 2000,
    		feature: "Fluctus",
    		feature_plural: "Fluctūs",
    		name: "Syvne Fluctus",
    		type: "Goddess",
    		origin: "Siberia",
    		continent: "Asia",
    		clean_name: "Syvne",
    		description: "Nenets (Samoyed) winter maiden.",
    		bio: "",
    		search_term: "",
    		diameter: "900.0",
    		center_lat: -36,
    		center_long: 72
    	},
    	{
    		feature_id: 6150,
    		year: 2000,
    		feature: "Tessera",
    		feature_plural: "Tesserae",
    		name: "Tushita Tesserae",
    		type: "Goddess",
    		origin: "India",
    		continent: "Asia",
    		clean_name: "Tushita",
    		description: "Hindu deity of resignation to fate. Name changed from Hikuleo Tesserae.",
    		bio: "",
    		search_term: "",
    		diameter: "1,400.0",
    		center_lat: -42,
    		center_long: 54
    	},
    	{
    		feature_id: 6374,
    		year: 2000,
    		feature: "Dorsum",
    		feature_plural: "Dorsa",
    		name: "Vetsorgo Dorsum",
    		type: "Goddess",
    		origin: "Mordvinian",
    		continent: "Asia",
    		clean_name: "Vetsorgo",
    		description: "Mordovian/Erzya (Volga Finn) daughter of the supreme sky god Nishke.",
    		bio: "",
    		search_term: "",
    		diameter: "700.0",
    		center_lat: -6.5,
    		center_long: 163
    	},
    	{
    		feature_id: 6458,
    		year: 2000,
    		feature: "Fluctus",
    		feature_plural: "Fluctūs",
    		name: "Vut-Ami Fluctus",
    		type: "Goddess",
    		origin: "Chuvash",
    		continent: "Asia",
    		clean_name: "Vut-Ami",
    		description: "Chuvash (Volga Region) fire goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "1,300.0",
    		center_lat: -38,
    		center_long: 67
    	},
    	{
    		feature_id: 6624,
    		year: 2000,
    		feature: "Fluctus",
    		feature_plural: "Fluctūs",
    		name: "Yagami Fluctus",
    		type: "Goddess",
    		origin: "Japan",
    		continent: "Asia",
    		clean_name: "Yagami",
    		description: "Japanese goddess, bride of god O-kuninusi.",
    		bio: "A descendant of Susanoo, the god Ōkuninushi helps a hapless hare that had been mistreated by his eighty brothers; the hare, in turn, helps Ōnamuji win the hand of the goddess Yagamihime of Inaba. ",
    		search_term: "Ōkuninushi",
    		diameter: "260.0",
    		center_lat: -80.6,
    		center_long: 152
    	},
    	{
    		feature_id: 6683,
    		year: 2000,
    		feature: "Tholus",
    		feature_plural: "Tholi",
    		name: "Yurt-Ava Tholus",
    		type: "Goddess",
    		origin: "Mordvinian",
    		continent: "Asia",
    		clean_name: "Yurt-Ava",
    		description: "Mordovian (Volga Finn) “home's mother“ deity.",
    		bio: "",
    		search_term: "",
    		diameter: "15.0",
    		center_lat: -13.8,
    		center_long: 341.5
    	},
    	{
    		feature_id: 6728,
    		year: 2000,
    		feature: "Fossa",
    		feature_plural: "Fossae",
    		name: "Zheztyrnak Fossae",
    		type: "Goddess",
    		origin: "Kazakhstan",
    		continent: "Asia",
    		clean_name: "Zheztyrnak",
    		description: "Kazakh evil deity, “copper claw“ maiden.",
    		bio: "",
    		search_term: "",
    		diameter: "180.0",
    		center_lat: -67.5,
    		center_long: 182
    	},
    	{
    		feature_id: 1533,
    		year: 2000,
    		feature: "Vallis",
    		feature_plural: "Valles",
    		name: "Dilbat Vallis",
    		type: "Other",
    		origin: "Assyro-Babylonian",
    		continent: "Asia",
    		clean_name: "Dilbat ",
    		description: "Assyro-Babylonian name for planet Venus.",
    		bio: "",
    		search_term: "",
    		diameter: "420.0",
    		center_lat: -55,
    		center_long: 184
    	},
    	{
    		feature_id: 3032,
    		year: 2000,
    		feature: "Vallis",
    		feature_plural: "Valles",
    		name: "Kimtinh Vallis",
    		type: "Other",
    		origin: "Vietnam",
    		continent: "Asia",
    		clean_name: "Kimtinh ",
    		description: "Vietnamese word for planet Venus.",
    		bio: "",
    		search_term: "",
    		diameter: "550.0",
    		center_lat: -46.5,
    		center_long: 67
    	},
    	{
    		feature_id: 711,
    		year: 2000,
    		feature: "Patera",
    		feature_plural: "Paterae",
    		name: "Bers Patera",
    		type: "Famous Woman",
    		origin: "Russia",
    		continent: "Europe",
    		clean_name: "Bers",
    		description: "Sofya Andreyevna (Tolstaya); wife and copyist for Leo Tolstoy (1844-1919).",
    		bio: "Countess Sophia Andreyevna Tolstaya (née Behrs; Russian: Со́фья Андре́евна Толста́я, sometimes anglicised as Sophia Tolstoy; 22 August 1844 – 4 November 1919), was a Russian diarist, and the wife of Russian writer Count Leo Tolstoy. Sophia acted as copyist of War and Peace, copying and editing the manuscript seven times from beginning to end at home at night by candlelight after the children and servants had gone to bed, using an inkwell pen and sometimes requiring a magnifying glass to read her husband's notes. She took over 1,000 photographs that documented her life, including with Tolstoy, and the decline of the Russian Empire.",
    		search_term: "Sophia Tolstaya",
    		diameter: "17.0",
    		center_lat: -66.7,
    		center_long: 183
    	},
    	{
    		feature_id: 3877,
    		year: 2000,
    		feature: "Patera",
    		feature_plural: "Paterae",
    		name: "Mezrina Patera",
    		type: "Famous Woman",
    		origin: "Russia",
    		continent: "Europe",
    		clean_name: "Mezrina",
    		description: "Anna; Russian clay toy sculptor (1853-1938).",
    		bio: "",
    		search_term: "",
    		diameter: "60.0",
    		center_lat: -33.3,
    		center_long: 68.8
    	},
    	{
    		feature_id: 4779,
    		year: 2000,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Polenova",
    		type: "Famous Woman",
    		origin: "Russia",
    		continent: "Europe",
    		clean_name: "Polenova",
    		description: "Elena; Russian painter, folk crafts trustee (1850-1898).",
    		bio: "Yelena Dmitrievna Polenova (Russian: Елена Дмитриевна Поленова; 15 November 1850, Saint Petersburg - 7 November 1898, Moscow) was a Russian painter and graphic artist in the Art Nouveau style. She was one of the first illustrators of children's books in Russia. Her brother was the landscape painter Vasily Polenov.",
    		search_term: "Yelena Polenova",
    		diameter: "41.0",
    		center_lat: -45.5,
    		center_long: 335.5
    	},
    	{
    		feature_id: 5920,
    		year: 2000,
    		feature: "Patera",
    		feature_plural: "Paterae",
    		name: "Tenisheva Patera",
    		type: "Famous Woman",
    		origin: "Russia",
    		continent: "Europe",
    		clean_name: "Tenisheva",
    		description: "Mariya; Russian painter and art collector (1867-1928).",
    		bio: "Maria Klavdievna Tenisheva (née Pyatkovskaya, in the first marriage - Nikolaeva, (20 May 1858 – 14 April 1928) was a Russian Princess, artist, educator, philanthropist and collector. She was born May 20, 1858, in St. Petersburg.",
    		search_term: "Princess Maria Tenisheva",
    		diameter: "80.0",
    		center_lat: -1.4,
    		center_long: 254.8
    	},
    	{
    		feature_id: 6376,
    		year: 2000,
    		feature: "Patera",
    		feature_plural: "Paterae",
    		name: "Viardot Patera",
    		type: "Famous Woman",
    		origin: "France",
    		continent: "Europe",
    		clean_name: "Viardot",
    		description: "(Viardot-Garcia) Pauline; French singer and composer (1821-1910).",
    		bio: "Pauline Viardot (pronounced [po.lin vjaʁ.do]; 18 July 1821 – 18 May 1910) was a nineteenth-century French mezzo-soprano, pedagogue and composer of Spanish descent. Born Michelle Ferdinande Pauline García, her name appears in various forms. When it is not simply 'Pauline Viardot', it most commonly appears in association with her maiden name García or the unaccented form, Garcia.",
    		search_term: "Pauline Viardot",
    		diameter: "55.0",
    		center_lat: -7,
    		center_long: 254.3
    	},
    	{
    		feature_id: 6545,
    		year: 2000,
    		feature: "Patera",
    		feature_plural: "Paterae",
    		name: "Wilde Patera",
    		type: "Famous Woman",
    		origin: "Ireland",
    		continent: "Europe",
    		clean_name: "Wilde",
    		description: "Lady Jane Francesca; Irish poet (1821-1891).",
    		bio: "Jane Francesca Agnes, Lady Wilde (née Elgee; 27 December 1821 – 3 February 1896) was an Irish poet under the pen name Speranza and supporter of the nationalist movement. Lady Wilde had a special interest in Irish folktales, which she helped to gather and was the mother of Oscar Wilde and Willie Wilde. Jane was the last of the four children of Charles Elgee (1783–1824), the son of Archdeacon John Elgee, a Wexford solicitor, and his wife Sarah (née Kingsbury, d.",
    		search_term: "Jane Wilde",
    		diameter: "75.0",
    		center_lat: -21.3,
    		center_long: 266.3
    	},
    	{
    		feature_id: 769,
    		year: 2000,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Blanche",
    		type: "First Name",
    		origin: "France",
    		continent: "Europe",
    		clean_name: "Blanche",
    		description: "French first name.",
    		bio: "",
    		search_term: "",
    		diameter: "12.3",
    		center_lat: -9.3,
    		center_long: 157
    	},
    	{
    		feature_id: 1228,
    		year: 2000,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Clara",
    		type: "First Name",
    		origin: "Latin",
    		continent: "Europe",
    		clean_name: "Clara",
    		description: "First name from Latin.",
    		bio: "",
    		search_term: "",
    		diameter: "3.2",
    		center_lat: -37.5,
    		center_long: 235.3
    	},
    	{
    		feature_id: 1486,
    		year: 2000,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Dena",
    		type: "First Name",
    		origin: "Lithuania",
    		continent: "Europe",
    		clean_name: "Dena",
    		description: "Lithuanian first name. Name changed from Drena.",
    		bio: "",
    		search_term: "",
    		diameter: "2.4",
    		center_lat: -20.7,
    		center_long: 338.7
    	},
    	{
    		feature_id: 3350,
    		year: 2000,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Leona",
    		type: "First Name",
    		origin: "Greek",
    		continent: "Europe",
    		clean_name: "Leona",
    		description: "Greek first name.",
    		bio: "",
    		search_term: "",
    		diameter: "3.0",
    		center_lat: -3.1,
    		center_long: 169
    	},
    	{
    		feature_id: 5179,
    		year: 2000,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Romola",
    		type: "First Name",
    		origin: "Italy",
    		continent: "Europe",
    		clean_name: "Romola",
    		description: "Italian first name.",
    		bio: "",
    		search_term: "",
    		diameter: "17.5",
    		center_lat: 9.3,
    		center_long: 54.2
    	},
    	{
    		feature_id: 5491,
    		year: 2000,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Shirley",
    		type: "First Name",
    		origin: "England",
    		continent: "Europe",
    		clean_name: "Shirley",
    		description: "English first name.",
    		bio: "",
    		search_term: "",
    		diameter: "18.0",
    		center_lat: 31.5,
    		center_long: 55.4
    	},
    	{
    		feature_id: 5621,
    		year: 2000,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Solace",
    		type: "First Name",
    		origin: "Latin",
    		continent: "Europe",
    		clean_name: "Solace",
    		description: "Latin first name.",
    		bio: "",
    		search_term: "",
    		diameter: "5.3",
    		center_lat: 35.9,
    		center_long: 317.2
    	},
    	{
    		feature_id: 360,
    		year: 2000,
    		feature: "Dorsum",
    		feature_plural: "Dorsa",
    		name: "Arev Dorsa",
    		type: "Goddess",
    		origin: "Armenia",
    		continent: "Europe",
    		clean_name: "Arev",
    		description: "Armenian female solar deity.",
    		bio: "",
    		search_term: "",
    		diameter: "420.0",
    		center_lat: -52,
    		center_long: 216
    	},
    	{
    		feature_id: 863,
    		year: 2000,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Branwen Corona",
    		type: "Goddess",
    		origin: "Great Britain",
    		continent: "Europe",
    		clean_name: "Branwen",
    		description: "British goddess of love.",
    		bio: "Branwen, Daughter of Llŷr is a major character in the Second Branch of the Mabinogi, which is sometimes called the \"Mabinogi of Branwen\" after her. She died of a broken heart.",
    		search_term: "Branwen",
    		diameter: "320.0",
    		center_lat: 27,
    		center_long: 35
    	},
    	{
    		feature_id: 1656,
    		year: 2000,
    		feature: "Dorsum",
    		feature_plural: "Dorsa",
    		name: "Dudumitsa Dorsa",
    		type: "Goddess",
    		origin: "Bulgaria",
    		continent: "Europe",
    		clean_name: "Dudumitsa",
    		description: "Bulgarian rain deity.",
    		bio: "",
    		search_term: "",
    		diameter: "980.0",
    		center_lat: -13.5,
    		center_long: 358
    	},
    	{
    		feature_id: 2242,
    		year: 2000,
    		feature: "Tholus",
    		feature_plural: "Tholi",
    		name: "Grechukha Tholi",
    		type: "Goddess",
    		origin: "Ukraine",
    		continent: "Europe",
    		clean_name: "Grechukha",
    		description: "Ukrainian field deity.",
    		bio: "",
    		search_term: "",
    		diameter: "200.0",
    		center_lat: -8.6,
    		center_long: 255.8
    	},
    	{
    		feature_id: 3298,
    		year: 2000,
    		feature: "Regio",
    		feature_plural: "Regiones",
    		name: "Laufey Regio",
    		type: "Goddess",
    		origin: "Norse",
    		continent: "Europe",
    		clean_name: "Laufey",
    		description: "Norse giantess.",
    		bio: "Laufey is a figure in Norse mythology and the mother of Loki. Since the name of her spouse Fárbauti means \"dangerous hitter\", a possible natural mythological interpretation has been proposed by some scholars, with lightning hitting the leaves, or needles of a tree to give rise to fire.",
    		search_term: "Laufey",
    		diameter: "2,100.0",
    		center_lat: 7,
    		center_long: 315
    	},
    	{
    		feature_id: 4247,
    		year: 2000,
    		feature: "Dorsum",
    		feature_plural: "Dorsa",
    		name: "Nichka Dorsa",
    		type: "Goddess",
    		origin: "Ukraine",
    		continent: "Europe",
    		clean_name: "Nichka",
    		description: "Ukrainian night deity.",
    		bio: "",
    		search_term: "",
    		diameter: "550.0",
    		center_lat: -10,
    		center_long: 354
    	},
    	{
    		feature_id: 4420,
    		year: 2000,
    		feature: "Fluctus",
    		feature_plural: "Fluctūs",
    		name: "Oilule Fluctus",
    		type: "Goddess",
    		origin: "Bulgaria",
    		continent: "Europe",
    		clean_name: "Oilule",
    		description: "West Bulgarian wife of thunder god.",
    		bio: "",
    		search_term: "",
    		diameter: "900.0",
    		center_lat: -22,
    		center_long: 79
    	},
    	{
    		feature_id: 4664,
    		year: 2000,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Persephone Corona",
    		type: "Goddess",
    		origin: "Greek",
    		continent: "Europe",
    		clean_name: "Persephone",
    		description: "Greek underworld goddess, daughter of corn goddess Demeter.",
    		bio: "In ancient Greek mythology and religion, Persephone is the daughter of Zeus and Demeter. She became the queen of the underworld after her abduction by and marriage to her uncle Hades, the king of the underworld. The myth of her abduction, her sojourn in the underworld, and her temporary return to the surface represents her functions as the embodiment of spring and the personification of vegetation, especially grain crops, which disappear into the earth when sown, sprout from the earth in spring, and are harvested when fully grown.",
    		search_term: "Persephone",
    		diameter: "120.0",
    		center_lat: -36,
    		center_long: 304.6
    	},
    	{
    		feature_id: 5292,
    		year: 2000,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Samdzimari Corona",
    		type: "Goddess",
    		origin: "Georgia",
    		continent: "Europe",
    		clean_name: "Samdzimari",
    		description: "Georgian (Caucasus) abundance deity.",
    		bio: "Samdzimari (also Samdzivari; Georgian: სამძიმარი, \"necklace-wearer\") is a fertility and oracular goddess from Georgian mythology. She was worshipped in the historical regions of Khevsureti and Pshavi in northeastern Georgia. Like the Svan hunting goddess Dali, who is attested in northwestern Georgia, Samdzimari was traditionally depicted as a beautiful blond-haired seductress with dominion over wild spaces.",
    		search_term: "Samdzimari",
    		diameter: "260.0",
    		center_lat: -11,
    		center_long: 339.5
    	},
    	{
    		feature_id: 5464,
    		year: 2000,
    		feature: "Tholus",
    		feature_plural: "Tholi",
    		name: "Shamiram Tholus",
    		type: "Goddess",
    		origin: "Armenia",
    		continent: "Europe",
    		clean_name: "Shamiram",
    		description: "Armenian goddess of love.",
    		bio: "",
    		search_term: "",
    		diameter: "10.0",
    		center_lat: -6.9,
    		center_long: 335.2
    	},
    	{
    		feature_id: 5754,
    		year: 2000,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Sulis Corona",
    		type: "Goddess",
    		origin: "Great Britain",
    		continent: "Europe",
    		clean_name: "Sulis",
    		description: "British goddess of springs and healing waters.",
    		bio: "In the localised Celtic polytheism practised in Great Britain, Sulis was a deity worshiped at the thermal spring of Bath (now in Somerset). Votive objects and inscribed lead tablets suggest that she was conceived of both as a nourishing, life-giving mother goddess and as an effective agent of curses wished by her votaries.",
    		search_term: "Sulis",
    		diameter: "136.0",
    		center_lat: 44.3,
    		center_long: 14.2
    	},
    	{
    		feature_id: 6367,
    		year: 2000,
    		feature: "Vallis",
    		feature_plural: "Valles",
    		name: "Vesper Vallis",
    		type: "Other",
    		origin: "Latin",
    		continent: "Europe",
    		clean_name: "Vesper ",
    		description: "Latin name for evening Venus.",
    		bio: "",
    		search_term: "",
    		diameter: "610.0",
    		center_lat: -59.3,
    		center_long: 180
    	},
    	{
    		feature_id: 4666,
    		year: 2000,
    		feature: "Tholus",
    		feature_plural: "Tholi",
    		name: "Perynya Tholus",
    		type: "Goddess",
    		origin: "Slavic",
    		continent: "Multiple",
    		clean_name: "Perynya",
    		description: "Slavic goddess, wife of thunderstorm god Perun.",
    		bio: "",
    		search_term: "",
    		diameter: "110.0",
    		center_lat: -0.7,
    		center_long: 353.2
    	},
    	{
    		feature_id: 4921,
    		year: 2000,
    		feature: "Labyrinthus",
    		feature_plural: "Labyrinthi",
    		name: "Radunitsa Labyrinthus",
    		type: "Goddess",
    		origin: "Slavic",
    		continent: "Multiple",
    		clean_name: "Radunitsa",
    		description: "Ancient Slavic goddess, keeper of souls of the deceased.",
    		bio: "Radonitsa (Russian Радоница, \"Day of Rejoicing\") in the Russian Orthodox Church is a commemoration of the departed. The Slavs, like many ancient peoples, had a tradition of visiting family members' graves during the springtime and feasting together with them.",
    		search_term: "Radunitsa",
    		diameter: "100.0",
    		center_lat: -8.9,
    		center_long: 351.3
    	},
    	{
    		feature_id: 5759,
    		year: 2000,
    		feature: "Tholus",
    		feature_plural: "Tholi",
    		name: "Sumerla Tholi",
    		type: "Goddess",
    		origin: "Slavic",
    		continent: "Multiple",
    		clean_name: "Sumerla",
    		description: "E. Slavic underworld goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "90.0",
    		center_lat: -13.8,
    		center_long: 252.2
    	},
    	{
    		feature_id: 4140,
    		year: 2000,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Nanichi",
    		type: "First Name",
    		origin: "Puerto Rico",
    		continent: "North America",
    		clean_name: "Nanichi",
    		description: "Taino (Puerto Rico) first name.",
    		bio: "",
    		search_term: "",
    		diameter: "19.0",
    		center_lat: -44.8,
    		center_long: 337.8
    	},
    	{
    		feature_id: 4455,
    		year: 2000,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Oma",
    		type: "First Name",
    		origin: "Sioux",
    		continent: "North America",
    		clean_name: "Oma",
    		description: "Sioux first name.",
    		bio: "",
    		search_term: "",
    		diameter: "7.6",
    		center_lat: -42.7,
    		center_long: 329.1
    	},
    	{
    		feature_id: 2766,
    		year: 2000,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Ixcuina Corona",
    		type: "Goddess",
    		origin: "Aztec",
    		continent: "North America",
    		clean_name: "Ixcuina",
    		description: "Aztec earth and fertility goddess.",
    		bio: "In Aztec mythology, Tlazolteotl is a deity of sexuality, vice, purification, steam baths, lust, filth, and a patroness of adulterers. She is associated with the day sign of the jaguar.Tlazolteotl played an important role in the confession of wrongdoing through her priests.",
    		search_term: "Ixcuina",
    		diameter: "150.0",
    		center_lat: -47.5,
    		center_long: 207.5
    	},
    	{
    		feature_id: 3247,
    		year: 2000,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Lalohonua Corona",
    		type: "Goddess",
    		origin: "Hawaii",
    		continent: "North America",
    		clean_name: "Lalohonua",
    		description: "The first woman in Hawaiian mythology.",
    		bio: "",
    		search_term: "",
    		diameter: "460.0",
    		center_lat: -24,
    		center_long: 250.5
    	},
    	{
    		feature_id: 3507,
    		year: 2000,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Ludjatako Corona",
    		type: "Goddess",
    		origin: "United States",
    		continent: "North America",
    		clean_name: "Ludjatako",
    		description: "Creek (SE USA) Giant turtle deity. Name changed from Ludjatako Mons.",
    		bio: "",
    		search_term: "",
    		diameter: "300.0",
    		center_lat: -12.5,
    		center_long: 250.5
    	},
    	{
    		feature_id: 3736,
    		year: 2000,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Masateotl Corona",
    		type: "Goddess",
    		origin: "Aztec",
    		continent: "North America",
    		clean_name: "Masateotl",
    		description: "Aztec goddess of love and fertility.",
    		bio: "",
    		search_term: "",
    		diameter: "180.0",
    		center_lat: -53,
    		center_long: 244
    	},
    	{
    		feature_id: 4188,
    		year: 2000,
    		feature: "Tholus",
    		feature_plural: "Tholi",
    		name: "Neegyauks Tholus",
    		type: "Goddess",
    		origin: "United States",
    		continent: "North America",
    		clean_name: "Neegyauks",
    		description: "Tlingit (SE Alaska) volcano woman and frog princess.",
    		bio: "",
    		search_term: "",
    		diameter: "30.0",
    		center_lat: -68.6,
    		center_long: 200
    	},
    	{
    		feature_id: 5191,
    		year: 2000,
    		feature: "Tholus",
    		feature_plural: "Tholi",
    		name: "Rosna Tholi",
    		type: "Goddess",
    		origin: "Chimalateco",
    		continent: "North America",
    		clean_name: "Rosna",
    		description: "Chimalateco/Chinanteco (Mexico) mountain goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "130.0",
    		center_lat: -25.5,
    		center_long: 73.3
    	},
    	{
    		feature_id: 6129,
    		year: 2000,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Tunehakwe Corona",
    		type: "Goddess",
    		origin: "Iroquois",
    		continent: "North America",
    		clean_name: "Tunehakwe",
    		description: "Onondaga/Iroquois deities of crops (“The Three Sisters“).",
    		bio: "",
    		search_term: "",
    		diameter: "290.0",
    		center_lat: -33.4,
    		center_long: 303.6
    	},
    	{
    		feature_id: 3237,
    		year: 2000,
    		feature: "Vallis",
    		feature_plural: "Valles",
    		name: "Laidamlulum Vallis",
    		type: "Other",
    		origin: "United States",
    		continent: "North America",
    		clean_name: "Laidamlulum ",
    		description: "Maidu (California) name for morning Venus.",
    		bio: "",
    		search_term: "",
    		diameter: "2,700.0",
    		center_lat: -73,
    		center_long: 151
    	},
    	{
    		feature_id: 100,
    		year: 2000,
    		feature: "Vallis",
    		feature_plural: "Valles",
    		name: "Ahsabkab Vallis",
    		type: "Other",
    		origin: "Mayan",
    		continent: "North America",
    		clean_name: "Ahsabkab ",
    		description: "Mayan name for morning Venus.",
    		bio: "",
    		search_term: "",
    		diameter: "700.0",
    		center_lat: -24,
    		center_long: 79
    	},
    	{
    		feature_id: 639,
    		year: 2000,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Batten",
    		type: "Famous Woman",
    		origin: "New Zealand",
    		continent: "Oceania",
    		clean_name: "Batten",
    		description: "Jean; New Zealand aviatrix (1909-1982).",
    		bio: "Jane Gardner Batten (15 September 1909 – 22 November 1982), commonly known as Jean Batten, was a New Zealand aviator, making a number of record-breaking solo flights across the world. She is notable for completing the first solo flight from England to New Zealand in 1936. Born in Rotorua, Batten went to England to learn to fly.",
    		search_term: "Jean Batten",
    		diameter: "65.0",
    		center_lat: 15.2,
    		center_long: 217.4
    	},
    	{
    		feature_id: 1534,
    		year: 2000,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Dilga Corona",
    		type: "Goddess",
    		origin: "Australia",
    		continent: "Oceania",
    		clean_name: "Dilga",
    		description: "Karadjeri (NW Australia) Earth goddess.",
    		bio: "In Australian aboriginal mythology (specifically: Karadjeri), Dilga is a goddess of fertility and growth, and the mother of the Bagadjimbiri. She avenged their deaths at the hands of Ngariman by drowning him in her milk.",
    		search_term: "Dilga",
    		diameter: "220.0",
    		center_lat: -18.7,
    		center_long: 250.4
    	},
    	{
    		feature_id: 2661,
    		year: 2000,
    		feature: "Fluctus",
    		feature_plural: "Fluctūs",
    		name: "Ilaheva Fluctus",
    		type: "Goddess",
    		origin: "Tonga",
    		continent: "Oceania",
    		clean_name: "Ilaheva",
    		description: "Tonga (Polynesia) worm goddess.",
    		bio: "In the mythology of Tonga, ʻIlaheva Vaʻepopua (ʻIlaheva, living at Vaʻepopua) was a mortal woman, the daughter of Seketoʻa. Seketo'a was either a chief of Tongatapu, or perhaps a god from Niuatoputapu, depending on the source.",
    		search_term: "Ilaheva",
    		diameter: "900.0",
    		center_lat: -42.5,
    		center_long: 84
    	},
    	{
    		feature_id: 2878,
    		year: 2000,
    		feature: "Fluctus",
    		feature_plural: "Fluctūs",
    		name: "Kaapaau Fluctus",
    		type: "Goddess",
    		origin: "Polynesia",
    		continent: "Oceania",
    		clean_name: "Kaapaau",
    		description: "Polynesian goddess of sharks.",
    		bio: "",
    		search_term: "",
    		diameter: "350.0",
    		center_lat: -66.5,
    		center_long: 181
    	},
    	{
    		feature_id: 4154,
    		year: 2000,
    		feature: "Tholus",
    		feature_plural: "Tholi",
    		name: "Narina Tholi",
    		type: "Goddess",
    		origin: "Australia",
    		continent: "Oceania",
    		clean_name: "Narina",
    		description: "Australian wild bird goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "55.0",
    		center_lat: -25.8,
    		center_long: 80
    	},
    	{
    		feature_id: 6142,
    		year: 2000,
    		feature: "Tholus",
    		feature_plural: "Tholi",
    		name: "Turi Tholus",
    		type: "Goddess",
    		origin: "Polynesia",
    		continent: "Oceania",
    		clean_name: "Turi",
    		description: "Polynesian goddess, created islands' relief.",
    		bio: "",
    		search_term: "",
    		diameter: "15.0",
    		center_lat: -66.9,
    		center_long: 222.3
    	},
    	{
    		feature_id: 6531,
    		year: 2000,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Whatitiri Corona",
    		type: "Goddess",
    		origin: "New Zealand",
    		continent: "Oceania",
    		clean_name: "Whatitiri",
    		description: "Māori ancestor goddess, great mother.",
    		bio: "",
    		search_term: "",
    		diameter: "300.0",
    		center_lat: -83,
    		center_long: 140
    	},
    	{
    		feature_id: 431,
    		year: 2000,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Asomama Corona",
    		type: "Goddess",
    		origin: "Peru",
    		continent: "South America",
    		clean_name: "Asomama",
    		description: "Quechua potato goddess.",
    		bio: "Axomamma (also Acsumamma and Ajomamma) is a goddess of potatoes in Inca mythology. She is one of the daughters of Pachamama, the earth mother. Potatoes forms a vital part of the food supply of the Incan people, and most villages had a particularly odd-shaped potato to worship and to beg for a good harvest.",
    		search_term: "Axomamma",
    		diameter: "180.0",
    		center_lat: 23.3,
    		center_long: 21.6
    	},
    	{
    		feature_id: 2945,
    		year: 2000,
    		feature: "Fluctus",
    		feature_plural: "Fluctūs",
    		name: "Kasogonaga Fluctus",
    		type: "Goddess",
    		origin: "Argentina",
    		continent: "South America",
    		clean_name: "Kasogonaga",
    		description: "Chaco tribes/Guarani (Argentina) female rain spirit.",
    		bio: "",
    		search_term: "",
    		diameter: "850.0",
    		center_lat: -18,
    		center_long: 268
    	},
    	{
    		feature_id: 4137,
    		year: 2000,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Nanen Corona",
    		type: "Goddess",
    		origin: "Brazil",
    		continent: "South America",
    		clean_name: "Nanen",
    		description: "Brazilian Earth and nature goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "50.0",
    		center_lat: 69.9,
    		center_long: 198.5
    	},
    	{
    		feature_id: 6702,
    		year: 2000,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Zaramama Corona",
    		type: "Goddess",
    		origin: "Peru",
    		continent: "South America",
    		clean_name: "Zaramama",
    		description: "Quechua (Peru) maize deity.",
    		bio: "Mama Sara (Maize mother; a.k.a. Saramama, Zaramama) was the goddess of grain. She was associated with maize that grew in multiples or were similarly strange. These strange plants were sometimes dressed as dolls of Mama Sara.",
    		search_term: "Zaramama",
    		diameter: "240.0",
    		center_lat: -22,
    		center_long: 240.5
    	},
    	{
    		feature_id: 2462,
    		year: 2003,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Heqet Corona",
    		type: "Goddess",
    		origin: "Egypt",
    		continent: "Africa",
    		clean_name: "Heqet",
    		description: "Egyptian fertility goddess.",
    		bio: "Heqet (Egyptian ḥqt, also ḥqtyt \"Heqtit\"), sometimes spelled Heket, is an Egyptian goddess of fertility, identified with Hathor, represented in the form of a frog. To the Egyptians, the frog was an ancient symbol of fertility, related to the annual flooding of the Nile.",
    		search_term: "Heqet",
    		diameter: "250.0",
    		center_lat: 7,
    		center_long: 169.5
    	},
    	{
    		feature_id: 3572,
    		year: 2003,
    		feature: "Tessera",
    		feature_plural: "Tesserae",
    		name: "Mafdet Tessera",
    		type: "Goddess",
    		origin: "Egypt",
    		continent: "Africa",
    		clean_name: "Mafdet",
    		description: "Egyptian goddess of judicial authority and executions.",
    		bio: "Mafdet (also Mefdet, Maftet) was a goddess in the ancient Egyptian religion. She was often depicted wearing a skin of a cheetah, and protected against the bite of snakes and scorpions. She is part of the ancient Egyptian deities during the First Dynasty of Egypt.",
    		search_term: "Mafdet",
    		diameter: "370.0",
    		center_lat: 9.2,
    		center_long: 38.5
    	},
    	{
    		feature_id: 4062,
    		year: 2003,
    		feature: "Mons",
    		feature_plural: "Montes",
    		name: "Muhongo Mons",
    		type: "Goddess",
    		origin: "Angola",
    		continent: "Africa",
    		clean_name: "Muhongo",
    		description: "Mbundu (Angola) ancestor deity.",
    		bio: "",
    		search_term: "",
    		diameter: "175.0",
    		center_lat: 10.6,
    		center_long: 174.5
    	},
    	{
    		feature_id: 4135,
    		year: 2003,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Nana-Buluku Coronae",
    		type: "Goddess",
    		origin: "Dahomean",
    		continent: "Africa",
    		clean_name: "Nana-Buluku",
    		description: "Dahomean world creator deity, both male and female.",
    		bio: "",
    		search_term: "",
    		diameter: "230.0",
    		center_lat: 39.4,
    		center_long: 14
    	},
    	{
    		feature_id: 4174,
    		year: 2003,
    		feature: "Mons",
    		feature_plural: "Montes",
    		name: "Nazit Mons",
    		type: "Goddess",
    		origin: "Egypt",
    		continent: "Africa",
    		clean_name: "Nazit",
    		description: "Egyptian winged serpent goddess.",
    		bio: "Wadjet was said to be the matron and protector of Lower Egypt, and upon unification with Upper Egypt, the joint protector and patron of all of Egypt. The image of Wadjet with the sun disk is called the uraeus, and it was the emblem on the crown of the rulers of Lower Egypt. She was also the protector of kings and of women in childbirth. Wadjet was depicted as a cobra.",
    		search_term: "Nazit",
    		diameter: "350.0",
    		center_lat: 22.5,
    		center_long: 240
    	},
    	{
    		feature_id: 4177,
    		year: 2003,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Ndoi Corona",
    		type: "Goddess",
    		origin: "Mende",
    		continent: "Africa",
    		clean_name: "Ndoi",
    		description: "Mende (Sierra Leone) Earth and nature goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "225.0",
    		center_lat: -20.3,
    		center_long: 230.3
    	},
    	{
    		feature_id: 4537,
    		year: 2003,
    		feature: "Dorsum",
    		feature_plural: "Dorsa",
    		name: "Oya Dorsa",
    		type: "Goddess",
    		origin: "Nigeria",
    		continent: "Africa",
    		clean_name: "Oya",
    		description: "Yoruba (Nigeria) goddess of violent rainstorms.",
    		bio: "Ọya is an orisha of winds, lightning, and violent storms, death, and rebirth. She is known as Ọya-Ìyáńsàn-án, the \"mother of nine\", because of nine children she gave birth to, all stillborn, suffering from a lifetime of barrenness. She is a warrior and is unbeatable.",
    		search_term: "Oya",
    		diameter: "480.0",
    		center_lat: 21.5,
    		center_long: 157.5
    	},
    	{
    		feature_id: 4997,
    		year: 2003,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Repa Corona",
    		type: "Goddess",
    		origin: "Egypt",
    		continent: "Africa",
    		clean_name: "Repa",
    		description: "Egyptian fertility and underworld goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "240.0",
    		center_lat: -13,
    		center_long: 218.8
    	},
    	{
    		feature_id: 5994,
    		year: 2003,
    		feature: "Fluctus",
    		feature_plural: "Fluctūs",
    		name: "Tie Fluctus",
    		type: "Goddess",
    		origin: "Egypt",
    		continent: "Africa",
    		clean_name: "Tie",
    		description: "Egyptian goddess of intelligence and wisdom.",
    		bio: "",
    		search_term: "",
    		diameter: "550.0",
    		center_lat: 21,
    		center_long: 159
    	},
    	{
    		feature_id: 4039,
    		year: 2003,
    		feature: "Vallis",
    		feature_plural: "Valles",
    		name: "Morongo Valles",
    		type: "Other",
    		origin: "Zimbabwe",
    		continent: "Africa",
    		clean_name: "Morongo ",
    		description: "Makoni (Zimbabwe) name of Venus as evening star.",
    		bio: "",
    		search_term: "",
    		diameter: "660.0",
    		center_lat: -20,
    		center_long: 111.4
    	},
    	{
    		feature_id: 5411,
    		year: 2003,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Seiko",
    		type: "First Name",
    		origin: "Japan",
    		continent: "Asia",
    		clean_name: "Seiko",
    		description: "Japanese first name.",
    		bio: "",
    		search_term: "",
    		diameter: "3.4",
    		center_lat: -21,
    		center_long: 216.6
    	},
    	{
    		feature_id: 125,
    		year: 2003,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Ak-Ene Corona",
    		type: "Goddess",
    		origin: "Altai",
    		continent: "Asia",
    		clean_name: "Ak-Ene",
    		description: "Altay Great Mother, “White Mother.”",
    		bio: "Ak Ana (Ağ Ana or Ak Ene), the 'Holy Mother', is the primordial creator-goddess of Turkic people and the Khanty and Mansi peoples of Siberia. She is also known as the goddess of the water. She was the consort and daughter of Kayra Han.",
    		search_term: "Ak Ana",
    		diameter: "150.0",
    		center_lat: 9.4,
    		center_long: 254.7
    	},
    	{
    		feature_id: 239,
    		year: 2003,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Among Corona",
    		type: "Goddess",
    		origin: "Myanmar",
    		continent: "Asia",
    		clean_name: "Among",
    		description: "Karen (Burma/Myanmar) mythological first woman.",
    		bio: "",
    		search_term: "",
    		diameter: "210.0",
    		center_lat: -13.4,
    		center_long: 213.5
    	},
    	{
    		feature_id: 423,
    		year: 2003,
    		feature: "Collis",
    		feature_plural: "Colles",
    		name: "Asherat Colles",
    		type: "Goddess",
    		origin: "Phoenician",
    		continent: "Asia",
    		clean_name: "Asherat",
    		description: "Phoenician goddess known as “Asherat-of-the-Sea.”",
    		bio: "",
    		search_term: "",
    		diameter: "500.0",
    		center_lat: 12,
    		center_long: 162
    	},
    	{
    		feature_id: 1196,
    		year: 2003,
    		feature: "Chasma",
    		feature_plural: "Chasmata",
    		name: "Chondi Chasma",
    		type: "Goddess",
    		origin: "Bangladesh",
    		continent: "Asia",
    		clean_name: "Chondi",
    		description: "Bengali goddess of wild animals.",
    		bio: "",
    		search_term: "",
    		diameter: "1,000.0",
    		center_lat: -18.5,
    		center_long: 230
    	},
    	{
    		feature_id: 1546,
    		year: 2003,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Disani Corona",
    		type: "Goddess",
    		origin: "Afghanistan",
    		continent: "Asia",
    		clean_name: "Disani",
    		description: "Nuristan (NE Afghanistan) fertility goddess.",
    		bio: "Disani (Kamkata-vari: Disaňi), also known as Disni was a goddess of the Nuristani people before their conversion to Islam. To the people of Nuristan, she was depicted as living in the terrestrial world, appearing in the shape of a woman with a golden garland. Milk and milk-products were offered to her at the altar on the hillside.",
    		search_term: "Disani",
    		diameter: "300.0",
    		center_lat: 2.7,
    		center_long: 57.5
    	},
    	{
    		feature_id: 1692,
    		year: 2003,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Dzuzdi Corona",
    		type: "Goddess",
    		origin: "Komi",
    		continent: "Asia",
    		clean_name: "Dzuzdi",
    		description: "W. Komi-Permyakan (Ural Finn) mythological ancestor of Zyuzdino tribes, Upper Kama River area.",
    		bio: "",
    		search_term: "",
    		diameter: "80.0",
    		center_lat: 35.2,
    		center_long: 20.6
    	},
    	{
    		feature_id: 1790,
    		year: 2003,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Emegelji Coronae",
    		type: "Goddess",
    		origin: "Mongolia",
    		continent: "Asia",
    		clean_name: "Emegelji",
    		description: "Mongolian childcare goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "225.0",
    		center_lat: -21.5,
    		center_long: 213.5
    	},
    	{
    		feature_id: 2110,
    		year: 2003,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Gashan-Ki Corona",
    		type: "Goddess",
    		origin: "Babylon",
    		continent: "Asia",
    		clean_name: "Gashan-Ki",
    		description: "Babylonian “Lady of the Earth.”",
    		bio: "",
    		search_term: "",
    		diameter: "225.0",
    		center_lat: 11.7,
    		center_long: 243.7
    	},
    	{
    		feature_id: 2118,
    		year: 2003,
    		feature: "Mons",
    		feature_plural: "Montes",
    		name: "Gauri Mons",
    		type: "Goddess",
    		origin: "India",
    		continent: "Asia",
    		clean_name: "Gauri",
    		description: "Indian mountain goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "75.0",
    		center_lat: -20.2,
    		center_long: 102.2
    	},
    	{
    		feature_id: 2350,
    		year: 2003,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Hannahannas Corona",
    		type: "Goddess",
    		origin: "Turkey",
    		continent: "Asia",
    		clean_name: "Hannahannas",
    		description: "Hittite (Asia Minor) mother and insect goddess.",
    		bio: "Ḫannaḫanna (from Hittite ḫanna- \"grandmother\") was a Hittite mother goddess. Ḫannaḫanna appears in a number of Hittite myths, and tends to help in solving the problems faced by other gods in them. Most of them are myths dealing with the disappearance of deities, a common theme in Hittite myths.",
    		search_term: "Hannahannas",
    		diameter: "200.0",
    		center_lat: 0,
    		center_long: 170.5
    	},
    	{
    		feature_id: 2838,
    		year: 2003,
    		feature: "Linea",
    		feature_plural: "Lineae",
    		name: "Jokwa Linea",
    		type: "Goddess",
    		origin: "Japan",
    		continent: "Asia",
    		clean_name: "Jokwa",
    		description: "Japanese “Royal Lady of the West“ who waged war with demons and giants, then set the world in order.",
    		bio: "",
    		search_term: "",
    		diameter: "2,200.0",
    		center_lat: -17,
    		center_long: 210
    	},
    	{
    		feature_id: 3023,
    		year: 2003,
    		feature: "Chasma",
    		feature_plural: "Chasmata",
    		name: "Kicheda Chasma",
    		type: "Goddess",
    		origin: "Siberia",
    		continent: "Asia",
    		clean_name: "Kicheda",
    		description: "Nganasan (Taymyr Peninsula Samoyed) lunar goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "1,500.0",
    		center_lat: -2.5,
    		center_long: 213
    	},
    	{
    		feature_id: 3149,
    		year: 2003,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Kumang Corona",
    		type: "Goddess",
    		origin: "Indonesia",
    		continent: "Asia",
    		clean_name: "Kumang",
    		description: "Mother goddess of Ibans, the Sea Dayaks of Borneo/Kalimantan, Indonesia.",
    		bio: "",
    		search_term: "",
    		diameter: "40.0",
    		center_lat: 25,
    		center_long: 11.8
    	},
    	{
    		feature_id: 3234,
    		year: 2003,
    		feature: "Mons",
    		feature_plural: "Montes",
    		name: "Lahar Mons",
    		type: "Goddess",
    		origin: "Assyro-Babylonian",
    		continent: "Asia",
    		clean_name: "Lahar",
    		description: "Assyro-Babylonian goddess of domestic animals.",
    		bio: "",
    		search_term: "",
    		diameter: "225.0",
    		center_lat: 14,
    		center_long: 162
    	},
    	{
    		feature_id: 3248,
    		year: 2003,
    		feature: "Tholus",
    		feature_plural: "Tholi",
    		name: "Lama Tholus",
    		type: "Goddess",
    		origin: "Sumerian",
    		continent: "Asia",
    		clean_name: "Lama",
    		description: "Sumerian protective goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "110.0",
    		center_lat: 7.8,
    		center_long: 266
    	},
    	{
    		feature_id: 3251,
    		year: 2003,
    		feature: "Mons",
    		feature_plural: "Montes",
    		name: "Lamashtu Mons",
    		type: "Goddess",
    		origin: "Sumerian",
    		continent: "Asia",
    		clean_name: "Lamashtu",
    		description: "Sumerian goddess who inflicted children with diseases.",
    		bio: "In Mesopotamian mythology, Lamashtu was a female demon, monster, malevolent goddess or demigoddess who menaced women during childbirth and, if possible, kidnapped their children while they were breastfeeding. She would gnaw on their bones and suck their blood, as well as being charged with a number of other evil deeds. She was a daughter of the Sky God Anu.",
    		search_term: "Lamashtu",
    		diameter: "260.0",
    		center_lat: 2.8,
    		center_long: 172.7
    	},
    	{
    		feature_id: 3346,
    		year: 2003,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Lengdin Corona",
    		type: "Goddess",
    		origin: "China",
    		continent: "Asia",
    		clean_name: "Lengdin",
    		description: "Chinese Earth goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "525.0",
    		center_lat: 2.5,
    		center_long: 223
    	},
    	{
    		feature_id: 3515,
    		year: 2003,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Lumimuut Corona",
    		type: "Goddess",
    		origin: "Indonesia",
    		continent: "Asia",
    		clean_name: "Lumimuut",
    		description: "Minahas (N. Sulavesi, Indonesia) ancestor goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "230.0",
    		center_lat: -11.5,
    		center_long: 234.5
    	},
    	{
    		feature_id: 3959,
    		year: 2003,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Momu Coronae",
    		type: "Goddess",
    		origin: "Caucasus",
    		continent: "Asia",
    		clean_name: "Momu",
    		description: "Darghinan (Daghestan) childbirth deity.",
    		bio: "",
    		search_term: "",
    		diameter: "260.0",
    		center_lat: -21,
    		center_long: 220.3
    	},
    	{
    		feature_id: 4108,
    		year: 2003,
    		feature: "Fossa",
    		feature_plural: "Fossae",
    		name: "Naguchitsa Fossae",
    		type: "Goddess",
    		origin: "Caucasus",
    		continent: "Asia",
    		clean_name: "Naguchitsa",
    		description: "Adygan evil warrior, old woman with iron teeth.",
    		bio: "",
    		search_term: "",
    		diameter: "730.0",
    		center_lat: -35.6,
    		center_long: 159.3
    	},
    	{
    		feature_id: 4130,
    		year: 2003,
    		feature: "Farrum",
    		feature_plural: "Farra",
    		name: "Nammu Farra",
    		type: "Goddess",
    		origin: "Assyro-Babylonian",
    		continent: "Asia",
    		clean_name: "Nammu",
    		description: "Assyro-Babylonian goddess of the waters of creation.",
    		bio: "Nammu was a Mesopotamian goddess regarded as a creator deity in the local theology of Eridu. It is assumed that she was associated with water. She is also well attested in connection with incantations and apotropaic magic.",
    		search_term: "Nammu",
    		diameter: "160.0",
    		center_lat: 2.3,
    		center_long: 169.4
    	},
    	{
    		feature_id: 4298,
    		year: 2003,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Ninmah Corona",
    		type: "Goddess",
    		origin: "Akkadian (Accadian)",
    		continent: "Asia",
    		clean_name: "Ninmah",
    		description: "Sumer-Akkadian mother goddess.",
    		bio: "Ninḫursaĝ sometimes transcribed Ninursag, Ninḫarsag, or Ninḫursaĝa, also known as Damgalnuna or Ninmah, was the ancient Sumerian mother goddess of the mountains, and one of the seven great deities of Sumer. She is known earliest as a nurturing or fertility goddess. Temple hymn sources identify her as the 'true and great lady of heaven' (possibly in relation to her standing on the mountain) and kings of Lagash were 'nourished by Ninhursag's milk'.",
    		search_term: "Ninhursag",
    		diameter: "700.0",
    		center_lat: 16.5,
    		center_long: 49
    	},
    	{
    		feature_id: 4550,
    		year: 2003,
    		feature: "Tholus",
    		feature_plural: "Tholi",
    		name: "Pajan Yan Tholus",
    		type: "Goddess",
    		origin: "Cambodia",
    		continent: "Asia",
    		clean_name: "Pajan Yan",
    		description: "Cambodian healing goddess whose face appears in markings on the Moon.",
    		bio: "",
    		search_term: "",
    		diameter: "80.0",
    		center_lat: 8.3,
    		center_long: 252.2
    	},
    	{
    		feature_id: 4591,
    		year: 2003,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Parma Corona",
    		type: "Goddess",
    		origin: "Komi",
    		continent: "Asia",
    		clean_name: "Parma",
    		description: "Komi-Permyakan (Ural Finn) personification of wilderness, in particular, of the North Ural taiga-covered uplands; mother of the first man, Pera.",
    		bio: "",
    		search_term: "",
    		diameter: "110.0",
    		center_lat: 44.5,
    		center_long: 17.5
    	},
    	{
    		feature_id: 4794,
    		year: 2003,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Ponmakya Corona",
    		type: "Goddess",
    		origin: "Myanmar",
    		continent: "Asia",
    		clean_name: "Ponmakya",
    		description: "Burman (Myanmar) fertility goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "280.0",
    		center_lat: 34.3,
    		center_long: 11.8
    	},
    	{
    		feature_id: 4855,
    		year: 2003,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Prthivi Corona",
    		type: "Goddess",
    		origin: "India",
    		continent: "Asia",
    		clean_name: "Prthivi",
    		description: "Hindu (India) mother goddess.",
    		bio: "Prithvi or Prithvi Mata is the Sanskrit name for the earth, as well as the name of a devi (goddess) in Hinduism and some branches of Buddhism. In the Vedas, her consort is Dyaus Pita, the sky god. Her counterpart later in Puranas, is known as Bhumi, Varaha's wife.",
    		search_term: "Prthivi",
    		diameter: "375.0",
    		center_lat: 10.8,
    		center_long: 248.5
    	},
    	{
    		feature_id: 4934,
    		year: 2003,
    		feature: "Chasma",
    		feature_plural: "Chasmata",
    		name: "Ralk-umgu Chasma",
    		type: "Goddess",
    		origin: "Siberia",
    		continent: "Asia",
    		clean_name: "Ralk-umgu",
    		description: "Nivkhan (Sakhalin Island) “lunar woman.”",
    		bio: "",
    		search_term: "",
    		diameter: "840.0",
    		center_lat: -15,
    		center_long: 106
    	},
    	{
    		feature_id: 5297,
    		year: 2003,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Samsing Corona",
    		type: "Goddess",
    		origin: "Korea",
    		continent: "Asia",
    		clean_name: "Samsing",
    		description: "Korean childcare deity, a good grandmother.",
    		bio: "",
    		search_term: "",
    		diameter: "165.0",
    		center_lat: -23.8,
    		center_long: 229.5
    	},
    	{
    		feature_id: 5542,
    		year: 2003,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Simoting Corona",
    		type: "Goddess",
    		origin: "India",
    		continent: "Asia",
    		clean_name: "Simoting",
    		description: "Naga (Tibetan people in NE India) ancestor of all people.",
    		bio: "",
    		search_term: "",
    		diameter: "270.0",
    		center_lat: 41.2,
    		center_long: 21.5
    	},
    	{
    		feature_id: 5817,
    		year: 2003,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Tadaka Corona",
    		type: "Goddess",
    		origin: "India",
    		continent: "Asia",
    		clean_name: "Tadaka",
    		description: "Indian Earth and nature goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "260.0",
    		center_lat: -4,
    		center_long: 210.5
    	},
    	{
    		feature_id: 5870,
    		year: 2003,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Tari Pennu Corona",
    		type: "Goddess",
    		origin: "India",
    		continent: "Asia",
    		clean_name: "Tari Pennu",
    		description: "Khonds (India) Earth goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "180.0",
    		center_lat: 0.3,
    		center_long: 264.3
    	},
    	{
    		feature_id: 5951,
    		year: 2003,
    		feature: "Linea",
    		feature_plural: "Lineae",
    		name: "Thaukhud Linea",
    		type: "Goddess",
    		origin: "Caucasus",
    		continent: "Asia",
    		clean_name: "Thaukhud",
    		description: "Adygan (N. Caucasus) brave female warrior, a good spirit.",
    		bio: "",
    		search_term: "",
    		diameter: "900.0",
    		center_lat: -24,
    		center_long: 232
    	},
    	{
    		feature_id: 6199,
    		year: 2003,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Ulgen-ekhe Coronae",
    		type: "Goddess",
    		origin: "Buriat",
    		continent: "Asia",
    		clean_name: "Ulgen-ekhe",
    		description: "Buryatan Earth mother.",
    		bio: "",
    		search_term: "",
    		diameter: "300.0",
    		center_lat: -14.2,
    		center_long: 224
    	},
    	{
    		feature_id: 6409,
    		year: 2003,
    		feature: "Vallis",
    		feature_plural: "Valles",
    		name: "Vishera Vallis",
    		type: "Goddess",
    		origin: "Komi",
    		continent: "Asia",
    		clean_name: "Vishera",
    		description: "Komi-Permyakan (Ural Finn) girl who turned into a river with the same name.",
    		bio: "",
    		search_term: "",
    		diameter: "300.0",
    		center_lat: -33.1,
    		center_long: 161.6
    	},
    	{
    		feature_id: 6621,
    		year: 2003,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Ya-Yerv Corona",
    		type: "Goddess",
    		origin: "Siberia",
    		continent: "Asia",
    		clean_name: "Ya-Yerv",
    		description: "Nenets (Samoyed) Earth mother.",
    		bio: "",
    		search_term: "",
    		diameter: "275.0",
    		center_lat: -9,
    		center_long: 214
    	},
    	{
    		feature_id: 6696,
    		year: 2003,
    		feature: "Mons",
    		feature_plural: "Montes",
    		name: "Zaltu Mons",
    		type: "Goddess",
    		origin: "Assyro-Babylonian",
    		continent: "Asia",
    		clean_name: "Zaltu",
    		description: "Assyro-Babylonian goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "220.0",
    		center_lat: 18,
    		center_long: 163.5
    	},
    	{
    		feature_id: 5498,
    		year: 2003,
    		feature: "Vallis",
    		feature_plural: "Valles",
    		name: "Sholpan Vallis",
    		type: "Other",
    		origin: "Kazakhstan",
    		continent: "Asia",
    		clean_name: "Sholpan ",
    		description: "Kazakh and Karakalpak name of planet Venus.",
    		bio: "",
    		search_term: "",
    		diameter: "590.0",
    		center_lat: -63.9,
    		center_long: 150
    	},
    	{
    		feature_id: 1085,
    		year: 2003,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Cavell Corona",
    		type: "Famous Woman",
    		origin: "Great Britain",
    		continent: "Europe",
    		clean_name: "Cavell",
    		description: "Edith; British nurse, heroine (1865-1915). (Changed from Cavell Patera.)",
    		bio: "Edith Louisa Cavell ( KAV-əl; 4 December 1865 – 12 October 1915) was a British nurse. She is celebrated for saving the lives of soldiers from both sides without discrimination and for helping some 200 Allied soldiers escape from German-occupied Belgium during the First World War, for which she was arrested under martial law. She was accused of treason, found guilty by a court-martial and sentenced to death. Despite international pressure for mercy, she was shot by a German firing squad. Her execution received worldwide condemnation and extensive press coverage. ",
    		search_term: "Edith Cavell",
    		diameter: "100.0",
    		center_lat: 38.3,
    		center_long: 18.8
    	},
    	{
    		feature_id: 1174,
    		year: 2003,
    		feature: "Patera",
    		feature_plural: "Paterae",
    		name: "Cherskaya Patera",
    		type: "Famous Woman",
    		origin: "Russia",
    		continent: "Europe",
    		clean_name: "Cherskaya",
    		description: "Mavra Pavlovna; Russian explorer of E. Siberia, wife of Ivan Chersky (c. 1850 - c. 1900).",
    		bio: "",
    		search_term: "",
    		diameter: "85.0",
    		center_lat: -5.2,
    		center_long: 232.5
    	},
    	{
    		feature_id: 3606,
    		year: 2003,
    		feature: "Patera",
    		feature_plural: "Paterae",
    		name: "Malibran Patera",
    		type: "Famous Woman",
    		origin: "Spain",
    		continent: "Europe",
    		clean_name: "Malibran",
    		description: "Maria Felicia Garcia; Spanish/French singer (1808-1836), sister of Pauline Viardot-Garcia (see Viardot Patera).",
    		bio: "Maria Felicia Malibran (24 March 1808 – 23 September 1836) was a Spanish singer who commonly sang both contralto and soprano parts, and was one of the best-known opera singers of the 19th century. Malibran was known for her stormy personality and dramatic intensity, becoming a legendary figure after her death in Manchester, England, at age 28. Contemporary accounts of her voice describe its range, power and flexibility as extraordinary.",
    		search_term: "Maria Malibran",
    		diameter: "60.0",
    		center_lat: -18.4,
    		center_long: 224.6
    	},
    	{
    		feature_id: 5300,
    		year: 2003,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Sand Corona",
    		type: "Famous Woman",
    		origin: "France",
    		continent: "Europe",
    		clean_name: "Sand",
    		description: "George (Aurore Dupin); French novelist (1804-1876). Name changed from Sand Patera.",
    		bio: "Amantine Lucile Aurore Dupin de Francueil (French: [amɑ̃tin lysil oʁɔʁ dypɛ̃]; 1 July 1804 – 8 June 1876), best known by her pen name George Sand (French: [ʒɔʁʒ sɑ̃d]), was a French novelist, memoirist, and journalist. One of the most popular writers in Europe in her lifetime, being more renowned than both Victor Hugo and Honoré de Balzac in England in the 1830s and 1840s, Sand is recognised as one of the most notable writers of the European Romantic era, with more than 70 novels to her credit and 50 volumes of various works including novels, tales, plays and political texts. Like her great-grandmother, Louise Dupin, whom she admired, George Sand stood up for women, advocated passion, castigated marriage and fought against the prejudices of a conservative society.",
    		search_term: "George Sand",
    		diameter: "181.0",
    		center_lat: 41.7,
    		center_long: 15.5
    	},
    	{
    		feature_id: 6092,
    		year: 2003,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Trotula Corona",
    		type: "Famous Woman",
    		origin: "Italy",
    		continent: "Europe",
    		clean_name: "Trotula",
    		description: "Italian physician (A.D. 1097). Name changed from Trotula Patera.",
    		bio: "Trota of Salerno (also spelled Trocta) was an Italian medical practitioner and writer whose fame spread as far as France and England in the 12th and 13th centuries. A Latin text that gathered some of her therapies was incorporated into an ensemble of treatises on women's medicine that came to be known as the Trotula. Misconceptions about the author of Trotula contributed to the erasure or modification of her name, gender, level of education, medical knowledge, or the time period in which the texts were written.",
    		search_term: "Trota of Salerno",
    		diameter: "146.0",
    		center_lat: 41.3,
    		center_long: 18.9
    	},
    	{
    		feature_id: 1762,
    		year: 2003,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Elenora",
    		type: "First Name",
    		origin: "Germany",
    		continent: "Europe",
    		clean_name: "Elenora",
    		description: "German first name (variation of Eleanor).",
    		bio: "",
    		search_term: "",
    		diameter: "4.5",
    		center_lat: 47.1,
    		center_long: 6.9
    	},
    	{
    		feature_id: 1853,
    		year: 2003,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Esterica",
    		type: "First Name",
    		origin: "Romania (Rumania)",
    		continent: "Europe",
    		clean_name: "Esterica",
    		description: "Romanian first name.",
    		bio: "",
    		search_term: "",
    		diameter: "3.6",
    		center_lat: 36.8,
    		center_long: 3.6
    	},
    	{
    		feature_id: 1962,
    		year: 2003,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Fiona",
    		type: "First Name",
    		origin: "Celtic",
    		continent: "Europe",
    		clean_name: "Fiona",
    		description: "Celtic first name.",
    		bio: "",
    		search_term: "",
    		diameter: "3.5",
    		center_lat: 5,
    		center_long: 166.6
    	},
    	{
    		feature_id: 41,
    		year: 2003,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Acrea Corona",
    		type: "Goddess",
    		origin: "Greek",
    		continent: "Europe",
    		clean_name: "Acrea",
    		description: "Greek resplendent mother goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "200.0",
    		center_lat: 24.2,
    		center_long: 243.7
    	},
    	{
    		feature_id: 169,
    		year: 2003,
    		feature: "Tholus",
    		feature_plural: "Tholi",
    		name: "Alcyone Tholus",
    		type: "Goddess",
    		origin: "Greek",
    		continent: "Europe",
    		clean_name: "Alcyone",
    		description: "Greek goddess who is the personification of a rain cloud.",
    		bio: "In Greek mythology, Alcyone or Halcyone and Ceyx were a wife and husband who incurred the wrath of the god Zeus.",
    		search_term: "Alcyone",
    		diameter: "70.0",
    		center_lat: -2.1,
    		center_long: 256.4
    	},
    	{
    		feature_id: 743,
    		year: 2003,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Bil Corona",
    		type: "Goddess",
    		origin: "Norse",
    		continent: "Europe",
    		clean_name: "Bil",
    		description: "Norse-Viking Earth and nature goddess.",
    		bio: "In Norse mythology, Hjúki and Bil are a brother and sister pair of children who follow the personified moon, Máni, across the heavens. Scholarly theories that surround the two concern their nature, their role as potential personifications of the craters on the Moon or its phases.",
    		search_term: "Bil",
    		diameter: "225.0",
    		center_lat: 3,
    		center_long: 168
    	},
    	{
    		feature_id: 775,
    		year: 2003,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Blid Corona",
    		type: "Goddess",
    		origin: "Scandinavian",
    		continent: "Europe",
    		clean_name: "Blid",
    		description: "Scandinavian Earth, nature, and happiness goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "175.0",
    		center_lat: -0.5,
    		center_long: 231.3
    	},
    	{
    		feature_id: 837,
    		year: 2003,
    		feature: "Dorsum",
    		feature_plural: "Dorsa",
    		name: "Boszorkány Dorsa",
    		type: "Goddess",
    		origin: "Hungary",
    		continent: "Europe",
    		clean_name: "Boszorkány",
    		description: "Hungarian witch, flies over the sky.",
    		bio: "",
    		search_term: "",
    		diameter: "550.0",
    		center_lat: -19.5,
    		center_long: 105
    	},
    	{
    		feature_id: 1248,
    		year: 2003,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Clonia Corona",
    		type: "Goddess",
    		origin: "Greek",
    		continent: "Europe",
    		clean_name: "Clonia",
    		description: "Greek Earth and nature goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "100.0",
    		center_lat: 16,
    		center_long: 167.4
    	},
    	{
    		feature_id: 1397,
    		year: 2003,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Damona Corona",
    		type: "Goddess",
    		origin: "France",
    		continent: "Europe",
    		clean_name: "Damona",
    		description: "Gaulish fertility goddess, “Great Cow.”",
    		bio: "Damona was a goddess worshipped in Gaul. She has been described as the patron deity of the hot springs at Bourbonne-les-Bains.",
    		search_term: "Damona",
    		diameter: "140.0",
    		center_lat: 48.9,
    		center_long: 28
    	},
    	{
    		feature_id: 1717,
    		year: 2003,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Edda Corona",
    		type: "Goddess",
    		origin: "Scotland",
    		continent: "Europe",
    		clean_name: "Edda",
    		description: "Scandinavian goddess, “great grandmother“, first woman to produce offspring.",
    		bio: "",
    		search_term: "",
    		diameter: "50.0",
    		center_lat: 47.2,
    		center_long: 25.4
    	},
    	{
    		feature_id: 1908,
    		year: 2003,
    		feature: "Mons",
    		feature_plural: "Montes",
    		name: "Fand Mons",
    		type: "Goddess",
    		origin: "Celtic",
    		continent: "Europe",
    		clean_name: "Fand",
    		description: "Celtic goddess of healing and pleasure.",
    		bio: "Fand (\"tear\", \"teardrop of beauty\") or Fann (\"weak, helpless person'\") is an otherworldly woman in Irish mythology. She appears most prominently in the Ulster Cycle tale, Serglige Con Culainn (\"The Sickbed of Cúchulainn\"). She enters the story in the form of an otherworldly sea bird.",
    		search_term: "Fand",
    		diameter: "300.0",
    		center_lat: 7,
    		center_long: 158
    	},
    	{
    		feature_id: 2295,
    		year: 2003,
    		feature: "Mons",
    		feature_plural: "Montes",
    		name: "Gwen Mons",
    		type: "Goddess",
    		origin: "Celtic",
    		continent: "Europe",
    		clean_name: "Gwen",
    		description: "Irish goddess of happiness and smiles.",
    		bio: "",
    		search_term: "",
    		diameter: "200.0",
    		center_lat: -21.4,
    		center_long: 238.7
    	},
    	{
    		feature_id: 2543,
    		year: 2003,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Holla Corona",
    		type: "Goddess",
    		origin: "Germany",
    		continent: "Europe",
    		clean_name: "Holla",
    		description: "German Earth, nature, and household affairs goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "180.0",
    		center_lat: -13,
    		center_long: 237.7
    	},
    	{
    		feature_id: 2631,
    		year: 2003,
    		feature: "Tholus",
    		feature_plural: "Tholi",
    		name: "Iaso Tholus",
    		type: "Goddess",
    		origin: "Greek",
    		continent: "Europe",
    		clean_name: "Iaso",
    		description: "Greek goddess of health, medicine, and recovery.",
    		bio: "Iaso was the Greek goddess of recuperation from illness. The daughter of Asclepius, she had four sisters. All five were associated with some aspect of health or healing.",
    		search_term: "Iaso",
    		diameter: "30.0",
    		center_lat: 5.2,
    		center_long: 255.3
    	},
    	{
    		feature_id: 2669,
    		year: 2003,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Ilmatar Corona",
    		type: "Goddess",
    		origin: "Finland",
    		continent: "Europe",
    		clean_name: "Ilmatar",
    		description: "Finnish sky goddess, creator of the world.",
    		bio: "In the Kalevala, the Finnish national epic, Ilmatar was a virgin spirit and goddess of the air. The name Ilmatar is derived from the Finnish word ilma, meaning \"air,\" and the female suffix -tar, corresponding to English \"-ress\". Thus, her name means Airress. She was impregnated by the sea and wind.",
    		search_term: "Ilmatar",
    		diameter: "110.0",
    		center_lat: 34.3,
    		center_long: 25
    	},
    	{
    		feature_id: 2794,
    		year: 2003,
    		feature: "Chasma",
    		feature_plural: "Chasmata",
    		name: "Jana Chasma",
    		type: "Goddess",
    		origin: "Romania (Rumania)",
    		continent: "Europe",
    		clean_name: "Jana",
    		description: "Roman moon goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "650.0",
    		center_lat: -12.2,
    		center_long: 117.9
    	},
    	{
    		feature_id: 3079,
    		year: 2003,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Kolias Corona",
    		type: "Goddess",
    		origin: "Greek",
    		continent: "Europe",
    		clean_name: "Kolias",
    		description: "Greek Earth, nature, and foothills goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "200.0",
    		center_lat: -16.5,
    		center_long: 207.9
    	},
    	{
    		feature_id: 3942,
    		year: 2003,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Modron Corona",
    		type: "Goddess",
    		origin: "Wales",
    		continent: "Europe",
    		clean_name: "Modron",
    		description: "Welsh divine mother goddess.",
    		bio: "Modron (\"mother\") largely features in the Welsh tradition as a supernatural mother figure. She may have been a prototype for Morgan le Fay from the Arthurian legend.",
    		search_term: "Modron",
    		diameter: "50.0",
    		center_lat: 32.8,
    		center_long: 23.1
    	},
    	{
    		feature_id: 4624,
    		year: 2003,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Pazar-ana Corona",
    		type: "Goddess",
    		origin: "Moldova",
    		continent: "Europe",
    		clean_name: "Pazar-ana",
    		description: "Gagauzan (Moldova) “Sunday mother,“ protector of women.",
    		bio: "",
    		search_term: "",
    		diameter: "300.0",
    		center_lat: -3.2,
    		center_long: 214.8
    	},
    	{
    		feature_id: 4941,
    		year: 2003,
    		feature: "Collis",
    		feature_plural: "Colles",
    		name: "Ran Colles",
    		type: "Goddess",
    		origin: "Scandinavian",
    		continent: "Europe",
    		clean_name: "Ran",
    		description: "Scandinavian sea goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "400.0",
    		center_lat: 1,
    		center_long: 163
    	},
    	{
    		feature_id: 5151,
    		year: 2003,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Rind Corona",
    		type: "Goddess",
    		origin: "Norse",
    		continent: "Europe",
    		clean_name: "Rind",
    		description: "Norse “Earth's Winter Queen,“ personification of the frost-covered Earth.",
    		bio: "",
    		search_term: "",
    		diameter: "140.0",
    		center_lat: 8.2,
    		center_long: 247.5
    	},
    	{
    		feature_id: 5250,
    		year: 2003,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Rzhanitsa Corona",
    		type: "Goddess",
    		origin: "Russia",
    		continent: "Europe",
    		clean_name: "Rzhanitsa",
    		description: "Russian goddess of rye fields.",
    		bio: "",
    		search_term: "",
    		diameter: "450.0",
    		center_lat: -17.6,
    		center_long: 214.6
    	},
    	{
    		feature_id: 5433,
    		year: 2003,
    		feature: "Mons",
    		feature_plural: "Montes",
    		name: "Sephira Mons",
    		type: "Goddess",
    		origin: "Spain",
    		continent: "Europe",
    		clean_name: "Sephira",
    		description: "Spanish goddess of intelligence and creativity.",
    		bio: "",
    		search_term: "",
    		diameter: "275.0",
    		center_lat: -43,
    		center_long: 28
    	},
    	{
    		feature_id: 6137,
    		year: 2003,
    		feature: "Planum",
    		feature_plural: "Plana",
    		name: "Turan Planum",
    		type: "Goddess",
    		origin: "Italy",
    		continent: "Europe",
    		clean_name: "Turan",
    		description: "Etruscan goddess of love, health, and fertility.",
    		bio: "Turan was the Etruscan goddess of love, fertility and vitality and patroness of the city of Velch. Turan was commonly associated with birds such as the dove, goose and above all the swan. Her name is the pre-Hellenic root of \"Turannos\" (i.e. tyrant).",
    		search_term: "Turan (mythology)",
    		diameter: "800.0",
    		center_lat: -13,
    		center_long: 116.5
    	},
    	{
    		feature_id: 6343,
    		year: 2003,
    		feature: "Linea",
    		feature_plural: "Lineae",
    		name: "Veleda Linea",
    		type: "Goddess",
    		origin: "Celtic",
    		continent: "Europe",
    		clean_name: "Veleda",
    		description: "Warrior goddess of the continental Celts.",
    		bio: "Veleda was seeress of the Bructeri, a Germanic people who achieved some prominence during the Batavian rebellion of AD 69–70. She gained prominence when she correctly predicted the initial successes of the rebels against Roman legions. In the latter half of the 1st century AD Veleda was regarded as a deity by most of the tribes in central Germany and enjoyed wide influence.",
    		search_term: "Veleda",
    		diameter: "1,350.0",
    		center_lat: -10,
    		center_long: 213
    	},
    	{
    		feature_id: 6404,
    		year: 2003,
    		feature: "Planum",
    		feature_plural: "Plana",
    		name: "Viriplaca Planum",
    		type: "Goddess",
    		origin: "Romania (Rumania)",
    		continent: "Europe",
    		clean_name: "Viriplaca",
    		description: "Roman goddess of matrimonial love and happiness.",
    		bio: "Viriplaca, in Roman mythology, was \"the goddess who soothes the anger of man,\" and was applied as a surname of Juno, describing her as the bringer of peace among married couples. She had a sacellum on the Palatine, into which women went when they thought themselves wronged by their husbands. They told the goddess about their grief, after which they would be relieved of their trouble.",
    		search_term: "Viriplaca",
    		diameter: "1,200.0",
    		center_lat: -20,
    		center_long: 112
    	},
    	{
    		feature_id: 6593,
    		year: 2003,
    		feature: "Mons",
    		feature_plural: "Montes",
    		name: "Wyrd Mons",
    		type: "Goddess",
    		origin: "England",
    		continent: "Europe",
    		clean_name: "Wyrd",
    		description: "Anglo-Saxon weaving goddess.",
    		bio: "Wyrd is a concept in Anglo-Saxon culture roughly corresponding to fate or personal destiny. The word is ancestral to Modern English weird, whose meaning has drifted towards an adjectival use with a more general sense of \"supernatural\" or \"uncanny\", or simply \"unexpected\".",
    		search_term: "Wyrd",
    		diameter: "150.0",
    		center_lat: 14,
    		center_long: 247.2
    	},
    	{
    		feature_id: 6641,
    		year: 2003,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Yaroslavna Corona",
    		type: "Goddess",
    		origin: "Russia",
    		continent: "Europe",
    		clean_name: "Yaroslavna",
    		description: "Russian, wife of Price Igor; patiently waited for his return from captivity (12th century). Name changed from Yaroslavna Patera.",
    		bio: "",
    		search_term: "",
    		diameter: "112.0",
    		center_lat: 38.8,
    		center_long: 21.2
    	},
    	{
    		feature_id: 5170,
    		year: 2003,
    		feature: "Patera",
    		feature_plural: "Paterae",
    		name: "Rogneda Patera",
    		type: "Famous Woman",
    		origin: "Slavic",
    		continent: "Multiple",
    		clean_name: "Rogneda",
    		description: "Gorislava; E. Slavic princess, wife of Vladimir 'The Red Sun', duke of Kiev, mother of Yaroslav 'The Wise', grand duke of Kiev (c. 950-1000).",
    		bio: "",
    		search_term: "",
    		diameter: "120.0",
    		center_lat: -2.8,
    		center_long: 220.5
    	},
    	{
    		feature_id: 1691,
    		year: 2003,
    		feature: "Chasma",
    		feature_plural: "Chasmata",
    		name: "Dziwica Chasma",
    		type: "Goddess",
    		origin: "Slavic",
    		continent: "Multiple",
    		clean_name: "Dziwica",
    		description: "Forest maiden in myths of Luzicke Serby/Sorben/Wenden, W. Slavic group in E. Germany.",
    		bio: "",
    		search_term: "",
    		diameter: "1,300.0",
    		center_lat: -16.5,
    		center_long: 235
    	},
    	{
    		feature_id: 3097,
    		year: 2003,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Kostroma Coronae",
    		type: "Goddess",
    		origin: "Slavic",
    		continent: "Multiple",
    		clean_name: "Kostroma",
    		description: "E. Slavic female deity of spring and fertility.",
    		bio: "Kostroma is an East Slavic fertility goddess. Her name is derived from the Russian word for \"bonfire\". During the Semik festival, a disguised girl or a straw figure portrayed Kostroma. First, a scarecrow was honored and revered. Then, participants of the rite mourned the death of Kostroma, and burned or tore the scarecrow. Rituals with Kostroma were aimed at improving soil fertility.",
    		search_term: "Kostroma (deity)",
    		diameter: "230.0",
    		center_lat: 40.6,
    		center_long: 7.6
    	},
    	{
    		feature_id: 3358,
    		year: 2003,
    		feature: "Chasma",
    		feature_plural: "Chasmata",
    		name: "Lesavka Chasma",
    		type: "Goddess",
    		origin: "Slavic",
    		continent: "Multiple",
    		clean_name: "Lesavka",
    		description: "E. Slavic forest deity, daughter of the forest father Leshiy and the swamp deity Kikimora.",
    		bio: "",
    		search_term: "",
    		diameter: "800.0",
    		center_lat: -0.8,
    		center_long: 215
    	},
    	{
    		feature_id: 611,
    		year: 2003,
    		feature: "Patera",
    		feature_plural: "Paterae",
    		name: "Barnes Patera",
    		type: "Famous Woman",
    		origin: "United States",
    		continent: "North America",
    		clean_name: "Barnes",
    		description: "Florence Lowe “Pancho“; American aviatrix (1901-1975).",
    		bio: "Florence Lowe 'Pancho' Barnes (July 22, 1901 – March 30, 1975) was a pioneer aviator and a founder of the first movie stunt pilots' union. In 1930, she broke Amelia Earhart's air speed record. Barnes raced in the Women's Air Derby and was a member of the Ninety-Nines.",
    		search_term: "Pancho Barnes",
    		diameter: "15.0",
    		center_lat: -15.5,
    		center_long: 229.2
    	},
    	{
    		feature_id: 1532,
    		year: 2003,
    		feature: "Patera",
    		feature_plural: "Paterae",
    		name: "Dietrich Patera",
    		type: "Famous Woman",
    		origin: "United States",
    		continent: "North America",
    		clean_name: "Dietrich",
    		description: "Marlene (Maria Magdalena von Losch); German-born American actress (1901-1992).",
    		bio: "Marie Magdalene 'Marlene' Dietrich (, German: [maʁˈleːnə ˈdiːtʁɪç] ; 27 December 1901 – 6 May 1992) was a German-born American actress and singer whose career spanned from the 1910s to the 1980s.In 1920s Berlin, Dietrich performed on the stage and in silent films. Her performance as Lola-Lola in Josef von Sternberg's The Blue Angel (1930) brought her international acclaim and a contract with Paramount Pictures. She starred in many Hollywood films, including six iconic roles directed by Sternberg: Morocco (1930) (her only Academy Award nomination), Dishonored (1931), Shanghai Express and Blonde Venus (both 1932), The Scarlet Empress (1934) and The Devil Is a Woman (1935), Desire (1936) and Destry Rides Again (1939).",
    		search_term: "Marlene Dietrich",
    		diameter: "100.0",
    		center_lat: -5.3,
    		center_long: 235.3
    	},
    	{
    		feature_id: 2103,
    		year: 2003,
    		feature: "Patera",
    		feature_plural: "Paterae",
    		name: "Garbo Patera",
    		type: "Famous Woman",
    		origin: "United States",
    		continent: "North America",
    		clean_name: "Garbo",
    		description: "Greta Gustafsson; Swedish-born American actress (1905-1990).",
    		bio: "",
    		search_term: "",
    		diameter: "75.0",
    		center_lat: 1.5,
    		center_long: 258.2
    	},
    	{
    		feature_id: 6377,
    		year: 2003,
    		feature: "Patera",
    		feature_plural: "Paterae",
    		name: "Vibert-Douglas Patera",
    		type: "Famous Woman",
    		origin: "Canada",
    		continent: "North America",
    		clean_name: "Vibert-Douglas",
    		description: "Allie; Canadian astronomer (1894-1988).",
    		bio: "Allie (or Alice) Vibert Douglas, (December 15, 1894 – July 2, 1988), who usually went by her middle name, was a Canadian astronomer and the first Canadian woman to become an astrophysicist. Douglas was born in Montreal, Quebec, on 15 December 1894. Because both of Douglas' parents died the year she was born, she first lived in London, England with her brother George Vibert Douglas, and her grandmother.",
    		search_term: "Vibert Douglas",
    		diameter: "45.0",
    		center_lat: -11.6,
    		center_long: 194.3
    	},
    	{
    		feature_id: 464,
    		year: 2003,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Attabeira Corona",
    		type: "Goddess",
    		origin: "Puerto Rico",
    		continent: "North America",
    		clean_name: "Attabeira",
    		description: "Taino (Puerto Rico) fertility goddess.",
    		bio: "Atabey is an ancestral mother of the Taino, one of two supreme ancestral spirits in the Taíno religion. She was worshipped as a zemi, which is an embodiment of nature and ancestral spirit, (not to be confused with a goddess, how she is commonly referred to in colonial terms to replace Taino verbiage and culture) of fresh water and fertility; she is the female entity who represents the Earth Spirit and the Spirit of all horizontal water, lakes, streams, the sea, and the marine tides.",
    		search_term: "Atabey (goddess)",
    		diameter: "240.0",
    		center_lat: -1.5,
    		center_long: 211.5
    	},
    	{
    		feature_id: 1139,
    		year: 2003,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Chantico Corona",
    		type: "Goddess",
    		origin: "Aztec",
    		continent: "North America",
    		clean_name: "Chantico",
    		description: "Aztec hearth goddess.",
    		bio: "In Aztec religion, Chantico (\"she who dwells in the house\") is the deity reigning over the fires in the family hearth. She broke a fast by eating paprika with roasted fish, and was turned into a dog by Tonacatecuhtli as punishment. She was associated with the town of Xochimilco, stonecutters, as well as warriorship.",
    		search_term: "Chantico",
    		diameter: "200.0",
    		center_lat: -1.7,
    		center_long: 215
    	},
    	{
    		feature_id: 2752,
    		year: 2003,
    		feature: "Fluctus",
    		feature_plural: "Fluctūs",
    		name: "Itoki Fluctus",
    		type: "Goddess",
    		origin: "Nicaragua",
    		continent: "North America",
    		clean_name: "Itoki",
    		description: "Nicaraguan goddess of insects, stars, and planets.",
    		bio: "",
    		search_term: "",
    		diameter: "900.0",
    		center_lat: -6,
    		center_long: 229
    	},
    	{
    		feature_id: 2767,
    		year: 2003,
    		feature: "Mons",
    		feature_plural: "Montes",
    		name: "Ixtab Mons",
    		type: "Goddess",
    		origin: "Mayan",
    		continent: "North America",
    		clean_name: "Ixtab",
    		description: "Mayan goddess of death.",
    		bio: "At the time of the Spanish conquest of Yucatán (1527–1546), Ix Tab or Ixtab (\"Rope Woman\", \"Hangwoman\") was the indigenous Maya goddess of suicide by hanging. Playing the role of a psychopomp, she would accompany such suicides to heaven.",
    		search_term: "Ixtab",
    		diameter: "80.0",
    		center_lat: 15.7,
    		center_long: 242.2
    	},
    	{
    		feature_id: 4304,
    		year: 2003,
    		feature: "Tholus",
    		feature_plural: "Tholi",
    		name: "Nipa Tholus",
    		type: "Goddess",
    		origin: "Algonquin",
    		continent: "North America",
    		clean_name: "Nipa",
    		description: "Algonquin moon goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "140.0",
    		center_lat: 8.4,
    		center_long: 255.7
    	},
    	{
    		feature_id: 4464,
    		year: 2003,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Onenhste Corona",
    		type: "Goddess",
    		origin: "Iroquois",
    		continent: "North America",
    		clean_name: "Onenhste",
    		description: "Mohawk/Iroquois corn maiden, the eldest of the Three Sisters, the harvest deities.",
    		bio: "",
    		search_term: "",
    		diameter: "230.0",
    		center_lat: -19,
    		center_long: 221.5
    	},
    	{
    		feature_id: 4859,
    		year: 2003,
    		feature: "Mons",
    		feature_plural: "Montes",
    		name: "Ptesanwi Mons",
    		type: "Goddess",
    		origin: "Sioux",
    		continent: "North America",
    		clean_name: "Ptesanwi",
    		description: "Lakota (Sioux) White Buffalo Woman.",
    		bio: "White Buffalo Calf Woman or White Buffalo Maiden is a sacred woman of supernatural origin, central to the Lakota religion as the primary cultural prophet. Oral traditions relate that she brought the \"Seven Sacred Rites\" to the Lakota people.",
    		search_term: "Ptesanwi",
    		diameter: "200.0",
    		center_lat: 2.8,
    		center_long: 45.4
    	},
    	{
    		feature_id: 6616,
    		year: 2003,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Xquiq Corona",
    		type: "Goddess",
    		origin: "Mayan",
    		continent: "North America",
    		clean_name: "Xquiq",
    		description: "Mayan fertility and motherhood divinity.",
    		bio: "Xquic (sometimes glossed as \"Blood Moon\" or \"Blood Girl/Maiden\" in English) is a mythological figure known from the 16th century. She was the daughter of one of the lords of the Mayan underworld. Noted particularly for being the mother of the Maya Hero Twins, Hunahpu and Xbalanque, she is sometimes considered to be the Maya goddess associated with the waning moon.",
    		search_term: "Xquiq",
    		diameter: "55.0",
    		center_lat: 38.1,
    		center_long: 14.6
    	},
    	{
    		feature_id: 1930,
    		year: 2003,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Fefafa Corona",
    		type: "Goddess",
    		origin: "Polynesia",
    		continent: "Oceania",
    		clean_name: "Fefafa",
    		description: "Polynesian goddess of Earth, nature, and the life/death cycle.",
    		bio: "",
    		search_term: "",
    		diameter: "100.0",
    		center_lat: -24.8,
    		center_long: 210.8
    	},
    	{
    		feature_id: 2681,
    		year: 2003,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Inacho Corona",
    		type: "Goddess",
    		origin: "Micronesia",
    		continent: "Oceania",
    		clean_name: "Inacho",
    		description: "Micronesian Earth and nature goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "125.0",
    		center_lat: -20.5,
    		center_long: 212.2
    	},
    	{
    		feature_id: 4195,
    		year: 2003,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Nei-Teukez Corona",
    		type: "Goddess",
    		origin: "Micronesia",
    		continent: "Oceania",
    		clean_name: "Nei-Teukez",
    		description: "Micronesian (Gilbert Islands, Kiribati) mother of gods.",
    		bio: "",
    		search_term: "",
    		diameter: "90.0",
    		center_lat: 14.2,
    		center_long: 258.8
    	},
    	{
    		feature_id: 4582,
    		year: 2003,
    		feature: "Tholus",
    		feature_plural: "Tholi",
    		name: "Paoro Tholi",
    		type: "Goddess",
    		origin: "New Zealand",
    		continent: "Oceania",
    		clean_name: "Paoro",
    		description: "Māori (New Zealand) goddess of echoes; she gave voice to the first woman Marikoriko.",
    		bio: "The name Paoro (Echo) appears in John White's English translation of a Māori story attributed by him to the Ngāti Hau tribe, as a personal name meaning 'Echo'. However, in the Māori language original which White also supplies, the name Paoro does not appear – instead the word used is 'pari-kārangaranga', \"echoing cliff\". In the Māori story, Mārikoriko (Twilight) is the first woman, created by Ārohirohi (Shimmering heat) from the heat of the sun and the echoing cliff.",
    		search_term: "Paoro",
    		diameter: "225.0",
    		center_lat: 10.5,
    		center_long: 268
    	},
    	{
    		feature_id: 5556,
    		year: 2003,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Sinlaku Corona",
    		type: "Goddess",
    		origin: "Micronesia",
    		continent: "Oceania",
    		clean_name: "Sinlaku",
    		description: "Micronesian (Kosrae Island, Caroline Islands) breadfruit tree goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "300.0",
    		center_lat: 17.3,
    		center_long: 260.3
    	},
    	{
    		feature_id: 6247,
    		year: 2003,
    		feature: "Collis",
    		feature_plural: "Colles",
    		name: "Urutonga Colles",
    		type: "Goddess",
    		origin: "New Zealand",
    		continent: "Oceania",
    		clean_name: "Urutonga",
    		description: "Māori sea goddess.",
    		bio: "In the mythology of some Māori tribal groups, Urutonga is the wife of Hemā, and the mother of Tāwhaki and Kahiri. Hema was killed by the Ponaturi, and Urutonga and her sons, Tāwhaki and Karihi, killed them all but two in revenge. They tricked the Ponaturi into entering a house, and then locked them in, claiming there was still time before the dawn. They then opened the door after the sun was up, the Ponaturi died at the exposure to sunlight.",
    		search_term: "Urutonga",
    		diameter: "500.0",
    		center_lat: 10,
    		center_long: 154
    	},
    	{
    		feature_id: 2806,
    		year: 2003,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Jarina Corona",
    		type: "Goddess",
    		origin: "Brazil",
    		continent: "South America",
    		clean_name: "Jarina",
    		description: "Brazilian Earth, tree, and happiness goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "250.0",
    		center_lat: 13,
    		center_long: 165
    	},
    	{
    		feature_id: 14220,
    		year: 2006,
    		feature: "Tholus",
    		feature_plural: "Tholi",
    		name: "Ezili Tholus",
    		type: "Goddess",
    		origin: "Benin",
    		continent: "Africa",
    		clean_name: "Ezili",
    		description: "Benin (West Africa) goddess of “sweet water,“ beauty, and love.",
    		bio: "Erzulie is a family of loa, or spirits, in Vodou. The Erzulie is a family of loa that are often associated with water (fluidity), femininity, and feminine bodies. Erzulie Fréda Dahomey, the \"sweet-tempered\" aspect of Erzulie, is the Haitian African spirit of love, beauty, jewelry, dancing, luxury, and flowers. She wears three wedding rings, one for each husband.",
    		search_term: "Ezili",
    		diameter: "150.0",
    		center_lat: 23.7,
    		center_long: 91.3
    	},
    	{
    		feature_id: 4284,
    		year: 2006,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Nimba Corona",
    		type: "Goddess",
    		origin: "Guinea",
    		continent: "Africa",
    		clean_name: "Nimba",
    		description: "Guinea (West Africa) Earth and mother goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "88.0",
    		center_lat: 32.8,
    		center_long: 204.5
    	},
    	{
    		feature_id: 2060,
    		year: 2006,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Gail",
    		type: "First Name",
    		origin: "Hebrew",
    		continent: "Asia",
    		clean_name: "Gail",
    		description: "Hebrew first name.",
    		bio: "",
    		search_term: "",
    		diameter: "10.0",
    		center_lat: -16.1,
    		center_long: 97.5
    	},
    	{
    		feature_id: 3421,
    		year: 2006,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Lisa",
    		type: "First Name",
    		origin: "Hebrew",
    		continent: "Asia",
    		clean_name: "Lisa",
    		description: "Short form of Elizabeth, Hebrew first name.",
    		bio: "",
    		search_term: "",
    		diameter: "4.5",
    		center_lat: 29,
    		center_long: 182
    	},
    	{
    		feature_id: 14175,
    		year: 2006,
    		feature: "Tholus",
    		feature_plural: "Tholi",
    		name: "Azimua Tholi",
    		type: "Goddess",
    		origin: "Sumerian",
    		continent: "Asia",
    		clean_name: "Azimua",
    		description: "Sumerian underworld goddess.",
    		bio: "Azimua, also known as Ninazimua, was a Mesopotamian goddess regarded as the wife of Ningishzida. Ninazimua is the original spelling of the name of this goddess, attested in sources from the Ur III period.",
    		search_term: "Azimua",
    		diameter: "40.0",
    		center_lat: -34.1,
    		center_long: 249.4
    	},
    	{
    		feature_id: 14173,
    		year: 2006,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Chanum Coronae",
    		type: "Goddess",
    		origin: "Myanmar",
    		continent: "Asia",
    		clean_name: "Chanum",
    		description: "Kachin (Tibetan people of Burma/Myanmar) creator goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "330.0",
    		center_lat: -29.2,
    		center_long: 245.5
    	},
    	{
    		feature_id: 14214,
    		year: 2006,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Durga Corona",
    		type: "Goddess",
    		origin: "Hindu",
    		continent: "Asia",
    		clean_name: "Durga",
    		description: "Hindu goddess of Earth, nature, and evil.",
    		bio: "Durga is a major Hindu goddess, worshipped as a principal aspect of the mother goddess Mahadevi. She is associated with protection, strength, motherhood, destruction, and wars. Durga's legend centres around combating evils and demonic forces that threaten peace, prosperity, and dharma, representing the power of good over evil. Durga is believed to unleash her divine wrath against the wicked for the liberation of the oppressed, and entails destruction to empower creation.",
    		search_term: "Durga",
    		diameter: "227.0",
    		center_lat: -31.1,
    		center_long: 286.2
    	},
    	{
    		feature_id: 2093,
    		year: 2006,
    		feature: "Vallis",
    		feature_plural: "Valles",
    		name: "Ganga Valles",
    		type: "Goddess",
    		origin: "India",
    		continent: "Asia",
    		clean_name: "Ganga",
    		description: "Hindu goddess of the sacred river Ganges.",
    		bio: "Ganga is the personification of the river Ganges, who is worshipped by Hindus as the goddess of purification and forgiveness. Known by many names, Ganga is often depicted as a fair, beautiful woman, riding a divine crocodile-like creature called the makara.",
    		search_term: "Ganga (goddess)",
    		diameter: "200.0",
    		center_lat: 4.8,
    		center_long: 53
    	},
    	{
    		feature_id: 3969,
    		year: 2006,
    		feature: "Tholus",
    		feature_plural: "Tholi",
    		name: "Monoshi Tholus",
    		type: "Goddess",
    		origin: "Bangladesh",
    		continent: "Asia",
    		clean_name: "Monoshi",
    		description: "Bengal goddess of snakes.",
    		bio: "",
    		search_term: "",
    		diameter: "15.0",
    		center_lat: -37.7,
    		center_long: 252
    	},
    	{
    		feature_id: 4293,
    		year: 2006,
    		feature: "Mons",
    		feature_plural: "Montes",
    		name: "Ninisinna Mons",
    		type: "Goddess",
    		origin: "Mesopotamian",
    		continent: "Asia",
    		clean_name: "Ninisinna",
    		description: "Mesopotamian goddess of health and healing.",
    		bio: "Ninisina (Sumerian: \"Mistress of Isin\") was a Mesopotamian goddess who served as the tutelary deity of the city of Isin. She was considered a healing deity. She was believed to be skilled in the medical arts, and could be described as a divine physician or midwife.",
    		search_term: "Ninisinna",
    		diameter: "110.0",
    		center_lat: 25.7,
    		center_long: 197.5
    	},
    	{
    		feature_id: 14176,
    		year: 2006,
    		feature: "Tholus",
    		feature_plural: "Tholi",
    		name: "Otohime Tholus",
    		type: "Goddess",
    		origin: "Japan",
    		continent: "Asia",
    		clean_name: "Otohime",
    		description: "Japanese goddess of the arts and beauty.",
    		bio: "Oto-hime or Otohime (Japanese: 乙姫), in the Japanese folktale of Urashima Tarō, is the princess of the undersea palace Ryūgū-jō.",
    		search_term: "Otohime",
    		diameter: "20.0",
    		center_lat: -32,
    		center_long: 268.2
    	},
    	{
    		feature_id: 14219,
    		year: 2006,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Parvati Corona",
    		type: "Goddess",
    		origin: "Hindu",
    		continent: "Asia",
    		clean_name: "Parvati",
    		description: "Hindu Earth and nature goddess, creator of life, primordial being.",
    		bio: "Parvati, Uma or Gauri is the Hindu goddess of power, energy, nourishment, harmony, love, beauty, devotion, and motherhood. She is a physical representation of Mahadevi in her complete form. She is also revered in her appearances as Durga and Kali.",
    		search_term: "Parvati",
    		diameter: "173.0",
    		center_lat: -36,
    		center_long: 276.7
    	},
    	{
    		feature_id: 5459,
    		year: 2006,
    		feature: "Mons",
    		feature_plural: "Montes",
    		name: "Shala Mons",
    		type: "Goddess",
    		origin: "Phoenician",
    		continent: "Asia",
    		clean_name: "Shala",
    		description: "Canaanite (Phoenicia) storm goddess.",
    		bio: "Shala (Šala) was a Mesopotamian goddess of weather and grain and the wife of the weather god Adad. It is assumed that she originated in northern Mesopotamia and that her name might have Hurrian origin. She was worshiped especially in Karkar and in Zabban, regarded as cult centers of her husband as well.",
    		search_term: "Shala",
    		diameter: "90.0",
    		center_lat: 39.4,
    		center_long: 208
    	},
    	{
    		feature_id: 5583,
    		year: 2006,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Sitapi Coronae",
    		type: "Goddess",
    		origin: "Indonesia",
    		continent: "Asia",
    		clean_name: "Sitapi",
    		description: "Indonesian earth, nature, and creator goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "270.0",
    		center_lat: -36.5,
    		center_long: 246.8
    	},
    	{
    		feature_id: 6053,
    		year: 2006,
    		feature: "Mons",
    		feature_plural: "Montes",
    		name: "Toma Mons",
    		type: "Goddess",
    		origin: "Tibet",
    		continent: "Asia",
    		clean_name: "Toma",
    		description: "Tibetan goddess of intelligence and creativity.",
    		bio: "",
    		search_term: "",
    		diameter: "80.0",
    		center_lat: -12.9,
    		center_long: 232
    	},
    	{
    		feature_id: 1412,
    		year: 2006,
    		feature: "Patera",
    		feature_plural: "Paterae",
    		name: "Darclée Patera",
    		type: "Famous Woman",
    		origin: "Romania (Rumania)",
    		continent: "Europe",
    		clean_name: "Darclée",
    		description: "Hariclea; Romanian soprano singer (1860-1939).",
    		bio: "Hariclea Darclée (née Haricli; later Hartulari; 10 June 1860 – 12 January 1939) was a celebrated Romanian operatic soprano who had a three-decade-long career.Darclée's repertoire ranged from coloratura soprano roles to heavier Verdi roles, including many in the Franco-Italian lyric repertory. Throughout her career she participated in several world premieres, creating the title roles in Giacomo Puccini's Tosca, Pietro Mascagni's Iris, and Alfredo Catalani's La Wally. Puccini reportedly considered her to have been 'the most beautiful and exquisite Manon'.",
    		search_term: "Hariclea Darclée",
    		diameter: "15.0",
    		center_lat: -37.4,
    		center_long: 263.8
    	},
    	{
    		feature_id: 1505,
    		year: 2006,
    		feature: "Patera",
    		feature_plural: "Paterae",
    		name: "Destinnová Patera",
    		type: "Famous Woman",
    		origin: "Czechoslovakia",
    		continent: "Europe",
    		clean_name: "Destinnová",
    		description: "Ema (pseudonym of Emilia Kittlova); Bohemian/Czech singer, also known as Emmy Destinn (1878-1930).",
    		bio: "Emmy Destinn (Ema Destinnová ([ˈɛma ˈdɛstɪnovaː] ); 26 February 1878 – 28 January 1930) was a Czech operatic soprano with a strong and soaring lyric-dramatic voice. She had a career both in Europe and at the New York Metropolitan Opera. Destinn was born Emílie Pavlína Věnceslava Kittlová ([ˈɛmiːlɪjɛ ˈpavliːna ˈvjɛntsɛslava ˈkɪtlovaː]) in Prague, in what was then the Austro-Hungarian Empire.",
    		search_term: "Emmy Destinn",
    		diameter: "15.0",
    		center_lat: -31.5,
    		center_long: 250.2
    	},
    	{
    		feature_id: 1677,
    		year: 2006,
    		feature: "Patera",
    		feature_plural: "Paterae",
    		name: "Dutrieu Patera",
    		type: "Famous Woman",
    		origin: "Belgium",
    		continent: "Europe",
    		clean_name: "Dutrieu",
    		description: "Helene; Belgian/French pioneer aviatrix (1877-1961).",
    		bio: "Hélène Dutrieu (10 July 1877 – 26 June 1961), was a Belgian cycling world champion, stunt cyclist, stunt motorcyclist, automobile racer, stunt driver, pioneer pilot, wartime ambulance driver, and director of a military hospital. Hélène Marguerite Dutrieu was born on 10 July 1877 in Tournai, Belgium, the daughter of a Belgian Army officer. The family later moved to Lille in northern France.",
    		search_term: "Helene Dutrieu",
    		diameter: "80.0",
    		center_lat: 33.8,
    		center_long: 198.5
    	},
    	{
    		feature_id: 14146,
    		year: 2006,
    		feature: "Patera",
    		feature_plural: "Paterae",
    		name: "Lindgren Patera",
    		type: "Famous Woman",
    		origin: "Sweden",
    		continent: "Europe",
    		clean_name: "Lindgren",
    		description: "Astrid; Swedish author (1907-2002).",
    		bio: "Astrid Anna Emilia Lindgren (Swedish: [ˈǎsːtrɪd ˈlɪ̌nːɡreːn] ; née Ericsson; 14 November 1907 – 28 January 2002) was a Swedish writer of fiction and screenplays. She is best known for several children's book series, featuring Pippi Longstocking, Emil of Lönneberga, Karlsson-on-the-Roof, and the Six Bullerby Children (Children of Noisy Village in the US), and for the children's fantasy novels Mio, My Son, Ronia the Robber's Daughter, and The Brothers Lionheart. Lindgren worked on the Children's Literature Editorial Board at the Rabén & Sjögren publishing house in Stockholm and wrote more than 30 books for children.",
    		search_term: "Astrid Lindgren",
    		diameter: "110.0",
    		center_lat: 28.1,
    		center_long: 241.4
    	},
    	{
    		feature_id: 6979,
    		year: 2006,
    		feature: "Patera",
    		feature_plural: "Paterae",
    		name: "Nikolaeva Patera",
    		type: "Famous Woman",
    		origin: "Russia",
    		continent: "Europe",
    		clean_name: "Nikolaeva",
    		description: "Olga V.; Russian planetologist/geochemist (1941-2000).",
    		bio: "",
    		search_term: "",
    		diameter: "100.0",
    		center_lat: 33.9,
    		center_long: 267.5
    	},
    	{
    		feature_id: 14174,
    		year: 2006,
    		feature: "Patera",
    		feature_plural: "Paterae",
    		name: "Witte Patera",
    		type: "Famous Woman",
    		origin: "Germany",
    		continent: "Europe",
    		clean_name: "Witte",
    		description: "Wilhelmine; German astronomer (1777-1854).",
    		bio: "Wilhelmine Sophie Elizabeth Witte (born Böttcher, 17 November 1777 - 17 September 1854) was a German amateur astronomer. Böttcher was born in 1777 in Hanover, as daughter of Johanne Sophie Marie, born Brinkmann (5 January 1755 - 25 November 1824) and of senator Gottfried Ernst Böttcher (16 February 1750 - 17 October 1823). She married privy councilor Friedrich Christian Witte (1773-1854) on 17 November 1797 and they had 14 children, among which Minna Witte and Friedrich Ernst Witte.",
    		search_term: "Wilhelmine Witte",
    		diameter: "35.0",
    		center_lat: -25.8,
    		center_long: 247.7
    	},
    	{
    		feature_id: 1238,
    		year: 2006,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Clementina",
    		type: "First Name",
    		origin: "Portugal",
    		continent: "Europe",
    		clean_name: "Clementina",
    		description: "Portuguese form of Clementine, French first name.",
    		bio: "",
    		search_term: "",
    		diameter: "4.0",
    		center_lat: 35.9,
    		center_long: 208.6
    	},
    	{
    		feature_id: 1488,
    		year: 2006,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Denise",
    		type: "First Name",
    		origin: "Greek",
    		continent: "Europe",
    		clean_name: "Denise",
    		description: "Greek first name.",
    		bio: "",
    		search_term: "",
    		diameter: "2.0",
    		center_lat: -14.4,
    		center_long: 94.7
    	},
    	{
    		feature_id: 30,
    		year: 2006,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Achall Corona",
    		type: "Goddess",
    		origin: "Celtic",
    		continent: "Europe",
    		clean_name: "Achall",
    		description: "Celtic earth and nature goddess.",
    		bio: "Achall is a minor character from the Ulster Cycle of Irish mythology. After her brother Erc was killed by Conall Cernach, she died of grief on a hill near Tara, which was named Achall after her. ",
    		search_term: "Achall",
    		diameter: "265.0",
    		center_lat: -31.2,
    		center_long: 259.6
    	},
    	{
    		feature_id: 6978,
    		year: 2006,
    		feature: "Linea",
    		feature_plural: "Lineae",
    		name: "Agrona Linea",
    		type: "Goddess",
    		origin: "Wales",
    		continent: "Europe",
    		clean_name: "Agrona",
    		description: "Welsh goddess of slaughter, destroyer of life.",
    		bio: "Agronā was a hypothetical reconstructed Proto-Celtic name for the River Ayr in Scotland, later applied to the River Aeron in Wales. The claim is linguistic and first appeared in William J. Watson's Celtic Placenames of Scotland (1926). Watson suggested the River Ayr in Scotland could be worked back to a hypothetical Proto-Celtic \"river goddess of slaughter and carnage\" and that the deity name was Agronā.",
    		search_term: "Agrona",
    		diameter: "2,300.0",
    		center_lat: 40,
    		center_long: 280
    	},
    	{
    		feature_id: 695,
    		year: 2006,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Benzozia Corona",
    		type: "Goddess",
    		origin: "Spain",
    		continent: "Europe",
    		clean_name: "Benzozia",
    		description: "Basque mother goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "185.0",
    		center_lat: 27.5,
    		center_long: 204.5
    	},
    	{
    		feature_id: 1788,
    		year: 2006,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Embla Coronae",
    		type: "Goddess",
    		origin: "Scandinavian",
    		continent: "Europe",
    		clean_name: "Embla",
    		description: "Scandinavian Earth goddess, creator of life.",
    		bio: "In Norse mythology, Ask and Embla — male and female respectively —were the first two humans, created by the gods.",
    		search_term: "Embla",
    		diameter: "132.0",
    		center_lat: 28.9,
    		center_long: 205.4
    	},
    	{
    		feature_id: 14217,
    		year: 2006,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Orbona Corona",
    		type: "Goddess",
    		origin: "Roman",
    		continent: "Europe",
    		clean_name: "Orbona",
    		description: "Roman goddess of children, protects orphans.",
    		bio: "In Roman mythology, Orbona was the goddess who granted new children to parents who had become childless. She was also the goddess of children, especially orphans.",
    		search_term: "Orbona",
    		diameter: "150.0",
    		center_lat: -47.8,
    		center_long: 293.2
    	},
    	{
    		feature_id: 14218,
    		year: 2006,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Partula Corona",
    		type: "Goddess",
    		origin: "Roman",
    		continent: "Europe",
    		clean_name: "Partula",
    		description: "Roman goddess of childbirth who determines the length of gestation.",
    		bio: "",
    		search_term: "",
    		diameter: "145.0",
    		center_lat: -49.7,
    		center_long: 289.2
    	},
    	{
    		feature_id: 2108,
    		year: 2006,
    		feature: "Patera",
    		feature_plural: "Paterae",
    		name: "Garland Patera",
    		type: "Famous Woman",
    		origin: "United States",
    		continent: "North America",
    		clean_name: "Garland",
    		description: "Judy; American singer and actress (1922-1969).",
    		bio: "",
    		search_term: "",
    		diameter: "45.0",
    		center_lat: 32.7,
    		center_long: 206.8
    	},
    	{
    		feature_id: 428,
    		year: 2006,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Asintmah Corona",
    		type: "Goddess",
    		origin: "Canada",
    		continent: "North America",
    		clean_name: "Asintmah",
    		description: "Athabaskan (W. Canada Subarctic) Earth and nature goddess; the first woman on Earth.",
    		bio: "",
    		search_term: "",
    		diameter: "150.0",
    		center_lat: 25.9,
    		center_long: 208
    	},
    	{
    		feature_id: 6977,
    		year: 2006,
    		feature: "Chasma",
    		feature_plural: "Chasmata",
    		name: "Hanwi Chasma",
    		type: "Goddess",
    		origin: "Sioux",
    		continent: "North America",
    		clean_name: "Hanwi",
    		description: "Oglala (Sioux) moon and sky goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "1,800.0",
    		center_lat: 10.5,
    		center_long: 247
    	},
    	{
    		feature_id: 14215,
    		year: 2006,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Hutash Corona",
    		type: "Goddess",
    		origin: "Chumash",
    		continent: "North America",
    		clean_name: "Hutash",
    		description: "Chumash (S. California) Earth and nature goddess, creator of the first people.",
    		bio: "",
    		search_term: "",
    		diameter: "91.0",
    		center_lat: -34.3,
    		center_long: 275.7
    	},
    	{
    		feature_id: 14216,
    		year: 2006,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Ikas Coronae",
    		type: "Goddess",
    		origin: "Algonquin",
    		continent: "North America",
    		clean_name: "Ikas",
    		description: "Algonquin Earth and mother goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "225.0",
    		center_lat: -40.7,
    		center_long: 288.6
    	},
    	{
    		feature_id: 4891,
    		year: 2006,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Qakma Corona",
    		type: "Goddess",
    		origin: "Canada",
    		continent: "North America",
    		clean_name: "Qakma",
    		description: "Bella Coola/Nuxalk (SW Canada) creator of life, the first woman.",
    		bio: "",
    		search_term: "",
    		diameter: "130.0",
    		center_lat: 35.5,
    		center_long: 207.1
    	},
    	{
    		feature_id: 6980,
    		year: 2006,
    		feature: "Tholus",
    		feature_plural: "Tholi",
    		name: "Wohpe Tholus",
    		type: "Goddess",
    		origin: "Lakota",
    		continent: "North America",
    		clean_name: "Wohpe",
    		description: "Lakota goddess of order, beauty, and happiness.",
    		bio: "In Lakota mythology, Wóȟpe (less correctly spelled \"Wohpe\") is a spirit of peace, the daughter of Wi and the Moon, Haŋhépi-Wi. She is the wife of the south wind. When she visited the Earth, she gave the Lakota people a pipe as a symbol of peace.",
    		search_term: "Wohpe",
    		diameter: "40.0",
    		center_lat: 41.4,
    		center_long: 288.1
    	},
    	{
    		feature_id: 6617,
    		year: 2006,
    		feature: "Mons",
    		feature_plural: "Montes",
    		name: "Xtoh Mons",
    		type: "Goddess",
    		origin: "Guatemala",
    		continent: "North America",
    		clean_name: "Xtoh",
    		description: "Quiche (Guatemala) goddess of weather and rain.",
    		bio: "",
    		search_term: "",
    		diameter: "110.0",
    		center_lat: 39.7,
    		center_long: 194.2
    	},
    	{
    		feature_id: 14213,
    		year: 2006,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Anjea Corona",
    		type: "Goddess",
    		origin: "Australia",
    		continent: "Oceania",
    		clean_name: "Anjea",
    		description: "Australian (Queensland) mother and guardian goddess, forms infants from mud and places them into their future mothers.",
    		bio: "In Australian Aboriginal mythology, Anjea is a fertility goddess or spirit. People's souls reside within her in between their incarnations. She picks them up at their resting places in the sand, which are marked with twigs.",
    		search_term: "Anjea",
    		diameter: "145.0",
    		center_lat: -29,
    		center_long: 282.8
    	},
    	{
    		feature_id: 313,
    		year: 2006,
    		feature: "Tholus",
    		feature_plural: "Tholi",
    		name: "Apakura Tholus",
    		type: "Goddess",
    		origin: "New Zealand",
    		continent: "Oceania",
    		clean_name: "Apakura",
    		description: "Māori (New Zealand) goddess of justice.",
    		bio: "In Māori mythology, her son Whakatau was born in a miraculous manner, from the girdle or apron which Apakura threw into the ocean which was made into a child by a sea deity.",
    		search_term: "Apakura",
    		diameter: "10.0",
    		center_lat: 40.3,
    		center_long: 208.8
    	},
    	{
    		feature_id: 3562,
    		year: 2006,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Madalait Corona",
    		type: "Goddess",
    		origin: "Australia",
    		continent: "Oceania",
    		clean_name: "Madalait",
    		description: "Australian creator goddess; “Creator of life.”",
    		bio: "",
    		search_term: "",
    		diameter: "150.0",
    		center_lat: 37.6,
    		center_long: 206.4
    	},
    	{
    		feature_id: 6473,
    		year: 2006,
    		feature: "Mons",
    		feature_plural: "Montes",
    		name: "Waka Mons",
    		type: "Goddess",
    		origin: "Polynesia",
    		continent: "Oceania",
    		clean_name: "Waka",
    		description: "Polynesian lizard goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "60.0",
    		center_lat: 26.3,
    		center_long: 207.7
    	},
    	{
    		feature_id: 3145,
    		year: 2006,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Kulimina Corona",
    		type: "Goddess",
    		origin: "Brazil",
    		continent: "South America",
    		clean_name: "Kulimina",
    		description: "Arawakan (Brazil, Venezuela) creator goddess who created women.",
    		bio: "",
    		search_term: "",
    		diameter: "170.0",
    		center_lat: -27.8,
    		center_long: 261.9
    	},
    	{
    		feature_id: 14273,
    		year: 2007,
    		feature: "Mons",
    		feature_plural: "Montes",
    		name: "Kono Mons",
    		type: "Goddess",
    		origin: "Mali",
    		continent: "Africa",
    		clean_name: "Kono",
    		description: "Senufu (Mali, Cote d’Ivoire) goddess of wild birds.",
    		bio: "",
    		search_term: "",
    		diameter: "350.0",
    		center_lat: 19.5,
    		center_long: 268
    	},
    	{
    		feature_id: 14289,
    		year: 2007,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Urash Corona",
    		type: "Goddess",
    		origin: "Sumerian",
    		continent: "Asia",
    		clean_name: "Urash",
    		description: "Sumerian-Akkadian earth goddess, wife of sky god Anu.",
    		bio: "Uraš or Urash, in Sumerian religion, is a goddess of earth, and one of the consorts of the sky god Anu. She is the mother of the goddess Ninsun and a grandmother of the hero Gilgamesh.",
    		search_term: "Urash",
    		diameter: "360.0",
    		center_lat: 43.2,
    		center_long: 282
    	},
    	{
    		feature_id: 14272,
    		year: 2007,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Larisa",
    		type: "First Name",
    		origin: "Latin",
    		continent: "Europe",
    		clean_name: "Larisa",
    		description: "Latin first name.",
    		bio: "",
    		search_term: "",
    		diameter: "3.7",
    		center_lat: -18.5,
    		center_long: 131.1
    	},
    	{
    		feature_id: 14288,
    		year: 2007,
    		feature: "Mons",
    		feature_plural: "Montes",
    		name: "Copacati Mons",
    		type: "Goddess",
    		origin: "Inca",
    		continent: "South America",
    		clean_name: "Copacati",
    		description: "Inca lake goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "80.0",
    		center_lat: 34.8,
    		center_long: 276.8
    	},
    	{
    		feature_id: 14338,
    		year: 2008,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Minona Corona",
    		type: "Goddess",
    		origin: "Benin",
    		continent: "Africa",
    		clean_name: "Minona",
    		description: "Benin (W. Africa) goddess who grants fertility to both women and the land.",
    		bio: "",
    		search_term: "",
    		diameter: "130.0",
    		center_lat: 23.5,
    		center_long: 218.5
    	},
    	{
    		feature_id: 14627,
    		year: 2009,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Azham Corona",
    		type: "Goddess",
    		origin: "Caucasus",
    		continent: "Asia",
    		clean_name: "Azham",
    		description: "Karachay and Balkar (N. Caucasus) great goddess of the nature forces.",
    		bio: "",
    		search_term: "",
    		diameter: "380.0",
    		center_lat: 66.4,
    		center_long: 252.7
    	},
    	{
    		feature_id: 14596,
    		year: 2009,
    		feature: "Mons",
    		feature_plural: "Montes",
    		name: "Sarasvati Mons",
    		type: "Goddess",
    		origin: "Hindu",
    		continent: "Asia",
    		clean_name: "Sarasvati",
    		description: "Hindu river goddess revered as a great fertilizing and purifying mother.",
    		bio: "Saraswati (Sanskrit: सरस्वती, IAST: Sarasvatī) is the Hindu goddess of knowledge, music, art, speech, wisdom, and learning. She is one of the Tridevi, along with the goddesses Lakshmi and Parvati.The earliest known mention of Saraswati as a goddess is in the Rigveda. She has remained significant as a goddess from the Vedic period through the modern period of Hindu traditions.",
    		search_term: "Sarasvati",
    		diameter: "200.0",
    		center_lat: 75.7,
    		center_long: 354.5
    	},
    	{
    		feature_id: 14600,
    		year: 2009,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Alina",
    		type: "First Name",
    		origin: "France",
    		continent: "Europe",
    		clean_name: "Alina",
    		description: "Short form of French first name Adeline/Adelaide.",
    		bio: "",
    		search_term: "",
    		diameter: "3.7",
    		center_lat: 8.3,
    		center_long: 267.8
    	},
    	{
    		feature_id: 14601,
    		year: 2009,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Amelia",
    		type: "First Name",
    		origin: "Latin",
    		continent: "Europe",
    		clean_name: "Amelia",
    		description: "First name from Latin.",
    		bio: "",
    		search_term: "",
    		diameter: "3.3",
    		center_lat: 8.6,
    		center_long: 280.5
    	},
    	{
    		feature_id: 14597,
    		year: 2009,
    		feature: "Tholus",
    		feature_plural: "Tholi",
    		name: "Akka Tholus",
    		type: "Goddess",
    		origin: "Finland",
    		continent: "Europe",
    		clean_name: "Akka",
    		description: "Finnish mother goddess.",
    		bio: "",
    		search_term: "",
    		diameter: "19.4",
    		center_lat: 75.1,
    		center_long: 233
    	},
    	{
    		feature_id: 14598,
    		year: 2009,
    		feature: "Tholus",
    		feature_plural: "Tholi",
    		name: "Eirene Tholus",
    		type: "Goddess",
    		origin: "Greek",
    		continent: "Europe",
    		clean_name: "Eirene",
    		description: "Greek goddess of peace.",
    		bio: "",
    		search_term: "",
    		diameter: "58.0",
    		center_lat: 75.5,
    		center_long: 230
    	},
    	{
    		feature_id: 14594,
    		year: 2009,
    		feature: "Dorsum",
    		feature_plural: "Dorsa",
    		name: "Fulgora Dorsa",
    		type: "Goddess",
    		origin: "Roman",
    		continent: "Europe",
    		clean_name: "Fulgora",
    		description: "Roman goddess of lightning.",
    		bio: "In Roman mythology, Fulgora was the female personification of lightning. She was the Roman counterpart to Astrape.",
    		search_term: "Fulgora (mythology)",
    		diameter: "463.0",
    		center_lat: 78.5,
    		center_long: 342
    	},
    	{
    		feature_id: 14628,
    		year: 2009,
    		feature: "Mons",
    		feature_plural: "Montes",
    		name: "Metis Mons",
    		type: "Goddess",
    		origin: "Greek",
    		continent: "Europe",
    		clean_name: "Metis",
    		description: "Greek Titaness.",
    		bio: "",
    		search_term: "",
    		diameter: "920.0",
    		center_lat: 71,
    		center_long: 253
    	},
    	{
    		feature_id: 14595,
    		year: 2009,
    		feature: "Fluctus",
    		feature_plural: "Fluctūs",
    		name: "Heloha Fluctus",
    		type: "Goddess",
    		origin: "Choktaw",
    		continent: "North America",
    		clean_name: "Heloha",
    		description: "Choktaw (SE USA) female thunderbird.",
    		bio: "",
    		search_term: "",
    		diameter: "375.0",
    		center_lat: 77,
    		center_long: 344
    	},
    	{
    		feature_id: 14599,
    		year: 2009,
    		feature: "Tholus",
    		feature_plural: "Tholi",
    		name: "Yansa Tholus",
    		type: "Goddess",
    		origin: "Brazil",
    		continent: "South America",
    		clean_name: "Yansa",
    		description: "Brazilian goddess of wind and fire.",
    		bio: "Ọya is an orisha (spirit) of winds, lightning, and violent storms, death, and rebirth. She is known as Ọya-Ìyáńsàn-án, the \"mother of nine\", because of nine children she gave birth to, all stillborn, suffering from a lifetime of barrenness.",
    		search_term: "Yansa",
    		diameter: "20.0",
    		center_lat: 76.1,
    		center_long: 232.2
    	},
    	{
    		feature_id: 14701,
    		year: 2010,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Nancy",
    		type: "First Name",
    		origin: "Hebrew",
    		continent: "Asia",
    		clean_name: "Nancy",
    		description: "First name derived from Hebrew.",
    		bio: "",
    		search_term: "",
    		diameter: "4.4",
    		center_lat: 6.4,
    		center_long: 272.2
    	},
    	{
    		feature_id: 14780,
    		year: 2010,
    		feature: "Linea",
    		feature_plural: "Lineae",
    		name: "Ningal Lineae",
    		type: "Goddess",
    		origin: "Sumerian",
    		continent: "Asia",
    		clean_name: "Ningal",
    		description: "Sumerian desert goddess.",
    		bio: "Ningal (Sumerian: \"Great Queen\"), also known as Nikkal in Akkadian, was a Mesopotamian goddess of Sumerian origin regarded as the wife of the moon god, Nanna/Sin. She was particularly closely associated with his main cult centers, Ur and Harran, but they were also worshiped together in other cities of Mesopotamia.",
    		search_term: "Ningal",
    		diameter: "225.0",
    		center_lat: 9,
    		center_long: 60.7
    	},
    	{
    		feature_id: 14783,
    		year: 2010,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Elihino Corona",
    		type: "Goddess",
    		origin: "Cherokee",
    		continent: "North America",
    		clean_name: "Elihino",
    		description: "Cherokee (SE USA) Earth Mother.",
    		bio: "",
    		search_term: "",
    		diameter: "175.0",
    		center_lat: -37,
    		center_long: 49.1
    	},
    	{
    		feature_id: 14784,
    		year: 2010,
    		feature: "Corona",
    		feature_plural: "Coronae",
    		name: "Pakoti Corona",
    		type: "Goddess",
    		origin: "New Zealand",
    		continent: "Oceania",
    		clean_name: "Pakoti",
    		description: "Māori (New Zealand) mother of a highly culturally significant fiber plant, harakeke (“New Zealand flax”), ancestor and wife of Tāne, father of plants.",
    		bio: "",
    		search_term: "",
    		diameter: "75.0",
    		center_lat: -38.8,
    		center_long: 42.4
    	},
    	{
    		feature_id: 15018,
    		year: 2012,
    		feature: "Chasma",
    		feature_plural: "Chasmata",
    		name: "Rona Chasma",
    		type: "Goddess",
    		origin: "New Zealand",
    		continent: "Oceania",
    		clean_name: "Rona",
    		description: "Maori Moon goddess who controls the tides.",
    		bio: "",
    		search_term: "",
    		diameter: "1,520.0",
    		center_lat: 2.5,
    		center_long: 288
    	},
    	{
    		feature_id: 15652,
    		year: 2017,
    		feature: "Crater",
    		feature_plural: "Craters",
    		name: "Annabelle",
    		type: "First Name",
    		origin: "Scotland",
    		continent: "Europe",
    		clean_name: "Annabelle",
    		description: "Scottish first name of Latin origin.",
    		bio: "",
    		search_term: "",
    		diameter: "7.7",
    		center_lat: -4.2,
    		center_long: 286.3
    	},
    	{
    		feature_id: 15864,
    		year: 2019,
    		feature: "Tessera",
    		feature_plural: "Tesserae",
    		name: "Istustaya Tesserae",
    		type: "Goddess",
    		origin: "Hittite",
    		continent: "Asia",
    		clean_name: "Istustaya",
    		description: "Hattian/Hittite goddess of destiny, who spins the threads of fate.",
    		bio: "",
    		search_term: "",
    		diameter: "505.0",
    		center_lat: -8.8,
    		center_long: 42.2
    	},
    	{
    		feature_id: 15863,
    		year: 2019,
    		feature: "Tessera",
    		feature_plural: "Tesserae",
    		name: "Jyestha Tesserae",
    		type: "Goddess",
    		origin: "India",
    		continent: "Asia",
    		clean_name: "Jyestha",
    		description: "Indian goddess of inauspicious things; sister of Lakshmi.",
    		bio: "Jyestha or Jyeshtha is the Hindu goddess of adversity and misfortune. She is regarded as the elder sister and antithesis of Lakshmi, the goddess of prosperity and auspiciousness.  She is also associated with sloth, poverty, sorrow, ugliness, and often depicted with the crow.",
    		search_term: "Jyestha (goddess)",
    		diameter: "1,252.0",
    		center_lat: 65.1,
    		center_long: 343.4
    	}
    ];

    // Constant
    const defaultFilters = {
        "type": [...new Set(dataSource.map(d => d["type"]))].sort(),
        "feature": [...new Set(dataSource.map(d => d["feature"]))].sort(),
        "continent": [...new Set(dataSource.map(d => d["continent"]))].sort(),
        "year": [...new Set(dataSource.map(d => d["year"]))].sort(),
    };

    // Get the theme color based on the feature
    // Optional "alpha" param to control transparency (0-100)
    function getThemeColor(type, alpha, light) {
        const colorMap = {
            "Default": "#6b6b6b",
            "Goddess": "#D7A954",
            "Heroine": "#8AB67B",
            "First Name": "#6CB4CC",
            "Famous Woman": "#C97889",
            "Other": "#9B9B9B",
        };

        //#f7e8ea
        const lightColorMap = {
            "Default": "#dddddd",
            "Goddess": "#f6e1c5",
            "Heroine": "#d8e7d2",
            "First Name": "#d0e6ee",
            "Famous Woman": "#efd1d6",
            "Other": "#9B9B9B",
        };

        let hexBase;

        if (light == true) {
            hexBase = lightColorMap[type] == undefined ? "Default" : lightColorMap[type];
        } else {
            hexBase = colorMap[type] == undefined ? "Default" : colorMap[type];
        }

        const hexAlpha = alpha ? `0${Math.round((255 / 100) * alpha).toString(16)}`.slice(-2).toUpperCase() : "";
        const output = `${hexBase}${hexAlpha}`;

        return output;
    }

    // Move globe to point at a specific feature
    function moveGlobeToPoint(id, data, world) {
        const found = data.find((element) => element.feature_id == id);
        const lat = found.center_lat;
        const lng = found.center_long;

        world.pointOfView(
            {
                lat: lat,
                lng: lng,
            },
            300
        );
    }


    // Reset globe view to default view, (0, 0)
    function resetGlobe(world) {
        world.pointOfView(
            {
                lat: 0,
                lng: 0
            },
            300
        );
    }

    // show one or more points on the globe
    function showGlobePoints(idArray, world) {
        if (idArray == null || idArray == [] || idArray == undefined) {
            world.pointRadius(d => 0);
        } else {
            world.pointRadius((d) => {
                if (idArray.includes(d.feature_id)) {
                    return 1
                } else {
                    return 0
                }
            });
        }
    }

    /**
     * Filters the data for specific values in a variable, and then updates the $data store
     * @param {Array} filterObj - The entire filter object in store
     * @param {Array} targetValues - An array of values to target for the filter
     * @param {String} variable - The name of the field to filter, must match data source
     * @param {Array} dataToFilter - The data source to filter, most likely $data
     * @param {Boolean} activate - If true, the targeted values will be active. If false, they will be hidden
     *
     */
    function filterData(filterObj, targetValues, variable, dataToFilter, activate) {
        let newFilterObj = {};
        let filteredData;
        const activeValues = filterObj[variable];
        const allFilters = Object.keys(filterObj);

        if (activate == true) {
            // add the new value to the existing active value array
            const newValues = [...new Set([...activeValues, ...targetValues])].sort();
            // filter on the data source so the value can be included
            filteredData = dataSource.filter((d) => newValues.includes(d[variable]));
            // generate the new filter object from the filtered data
            allFilters.map(category => {
                return newFilterObj[category] = [...new Set(filteredData.map(d => d[category]))].sort();
            });
            //console.log("adding", variable, targetValues, "to", activeValues, "-- now", newValues);
        } else if (activate == false) {
            const data = dataToFilter.length == 0 ? dataSource : dataToFilter;
            // remove the value from the existing active value array
            const newValues = activeValues.filter(v => !targetValues.includes(v)).sort();
            // filter existing data so the value is taken out
            filteredData = data.filter((d) => newValues.includes(d[variable]));
            // generate the new filter object from the filtered data
            allFilters.map(category => {
                return newFilterObj[category] = [...new Set(filteredData.map(d => d[category]))].sort();
            });
            //console.log("removing", variable, targetValues, "from", activeValues, "-- now", newValues);
        }
        //console.log(data.length, filteredData.length);
        updateData(filteredData, newFilterObj);
    }

    // Fade the two pages in and out
    function handlePageChange(activePage, globe) {
        const introSection = document.querySelector(`.intro-mode`);
        const mainSection = document.querySelector(`.main-mode`);
        const newPage = activePage == "intro" ? "main" : "intro";

        if (newPage == "intro") {
            //clearGlobePoints(globe);
            mainSection.style.opacity = 0;
            introSection.style.opacity = 1;
        } else {
            //showGlobePoints(idArray, $globe);
            mainSection.style.opacity = 1;
            introSection.style.opacity = 0;
        }

        setActivePage(newPage);
    }

    // Clean up a value if it is a string to remove whitespace
    function parseValue(value) {
        if (typeof(value) == "string") {
            return value.toLowerCase().replace(" ","")
        } else {
            return value
        }
    }

    // Get the share of features that match the filters
    // E.g. the share of features that are Famous Women
    function getPercentages(data, defaultFilters) {
        let output = {};
        let sorted = {};
        const keys = Object.keys(defaultFilters);

        keys.map(variable => {
            output[variable] = [];
            const obj = defaultFilters[variable];
            obj.map(value => {
                const values = data.filter((d) => d[variable] == value).length;
                const total = data.length;
                const percent = values == 0 ? 0 : total == 0 ? 0 : (values / total) * 100;
                output[variable].push([
                    value,
                    percent
                ]);
            });
        });

        keys.map(variable => {
            const arr = output[variable];
            const sortedOutput = arr.sort(function(a, b) {
                return b[1] - a[1];
            });
            sorted[variable] = sortedOutput;
        });

        return sorted;
    }

    const windowWidth = writable(window.innerWidth);
    const modalLocation = writable(0);

    const isMobile = derived(windowWidth,
        $windowWidth => $windowWidth <= 560 ? true : false
    );

    derived(windowWidth,
        $windowWidth => $windowWidth > 1200 ? true : false
    );

    const cardsPerPage = derived(windowWidth,
        $windowWidth => $windowWidth <= 560 ? 6 : 9
    );

    const data = writable(dataSource);
    const visibleData = writable(6);
    const page = writable(0);
    const globe$1 = writable();
    const activePage = writable("intro"); // or main
    const pageTheme = writable("Default");

    const filterObj = writable(defaultFilters);
    const percentages = derived(data,
        data => getPercentages(data, defaultFilters)
    );

    function updateData(newData, newFilterObj) {
        data.set(newData);
        filterObj.set(newFilterObj);
        page.set(0);
        pageTheme.set("Default");
    }

    function resetData() {
        page.set(0);
        data.set(dataSource);
        filterObj.set(defaultFilters);
        pageTheme.set("Default");
    }

    function setActivePage(newPage) {
        activePage.set(newPage);
    }

    function setPercentages(newArr) {
        percentages.set(newArr);
    }

    function setModalLocation(newValue) {
        modalLocation.set(newValue);
    }

    /**
     * @license
     * Copyright 2010-2022 Three.js Authors
     * SPDX-License-Identifier: MIT
     */
    const REVISION = '147';
    const MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 };
    const TOUCH = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 };
    const CullFaceNone = 0;
    const CullFaceBack = 1;
    const CullFaceFront = 2;
    const PCFShadowMap = 1;
    const PCFSoftShadowMap = 2;
    const VSMShadowMap = 3;
    const FrontSide = 0;
    const BackSide = 1;
    const DoubleSide = 2;
    const NoBlending = 0;
    const NormalBlending = 1;
    const AdditiveBlending = 2;
    const SubtractiveBlending = 3;
    const MultiplyBlending = 4;
    const CustomBlending = 5;
    const AddEquation = 100;
    const SubtractEquation = 101;
    const ReverseSubtractEquation = 102;
    const MinEquation = 103;
    const MaxEquation = 104;
    const ZeroFactor = 200;
    const OneFactor = 201;
    const SrcColorFactor = 202;
    const OneMinusSrcColorFactor = 203;
    const SrcAlphaFactor = 204;
    const OneMinusSrcAlphaFactor = 205;
    const DstAlphaFactor = 206;
    const OneMinusDstAlphaFactor = 207;
    const DstColorFactor = 208;
    const OneMinusDstColorFactor = 209;
    const SrcAlphaSaturateFactor = 210;
    const NeverDepth = 0;
    const AlwaysDepth = 1;
    const LessDepth = 2;
    const LessEqualDepth = 3;
    const EqualDepth = 4;
    const GreaterEqualDepth = 5;
    const GreaterDepth = 6;
    const NotEqualDepth = 7;
    const MultiplyOperation = 0;
    const MixOperation = 1;
    const AddOperation = 2;
    const NoToneMapping = 0;
    const LinearToneMapping = 1;
    const ReinhardToneMapping = 2;
    const CineonToneMapping = 3;
    const ACESFilmicToneMapping = 4;
    const CustomToneMapping = 5;

    const UVMapping = 300;
    const CubeReflectionMapping = 301;
    const CubeRefractionMapping = 302;
    const EquirectangularReflectionMapping = 303;
    const EquirectangularRefractionMapping = 304;
    const CubeUVReflectionMapping = 306;
    const RepeatWrapping = 1000;
    const ClampToEdgeWrapping = 1001;
    const MirroredRepeatWrapping = 1002;
    const NearestFilter = 1003;
    const NearestMipmapNearestFilter = 1004;
    const NearestMipmapLinearFilter = 1005;
    const LinearFilter = 1006;
    const LinearMipmapNearestFilter = 1007;
    const LinearMipmapLinearFilter = 1008;
    const UnsignedByteType = 1009;
    const ByteType = 1010;
    const ShortType = 1011;
    const UnsignedShortType = 1012;
    const IntType = 1013;
    const UnsignedIntType = 1014;
    const FloatType = 1015;
    const HalfFloatType = 1016;
    const UnsignedShort4444Type = 1017;
    const UnsignedShort5551Type = 1018;
    const UnsignedInt248Type = 1020;
    const AlphaFormat = 1021;
    const RGBFormat = 1022; // @deprecated since r137
    const RGBAFormat = 1023;
    const LuminanceFormat = 1024;
    const LuminanceAlphaFormat = 1025;
    const DepthFormat = 1026;
    const DepthStencilFormat = 1027;
    const RedFormat = 1028;
    const RedIntegerFormat = 1029;
    const RGFormat = 1030;
    const RGIntegerFormat = 1031;
    const RGBAIntegerFormat = 1033;

    const RGB_S3TC_DXT1_Format = 33776;
    const RGBA_S3TC_DXT1_Format = 33777;
    const RGBA_S3TC_DXT3_Format = 33778;
    const RGBA_S3TC_DXT5_Format = 33779;
    const RGB_PVRTC_4BPPV1_Format = 35840;
    const RGB_PVRTC_2BPPV1_Format = 35841;
    const RGBA_PVRTC_4BPPV1_Format = 35842;
    const RGBA_PVRTC_2BPPV1_Format = 35843;
    const RGB_ETC1_Format = 36196;
    const RGB_ETC2_Format = 37492;
    const RGBA_ETC2_EAC_Format = 37496;
    const RGBA_ASTC_4x4_Format = 37808;
    const RGBA_ASTC_5x4_Format = 37809;
    const RGBA_ASTC_5x5_Format = 37810;
    const RGBA_ASTC_6x5_Format = 37811;
    const RGBA_ASTC_6x6_Format = 37812;
    const RGBA_ASTC_8x5_Format = 37813;
    const RGBA_ASTC_8x6_Format = 37814;
    const RGBA_ASTC_8x8_Format = 37815;
    const RGBA_ASTC_10x5_Format = 37816;
    const RGBA_ASTC_10x6_Format = 37817;
    const RGBA_ASTC_10x8_Format = 37818;
    const RGBA_ASTC_10x10_Format = 37819;
    const RGBA_ASTC_12x10_Format = 37820;
    const RGBA_ASTC_12x12_Format = 37821;
    const RGBA_BPTC_Format = 36492;
    const TrianglesDrawMode = 0;
    const TriangleStripDrawMode = 1;
    const TriangleFanDrawMode = 2;
    const LinearEncoding = 3000;
    const sRGBEncoding = 3001;
    const BasicDepthPacking = 3200;
    const RGBADepthPacking = 3201;
    const TangentSpaceNormalMap = 0;
    const ObjectSpaceNormalMap = 1;
    const SRGBColorSpace = 'srgb';
    const LinearSRGBColorSpace = 'srgb-linear';
    const KeepStencilOp = 7680;
    const AlwaysStencilFunc = 519;

    const StaticDrawUsage = 35044;
    const GLSL3 = '300 es';

    const _SRGBAFormat = 1035; // fallback for WebGL 1

    /**
     * https://github.com/mrdoob/eventdispatcher.js/
     */

    class EventDispatcher {

    	addEventListener( type, listener ) {

    		if ( this._listeners === undefined ) this._listeners = {};

    		const listeners = this._listeners;

    		if ( listeners[ type ] === undefined ) {

    			listeners[ type ] = [];

    		}

    		if ( listeners[ type ].indexOf( listener ) === - 1 ) {

    			listeners[ type ].push( listener );

    		}

    	}

    	hasEventListener( type, listener ) {

    		if ( this._listeners === undefined ) return false;

    		const listeners = this._listeners;

    		return listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1;

    	}

    	removeEventListener( type, listener ) {

    		if ( this._listeners === undefined ) return;

    		const listeners = this._listeners;
    		const listenerArray = listeners[ type ];

    		if ( listenerArray !== undefined ) {

    			const index = listenerArray.indexOf( listener );

    			if ( index !== - 1 ) {

    				listenerArray.splice( index, 1 );

    			}

    		}

    	}

    	dispatchEvent( event ) {

    		if ( this._listeners === undefined ) return;

    		const listeners = this._listeners;
    		const listenerArray = listeners[ event.type ];

    		if ( listenerArray !== undefined ) {

    			event.target = this;

    			// Make a copy, in case listeners are removed while iterating.
    			const array = listenerArray.slice( 0 );

    			for ( let i = 0, l = array.length; i < l; i ++ ) {

    				array[ i ].call( this, event );

    			}

    			event.target = null;

    		}

    	}

    }

    const _lut = [ '00', '01', '02', '03', '04', '05', '06', '07', '08', '09', '0a', '0b', '0c', '0d', '0e', '0f', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '1a', '1b', '1c', '1d', '1e', '1f', '20', '21', '22', '23', '24', '25', '26', '27', '28', '29', '2a', '2b', '2c', '2d', '2e', '2f', '30', '31', '32', '33', '34', '35', '36', '37', '38', '39', '3a', '3b', '3c', '3d', '3e', '3f', '40', '41', '42', '43', '44', '45', '46', '47', '48', '49', '4a', '4b', '4c', '4d', '4e', '4f', '50', '51', '52', '53', '54', '55', '56', '57', '58', '59', '5a', '5b', '5c', '5d', '5e', '5f', '60', '61', '62', '63', '64', '65', '66', '67', '68', '69', '6a', '6b', '6c', '6d', '6e', '6f', '70', '71', '72', '73', '74', '75', '76', '77', '78', '79', '7a', '7b', '7c', '7d', '7e', '7f', '80', '81', '82', '83', '84', '85', '86', '87', '88', '89', '8a', '8b', '8c', '8d', '8e', '8f', '90', '91', '92', '93', '94', '95', '96', '97', '98', '99', '9a', '9b', '9c', '9d', '9e', '9f', 'a0', 'a1', 'a2', 'a3', 'a4', 'a5', 'a6', 'a7', 'a8', 'a9', 'aa', 'ab', 'ac', 'ad', 'ae', 'af', 'b0', 'b1', 'b2', 'b3', 'b4', 'b5', 'b6', 'b7', 'b8', 'b9', 'ba', 'bb', 'bc', 'bd', 'be', 'bf', 'c0', 'c1', 'c2', 'c3', 'c4', 'c5', 'c6', 'c7', 'c8', 'c9', 'ca', 'cb', 'cc', 'cd', 'ce', 'cf', 'd0', 'd1', 'd2', 'd3', 'd4', 'd5', 'd6', 'd7', 'd8', 'd9', 'da', 'db', 'dc', 'dd', 'de', 'df', 'e0', 'e1', 'e2', 'e3', 'e4', 'e5', 'e6', 'e7', 'e8', 'e9', 'ea', 'eb', 'ec', 'ed', 'ee', 'ef', 'f0', 'f1', 'f2', 'f3', 'f4', 'f5', 'f6', 'f7', 'f8', 'f9', 'fa', 'fb', 'fc', 'fd', 'fe', 'ff' ];

    let _seed = 1234567;


    const DEG2RAD = Math.PI / 180;
    const RAD2DEG = 180 / Math.PI;

    // http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136
    function generateUUID() {

    	const d0 = Math.random() * 0xffffffff | 0;
    	const d1 = Math.random() * 0xffffffff | 0;
    	const d2 = Math.random() * 0xffffffff | 0;
    	const d3 = Math.random() * 0xffffffff | 0;
    	const uuid = _lut[ d0 & 0xff ] + _lut[ d0 >> 8 & 0xff ] + _lut[ d0 >> 16 & 0xff ] + _lut[ d0 >> 24 & 0xff ] + '-' +
    			_lut[ d1 & 0xff ] + _lut[ d1 >> 8 & 0xff ] + '-' + _lut[ d1 >> 16 & 0x0f | 0x40 ] + _lut[ d1 >> 24 & 0xff ] + '-' +
    			_lut[ d2 & 0x3f | 0x80 ] + _lut[ d2 >> 8 & 0xff ] + '-' + _lut[ d2 >> 16 & 0xff ] + _lut[ d2 >> 24 & 0xff ] +
    			_lut[ d3 & 0xff ] + _lut[ d3 >> 8 & 0xff ] + _lut[ d3 >> 16 & 0xff ] + _lut[ d3 >> 24 & 0xff ];

    	// .toLowerCase() here flattens concatenated strings to save heap memory space.
    	return uuid.toLowerCase();

    }

    function clamp$1( value, min, max ) {

    	return Math.max( min, Math.min( max, value ) );

    }

    // compute euclidean modulo of m % n
    // https://en.wikipedia.org/wiki/Modulo_operation
    function euclideanModulo( n, m ) {

    	return ( ( n % m ) + m ) % m;

    }

    // Linear mapping from range <a1, a2> to range <b1, b2>
    function mapLinear( x, a1, a2, b1, b2 ) {

    	return b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );

    }

    // https://www.gamedev.net/tutorials/programming/general-and-gameplay-programming/inverse-lerp-a-super-useful-yet-often-overlooked-function-r5230/
    function inverseLerp( x, y, value ) {

    	if ( x !== y ) {

    		return ( value - x ) / ( y - x );

    	} else {

    		return 0;

    	}

    }

    // https://en.wikipedia.org/wiki/Linear_interpolation
    function lerp( x, y, t ) {

    	return ( 1 - t ) * x + t * y;

    }

    // http://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/
    function damp( x, y, lambda, dt ) {

    	return lerp( x, y, 1 - Math.exp( - lambda * dt ) );

    }

    // https://www.desmos.com/calculator/vcsjnyz7x4
    function pingpong( x, length = 1 ) {

    	return length - Math.abs( euclideanModulo( x, length * 2 ) - length );

    }

    // http://en.wikipedia.org/wiki/Smoothstep
    function smoothstep( x, min, max ) {

    	if ( x <= min ) return 0;
    	if ( x >= max ) return 1;

    	x = ( x - min ) / ( max - min );

    	return x * x * ( 3 - 2 * x );

    }

    function smootherstep( x, min, max ) {

    	if ( x <= min ) return 0;
    	if ( x >= max ) return 1;

    	x = ( x - min ) / ( max - min );

    	return x * x * x * ( x * ( x * 6 - 15 ) + 10 );

    }

    // Random integer from <low, high> interval
    function randInt( low, high ) {

    	return low + Math.floor( Math.random() * ( high - low + 1 ) );

    }

    // Random float from <low, high> interval
    function randFloat( low, high ) {

    	return low + Math.random() * ( high - low );

    }

    // Random float from <-range/2, range/2> interval
    function randFloatSpread( range ) {

    	return range * ( 0.5 - Math.random() );

    }

    // Deterministic pseudo-random float in the interval [ 0, 1 ]
    function seededRandom( s ) {

    	if ( s !== undefined ) _seed = s;

    	// Mulberry32 generator

    	let t = _seed += 0x6D2B79F5;

    	t = Math.imul( t ^ t >>> 15, t | 1 );

    	t ^= t + Math.imul( t ^ t >>> 7, t | 61 );

    	return ( ( t ^ t >>> 14 ) >>> 0 ) / 4294967296;

    }

    function degToRad( degrees ) {

    	return degrees * DEG2RAD;

    }

    function radToDeg( radians ) {

    	return radians * RAD2DEG;

    }

    function isPowerOfTwo( value ) {

    	return ( value & ( value - 1 ) ) === 0 && value !== 0;

    }

    function ceilPowerOfTwo( value ) {

    	return Math.pow( 2, Math.ceil( Math.log( value ) / Math.LN2 ) );

    }

    function floorPowerOfTwo( value ) {

    	return Math.pow( 2, Math.floor( Math.log( value ) / Math.LN2 ) );

    }

    function setQuaternionFromProperEuler( q, a, b, c, order ) {

    	// Intrinsic Proper Euler Angles - see https://en.wikipedia.org/wiki/Euler_angles

    	// rotations are applied to the axes in the order specified by 'order'
    	// rotation by angle 'a' is applied first, then by angle 'b', then by angle 'c'
    	// angles are in radians

    	const cos = Math.cos;
    	const sin = Math.sin;

    	const c2 = cos( b / 2 );
    	const s2 = sin( b / 2 );

    	const c13 = cos( ( a + c ) / 2 );
    	const s13 = sin( ( a + c ) / 2 );

    	const c1_3 = cos( ( a - c ) / 2 );
    	const s1_3 = sin( ( a - c ) / 2 );

    	const c3_1 = cos( ( c - a ) / 2 );
    	const s3_1 = sin( ( c - a ) / 2 );

    	switch ( order ) {

    		case 'XYX':
    			q.set( c2 * s13, s2 * c1_3, s2 * s1_3, c2 * c13 );
    			break;

    		case 'YZY':
    			q.set( s2 * s1_3, c2 * s13, s2 * c1_3, c2 * c13 );
    			break;

    		case 'ZXZ':
    			q.set( s2 * c1_3, s2 * s1_3, c2 * s13, c2 * c13 );
    			break;

    		case 'XZX':
    			q.set( c2 * s13, s2 * s3_1, s2 * c3_1, c2 * c13 );
    			break;

    		case 'YXY':
    			q.set( s2 * c3_1, c2 * s13, s2 * s3_1, c2 * c13 );
    			break;

    		case 'ZYZ':
    			q.set( s2 * s3_1, s2 * c3_1, c2 * s13, c2 * c13 );
    			break;

    		default:
    			console.warn( 'THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: ' + order );

    	}

    }

    function denormalize( value, array ) {

    	switch ( array.constructor ) {

    		case Float32Array:

    			return value;

    		case Uint16Array:

    			return value / 65535.0;

    		case Uint8Array:

    			return value / 255.0;

    		case Int16Array:

    			return Math.max( value / 32767.0, - 1.0 );

    		case Int8Array:

    			return Math.max( value / 127.0, - 1.0 );

    		default:

    			throw new Error( 'Invalid component type.' );

    	}

    }

    function normalize$1( value, array ) {

    	switch ( array.constructor ) {

    		case Float32Array:

    			return value;

    		case Uint16Array:

    			return Math.round( value * 65535.0 );

    		case Uint8Array:

    			return Math.round( value * 255.0 );

    		case Int16Array:

    			return Math.round( value * 32767.0 );

    		case Int8Array:

    			return Math.round( value * 127.0 );

    		default:

    			throw new Error( 'Invalid component type.' );

    	}

    }

    var MathUtils = /*#__PURE__*/Object.freeze({
    	__proto__: null,
    	DEG2RAD: DEG2RAD,
    	RAD2DEG: RAD2DEG,
    	generateUUID: generateUUID,
    	clamp: clamp$1,
    	euclideanModulo: euclideanModulo,
    	mapLinear: mapLinear,
    	inverseLerp: inverseLerp,
    	lerp: lerp,
    	damp: damp,
    	pingpong: pingpong,
    	smoothstep: smoothstep,
    	smootherstep: smootherstep,
    	randInt: randInt,
    	randFloat: randFloat,
    	randFloatSpread: randFloatSpread,
    	seededRandom: seededRandom,
    	degToRad: degToRad,
    	radToDeg: radToDeg,
    	isPowerOfTwo: isPowerOfTwo,
    	ceilPowerOfTwo: ceilPowerOfTwo,
    	floorPowerOfTwo: floorPowerOfTwo,
    	setQuaternionFromProperEuler: setQuaternionFromProperEuler,
    	normalize: normalize$1,
    	denormalize: denormalize
    });

    class Vector2 {

    	constructor( x = 0, y = 0 ) {

    		Vector2.prototype.isVector2 = true;

    		this.x = x;
    		this.y = y;

    	}

    	get width() {

    		return this.x;

    	}

    	set width( value ) {

    		this.x = value;

    	}

    	get height() {

    		return this.y;

    	}

    	set height( value ) {

    		this.y = value;

    	}

    	set( x, y ) {

    		this.x = x;
    		this.y = y;

    		return this;

    	}

    	setScalar( scalar ) {

    		this.x = scalar;
    		this.y = scalar;

    		return this;

    	}

    	setX( x ) {

    		this.x = x;

    		return this;

    	}

    	setY( y ) {

    		this.y = y;

    		return this;

    	}

    	setComponent( index, value ) {

    		switch ( index ) {

    			case 0: this.x = value; break;
    			case 1: this.y = value; break;
    			default: throw new Error( 'index is out of range: ' + index );

    		}

    		return this;

    	}

    	getComponent( index ) {

    		switch ( index ) {

    			case 0: return this.x;
    			case 1: return this.y;
    			default: throw new Error( 'index is out of range: ' + index );

    		}

    	}

    	clone() {

    		return new this.constructor( this.x, this.y );

    	}

    	copy( v ) {

    		this.x = v.x;
    		this.y = v.y;

    		return this;

    	}

    	add( v ) {

    		this.x += v.x;
    		this.y += v.y;

    		return this;

    	}

    	addScalar( s ) {

    		this.x += s;
    		this.y += s;

    		return this;

    	}

    	addVectors( a, b ) {

    		this.x = a.x + b.x;
    		this.y = a.y + b.y;

    		return this;

    	}

    	addScaledVector( v, s ) {

    		this.x += v.x * s;
    		this.y += v.y * s;

    		return this;

    	}

    	sub( v ) {

    		this.x -= v.x;
    		this.y -= v.y;

    		return this;

    	}

    	subScalar( s ) {

    		this.x -= s;
    		this.y -= s;

    		return this;

    	}

    	subVectors( a, b ) {

    		this.x = a.x - b.x;
    		this.y = a.y - b.y;

    		return this;

    	}

    	multiply( v ) {

    		this.x *= v.x;
    		this.y *= v.y;

    		return this;

    	}

    	multiplyScalar( scalar ) {

    		this.x *= scalar;
    		this.y *= scalar;

    		return this;

    	}

    	divide( v ) {

    		this.x /= v.x;
    		this.y /= v.y;

    		return this;

    	}

    	divideScalar( scalar ) {

    		return this.multiplyScalar( 1 / scalar );

    	}

    	applyMatrix3( m ) {

    		const x = this.x, y = this.y;
    		const e = m.elements;

    		this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ];
    		this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ];

    		return this;

    	}

    	min( v ) {

    		this.x = Math.min( this.x, v.x );
    		this.y = Math.min( this.y, v.y );

    		return this;

    	}

    	max( v ) {

    		this.x = Math.max( this.x, v.x );
    		this.y = Math.max( this.y, v.y );

    		return this;

    	}

    	clamp( min, max ) {

    		// assumes min < max, componentwise

    		this.x = Math.max( min.x, Math.min( max.x, this.x ) );
    		this.y = Math.max( min.y, Math.min( max.y, this.y ) );

    		return this;

    	}

    	clampScalar( minVal, maxVal ) {

    		this.x = Math.max( minVal, Math.min( maxVal, this.x ) );
    		this.y = Math.max( minVal, Math.min( maxVal, this.y ) );

    		return this;

    	}

    	clampLength( min, max ) {

    		const length = this.length();

    		return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );

    	}

    	floor() {

    		this.x = Math.floor( this.x );
    		this.y = Math.floor( this.y );

    		return this;

    	}

    	ceil() {

    		this.x = Math.ceil( this.x );
    		this.y = Math.ceil( this.y );

    		return this;

    	}

    	round() {

    		this.x = Math.round( this.x );
    		this.y = Math.round( this.y );

    		return this;

    	}

    	roundToZero() {

    		this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
    		this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );

    		return this;

    	}

    	negate() {

    		this.x = - this.x;
    		this.y = - this.y;

    		return this;

    	}

    	dot( v ) {

    		return this.x * v.x + this.y * v.y;

    	}

    	cross( v ) {

    		return this.x * v.y - this.y * v.x;

    	}

    	lengthSq() {

    		return this.x * this.x + this.y * this.y;

    	}

    	length() {

    		return Math.sqrt( this.x * this.x + this.y * this.y );

    	}

    	manhattanLength() {

    		return Math.abs( this.x ) + Math.abs( this.y );

    	}

    	normalize() {

    		return this.divideScalar( this.length() || 1 );

    	}

    	angle() {

    		// computes the angle in radians with respect to the positive x-axis

    		const angle = Math.atan2( - this.y, - this.x ) + Math.PI;

    		return angle;

    	}

    	distanceTo( v ) {

    		return Math.sqrt( this.distanceToSquared( v ) );

    	}

    	distanceToSquared( v ) {

    		const dx = this.x - v.x, dy = this.y - v.y;
    		return dx * dx + dy * dy;

    	}

    	manhattanDistanceTo( v ) {

    		return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y );

    	}

    	setLength( length ) {

    		return this.normalize().multiplyScalar( length );

    	}

    	lerp( v, alpha ) {

    		this.x += ( v.x - this.x ) * alpha;
    		this.y += ( v.y - this.y ) * alpha;

    		return this;

    	}

    	lerpVectors( v1, v2, alpha ) {

    		this.x = v1.x + ( v2.x - v1.x ) * alpha;
    		this.y = v1.y + ( v2.y - v1.y ) * alpha;

    		return this;

    	}

    	equals( v ) {

    		return ( ( v.x === this.x ) && ( v.y === this.y ) );

    	}

    	fromArray( array, offset = 0 ) {

    		this.x = array[ offset ];
    		this.y = array[ offset + 1 ];

    		return this;

    	}

    	toArray( array = [], offset = 0 ) {

    		array[ offset ] = this.x;
    		array[ offset + 1 ] = this.y;

    		return array;

    	}

    	fromBufferAttribute( attribute, index ) {

    		this.x = attribute.getX( index );
    		this.y = attribute.getY( index );

    		return this;

    	}

    	rotateAround( center, angle ) {

    		const c = Math.cos( angle ), s = Math.sin( angle );

    		const x = this.x - center.x;
    		const y = this.y - center.y;

    		this.x = x * c - y * s + center.x;
    		this.y = x * s + y * c + center.y;

    		return this;

    	}

    	random() {

    		this.x = Math.random();
    		this.y = Math.random();

    		return this;

    	}

    	*[ Symbol.iterator ]() {

    		yield this.x;
    		yield this.y;

    	}

    }

    class Matrix3 {

    	constructor() {

    		Matrix3.prototype.isMatrix3 = true;

    		this.elements = [

    			1, 0, 0,
    			0, 1, 0,
    			0, 0, 1

    		];

    	}

    	set( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {

    		const te = this.elements;

    		te[ 0 ] = n11; te[ 1 ] = n21; te[ 2 ] = n31;
    		te[ 3 ] = n12; te[ 4 ] = n22; te[ 5 ] = n32;
    		te[ 6 ] = n13; te[ 7 ] = n23; te[ 8 ] = n33;

    		return this;

    	}

    	identity() {

    		this.set(

    			1, 0, 0,
    			0, 1, 0,
    			0, 0, 1

    		);

    		return this;

    	}

    	copy( m ) {

    		const te = this.elements;
    		const me = m.elements;

    		te[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ];
    		te[ 3 ] = me[ 3 ]; te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ];
    		te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ]; te[ 8 ] = me[ 8 ];

    		return this;

    	}

    	extractBasis( xAxis, yAxis, zAxis ) {

    		xAxis.setFromMatrix3Column( this, 0 );
    		yAxis.setFromMatrix3Column( this, 1 );
    		zAxis.setFromMatrix3Column( this, 2 );

    		return this;

    	}

    	setFromMatrix4( m ) {

    		const me = m.elements;

    		this.set(

    			me[ 0 ], me[ 4 ], me[ 8 ],
    			me[ 1 ], me[ 5 ], me[ 9 ],
    			me[ 2 ], me[ 6 ], me[ 10 ]

    		);

    		return this;

    	}

    	multiply( m ) {

    		return this.multiplyMatrices( this, m );

    	}

    	premultiply( m ) {

    		return this.multiplyMatrices( m, this );

    	}

    	multiplyMatrices( a, b ) {

    		const ae = a.elements;
    		const be = b.elements;
    		const te = this.elements;

    		const a11 = ae[ 0 ], a12 = ae[ 3 ], a13 = ae[ 6 ];
    		const a21 = ae[ 1 ], a22 = ae[ 4 ], a23 = ae[ 7 ];
    		const a31 = ae[ 2 ], a32 = ae[ 5 ], a33 = ae[ 8 ];

    		const b11 = be[ 0 ], b12 = be[ 3 ], b13 = be[ 6 ];
    		const b21 = be[ 1 ], b22 = be[ 4 ], b23 = be[ 7 ];
    		const b31 = be[ 2 ], b32 = be[ 5 ], b33 = be[ 8 ];

    		te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31;
    		te[ 3 ] = a11 * b12 + a12 * b22 + a13 * b32;
    		te[ 6 ] = a11 * b13 + a12 * b23 + a13 * b33;

    		te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31;
    		te[ 4 ] = a21 * b12 + a22 * b22 + a23 * b32;
    		te[ 7 ] = a21 * b13 + a22 * b23 + a23 * b33;

    		te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31;
    		te[ 5 ] = a31 * b12 + a32 * b22 + a33 * b32;
    		te[ 8 ] = a31 * b13 + a32 * b23 + a33 * b33;

    		return this;

    	}

    	multiplyScalar( s ) {

    		const te = this.elements;

    		te[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;
    		te[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;
    		te[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;

    		return this;

    	}

    	determinant() {

    		const te = this.elements;

    		const a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],
    			d = te[ 3 ], e = te[ 4 ], f = te[ 5 ],
    			g = te[ 6 ], h = te[ 7 ], i = te[ 8 ];

    		return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;

    	}

    	invert() {

    		const te = this.elements,

    			n11 = te[ 0 ], n21 = te[ 1 ], n31 = te[ 2 ],
    			n12 = te[ 3 ], n22 = te[ 4 ], n32 = te[ 5 ],
    			n13 = te[ 6 ], n23 = te[ 7 ], n33 = te[ 8 ],

    			t11 = n33 * n22 - n32 * n23,
    			t12 = n32 * n13 - n33 * n12,
    			t13 = n23 * n12 - n22 * n13,

    			det = n11 * t11 + n21 * t12 + n31 * t13;

    		if ( det === 0 ) return this.set( 0, 0, 0, 0, 0, 0, 0, 0, 0 );

    		const detInv = 1 / det;

    		te[ 0 ] = t11 * detInv;
    		te[ 1 ] = ( n31 * n23 - n33 * n21 ) * detInv;
    		te[ 2 ] = ( n32 * n21 - n31 * n22 ) * detInv;

    		te[ 3 ] = t12 * detInv;
    		te[ 4 ] = ( n33 * n11 - n31 * n13 ) * detInv;
    		te[ 5 ] = ( n31 * n12 - n32 * n11 ) * detInv;

    		te[ 6 ] = t13 * detInv;
    		te[ 7 ] = ( n21 * n13 - n23 * n11 ) * detInv;
    		te[ 8 ] = ( n22 * n11 - n21 * n12 ) * detInv;

    		return this;

    	}

    	transpose() {

    		let tmp;
    		const m = this.elements;

    		tmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;
    		tmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;
    		tmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;

    		return this;

    	}

    	getNormalMatrix( matrix4 ) {

    		return this.setFromMatrix4( matrix4 ).invert().transpose();

    	}

    	transposeIntoArray( r ) {

    		const m = this.elements;

    		r[ 0 ] = m[ 0 ];
    		r[ 1 ] = m[ 3 ];
    		r[ 2 ] = m[ 6 ];
    		r[ 3 ] = m[ 1 ];
    		r[ 4 ] = m[ 4 ];
    		r[ 5 ] = m[ 7 ];
    		r[ 6 ] = m[ 2 ];
    		r[ 7 ] = m[ 5 ];
    		r[ 8 ] = m[ 8 ];

    		return this;

    	}

    	setUvTransform( tx, ty, sx, sy, rotation, cx, cy ) {

    		const c = Math.cos( rotation );
    		const s = Math.sin( rotation );

    		this.set(
    			sx * c, sx * s, - sx * ( c * cx + s * cy ) + cx + tx,
    			- sy * s, sy * c, - sy * ( - s * cx + c * cy ) + cy + ty,
    			0, 0, 1
    		);

    		return this;

    	}

    	//

    	scale( sx, sy ) {

    		this.premultiply( _m3.makeScale( sx, sy ) );

    		return this;

    	}

    	rotate( theta ) {

    		this.premultiply( _m3.makeRotation( - theta ) );

    		return this;

    	}

    	translate( tx, ty ) {

    		this.premultiply( _m3.makeTranslation( tx, ty ) );

    		return this;

    	}

    	// for 2D Transforms

    	makeTranslation( x, y ) {

    		this.set(

    			1, 0, x,
    			0, 1, y,
    			0, 0, 1

    		);

    		return this;

    	}

    	makeRotation( theta ) {

    		// counterclockwise

    		const c = Math.cos( theta );
    		const s = Math.sin( theta );

    		this.set(

    			c, - s, 0,
    			s, c, 0,
    			0, 0, 1

    		);

    		return this;

    	}

    	makeScale( x, y ) {

    		this.set(

    			x, 0, 0,
    			0, y, 0,
    			0, 0, 1

    		);

    		return this;

    	}

    	//

    	equals( matrix ) {

    		const te = this.elements;
    		const me = matrix.elements;

    		for ( let i = 0; i < 9; i ++ ) {

    			if ( te[ i ] !== me[ i ] ) return false;

    		}

    		return true;

    	}

    	fromArray( array, offset = 0 ) {

    		for ( let i = 0; i < 9; i ++ ) {

    			this.elements[ i ] = array[ i + offset ];

    		}

    		return this;

    	}

    	toArray( array = [], offset = 0 ) {

    		const te = this.elements;

    		array[ offset ] = te[ 0 ];
    		array[ offset + 1 ] = te[ 1 ];
    		array[ offset + 2 ] = te[ 2 ];

    		array[ offset + 3 ] = te[ 3 ];
    		array[ offset + 4 ] = te[ 4 ];
    		array[ offset + 5 ] = te[ 5 ];

    		array[ offset + 6 ] = te[ 6 ];
    		array[ offset + 7 ] = te[ 7 ];
    		array[ offset + 8 ] = te[ 8 ];

    		return array;

    	}

    	clone() {

    		return new this.constructor().fromArray( this.elements );

    	}

    }

    const _m3 = /*@__PURE__*/ new Matrix3();

    function arrayNeedsUint32( array ) {

    	// assumes larger values usually on last

    	for ( let i = array.length - 1; i >= 0; -- i ) {

    		if ( array[ i ] >= 65535 ) return true; // account for PRIMITIVE_RESTART_FIXED_INDEX, #24565

    	}

    	return false;

    }

    function createElementNS( name ) {

    	return document.createElementNS( 'http://www.w3.org/1999/xhtml', name );

    }

    function SRGBToLinear( c ) {

    	return ( c < 0.04045 ) ? c * 0.0773993808 : Math.pow( c * 0.9478672986 + 0.0521327014, 2.4 );

    }

    function LinearToSRGB( c ) {

    	return ( c < 0.0031308 ) ? c * 12.92 : 1.055 * ( Math.pow( c, 0.41666 ) ) - 0.055;

    }

    // JavaScript RGB-to-RGB transforms, defined as
    // FN[InputColorSpace][OutputColorSpace] callback functions.
    const FN = {
    	[ SRGBColorSpace ]: { [ LinearSRGBColorSpace ]: SRGBToLinear },
    	[ LinearSRGBColorSpace ]: { [ SRGBColorSpace ]: LinearToSRGB },
    };

    const ColorManagement = {

    	legacyMode: true,

    	get workingColorSpace() {

    		return LinearSRGBColorSpace;

    	},

    	set workingColorSpace( colorSpace ) {

    		console.warn( 'THREE.ColorManagement: .workingColorSpace is readonly.' );

    	},

    	convert: function ( color, sourceColorSpace, targetColorSpace ) {

    		if ( this.legacyMode || sourceColorSpace === targetColorSpace || ! sourceColorSpace || ! targetColorSpace ) {

    			return color;

    		}

    		if ( FN[ sourceColorSpace ] && FN[ sourceColorSpace ][ targetColorSpace ] !== undefined ) {

    			const fn = FN[ sourceColorSpace ][ targetColorSpace ];

    			color.r = fn( color.r );
    			color.g = fn( color.g );
    			color.b = fn( color.b );

    			return color;

    		}

    		throw new Error( 'Unsupported color space conversion.' );

    	},

    	fromWorkingColorSpace: function ( color, targetColorSpace ) {

    		return this.convert( color, this.workingColorSpace, targetColorSpace );

    	},

    	toWorkingColorSpace: function ( color, sourceColorSpace ) {

    		return this.convert( color, sourceColorSpace, this.workingColorSpace );

    	},

    };

    const _colorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,
    	'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,
    	'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,
    	'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,
    	'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,
    	'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,
    	'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,
    	'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,
    	'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,
    	'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,
    	'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,
    	'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,
    	'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,
    	'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,
    	'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,
    	'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,
    	'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,
    	'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,
    	'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,
    	'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'rebeccapurple': 0x663399, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,
    	'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,
    	'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,
    	'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,
    	'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };

    const _rgb$1 = { r: 0, g: 0, b: 0 };
    const _hslA = { h: 0, s: 0, l: 0 };
    const _hslB = { h: 0, s: 0, l: 0 };

    function hue2rgb( p, q, t ) {

    	if ( t < 0 ) t += 1;
    	if ( t > 1 ) t -= 1;
    	if ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;
    	if ( t < 1 / 2 ) return q;
    	if ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );
    	return p;

    }

    function toComponents( source, target ) {

    	target.r = source.r;
    	target.g = source.g;
    	target.b = source.b;

    	return target;

    }

    class Color$1 {

    	constructor( r, g, b ) {

    		this.isColor = true;

    		this.r = 1;
    		this.g = 1;
    		this.b = 1;

    		if ( g === undefined && b === undefined ) {

    			// r is THREE.Color, hex or string
    			return this.set( r );

    		}

    		return this.setRGB( r, g, b );

    	}

    	set( value ) {

    		if ( value && value.isColor ) {

    			this.copy( value );

    		} else if ( typeof value === 'number' ) {

    			this.setHex( value );

    		} else if ( typeof value === 'string' ) {

    			this.setStyle( value );

    		}

    		return this;

    	}

    	setScalar( scalar ) {

    		this.r = scalar;
    		this.g = scalar;
    		this.b = scalar;

    		return this;

    	}

    	setHex( hex, colorSpace = SRGBColorSpace ) {

    		hex = Math.floor( hex );

    		this.r = ( hex >> 16 & 255 ) / 255;
    		this.g = ( hex >> 8 & 255 ) / 255;
    		this.b = ( hex & 255 ) / 255;

    		ColorManagement.toWorkingColorSpace( this, colorSpace );

    		return this;

    	}

    	setRGB( r, g, b, colorSpace = ColorManagement.workingColorSpace ) {

    		this.r = r;
    		this.g = g;
    		this.b = b;

    		ColorManagement.toWorkingColorSpace( this, colorSpace );

    		return this;

    	}

    	setHSL( h, s, l, colorSpace = ColorManagement.workingColorSpace ) {

    		// h,s,l ranges are in 0.0 - 1.0
    		h = euclideanModulo( h, 1 );
    		s = clamp$1( s, 0, 1 );
    		l = clamp$1( l, 0, 1 );

    		if ( s === 0 ) {

    			this.r = this.g = this.b = l;

    		} else {

    			const p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );
    			const q = ( 2 * l ) - p;

    			this.r = hue2rgb( q, p, h + 1 / 3 );
    			this.g = hue2rgb( q, p, h );
    			this.b = hue2rgb( q, p, h - 1 / 3 );

    		}

    		ColorManagement.toWorkingColorSpace( this, colorSpace );

    		return this;

    	}

    	setStyle( style, colorSpace = SRGBColorSpace ) {

    		function handleAlpha( string ) {

    			if ( string === undefined ) return;

    			if ( parseFloat( string ) < 1 ) {

    				console.warn( 'THREE.Color: Alpha component of ' + style + ' will be ignored.' );

    			}

    		}


    		let m;

    		if ( m = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec( style ) ) {

    			// rgb / hsl

    			let color;
    			const name = m[ 1 ];
    			const components = m[ 2 ];

    			switch ( name ) {

    				case 'rgb':
    				case 'rgba':

    					if ( color = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec( components ) ) {

    						// rgb(255,0,0) rgba(255,0,0,0.5)
    						this.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;
    						this.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;
    						this.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;

    						ColorManagement.toWorkingColorSpace( this, colorSpace );

    						handleAlpha( color[ 4 ] );

    						return this;

    					}

    					if ( color = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec( components ) ) {

    						// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)
    						this.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;
    						this.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;
    						this.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;

    						ColorManagement.toWorkingColorSpace( this, colorSpace );

    						handleAlpha( color[ 4 ] );

    						return this;

    					}

    					break;

    				case 'hsl':
    				case 'hsla':

    					if ( color = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec( components ) ) {

    						// hsl(120,50%,50%) hsla(120,50%,50%,0.5)
    						const h = parseFloat( color[ 1 ] ) / 360;
    						const s = parseFloat( color[ 2 ] ) / 100;
    						const l = parseFloat( color[ 3 ] ) / 100;

    						handleAlpha( color[ 4 ] );

    						return this.setHSL( h, s, l, colorSpace );

    					}

    					break;

    			}

    		} else if ( m = /^\#([A-Fa-f\d]+)$/.exec( style ) ) {

    			// hex color

    			const hex = m[ 1 ];
    			const size = hex.length;

    			if ( size === 3 ) {

    				// #ff0
    				this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 0 ), 16 ) / 255;
    				this.g = parseInt( hex.charAt( 1 ) + hex.charAt( 1 ), 16 ) / 255;
    				this.b = parseInt( hex.charAt( 2 ) + hex.charAt( 2 ), 16 ) / 255;

    				ColorManagement.toWorkingColorSpace( this, colorSpace );

    				return this;

    			} else if ( size === 6 ) {

    				// #ff0000
    				this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 1 ), 16 ) / 255;
    				this.g = parseInt( hex.charAt( 2 ) + hex.charAt( 3 ), 16 ) / 255;
    				this.b = parseInt( hex.charAt( 4 ) + hex.charAt( 5 ), 16 ) / 255;

    				ColorManagement.toWorkingColorSpace( this, colorSpace );

    				return this;

    			}

    		}

    		if ( style && style.length > 0 ) {

    			return this.setColorName( style, colorSpace );

    		}

    		return this;

    	}

    	setColorName( style, colorSpace = SRGBColorSpace ) {

    		// color keywords
    		const hex = _colorKeywords[ style.toLowerCase() ];

    		if ( hex !== undefined ) {

    			// red
    			this.setHex( hex, colorSpace );

    		} else {

    			// unknown color
    			console.warn( 'THREE.Color: Unknown color ' + style );

    		}

    		return this;

    	}

    	clone() {

    		return new this.constructor( this.r, this.g, this.b );

    	}

    	copy( color ) {

    		this.r = color.r;
    		this.g = color.g;
    		this.b = color.b;

    		return this;

    	}

    	copySRGBToLinear( color ) {

    		this.r = SRGBToLinear( color.r );
    		this.g = SRGBToLinear( color.g );
    		this.b = SRGBToLinear( color.b );

    		return this;

    	}

    	copyLinearToSRGB( color ) {

    		this.r = LinearToSRGB( color.r );
    		this.g = LinearToSRGB( color.g );
    		this.b = LinearToSRGB( color.b );

    		return this;

    	}

    	convertSRGBToLinear() {

    		this.copySRGBToLinear( this );

    		return this;

    	}

    	convertLinearToSRGB() {

    		this.copyLinearToSRGB( this );

    		return this;

    	}

    	getHex( colorSpace = SRGBColorSpace ) {

    		ColorManagement.fromWorkingColorSpace( toComponents( this, _rgb$1 ), colorSpace );

    		return clamp$1( _rgb$1.r * 255, 0, 255 ) << 16 ^ clamp$1( _rgb$1.g * 255, 0, 255 ) << 8 ^ clamp$1( _rgb$1.b * 255, 0, 255 ) << 0;

    	}

    	getHexString( colorSpace = SRGBColorSpace ) {

    		return ( '000000' + this.getHex( colorSpace ).toString( 16 ) ).slice( - 6 );

    	}

    	getHSL( target, colorSpace = ColorManagement.workingColorSpace ) {

    		// h,s,l ranges are in 0.0 - 1.0

    		ColorManagement.fromWorkingColorSpace( toComponents( this, _rgb$1 ), colorSpace );

    		const r = _rgb$1.r, g = _rgb$1.g, b = _rgb$1.b;

    		const max = Math.max( r, g, b );
    		const min = Math.min( r, g, b );

    		let hue, saturation;
    		const lightness = ( min + max ) / 2.0;

    		if ( min === max ) {

    			hue = 0;
    			saturation = 0;

    		} else {

    			const delta = max - min;

    			saturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );

    			switch ( max ) {

    				case r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;
    				case g: hue = ( b - r ) / delta + 2; break;
    				case b: hue = ( r - g ) / delta + 4; break;

    			}

    			hue /= 6;

    		}

    		target.h = hue;
    		target.s = saturation;
    		target.l = lightness;

    		return target;

    	}

    	getRGB( target, colorSpace = ColorManagement.workingColorSpace ) {

    		ColorManagement.fromWorkingColorSpace( toComponents( this, _rgb$1 ), colorSpace );

    		target.r = _rgb$1.r;
    		target.g = _rgb$1.g;
    		target.b = _rgb$1.b;

    		return target;

    	}

    	getStyle( colorSpace = SRGBColorSpace ) {

    		ColorManagement.fromWorkingColorSpace( toComponents( this, _rgb$1 ), colorSpace );

    		if ( colorSpace !== SRGBColorSpace ) {

    			// Requires CSS Color Module Level 4 (https://www.w3.org/TR/css-color-4/).
    			return `color(${ colorSpace } ${ _rgb$1.r } ${ _rgb$1.g } ${ _rgb$1.b })`;

    		}

    		return `rgb(${( _rgb$1.r * 255 ) | 0},${( _rgb$1.g * 255 ) | 0},${( _rgb$1.b * 255 ) | 0})`;

    	}

    	offsetHSL( h, s, l ) {

    		this.getHSL( _hslA );

    		_hslA.h += h; _hslA.s += s; _hslA.l += l;

    		this.setHSL( _hslA.h, _hslA.s, _hslA.l );

    		return this;

    	}

    	add( color ) {

    		this.r += color.r;
    		this.g += color.g;
    		this.b += color.b;

    		return this;

    	}

    	addColors( color1, color2 ) {

    		this.r = color1.r + color2.r;
    		this.g = color1.g + color2.g;
    		this.b = color1.b + color2.b;

    		return this;

    	}

    	addScalar( s ) {

    		this.r += s;
    		this.g += s;
    		this.b += s;

    		return this;

    	}

    	sub( color ) {

    		this.r = Math.max( 0, this.r - color.r );
    		this.g = Math.max( 0, this.g - color.g );
    		this.b = Math.max( 0, this.b - color.b );

    		return this;

    	}

    	multiply( color ) {

    		this.r *= color.r;
    		this.g *= color.g;
    		this.b *= color.b;

    		return this;

    	}

    	multiplyScalar( s ) {

    		this.r *= s;
    		this.g *= s;
    		this.b *= s;

    		return this;

    	}

    	lerp( color, alpha ) {

    		this.r += ( color.r - this.r ) * alpha;
    		this.g += ( color.g - this.g ) * alpha;
    		this.b += ( color.b - this.b ) * alpha;

    		return this;

    	}

    	lerpColors( color1, color2, alpha ) {

    		this.r = color1.r + ( color2.r - color1.r ) * alpha;
    		this.g = color1.g + ( color2.g - color1.g ) * alpha;
    		this.b = color1.b + ( color2.b - color1.b ) * alpha;

    		return this;

    	}

    	lerpHSL( color, alpha ) {

    		this.getHSL( _hslA );
    		color.getHSL( _hslB );

    		const h = lerp( _hslA.h, _hslB.h, alpha );
    		const s = lerp( _hslA.s, _hslB.s, alpha );
    		const l = lerp( _hslA.l, _hslB.l, alpha );

    		this.setHSL( h, s, l );

    		return this;

    	}

    	equals( c ) {

    		return ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );

    	}

    	fromArray( array, offset = 0 ) {

    		this.r = array[ offset ];
    		this.g = array[ offset + 1 ];
    		this.b = array[ offset + 2 ];

    		return this;

    	}

    	toArray( array = [], offset = 0 ) {

    		array[ offset ] = this.r;
    		array[ offset + 1 ] = this.g;
    		array[ offset + 2 ] = this.b;

    		return array;

    	}

    	fromBufferAttribute( attribute, index ) {

    		this.r = attribute.getX( index );
    		this.g = attribute.getY( index );
    		this.b = attribute.getZ( index );

    		return this;

    	}

    	toJSON() {

    		return this.getHex();

    	}

    	*[ Symbol.iterator ]() {

    		yield this.r;
    		yield this.g;
    		yield this.b;

    	}

    }

    Color$1.NAMES = _colorKeywords;

    let _canvas;

    class ImageUtils {

    	static getDataURL( image ) {

    		if ( /^data:/i.test( image.src ) ) {

    			return image.src;

    		}

    		if ( typeof HTMLCanvasElement == 'undefined' ) {

    			return image.src;

    		}

    		let canvas;

    		if ( image instanceof HTMLCanvasElement ) {

    			canvas = image;

    		} else {

    			if ( _canvas === undefined ) _canvas = createElementNS( 'canvas' );

    			_canvas.width = image.width;
    			_canvas.height = image.height;

    			const context = _canvas.getContext( '2d' );

    			if ( image instanceof ImageData ) {

    				context.putImageData( image, 0, 0 );

    			} else {

    				context.drawImage( image, 0, 0, image.width, image.height );

    			}

    			canvas = _canvas;

    		}

    		if ( canvas.width > 2048 || canvas.height > 2048 ) {

    			console.warn( 'THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons', image );

    			return canvas.toDataURL( 'image/jpeg', 0.6 );

    		} else {

    			return canvas.toDataURL( 'image/png' );

    		}

    	}

    	static sRGBToLinear( image ) {

    		if ( ( typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement ) ||
    			( typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement ) ||
    			( typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap ) ) {

    			const canvas = createElementNS( 'canvas' );

    			canvas.width = image.width;
    			canvas.height = image.height;

    			const context = canvas.getContext( '2d' );
    			context.drawImage( image, 0, 0, image.width, image.height );

    			const imageData = context.getImageData( 0, 0, image.width, image.height );
    			const data = imageData.data;

    			for ( let i = 0; i < data.length; i ++ ) {

    				data[ i ] = SRGBToLinear( data[ i ] / 255 ) * 255;

    			}

    			context.putImageData( imageData, 0, 0 );

    			return canvas;

    		} else if ( image.data ) {

    			const data = image.data.slice( 0 );

    			for ( let i = 0; i < data.length; i ++ ) {

    				if ( data instanceof Uint8Array || data instanceof Uint8ClampedArray ) {

    					data[ i ] = Math.floor( SRGBToLinear( data[ i ] / 255 ) * 255 );

    				} else {

    					// assuming float

    					data[ i ] = SRGBToLinear( data[ i ] );

    				}

    			}

    			return {
    				data: data,
    				width: image.width,
    				height: image.height
    			};

    		} else {

    			console.warn( 'THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied.' );
    			return image;

    		}

    	}

    }

    class Source {

    	constructor( data = null ) {

    		this.isSource = true;

    		this.uuid = generateUUID();

    		this.data = data;

    		this.version = 0;

    	}

    	set needsUpdate( value ) {

    		if ( value === true ) this.version ++;

    	}

    	toJSON( meta ) {

    		const isRootObject = ( meta === undefined || typeof meta === 'string' );

    		if ( ! isRootObject && meta.images[ this.uuid ] !== undefined ) {

    			return meta.images[ this.uuid ];

    		}

    		const output = {
    			uuid: this.uuid,
    			url: ''
    		};

    		const data = this.data;

    		if ( data !== null ) {

    			let url;

    			if ( Array.isArray( data ) ) {

    				// cube texture

    				url = [];

    				for ( let i = 0, l = data.length; i < l; i ++ ) {

    					if ( data[ i ].isDataTexture ) {

    						url.push( serializeImage( data[ i ].image ) );

    					} else {

    						url.push( serializeImage( data[ i ] ) );

    					}

    				}

    			} else {

    				// texture

    				url = serializeImage( data );

    			}

    			output.url = url;

    		}

    		if ( ! isRootObject ) {

    			meta.images[ this.uuid ] = output;

    		}

    		return output;

    	}

    }

    function serializeImage( image ) {

    	if ( ( typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement ) ||
    		( typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement ) ||
    		( typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap ) ) {

    		// default images

    		return ImageUtils.getDataURL( image );

    	} else {

    		if ( image.data ) {

    			// images of DataTexture

    			return {
    				data: Array.from( image.data ),
    				width: image.width,
    				height: image.height,
    				type: image.data.constructor.name
    			};

    		} else {

    			console.warn( 'THREE.Texture: Unable to serialize Texture.' );
    			return {};

    		}

    	}

    }

    let textureId = 0;

    class Texture extends EventDispatcher {

    	constructor( image = Texture.DEFAULT_IMAGE, mapping = Texture.DEFAULT_MAPPING, wrapS = ClampToEdgeWrapping, wrapT = ClampToEdgeWrapping, magFilter = LinearFilter, minFilter = LinearMipmapLinearFilter, format = RGBAFormat, type = UnsignedByteType, anisotropy = Texture.DEFAULT_ANISOTROPY, encoding = LinearEncoding ) {

    		super();

    		this.isTexture = true;

    		Object.defineProperty( this, 'id', { value: textureId ++ } );

    		this.uuid = generateUUID();

    		this.name = '';

    		this.source = new Source( image );
    		this.mipmaps = [];

    		this.mapping = mapping;

    		this.wrapS = wrapS;
    		this.wrapT = wrapT;

    		this.magFilter = magFilter;
    		this.minFilter = minFilter;

    		this.anisotropy = anisotropy;

    		this.format = format;
    		this.internalFormat = null;
    		this.type = type;

    		this.offset = new Vector2( 0, 0 );
    		this.repeat = new Vector2( 1, 1 );
    		this.center = new Vector2( 0, 0 );
    		this.rotation = 0;

    		this.matrixAutoUpdate = true;
    		this.matrix = new Matrix3();

    		this.generateMipmaps = true;
    		this.premultiplyAlpha = false;
    		this.flipY = true;
    		this.unpackAlignment = 4;	// valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)

    		// Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.
    		//
    		// Also changing the encoding after already used by a Material will not automatically make the Material
    		// update. You need to explicitly call Material.needsUpdate to trigger it to recompile.
    		this.encoding = encoding;

    		this.userData = {};

    		this.version = 0;
    		this.onUpdate = null;

    		this.isRenderTargetTexture = false; // indicates whether a texture belongs to a render target or not
    		this.needsPMREMUpdate = false; // indicates whether this texture should be processed by PMREMGenerator or not (only relevant for render target textures)

    	}

    	get image() {

    		return this.source.data;

    	}

    	set image( value ) {

    		this.source.data = value;

    	}

    	updateMatrix() {

    		this.matrix.setUvTransform( this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y );

    	}

    	clone() {

    		return new this.constructor().copy( this );

    	}

    	copy( source ) {

    		this.name = source.name;

    		this.source = source.source;
    		this.mipmaps = source.mipmaps.slice( 0 );

    		this.mapping = source.mapping;

    		this.wrapS = source.wrapS;
    		this.wrapT = source.wrapT;

    		this.magFilter = source.magFilter;
    		this.minFilter = source.minFilter;

    		this.anisotropy = source.anisotropy;

    		this.format = source.format;
    		this.internalFormat = source.internalFormat;
    		this.type = source.type;

    		this.offset.copy( source.offset );
    		this.repeat.copy( source.repeat );
    		this.center.copy( source.center );
    		this.rotation = source.rotation;

    		this.matrixAutoUpdate = source.matrixAutoUpdate;
    		this.matrix.copy( source.matrix );

    		this.generateMipmaps = source.generateMipmaps;
    		this.premultiplyAlpha = source.premultiplyAlpha;
    		this.flipY = source.flipY;
    		this.unpackAlignment = source.unpackAlignment;
    		this.encoding = source.encoding;

    		this.userData = JSON.parse( JSON.stringify( source.userData ) );

    		this.needsUpdate = true;

    		return this;

    	}

    	toJSON( meta ) {

    		const isRootObject = ( meta === undefined || typeof meta === 'string' );

    		if ( ! isRootObject && meta.textures[ this.uuid ] !== undefined ) {

    			return meta.textures[ this.uuid ];

    		}

    		const output = {

    			metadata: {
    				version: 4.5,
    				type: 'Texture',
    				generator: 'Texture.toJSON'
    			},

    			uuid: this.uuid,
    			name: this.name,

    			image: this.source.toJSON( meta ).uuid,

    			mapping: this.mapping,

    			repeat: [ this.repeat.x, this.repeat.y ],
    			offset: [ this.offset.x, this.offset.y ],
    			center: [ this.center.x, this.center.y ],
    			rotation: this.rotation,

    			wrap: [ this.wrapS, this.wrapT ],

    			format: this.format,
    			type: this.type,
    			encoding: this.encoding,

    			minFilter: this.minFilter,
    			magFilter: this.magFilter,
    			anisotropy: this.anisotropy,

    			flipY: this.flipY,

    			premultiplyAlpha: this.premultiplyAlpha,
    			unpackAlignment: this.unpackAlignment

    		};

    		if ( JSON.stringify( this.userData ) !== '{}' ) output.userData = this.userData;

    		if ( ! isRootObject ) {

    			meta.textures[ this.uuid ] = output;

    		}

    		return output;

    	}

    	dispose() {

    		this.dispatchEvent( { type: 'dispose' } );

    	}

    	transformUv( uv ) {

    		if ( this.mapping !== UVMapping ) return uv;

    		uv.applyMatrix3( this.matrix );

    		if ( uv.x < 0 || uv.x > 1 ) {

    			switch ( this.wrapS ) {

    				case RepeatWrapping:

    					uv.x = uv.x - Math.floor( uv.x );
    					break;

    				case ClampToEdgeWrapping:

    					uv.x = uv.x < 0 ? 0 : 1;
    					break;

    				case MirroredRepeatWrapping:

    					if ( Math.abs( Math.floor( uv.x ) % 2 ) === 1 ) {

    						uv.x = Math.ceil( uv.x ) - uv.x;

    					} else {

    						uv.x = uv.x - Math.floor( uv.x );

    					}

    					break;

    			}

    		}

    		if ( uv.y < 0 || uv.y > 1 ) {

    			switch ( this.wrapT ) {

    				case RepeatWrapping:

    					uv.y = uv.y - Math.floor( uv.y );
    					break;

    				case ClampToEdgeWrapping:

    					uv.y = uv.y < 0 ? 0 : 1;
    					break;

    				case MirroredRepeatWrapping:

    					if ( Math.abs( Math.floor( uv.y ) % 2 ) === 1 ) {

    						uv.y = Math.ceil( uv.y ) - uv.y;

    					} else {

    						uv.y = uv.y - Math.floor( uv.y );

    					}

    					break;

    			}

    		}

    		if ( this.flipY ) {

    			uv.y = 1 - uv.y;

    		}

    		return uv;

    	}

    	set needsUpdate( value ) {

    		if ( value === true ) {

    			this.version ++;
    			this.source.needsUpdate = true;

    		}

    	}

    }

    Texture.DEFAULT_IMAGE = null;
    Texture.DEFAULT_MAPPING = UVMapping;
    Texture.DEFAULT_ANISOTROPY = 1;

    class Vector4 {

    	constructor( x = 0, y = 0, z = 0, w = 1 ) {

    		Vector4.prototype.isVector4 = true;

    		this.x = x;
    		this.y = y;
    		this.z = z;
    		this.w = w;

    	}

    	get width() {

    		return this.z;

    	}

    	set width( value ) {

    		this.z = value;

    	}

    	get height() {

    		return this.w;

    	}

    	set height( value ) {

    		this.w = value;

    	}

    	set( x, y, z, w ) {

    		this.x = x;
    		this.y = y;
    		this.z = z;
    		this.w = w;

    		return this;

    	}

    	setScalar( scalar ) {

    		this.x = scalar;
    		this.y = scalar;
    		this.z = scalar;
    		this.w = scalar;

    		return this;

    	}

    	setX( x ) {

    		this.x = x;

    		return this;

    	}

    	setY( y ) {

    		this.y = y;

    		return this;

    	}

    	setZ( z ) {

    		this.z = z;

    		return this;

    	}

    	setW( w ) {

    		this.w = w;

    		return this;

    	}

    	setComponent( index, value ) {

    		switch ( index ) {

    			case 0: this.x = value; break;
    			case 1: this.y = value; break;
    			case 2: this.z = value; break;
    			case 3: this.w = value; break;
    			default: throw new Error( 'index is out of range: ' + index );

    		}

    		return this;

    	}

    	getComponent( index ) {

    		switch ( index ) {

    			case 0: return this.x;
    			case 1: return this.y;
    			case 2: return this.z;
    			case 3: return this.w;
    			default: throw new Error( 'index is out of range: ' + index );

    		}

    	}

    	clone() {

    		return new this.constructor( this.x, this.y, this.z, this.w );

    	}

    	copy( v ) {

    		this.x = v.x;
    		this.y = v.y;
    		this.z = v.z;
    		this.w = ( v.w !== undefined ) ? v.w : 1;

    		return this;

    	}

    	add( v ) {

    		this.x += v.x;
    		this.y += v.y;
    		this.z += v.z;
    		this.w += v.w;

    		return this;

    	}

    	addScalar( s ) {

    		this.x += s;
    		this.y += s;
    		this.z += s;
    		this.w += s;

    		return this;

    	}

    	addVectors( a, b ) {

    		this.x = a.x + b.x;
    		this.y = a.y + b.y;
    		this.z = a.z + b.z;
    		this.w = a.w + b.w;

    		return this;

    	}

    	addScaledVector( v, s ) {

    		this.x += v.x * s;
    		this.y += v.y * s;
    		this.z += v.z * s;
    		this.w += v.w * s;

    		return this;

    	}

    	sub( v ) {

    		this.x -= v.x;
    		this.y -= v.y;
    		this.z -= v.z;
    		this.w -= v.w;

    		return this;

    	}

    	subScalar( s ) {

    		this.x -= s;
    		this.y -= s;
    		this.z -= s;
    		this.w -= s;

    		return this;

    	}

    	subVectors( a, b ) {

    		this.x = a.x - b.x;
    		this.y = a.y - b.y;
    		this.z = a.z - b.z;
    		this.w = a.w - b.w;

    		return this;

    	}

    	multiply( v ) {

    		this.x *= v.x;
    		this.y *= v.y;
    		this.z *= v.z;
    		this.w *= v.w;

    		return this;

    	}

    	multiplyScalar( scalar ) {

    		this.x *= scalar;
    		this.y *= scalar;
    		this.z *= scalar;
    		this.w *= scalar;

    		return this;

    	}

    	applyMatrix4( m ) {

    		const x = this.x, y = this.y, z = this.z, w = this.w;
    		const e = m.elements;

    		this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;
    		this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;
    		this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;
    		this.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;

    		return this;

    	}

    	divideScalar( scalar ) {

    		return this.multiplyScalar( 1 / scalar );

    	}

    	setAxisAngleFromQuaternion( q ) {

    		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm

    		// q is assumed to be normalized

    		this.w = 2 * Math.acos( q.w );

    		const s = Math.sqrt( 1 - q.w * q.w );

    		if ( s < 0.0001 ) {

    			this.x = 1;
    			this.y = 0;
    			this.z = 0;

    		} else {

    			this.x = q.x / s;
    			this.y = q.y / s;
    			this.z = q.z / s;

    		}

    		return this;

    	}

    	setAxisAngleFromRotationMatrix( m ) {

    		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm

    		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

    		let angle, x, y, z; // variables for result
    		const epsilon = 0.01,		// margin to allow for rounding errors
    			epsilon2 = 0.1,		// margin to distinguish between 0 and 180 degrees

    			te = m.elements,

    			m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
    			m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
    			m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

    		if ( ( Math.abs( m12 - m21 ) < epsilon ) &&
    		     ( Math.abs( m13 - m31 ) < epsilon ) &&
    		     ( Math.abs( m23 - m32 ) < epsilon ) ) {

    			// singularity found
    			// first check for identity matrix which must have +1 for all terms
    			// in leading diagonal and zero in other terms

    			if ( ( Math.abs( m12 + m21 ) < epsilon2 ) &&
    			     ( Math.abs( m13 + m31 ) < epsilon2 ) &&
    			     ( Math.abs( m23 + m32 ) < epsilon2 ) &&
    			     ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {

    				// this singularity is identity matrix so angle = 0

    				this.set( 1, 0, 0, 0 );

    				return this; // zero angle, arbitrary axis

    			}

    			// otherwise this singularity is angle = 180

    			angle = Math.PI;

    			const xx = ( m11 + 1 ) / 2;
    			const yy = ( m22 + 1 ) / 2;
    			const zz = ( m33 + 1 ) / 2;
    			const xy = ( m12 + m21 ) / 4;
    			const xz = ( m13 + m31 ) / 4;
    			const yz = ( m23 + m32 ) / 4;

    			if ( ( xx > yy ) && ( xx > zz ) ) {

    				// m11 is the largest diagonal term

    				if ( xx < epsilon ) {

    					x = 0;
    					y = 0.707106781;
    					z = 0.707106781;

    				} else {

    					x = Math.sqrt( xx );
    					y = xy / x;
    					z = xz / x;

    				}

    			} else if ( yy > zz ) {

    				// m22 is the largest diagonal term

    				if ( yy < epsilon ) {

    					x = 0.707106781;
    					y = 0;
    					z = 0.707106781;

    				} else {

    					y = Math.sqrt( yy );
    					x = xy / y;
    					z = yz / y;

    				}

    			} else {

    				// m33 is the largest diagonal term so base result on this

    				if ( zz < epsilon ) {

    					x = 0.707106781;
    					y = 0.707106781;
    					z = 0;

    				} else {

    					z = Math.sqrt( zz );
    					x = xz / z;
    					y = yz / z;

    				}

    			}

    			this.set( x, y, z, angle );

    			return this; // return 180 deg rotation

    		}

    		// as we have reached here there are no singularities so we can handle normally

    		let s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 ) +
    			( m13 - m31 ) * ( m13 - m31 ) +
    			( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize

    		if ( Math.abs( s ) < 0.001 ) s = 1;

    		// prevent divide by zero, should not happen if matrix is orthogonal and should be
    		// caught by singularity test above, but I've left it in just in case

    		this.x = ( m32 - m23 ) / s;
    		this.y = ( m13 - m31 ) / s;
    		this.z = ( m21 - m12 ) / s;
    		this.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );

    		return this;

    	}

    	min( v ) {

    		this.x = Math.min( this.x, v.x );
    		this.y = Math.min( this.y, v.y );
    		this.z = Math.min( this.z, v.z );
    		this.w = Math.min( this.w, v.w );

    		return this;

    	}

    	max( v ) {

    		this.x = Math.max( this.x, v.x );
    		this.y = Math.max( this.y, v.y );
    		this.z = Math.max( this.z, v.z );
    		this.w = Math.max( this.w, v.w );

    		return this;

    	}

    	clamp( min, max ) {

    		// assumes min < max, componentwise

    		this.x = Math.max( min.x, Math.min( max.x, this.x ) );
    		this.y = Math.max( min.y, Math.min( max.y, this.y ) );
    		this.z = Math.max( min.z, Math.min( max.z, this.z ) );
    		this.w = Math.max( min.w, Math.min( max.w, this.w ) );

    		return this;

    	}

    	clampScalar( minVal, maxVal ) {

    		this.x = Math.max( minVal, Math.min( maxVal, this.x ) );
    		this.y = Math.max( minVal, Math.min( maxVal, this.y ) );
    		this.z = Math.max( minVal, Math.min( maxVal, this.z ) );
    		this.w = Math.max( minVal, Math.min( maxVal, this.w ) );

    		return this;

    	}

    	clampLength( min, max ) {

    		const length = this.length();

    		return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );

    	}

    	floor() {

    		this.x = Math.floor( this.x );
    		this.y = Math.floor( this.y );
    		this.z = Math.floor( this.z );
    		this.w = Math.floor( this.w );

    		return this;

    	}

    	ceil() {

    		this.x = Math.ceil( this.x );
    		this.y = Math.ceil( this.y );
    		this.z = Math.ceil( this.z );
    		this.w = Math.ceil( this.w );

    		return this;

    	}

    	round() {

    		this.x = Math.round( this.x );
    		this.y = Math.round( this.y );
    		this.z = Math.round( this.z );
    		this.w = Math.round( this.w );

    		return this;

    	}

    	roundToZero() {

    		this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
    		this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
    		this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );
    		this.w = ( this.w < 0 ) ? Math.ceil( this.w ) : Math.floor( this.w );

    		return this;

    	}

    	negate() {

    		this.x = - this.x;
    		this.y = - this.y;
    		this.z = - this.z;
    		this.w = - this.w;

    		return this;

    	}

    	dot( v ) {

    		return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;

    	}

    	lengthSq() {

    		return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;

    	}

    	length() {

    		return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );

    	}

    	manhattanLength() {

    		return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );

    	}

    	normalize() {

    		return this.divideScalar( this.length() || 1 );

    	}

    	setLength( length ) {

    		return this.normalize().multiplyScalar( length );

    	}

    	lerp( v, alpha ) {

    		this.x += ( v.x - this.x ) * alpha;
    		this.y += ( v.y - this.y ) * alpha;
    		this.z += ( v.z - this.z ) * alpha;
    		this.w += ( v.w - this.w ) * alpha;

    		return this;

    	}

    	lerpVectors( v1, v2, alpha ) {

    		this.x = v1.x + ( v2.x - v1.x ) * alpha;
    		this.y = v1.y + ( v2.y - v1.y ) * alpha;
    		this.z = v1.z + ( v2.z - v1.z ) * alpha;
    		this.w = v1.w + ( v2.w - v1.w ) * alpha;

    		return this;

    	}

    	equals( v ) {

    		return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );

    	}

    	fromArray( array, offset = 0 ) {

    		this.x = array[ offset ];
    		this.y = array[ offset + 1 ];
    		this.z = array[ offset + 2 ];
    		this.w = array[ offset + 3 ];

    		return this;

    	}

    	toArray( array = [], offset = 0 ) {

    		array[ offset ] = this.x;
    		array[ offset + 1 ] = this.y;
    		array[ offset + 2 ] = this.z;
    		array[ offset + 3 ] = this.w;

    		return array;

    	}

    	fromBufferAttribute( attribute, index ) {

    		this.x = attribute.getX( index );
    		this.y = attribute.getY( index );
    		this.z = attribute.getZ( index );
    		this.w = attribute.getW( index );

    		return this;

    	}

    	random() {

    		this.x = Math.random();
    		this.y = Math.random();
    		this.z = Math.random();
    		this.w = Math.random();

    		return this;

    	}

    	*[ Symbol.iterator ]() {

    		yield this.x;
    		yield this.y;
    		yield this.z;
    		yield this.w;

    	}

    }

    /*
     In options, we can specify:
     * Texture parameters for an auto-generated target texture
     * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers
    */
    class WebGLRenderTarget extends EventDispatcher {

    	constructor( width = 1, height = 1, options = {} ) {

    		super();

    		this.isWebGLRenderTarget = true;

    		this.width = width;
    		this.height = height;
    		this.depth = 1;

    		this.scissor = new Vector4( 0, 0, width, height );
    		this.scissorTest = false;

    		this.viewport = new Vector4( 0, 0, width, height );

    		const image = { width: width, height: height, depth: 1 };

    		this.texture = new Texture( image, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding );
    		this.texture.isRenderTargetTexture = true;

    		this.texture.flipY = false;
    		this.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : false;
    		this.texture.internalFormat = options.internalFormat !== undefined ? options.internalFormat : null;
    		this.texture.minFilter = options.minFilter !== undefined ? options.minFilter : LinearFilter;

    		this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
    		this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : false;

    		this.depthTexture = options.depthTexture !== undefined ? options.depthTexture : null;

    		this.samples = options.samples !== undefined ? options.samples : 0;

    	}

    	setSize( width, height, depth = 1 ) {

    		if ( this.width !== width || this.height !== height || this.depth !== depth ) {

    			this.width = width;
    			this.height = height;
    			this.depth = depth;

    			this.texture.image.width = width;
    			this.texture.image.height = height;
    			this.texture.image.depth = depth;

    			this.dispose();

    		}

    		this.viewport.set( 0, 0, width, height );
    		this.scissor.set( 0, 0, width, height );

    	}

    	clone() {

    		return new this.constructor().copy( this );

    	}

    	copy( source ) {

    		this.width = source.width;
    		this.height = source.height;
    		this.depth = source.depth;

    		this.viewport.copy( source.viewport );

    		this.texture = source.texture.clone();
    		this.texture.isRenderTargetTexture = true;

    		// ensure image object is not shared, see #20328

    		const image = Object.assign( {}, source.texture.image );
    		this.texture.source = new Source( image );

    		this.depthBuffer = source.depthBuffer;
    		this.stencilBuffer = source.stencilBuffer;

    		if ( source.depthTexture !== null ) this.depthTexture = source.depthTexture.clone();

    		this.samples = source.samples;

    		return this;

    	}

    	dispose() {

    		this.dispatchEvent( { type: 'dispose' } );

    	}

    }

    class DataArrayTexture extends Texture {

    	constructor( data = null, width = 1, height = 1, depth = 1 ) {

    		super( null );

    		this.isDataArrayTexture = true;

    		this.image = { data, width, height, depth };

    		this.magFilter = NearestFilter;
    		this.minFilter = NearestFilter;

    		this.wrapR = ClampToEdgeWrapping;

    		this.generateMipmaps = false;
    		this.flipY = false;
    		this.unpackAlignment = 1;

    	}

    }

    class Data3DTexture extends Texture {

    	constructor( data = null, width = 1, height = 1, depth = 1 ) {

    		// We're going to add .setXXX() methods for setting properties later.
    		// Users can still set in DataTexture3D directly.
    		//
    		//	const texture = new THREE.DataTexture3D( data, width, height, depth );
    		// 	texture.anisotropy = 16;
    		//
    		// See #14839

    		super( null );

    		this.isData3DTexture = true;

    		this.image = { data, width, height, depth };

    		this.magFilter = NearestFilter;
    		this.minFilter = NearestFilter;

    		this.wrapR = ClampToEdgeWrapping;

    		this.generateMipmaps = false;
    		this.flipY = false;
    		this.unpackAlignment = 1;

    	}

    }

    class Quaternion {

    	constructor( x = 0, y = 0, z = 0, w = 1 ) {

    		this.isQuaternion = true;

    		this._x = x;
    		this._y = y;
    		this._z = z;
    		this._w = w;

    	}

    	static slerpFlat( dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t ) {

    		// fuzz-free, array-based Quaternion SLERP operation

    		let x0 = src0[ srcOffset0 + 0 ],
    			y0 = src0[ srcOffset0 + 1 ],
    			z0 = src0[ srcOffset0 + 2 ],
    			w0 = src0[ srcOffset0 + 3 ];

    		const x1 = src1[ srcOffset1 + 0 ],
    			y1 = src1[ srcOffset1 + 1 ],
    			z1 = src1[ srcOffset1 + 2 ],
    			w1 = src1[ srcOffset1 + 3 ];

    		if ( t === 0 ) {

    			dst[ dstOffset + 0 ] = x0;
    			dst[ dstOffset + 1 ] = y0;
    			dst[ dstOffset + 2 ] = z0;
    			dst[ dstOffset + 3 ] = w0;
    			return;

    		}

    		if ( t === 1 ) {

    			dst[ dstOffset + 0 ] = x1;
    			dst[ dstOffset + 1 ] = y1;
    			dst[ dstOffset + 2 ] = z1;
    			dst[ dstOffset + 3 ] = w1;
    			return;

    		}

    		if ( w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1 ) {

    			let s = 1 - t;
    			const cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,
    				dir = ( cos >= 0 ? 1 : - 1 ),
    				sqrSin = 1 - cos * cos;

    			// Skip the Slerp for tiny steps to avoid numeric problems:
    			if ( sqrSin > Number.EPSILON ) {

    				const sin = Math.sqrt( sqrSin ),
    					len = Math.atan2( sin, cos * dir );

    				s = Math.sin( s * len ) / sin;
    				t = Math.sin( t * len ) / sin;

    			}

    			const tDir = t * dir;

    			x0 = x0 * s + x1 * tDir;
    			y0 = y0 * s + y1 * tDir;
    			z0 = z0 * s + z1 * tDir;
    			w0 = w0 * s + w1 * tDir;

    			// Normalize in case we just did a lerp:
    			if ( s === 1 - t ) {

    				const f = 1 / Math.sqrt( x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0 );

    				x0 *= f;
    				y0 *= f;
    				z0 *= f;
    				w0 *= f;

    			}

    		}

    		dst[ dstOffset ] = x0;
    		dst[ dstOffset + 1 ] = y0;
    		dst[ dstOffset + 2 ] = z0;
    		dst[ dstOffset + 3 ] = w0;

    	}

    	static multiplyQuaternionsFlat( dst, dstOffset, src0, srcOffset0, src1, srcOffset1 ) {

    		const x0 = src0[ srcOffset0 ];
    		const y0 = src0[ srcOffset0 + 1 ];
    		const z0 = src0[ srcOffset0 + 2 ];
    		const w0 = src0[ srcOffset0 + 3 ];

    		const x1 = src1[ srcOffset1 ];
    		const y1 = src1[ srcOffset1 + 1 ];
    		const z1 = src1[ srcOffset1 + 2 ];
    		const w1 = src1[ srcOffset1 + 3 ];

    		dst[ dstOffset ] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;
    		dst[ dstOffset + 1 ] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;
    		dst[ dstOffset + 2 ] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;
    		dst[ dstOffset + 3 ] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;

    		return dst;

    	}

    	get x() {

    		return this._x;

    	}

    	set x( value ) {

    		this._x = value;
    		this._onChangeCallback();

    	}

    	get y() {

    		return this._y;

    	}

    	set y( value ) {

    		this._y = value;
    		this._onChangeCallback();

    	}

    	get z() {

    		return this._z;

    	}

    	set z( value ) {

    		this._z = value;
    		this._onChangeCallback();

    	}

    	get w() {

    		return this._w;

    	}

    	set w( value ) {

    		this._w = value;
    		this._onChangeCallback();

    	}

    	set( x, y, z, w ) {

    		this._x = x;
    		this._y = y;
    		this._z = z;
    		this._w = w;

    		this._onChangeCallback();

    		return this;

    	}

    	clone() {

    		return new this.constructor( this._x, this._y, this._z, this._w );

    	}

    	copy( quaternion ) {

    		this._x = quaternion.x;
    		this._y = quaternion.y;
    		this._z = quaternion.z;
    		this._w = quaternion.w;

    		this._onChangeCallback();

    		return this;

    	}

    	setFromEuler( euler, update ) {

    		const x = euler._x, y = euler._y, z = euler._z, order = euler._order;

    		// http://www.mathworks.com/matlabcentral/fileexchange/
    		// 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
    		//	content/SpinCalc.m

    		const cos = Math.cos;
    		const sin = Math.sin;

    		const c1 = cos( x / 2 );
    		const c2 = cos( y / 2 );
    		const c3 = cos( z / 2 );

    		const s1 = sin( x / 2 );
    		const s2 = sin( y / 2 );
    		const s3 = sin( z / 2 );

    		switch ( order ) {

    			case 'XYZ':
    				this._x = s1 * c2 * c3 + c1 * s2 * s3;
    				this._y = c1 * s2 * c3 - s1 * c2 * s3;
    				this._z = c1 * c2 * s3 + s1 * s2 * c3;
    				this._w = c1 * c2 * c3 - s1 * s2 * s3;
    				break;

    			case 'YXZ':
    				this._x = s1 * c2 * c3 + c1 * s2 * s3;
    				this._y = c1 * s2 * c3 - s1 * c2 * s3;
    				this._z = c1 * c2 * s3 - s1 * s2 * c3;
    				this._w = c1 * c2 * c3 + s1 * s2 * s3;
    				break;

    			case 'ZXY':
    				this._x = s1 * c2 * c3 - c1 * s2 * s3;
    				this._y = c1 * s2 * c3 + s1 * c2 * s3;
    				this._z = c1 * c2 * s3 + s1 * s2 * c3;
    				this._w = c1 * c2 * c3 - s1 * s2 * s3;
    				break;

    			case 'ZYX':
    				this._x = s1 * c2 * c3 - c1 * s2 * s3;
    				this._y = c1 * s2 * c3 + s1 * c2 * s3;
    				this._z = c1 * c2 * s3 - s1 * s2 * c3;
    				this._w = c1 * c2 * c3 + s1 * s2 * s3;
    				break;

    			case 'YZX':
    				this._x = s1 * c2 * c3 + c1 * s2 * s3;
    				this._y = c1 * s2 * c3 + s1 * c2 * s3;
    				this._z = c1 * c2 * s3 - s1 * s2 * c3;
    				this._w = c1 * c2 * c3 - s1 * s2 * s3;
    				break;

    			case 'XZY':
    				this._x = s1 * c2 * c3 - c1 * s2 * s3;
    				this._y = c1 * s2 * c3 - s1 * c2 * s3;
    				this._z = c1 * c2 * s3 + s1 * s2 * c3;
    				this._w = c1 * c2 * c3 + s1 * s2 * s3;
    				break;

    			default:
    				console.warn( 'THREE.Quaternion: .setFromEuler() encountered an unknown order: ' + order );

    		}

    		if ( update !== false ) this._onChangeCallback();

    		return this;

    	}

    	setFromAxisAngle( axis, angle ) {

    		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm

    		// assumes axis is normalized

    		const halfAngle = angle / 2, s = Math.sin( halfAngle );

    		this._x = axis.x * s;
    		this._y = axis.y * s;
    		this._z = axis.z * s;
    		this._w = Math.cos( halfAngle );

    		this._onChangeCallback();

    		return this;

    	}

    	setFromRotationMatrix( m ) {

    		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm

    		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

    		const te = m.elements,

    			m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
    			m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
    			m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],

    			trace = m11 + m22 + m33;

    		if ( trace > 0 ) {

    			const s = 0.5 / Math.sqrt( trace + 1.0 );

    			this._w = 0.25 / s;
    			this._x = ( m32 - m23 ) * s;
    			this._y = ( m13 - m31 ) * s;
    			this._z = ( m21 - m12 ) * s;

    		} else if ( m11 > m22 && m11 > m33 ) {

    			const s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );

    			this._w = ( m32 - m23 ) / s;
    			this._x = 0.25 * s;
    			this._y = ( m12 + m21 ) / s;
    			this._z = ( m13 + m31 ) / s;

    		} else if ( m22 > m33 ) {

    			const s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );

    			this._w = ( m13 - m31 ) / s;
    			this._x = ( m12 + m21 ) / s;
    			this._y = 0.25 * s;
    			this._z = ( m23 + m32 ) / s;

    		} else {

    			const s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );

    			this._w = ( m21 - m12 ) / s;
    			this._x = ( m13 + m31 ) / s;
    			this._y = ( m23 + m32 ) / s;
    			this._z = 0.25 * s;

    		}

    		this._onChangeCallback();

    		return this;

    	}

    	setFromUnitVectors( vFrom, vTo ) {

    		// assumes direction vectors vFrom and vTo are normalized

    		let r = vFrom.dot( vTo ) + 1;

    		if ( r < Number.EPSILON ) {

    			// vFrom and vTo point in opposite directions

    			r = 0;

    			if ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {

    				this._x = - vFrom.y;
    				this._y = vFrom.x;
    				this._z = 0;
    				this._w = r;

    			} else {

    				this._x = 0;
    				this._y = - vFrom.z;
    				this._z = vFrom.y;
    				this._w = r;

    			}

    		} else {

    			// crossVectors( vFrom, vTo ); // inlined to avoid cyclic dependency on Vector3

    			this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
    			this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
    			this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
    			this._w = r;

    		}

    		return this.normalize();

    	}

    	angleTo( q ) {

    		return 2 * Math.acos( Math.abs( clamp$1( this.dot( q ), - 1, 1 ) ) );

    	}

    	rotateTowards( q, step ) {

    		const angle = this.angleTo( q );

    		if ( angle === 0 ) return this;

    		const t = Math.min( 1, step / angle );

    		this.slerp( q, t );

    		return this;

    	}

    	identity() {

    		return this.set( 0, 0, 0, 1 );

    	}

    	invert() {

    		// quaternion is assumed to have unit length

    		return this.conjugate();

    	}

    	conjugate() {

    		this._x *= - 1;
    		this._y *= - 1;
    		this._z *= - 1;

    		this._onChangeCallback();

    		return this;

    	}

    	dot( v ) {

    		return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;

    	}

    	lengthSq() {

    		return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;

    	}

    	length() {

    		return Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );

    	}

    	normalize() {

    		let l = this.length();

    		if ( l === 0 ) {

    			this._x = 0;
    			this._y = 0;
    			this._z = 0;
    			this._w = 1;

    		} else {

    			l = 1 / l;

    			this._x = this._x * l;
    			this._y = this._y * l;
    			this._z = this._z * l;
    			this._w = this._w * l;

    		}

    		this._onChangeCallback();

    		return this;

    	}

    	multiply( q ) {

    		return this.multiplyQuaternions( this, q );

    	}

    	premultiply( q ) {

    		return this.multiplyQuaternions( q, this );

    	}

    	multiplyQuaternions( a, b ) {

    		// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm

    		const qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
    		const qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;

    		this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
    		this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
    		this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
    		this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;

    		this._onChangeCallback();

    		return this;

    	}

    	slerp( qb, t ) {

    		if ( t === 0 ) return this;
    		if ( t === 1 ) return this.copy( qb );

    		const x = this._x, y = this._y, z = this._z, w = this._w;

    		// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

    		let cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;

    		if ( cosHalfTheta < 0 ) {

    			this._w = - qb._w;
    			this._x = - qb._x;
    			this._y = - qb._y;
    			this._z = - qb._z;

    			cosHalfTheta = - cosHalfTheta;

    		} else {

    			this.copy( qb );

    		}

    		if ( cosHalfTheta >= 1.0 ) {

    			this._w = w;
    			this._x = x;
    			this._y = y;
    			this._z = z;

    			return this;

    		}

    		const sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta;

    		if ( sqrSinHalfTheta <= Number.EPSILON ) {

    			const s = 1 - t;
    			this._w = s * w + t * this._w;
    			this._x = s * x + t * this._x;
    			this._y = s * y + t * this._y;
    			this._z = s * z + t * this._z;

    			this.normalize();
    			this._onChangeCallback();

    			return this;

    		}

    		const sinHalfTheta = Math.sqrt( sqrSinHalfTheta );
    		const halfTheta = Math.atan2( sinHalfTheta, cosHalfTheta );
    		const ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,
    			ratioB = Math.sin( t * halfTheta ) / sinHalfTheta;

    		this._w = ( w * ratioA + this._w * ratioB );
    		this._x = ( x * ratioA + this._x * ratioB );
    		this._y = ( y * ratioA + this._y * ratioB );
    		this._z = ( z * ratioA + this._z * ratioB );

    		this._onChangeCallback();

    		return this;

    	}

    	slerpQuaternions( qa, qb, t ) {

    		return this.copy( qa ).slerp( qb, t );

    	}

    	random() {

    		// Derived from http://planning.cs.uiuc.edu/node198.html
    		// Note, this source uses w, x, y, z ordering,
    		// so we swap the order below.

    		const u1 = Math.random();
    		const sqrt1u1 = Math.sqrt( 1 - u1 );
    		const sqrtu1 = Math.sqrt( u1 );

    		const u2 = 2 * Math.PI * Math.random();

    		const u3 = 2 * Math.PI * Math.random();

    		return this.set(
    			sqrt1u1 * Math.cos( u2 ),
    			sqrtu1 * Math.sin( u3 ),
    			sqrtu1 * Math.cos( u3 ),
    			sqrt1u1 * Math.sin( u2 ),
    		);

    	}

    	equals( quaternion ) {

    		return ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );

    	}

    	fromArray( array, offset = 0 ) {

    		this._x = array[ offset ];
    		this._y = array[ offset + 1 ];
    		this._z = array[ offset + 2 ];
    		this._w = array[ offset + 3 ];

    		this._onChangeCallback();

    		return this;

    	}

    	toArray( array = [], offset = 0 ) {

    		array[ offset ] = this._x;
    		array[ offset + 1 ] = this._y;
    		array[ offset + 2 ] = this._z;
    		array[ offset + 3 ] = this._w;

    		return array;

    	}

    	fromBufferAttribute( attribute, index ) {

    		this._x = attribute.getX( index );
    		this._y = attribute.getY( index );
    		this._z = attribute.getZ( index );
    		this._w = attribute.getW( index );

    		return this;

    	}

    	_onChange( callback ) {

    		this._onChangeCallback = callback;

    		return this;

    	}

    	_onChangeCallback() {}

    	*[ Symbol.iterator ]() {

    		yield this._x;
    		yield this._y;
    		yield this._z;
    		yield this._w;

    	}

    }

    class Vector3 {

    	constructor( x = 0, y = 0, z = 0 ) {

    		Vector3.prototype.isVector3 = true;

    		this.x = x;
    		this.y = y;
    		this.z = z;

    	}

    	set( x, y, z ) {

    		if ( z === undefined ) z = this.z; // sprite.scale.set(x,y)

    		this.x = x;
    		this.y = y;
    		this.z = z;

    		return this;

    	}

    	setScalar( scalar ) {

    		this.x = scalar;
    		this.y = scalar;
    		this.z = scalar;

    		return this;

    	}

    	setX( x ) {

    		this.x = x;

    		return this;

    	}

    	setY( y ) {

    		this.y = y;

    		return this;

    	}

    	setZ( z ) {

    		this.z = z;

    		return this;

    	}

    	setComponent( index, value ) {

    		switch ( index ) {

    			case 0: this.x = value; break;
    			case 1: this.y = value; break;
    			case 2: this.z = value; break;
    			default: throw new Error( 'index is out of range: ' + index );

    		}

    		return this;

    	}

    	getComponent( index ) {

    		switch ( index ) {

    			case 0: return this.x;
    			case 1: return this.y;
    			case 2: return this.z;
    			default: throw new Error( 'index is out of range: ' + index );

    		}

    	}

    	clone() {

    		return new this.constructor( this.x, this.y, this.z );

    	}

    	copy( v ) {

    		this.x = v.x;
    		this.y = v.y;
    		this.z = v.z;

    		return this;

    	}

    	add( v ) {

    		this.x += v.x;
    		this.y += v.y;
    		this.z += v.z;

    		return this;

    	}

    	addScalar( s ) {

    		this.x += s;
    		this.y += s;
    		this.z += s;

    		return this;

    	}

    	addVectors( a, b ) {

    		this.x = a.x + b.x;
    		this.y = a.y + b.y;
    		this.z = a.z + b.z;

    		return this;

    	}

    	addScaledVector( v, s ) {

    		this.x += v.x * s;
    		this.y += v.y * s;
    		this.z += v.z * s;

    		return this;

    	}

    	sub( v ) {

    		this.x -= v.x;
    		this.y -= v.y;
    		this.z -= v.z;

    		return this;

    	}

    	subScalar( s ) {

    		this.x -= s;
    		this.y -= s;
    		this.z -= s;

    		return this;

    	}

    	subVectors( a, b ) {

    		this.x = a.x - b.x;
    		this.y = a.y - b.y;
    		this.z = a.z - b.z;

    		return this;

    	}

    	multiply( v ) {

    		this.x *= v.x;
    		this.y *= v.y;
    		this.z *= v.z;

    		return this;

    	}

    	multiplyScalar( scalar ) {

    		this.x *= scalar;
    		this.y *= scalar;
    		this.z *= scalar;

    		return this;

    	}

    	multiplyVectors( a, b ) {

    		this.x = a.x * b.x;
    		this.y = a.y * b.y;
    		this.z = a.z * b.z;

    		return this;

    	}

    	applyEuler( euler ) {

    		return this.applyQuaternion( _quaternion$4.setFromEuler( euler ) );

    	}

    	applyAxisAngle( axis, angle ) {

    		return this.applyQuaternion( _quaternion$4.setFromAxisAngle( axis, angle ) );

    	}

    	applyMatrix3( m ) {

    		const x = this.x, y = this.y, z = this.z;
    		const e = m.elements;

    		this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;
    		this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;
    		this.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;

    		return this;

    	}

    	applyNormalMatrix( m ) {

    		return this.applyMatrix3( m ).normalize();

    	}

    	applyMatrix4( m ) {

    		const x = this.x, y = this.y, z = this.z;
    		const e = m.elements;

    		const w = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] );

    		this.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] ) * w;
    		this.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] ) * w;
    		this.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * w;

    		return this;

    	}

    	applyQuaternion( q ) {

    		const x = this.x, y = this.y, z = this.z;
    		const qx = q.x, qy = q.y, qz = q.z, qw = q.w;

    		// calculate quat * vector

    		const ix = qw * x + qy * z - qz * y;
    		const iy = qw * y + qz * x - qx * z;
    		const iz = qw * z + qx * y - qy * x;
    		const iw = - qx * x - qy * y - qz * z;

    		// calculate result * inverse quat

    		this.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;
    		this.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;
    		this.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;

    		return this;

    	}

    	project( camera ) {

    		return this.applyMatrix4( camera.matrixWorldInverse ).applyMatrix4( camera.projectionMatrix );

    	}

    	unproject( camera ) {

    		return this.applyMatrix4( camera.projectionMatrixInverse ).applyMatrix4( camera.matrixWorld );

    	}

    	transformDirection( m ) {

    		// input: THREE.Matrix4 affine matrix
    		// vector interpreted as a direction

    		const x = this.x, y = this.y, z = this.z;
    		const e = m.elements;

    		this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z;
    		this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z;
    		this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;

    		return this.normalize();

    	}

    	divide( v ) {

    		this.x /= v.x;
    		this.y /= v.y;
    		this.z /= v.z;

    		return this;

    	}

    	divideScalar( scalar ) {

    		return this.multiplyScalar( 1 / scalar );

    	}

    	min( v ) {

    		this.x = Math.min( this.x, v.x );
    		this.y = Math.min( this.y, v.y );
    		this.z = Math.min( this.z, v.z );

    		return this;

    	}

    	max( v ) {

    		this.x = Math.max( this.x, v.x );
    		this.y = Math.max( this.y, v.y );
    		this.z = Math.max( this.z, v.z );

    		return this;

    	}

    	clamp( min, max ) {

    		// assumes min < max, componentwise

    		this.x = Math.max( min.x, Math.min( max.x, this.x ) );
    		this.y = Math.max( min.y, Math.min( max.y, this.y ) );
    		this.z = Math.max( min.z, Math.min( max.z, this.z ) );

    		return this;

    	}

    	clampScalar( minVal, maxVal ) {

    		this.x = Math.max( minVal, Math.min( maxVal, this.x ) );
    		this.y = Math.max( minVal, Math.min( maxVal, this.y ) );
    		this.z = Math.max( minVal, Math.min( maxVal, this.z ) );

    		return this;

    	}

    	clampLength( min, max ) {

    		const length = this.length();

    		return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );

    	}

    	floor() {

    		this.x = Math.floor( this.x );
    		this.y = Math.floor( this.y );
    		this.z = Math.floor( this.z );

    		return this;

    	}

    	ceil() {

    		this.x = Math.ceil( this.x );
    		this.y = Math.ceil( this.y );
    		this.z = Math.ceil( this.z );

    		return this;

    	}

    	round() {

    		this.x = Math.round( this.x );
    		this.y = Math.round( this.y );
    		this.z = Math.round( this.z );

    		return this;

    	}

    	roundToZero() {

    		this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
    		this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
    		this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );

    		return this;

    	}

    	negate() {

    		this.x = - this.x;
    		this.y = - this.y;
    		this.z = - this.z;

    		return this;

    	}

    	dot( v ) {

    		return this.x * v.x + this.y * v.y + this.z * v.z;

    	}

    	// TODO lengthSquared?

    	lengthSq() {

    		return this.x * this.x + this.y * this.y + this.z * this.z;

    	}

    	length() {

    		return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );

    	}

    	manhattanLength() {

    		return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );

    	}

    	normalize() {

    		return this.divideScalar( this.length() || 1 );

    	}

    	setLength( length ) {

    		return this.normalize().multiplyScalar( length );

    	}

    	lerp( v, alpha ) {

    		this.x += ( v.x - this.x ) * alpha;
    		this.y += ( v.y - this.y ) * alpha;
    		this.z += ( v.z - this.z ) * alpha;

    		return this;

    	}

    	lerpVectors( v1, v2, alpha ) {

    		this.x = v1.x + ( v2.x - v1.x ) * alpha;
    		this.y = v1.y + ( v2.y - v1.y ) * alpha;
    		this.z = v1.z + ( v2.z - v1.z ) * alpha;

    		return this;

    	}

    	cross( v ) {

    		return this.crossVectors( this, v );

    	}

    	crossVectors( a, b ) {

    		const ax = a.x, ay = a.y, az = a.z;
    		const bx = b.x, by = b.y, bz = b.z;

    		this.x = ay * bz - az * by;
    		this.y = az * bx - ax * bz;
    		this.z = ax * by - ay * bx;

    		return this;

    	}

    	projectOnVector( v ) {

    		const denominator = v.lengthSq();

    		if ( denominator === 0 ) return this.set( 0, 0, 0 );

    		const scalar = v.dot( this ) / denominator;

    		return this.copy( v ).multiplyScalar( scalar );

    	}

    	projectOnPlane( planeNormal ) {

    		_vector$c.copy( this ).projectOnVector( planeNormal );

    		return this.sub( _vector$c );

    	}

    	reflect( normal ) {

    		// reflect incident vector off plane orthogonal to normal
    		// normal is assumed to have unit length

    		return this.sub( _vector$c.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );

    	}

    	angleTo( v ) {

    		const denominator = Math.sqrt( this.lengthSq() * v.lengthSq() );

    		if ( denominator === 0 ) return Math.PI / 2;

    		const theta = this.dot( v ) / denominator;

    		// clamp, to handle numerical problems

    		return Math.acos( clamp$1( theta, - 1, 1 ) );

    	}

    	distanceTo( v ) {

    		return Math.sqrt( this.distanceToSquared( v ) );

    	}

    	distanceToSquared( v ) {

    		const dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;

    		return dx * dx + dy * dy + dz * dz;

    	}

    	manhattanDistanceTo( v ) {

    		return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y ) + Math.abs( this.z - v.z );

    	}

    	setFromSpherical( s ) {

    		return this.setFromSphericalCoords( s.radius, s.phi, s.theta );

    	}

    	setFromSphericalCoords( radius, phi, theta ) {

    		const sinPhiRadius = Math.sin( phi ) * radius;

    		this.x = sinPhiRadius * Math.sin( theta );
    		this.y = Math.cos( phi ) * radius;
    		this.z = sinPhiRadius * Math.cos( theta );

    		return this;

    	}

    	setFromCylindrical( c ) {

    		return this.setFromCylindricalCoords( c.radius, c.theta, c.y );

    	}

    	setFromCylindricalCoords( radius, theta, y ) {

    		this.x = radius * Math.sin( theta );
    		this.y = y;
    		this.z = radius * Math.cos( theta );

    		return this;

    	}

    	setFromMatrixPosition( m ) {

    		const e = m.elements;

    		this.x = e[ 12 ];
    		this.y = e[ 13 ];
    		this.z = e[ 14 ];

    		return this;

    	}

    	setFromMatrixScale( m ) {

    		const sx = this.setFromMatrixColumn( m, 0 ).length();
    		const sy = this.setFromMatrixColumn( m, 1 ).length();
    		const sz = this.setFromMatrixColumn( m, 2 ).length();

    		this.x = sx;
    		this.y = sy;
    		this.z = sz;

    		return this;

    	}

    	setFromMatrixColumn( m, index ) {

    		return this.fromArray( m.elements, index * 4 );

    	}

    	setFromMatrix3Column( m, index ) {

    		return this.fromArray( m.elements, index * 3 );

    	}

    	setFromEuler( e ) {

    		this.x = e._x;
    		this.y = e._y;
    		this.z = e._z;

    		return this;

    	}

    	equals( v ) {

    		return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );

    	}

    	fromArray( array, offset = 0 ) {

    		this.x = array[ offset ];
    		this.y = array[ offset + 1 ];
    		this.z = array[ offset + 2 ];

    		return this;

    	}

    	toArray( array = [], offset = 0 ) {

    		array[ offset ] = this.x;
    		array[ offset + 1 ] = this.y;
    		array[ offset + 2 ] = this.z;

    		return array;

    	}

    	fromBufferAttribute( attribute, index ) {

    		this.x = attribute.getX( index );
    		this.y = attribute.getY( index );
    		this.z = attribute.getZ( index );

    		return this;

    	}

    	random() {

    		this.x = Math.random();
    		this.y = Math.random();
    		this.z = Math.random();

    		return this;

    	}

    	randomDirection() {

    		// Derived from https://mathworld.wolfram.com/SpherePointPicking.html

    		const u = ( Math.random() - 0.5 ) * 2;
    		const t = Math.random() * Math.PI * 2;
    		const f = Math.sqrt( 1 - u ** 2 );

    		this.x = f * Math.cos( t );
    		this.y = f * Math.sin( t );
    		this.z = u;

    		return this;

    	}

    	*[ Symbol.iterator ]() {

    		yield this.x;
    		yield this.y;
    		yield this.z;

    	}

    }

    const _vector$c = /*@__PURE__*/ new Vector3();
    const _quaternion$4 = /*@__PURE__*/ new Quaternion();

    class Box3 {

    	constructor( min = new Vector3( + Infinity, + Infinity, + Infinity ), max = new Vector3( - Infinity, - Infinity, - Infinity ) ) {

    		this.isBox3 = true;

    		this.min = min;
    		this.max = max;

    	}

    	set( min, max ) {

    		this.min.copy( min );
    		this.max.copy( max );

    		return this;

    	}

    	setFromArray( array ) {

    		let minX = + Infinity;
    		let minY = + Infinity;
    		let minZ = + Infinity;

    		let maxX = - Infinity;
    		let maxY = - Infinity;
    		let maxZ = - Infinity;

    		for ( let i = 0, l = array.length; i < l; i += 3 ) {

    			const x = array[ i ];
    			const y = array[ i + 1 ];
    			const z = array[ i + 2 ];

    			if ( x < minX ) minX = x;
    			if ( y < minY ) minY = y;
    			if ( z < minZ ) minZ = z;

    			if ( x > maxX ) maxX = x;
    			if ( y > maxY ) maxY = y;
    			if ( z > maxZ ) maxZ = z;

    		}

    		this.min.set( minX, minY, minZ );
    		this.max.set( maxX, maxY, maxZ );

    		return this;

    	}

    	setFromBufferAttribute( attribute ) {

    		let minX = + Infinity;
    		let minY = + Infinity;
    		let minZ = + Infinity;

    		let maxX = - Infinity;
    		let maxY = - Infinity;
    		let maxZ = - Infinity;

    		for ( let i = 0, l = attribute.count; i < l; i ++ ) {

    			const x = attribute.getX( i );
    			const y = attribute.getY( i );
    			const z = attribute.getZ( i );

    			if ( x < minX ) minX = x;
    			if ( y < minY ) minY = y;
    			if ( z < minZ ) minZ = z;

    			if ( x > maxX ) maxX = x;
    			if ( y > maxY ) maxY = y;
    			if ( z > maxZ ) maxZ = z;

    		}

    		this.min.set( minX, minY, minZ );
    		this.max.set( maxX, maxY, maxZ );

    		return this;

    	}

    	setFromPoints( points ) {

    		this.makeEmpty();

    		for ( let i = 0, il = points.length; i < il; i ++ ) {

    			this.expandByPoint( points[ i ] );

    		}

    		return this;

    	}

    	setFromCenterAndSize( center, size ) {

    		const halfSize = _vector$b.copy( size ).multiplyScalar( 0.5 );

    		this.min.copy( center ).sub( halfSize );
    		this.max.copy( center ).add( halfSize );

    		return this;

    	}

    	setFromObject( object, precise = false ) {

    		this.makeEmpty();

    		return this.expandByObject( object, precise );

    	}

    	clone() {

    		return new this.constructor().copy( this );

    	}

    	copy( box ) {

    		this.min.copy( box.min );
    		this.max.copy( box.max );

    		return this;

    	}

    	makeEmpty() {

    		this.min.x = this.min.y = this.min.z = + Infinity;
    		this.max.x = this.max.y = this.max.z = - Infinity;

    		return this;

    	}

    	isEmpty() {

    		// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

    		return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );

    	}

    	getCenter( target ) {

    		return this.isEmpty() ? target.set( 0, 0, 0 ) : target.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

    	}

    	getSize( target ) {

    		return this.isEmpty() ? target.set( 0, 0, 0 ) : target.subVectors( this.max, this.min );

    	}

    	expandByPoint( point ) {

    		this.min.min( point );
    		this.max.max( point );

    		return this;

    	}

    	expandByVector( vector ) {

    		this.min.sub( vector );
    		this.max.add( vector );

    		return this;

    	}

    	expandByScalar( scalar ) {

    		this.min.addScalar( - scalar );
    		this.max.addScalar( scalar );

    		return this;

    	}

    	expandByObject( object, precise = false ) {

    		// Computes the world-axis-aligned bounding box of an object (including its children),
    		// accounting for both the object's, and children's, world transforms

    		object.updateWorldMatrix( false, false );

    		const geometry = object.geometry;

    		if ( geometry !== undefined ) {

    			if ( precise && geometry.attributes != undefined && geometry.attributes.position !== undefined ) {

    				const position = geometry.attributes.position;
    				for ( let i = 0, l = position.count; i < l; i ++ ) {

    					_vector$b.fromBufferAttribute( position, i ).applyMatrix4( object.matrixWorld );
    					this.expandByPoint( _vector$b );

    				}

    			} else {

    				if ( geometry.boundingBox === null ) {

    					geometry.computeBoundingBox();

    				}

    				_box$3.copy( geometry.boundingBox );
    				_box$3.applyMatrix4( object.matrixWorld );

    				this.union( _box$3 );

    			}

    		}

    		const children = object.children;

    		for ( let i = 0, l = children.length; i < l; i ++ ) {

    			this.expandByObject( children[ i ], precise );

    		}

    		return this;

    	}

    	containsPoint( point ) {

    		return point.x < this.min.x || point.x > this.max.x ||
    			point.y < this.min.y || point.y > this.max.y ||
    			point.z < this.min.z || point.z > this.max.z ? false : true;

    	}

    	containsBox( box ) {

    		return this.min.x <= box.min.x && box.max.x <= this.max.x &&
    			this.min.y <= box.min.y && box.max.y <= this.max.y &&
    			this.min.z <= box.min.z && box.max.z <= this.max.z;

    	}

    	getParameter( point, target ) {

    		// This can potentially have a divide by zero if the box
    		// has a size dimension of 0.

    		return target.set(
    			( point.x - this.min.x ) / ( this.max.x - this.min.x ),
    			( point.y - this.min.y ) / ( this.max.y - this.min.y ),
    			( point.z - this.min.z ) / ( this.max.z - this.min.z )
    		);

    	}

    	intersectsBox( box ) {

    		// using 6 splitting planes to rule out intersections.
    		return box.max.x < this.min.x || box.min.x > this.max.x ||
    			box.max.y < this.min.y || box.min.y > this.max.y ||
    			box.max.z < this.min.z || box.min.z > this.max.z ? false : true;

    	}

    	intersectsSphere( sphere ) {

    		// Find the point on the AABB closest to the sphere center.
    		this.clampPoint( sphere.center, _vector$b );

    		// If that point is inside the sphere, the AABB and sphere intersect.
    		return _vector$b.distanceToSquared( sphere.center ) <= ( sphere.radius * sphere.radius );

    	}

    	intersectsPlane( plane ) {

    		// We compute the minimum and maximum dot product values. If those values
    		// are on the same side (back or front) of the plane, then there is no intersection.

    		let min, max;

    		if ( plane.normal.x > 0 ) {

    			min = plane.normal.x * this.min.x;
    			max = plane.normal.x * this.max.x;

    		} else {

    			min = plane.normal.x * this.max.x;
    			max = plane.normal.x * this.min.x;

    		}

    		if ( plane.normal.y > 0 ) {

    			min += plane.normal.y * this.min.y;
    			max += plane.normal.y * this.max.y;

    		} else {

    			min += plane.normal.y * this.max.y;
    			max += plane.normal.y * this.min.y;

    		}

    		if ( plane.normal.z > 0 ) {

    			min += plane.normal.z * this.min.z;
    			max += plane.normal.z * this.max.z;

    		} else {

    			min += plane.normal.z * this.max.z;
    			max += plane.normal.z * this.min.z;

    		}

    		return ( min <= - plane.constant && max >= - plane.constant );

    	}

    	intersectsTriangle( triangle ) {

    		if ( this.isEmpty() ) {

    			return false;

    		}

    		// compute box center and extents
    		this.getCenter( _center );
    		_extents.subVectors( this.max, _center );

    		// translate triangle to aabb origin
    		_v0$2.subVectors( triangle.a, _center );
    		_v1$7.subVectors( triangle.b, _center );
    		_v2$4.subVectors( triangle.c, _center );

    		// compute edge vectors for triangle
    		_f0.subVectors( _v1$7, _v0$2 );
    		_f1.subVectors( _v2$4, _v1$7 );
    		_f2.subVectors( _v0$2, _v2$4 );

    		// test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb
    		// make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation
    		// axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned)
    		let axes = [
    			0, - _f0.z, _f0.y, 0, - _f1.z, _f1.y, 0, - _f2.z, _f2.y,
    			_f0.z, 0, - _f0.x, _f1.z, 0, - _f1.x, _f2.z, 0, - _f2.x,
    			- _f0.y, _f0.x, 0, - _f1.y, _f1.x, 0, - _f2.y, _f2.x, 0
    		];
    		if ( ! satForAxes( axes, _v0$2, _v1$7, _v2$4, _extents ) ) {

    			return false;

    		}

    		// test 3 face normals from the aabb
    		axes = [ 1, 0, 0, 0, 1, 0, 0, 0, 1 ];
    		if ( ! satForAxes( axes, _v0$2, _v1$7, _v2$4, _extents ) ) {

    			return false;

    		}

    		// finally testing the face normal of the triangle
    		// use already existing triangle edge vectors here
    		_triangleNormal.crossVectors( _f0, _f1 );
    		axes = [ _triangleNormal.x, _triangleNormal.y, _triangleNormal.z ];

    		return satForAxes( axes, _v0$2, _v1$7, _v2$4, _extents );

    	}

    	clampPoint( point, target ) {

    		return target.copy( point ).clamp( this.min, this.max );

    	}

    	distanceToPoint( point ) {

    		const clampedPoint = _vector$b.copy( point ).clamp( this.min, this.max );

    		return clampedPoint.sub( point ).length();

    	}

    	getBoundingSphere( target ) {

    		this.getCenter( target.center );

    		target.radius = this.getSize( _vector$b ).length() * 0.5;

    		return target;

    	}

    	intersect( box ) {

    		this.min.max( box.min );
    		this.max.min( box.max );

    		// ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.
    		if ( this.isEmpty() ) this.makeEmpty();

    		return this;

    	}

    	union( box ) {

    		this.min.min( box.min );
    		this.max.max( box.max );

    		return this;

    	}

    	applyMatrix4( matrix ) {

    		// transform of empty box is an empty box.
    		if ( this.isEmpty() ) return this;

    		// NOTE: I am using a binary pattern to specify all 2^3 combinations below
    		_points[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000
    		_points[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001
    		_points[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010
    		_points[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011
    		_points[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100
    		_points[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101
    		_points[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110
    		_points[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 111

    		this.setFromPoints( _points );

    		return this;

    	}

    	translate( offset ) {

    		this.min.add( offset );
    		this.max.add( offset );

    		return this;

    	}

    	equals( box ) {

    		return box.min.equals( this.min ) && box.max.equals( this.max );

    	}

    }

    const _points = [
    	/*@__PURE__*/ new Vector3(),
    	/*@__PURE__*/ new Vector3(),
    	/*@__PURE__*/ new Vector3(),
    	/*@__PURE__*/ new Vector3(),
    	/*@__PURE__*/ new Vector3(),
    	/*@__PURE__*/ new Vector3(),
    	/*@__PURE__*/ new Vector3(),
    	/*@__PURE__*/ new Vector3()
    ];

    const _vector$b = /*@__PURE__*/ new Vector3();

    const _box$3 = /*@__PURE__*/ new Box3();

    // triangle centered vertices

    const _v0$2 = /*@__PURE__*/ new Vector3();
    const _v1$7 = /*@__PURE__*/ new Vector3();
    const _v2$4 = /*@__PURE__*/ new Vector3();

    // triangle edge vectors

    const _f0 = /*@__PURE__*/ new Vector3();
    const _f1 = /*@__PURE__*/ new Vector3();
    const _f2 = /*@__PURE__*/ new Vector3();

    const _center = /*@__PURE__*/ new Vector3();
    const _extents = /*@__PURE__*/ new Vector3();
    const _triangleNormal = /*@__PURE__*/ new Vector3();
    const _testAxis = /*@__PURE__*/ new Vector3();

    function satForAxes( axes, v0, v1, v2, extents ) {

    	for ( let i = 0, j = axes.length - 3; i <= j; i += 3 ) {

    		_testAxis.fromArray( axes, i );
    		// project the aabb onto the separating axis
    		const r = extents.x * Math.abs( _testAxis.x ) + extents.y * Math.abs( _testAxis.y ) + extents.z * Math.abs( _testAxis.z );
    		// project all 3 vertices of the triangle onto the separating axis
    		const p0 = v0.dot( _testAxis );
    		const p1 = v1.dot( _testAxis );
    		const p2 = v2.dot( _testAxis );
    		// actual test, basically see if either of the most extreme of the triangle points intersects r
    		if ( Math.max( - Math.max( p0, p1, p2 ), Math.min( p0, p1, p2 ) ) > r ) {

    			// points of the projected triangle are outside the projected half-length of the aabb
    			// the axis is separating and we can exit
    			return false;

    		}

    	}

    	return true;

    }

    const _box$2 = /*@__PURE__*/ new Box3();
    const _v1$6 = /*@__PURE__*/ new Vector3();
    const _v2$3 = /*@__PURE__*/ new Vector3();

    class Sphere {

    	constructor( center = new Vector3(), radius = - 1 ) {

    		this.center = center;
    		this.radius = radius;

    	}

    	set( center, radius ) {

    		this.center.copy( center );
    		this.radius = radius;

    		return this;

    	}

    	setFromPoints( points, optionalCenter ) {

    		const center = this.center;

    		if ( optionalCenter !== undefined ) {

    			center.copy( optionalCenter );

    		} else {

    			_box$2.setFromPoints( points ).getCenter( center );

    		}

    		let maxRadiusSq = 0;

    		for ( let i = 0, il = points.length; i < il; i ++ ) {

    			maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );

    		}

    		this.radius = Math.sqrt( maxRadiusSq );

    		return this;

    	}

    	copy( sphere ) {

    		this.center.copy( sphere.center );
    		this.radius = sphere.radius;

    		return this;

    	}

    	isEmpty() {

    		return ( this.radius < 0 );

    	}

    	makeEmpty() {

    		this.center.set( 0, 0, 0 );
    		this.radius = - 1;

    		return this;

    	}

    	containsPoint( point ) {

    		return ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );

    	}

    	distanceToPoint( point ) {

    		return ( point.distanceTo( this.center ) - this.radius );

    	}

    	intersectsSphere( sphere ) {

    		const radiusSum = this.radius + sphere.radius;

    		return sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );

    	}

    	intersectsBox( box ) {

    		return box.intersectsSphere( this );

    	}

    	intersectsPlane( plane ) {

    		return Math.abs( plane.distanceToPoint( this.center ) ) <= this.radius;

    	}

    	clampPoint( point, target ) {

    		const deltaLengthSq = this.center.distanceToSquared( point );

    		target.copy( point );

    		if ( deltaLengthSq > ( this.radius * this.radius ) ) {

    			target.sub( this.center ).normalize();
    			target.multiplyScalar( this.radius ).add( this.center );

    		}

    		return target;

    	}

    	getBoundingBox( target ) {

    		if ( this.isEmpty() ) {

    			// Empty sphere produces empty bounding box
    			target.makeEmpty();
    			return target;

    		}

    		target.set( this.center, this.center );
    		target.expandByScalar( this.radius );

    		return target;

    	}

    	applyMatrix4( matrix ) {

    		this.center.applyMatrix4( matrix );
    		this.radius = this.radius * matrix.getMaxScaleOnAxis();

    		return this;

    	}

    	translate( offset ) {

    		this.center.add( offset );

    		return this;

    	}

    	expandByPoint( point ) {

    		if ( this.isEmpty() ) {

    			this.center.copy( point );

    			this.radius = 0;

    			return this;

    		}

    		_v1$6.subVectors( point, this.center );

    		const lengthSq = _v1$6.lengthSq();

    		if ( lengthSq > ( this.radius * this.radius ) ) {

    			// calculate the minimal sphere

    			const length = Math.sqrt( lengthSq );

    			const delta = ( length - this.radius ) * 0.5;

    			this.center.addScaledVector( _v1$6, delta / length );

    			this.radius += delta;

    		}

    		return this;

    	}

    	union( sphere ) {

    		if ( sphere.isEmpty() ) {

    			return this;

    		}

    		if ( this.isEmpty() ) {

    			this.copy( sphere );

    			return this;

    		}

    		if ( this.center.equals( sphere.center ) === true ) {

    			 this.radius = Math.max( this.radius, sphere.radius );

    		} else {

    			_v2$3.subVectors( sphere.center, this.center ).setLength( sphere.radius );

    			this.expandByPoint( _v1$6.copy( sphere.center ).add( _v2$3 ) );

    			this.expandByPoint( _v1$6.copy( sphere.center ).sub( _v2$3 ) );

    		}

    		return this;

    	}

    	equals( sphere ) {

    		return sphere.center.equals( this.center ) && ( sphere.radius === this.radius );

    	}

    	clone() {

    		return new this.constructor().copy( this );

    	}

    }

    const _vector$a = /*@__PURE__*/ new Vector3();
    const _segCenter = /*@__PURE__*/ new Vector3();
    const _segDir = /*@__PURE__*/ new Vector3();
    const _diff = /*@__PURE__*/ new Vector3();

    const _edge1 = /*@__PURE__*/ new Vector3();
    const _edge2 = /*@__PURE__*/ new Vector3();
    const _normal$1 = /*@__PURE__*/ new Vector3();

    class Ray {

    	constructor( origin = new Vector3(), direction = new Vector3( 0, 0, - 1 ) ) {

    		this.origin = origin;
    		this.direction = direction;

    	}

    	set( origin, direction ) {

    		this.origin.copy( origin );
    		this.direction.copy( direction );

    		return this;

    	}

    	copy( ray ) {

    		this.origin.copy( ray.origin );
    		this.direction.copy( ray.direction );

    		return this;

    	}

    	at( t, target ) {

    		return target.copy( this.direction ).multiplyScalar( t ).add( this.origin );

    	}

    	lookAt( v ) {

    		this.direction.copy( v ).sub( this.origin ).normalize();

    		return this;

    	}

    	recast( t ) {

    		this.origin.copy( this.at( t, _vector$a ) );

    		return this;

    	}

    	closestPointToPoint( point, target ) {

    		target.subVectors( point, this.origin );

    		const directionDistance = target.dot( this.direction );

    		if ( directionDistance < 0 ) {

    			return target.copy( this.origin );

    		}

    		return target.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );

    	}

    	distanceToPoint( point ) {

    		return Math.sqrt( this.distanceSqToPoint( point ) );

    	}

    	distanceSqToPoint( point ) {

    		const directionDistance = _vector$a.subVectors( point, this.origin ).dot( this.direction );

    		// point behind the ray

    		if ( directionDistance < 0 ) {

    			return this.origin.distanceToSquared( point );

    		}

    		_vector$a.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );

    		return _vector$a.distanceToSquared( point );

    	}

    	distanceSqToSegment( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {

    		// from https://github.com/pmjoniak/GeometricTools/blob/master/GTEngine/Include/Mathematics/GteDistRaySegment.h
    		// It returns the min distance between the ray and the segment
    		// defined by v0 and v1
    		// It can also set two optional targets :
    		// - The closest point on the ray
    		// - The closest point on the segment

    		_segCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );
    		_segDir.copy( v1 ).sub( v0 ).normalize();
    		_diff.copy( this.origin ).sub( _segCenter );

    		const segExtent = v0.distanceTo( v1 ) * 0.5;
    		const a01 = - this.direction.dot( _segDir );
    		const b0 = _diff.dot( this.direction );
    		const b1 = - _diff.dot( _segDir );
    		const c = _diff.lengthSq();
    		const det = Math.abs( 1 - a01 * a01 );
    		let s0, s1, sqrDist, extDet;

    		if ( det > 0 ) {

    			// The ray and segment are not parallel.

    			s0 = a01 * b1 - b0;
    			s1 = a01 * b0 - b1;
    			extDet = segExtent * det;

    			if ( s0 >= 0 ) {

    				if ( s1 >= - extDet ) {

    					if ( s1 <= extDet ) {

    						// region 0
    						// Minimum at interior points of ray and segment.

    						const invDet = 1 / det;
    						s0 *= invDet;
    						s1 *= invDet;
    						sqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;

    					} else {

    						// region 1

    						s1 = segExtent;
    						s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
    						sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

    					}

    				} else {

    					// region 5

    					s1 = - segExtent;
    					s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
    					sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

    				}

    			} else {

    				if ( s1 <= - extDet ) {

    					// region 4

    					s0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );
    					s1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
    					sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

    				} else if ( s1 <= extDet ) {

    					// region 3

    					s0 = 0;
    					s1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );
    					sqrDist = s1 * ( s1 + 2 * b1 ) + c;

    				} else {

    					// region 2

    					s0 = Math.max( 0, - ( a01 * segExtent + b0 ) );
    					s1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
    					sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

    				}

    			}

    		} else {

    			// Ray and segment are parallel.

    			s1 = ( a01 > 0 ) ? - segExtent : segExtent;
    			s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
    			sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

    		}

    		if ( optionalPointOnRay ) {

    			optionalPointOnRay.copy( this.direction ).multiplyScalar( s0 ).add( this.origin );

    		}

    		if ( optionalPointOnSegment ) {

    			optionalPointOnSegment.copy( _segDir ).multiplyScalar( s1 ).add( _segCenter );

    		}

    		return sqrDist;

    	}

    	intersectSphere( sphere, target ) {

    		_vector$a.subVectors( sphere.center, this.origin );
    		const tca = _vector$a.dot( this.direction );
    		const d2 = _vector$a.dot( _vector$a ) - tca * tca;
    		const radius2 = sphere.radius * sphere.radius;

    		if ( d2 > radius2 ) return null;

    		const thc = Math.sqrt( radius2 - d2 );

    		// t0 = first intersect point - entrance on front of sphere
    		const t0 = tca - thc;

    		// t1 = second intersect point - exit point on back of sphere
    		const t1 = tca + thc;

    		// test to see if both t0 and t1 are behind the ray - if so, return null
    		if ( t0 < 0 && t1 < 0 ) return null;

    		// test to see if t0 is behind the ray:
    		// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
    		// in order to always return an intersect point that is in front of the ray.
    		if ( t0 < 0 ) return this.at( t1, target );

    		// else t0 is in front of the ray, so return the first collision point scaled by t0
    		return this.at( t0, target );

    	}

    	intersectsSphere( sphere ) {

    		return this.distanceSqToPoint( sphere.center ) <= ( sphere.radius * sphere.radius );

    	}

    	distanceToPlane( plane ) {

    		const denominator = plane.normal.dot( this.direction );

    		if ( denominator === 0 ) {

    			// line is coplanar, return origin
    			if ( plane.distanceToPoint( this.origin ) === 0 ) {

    				return 0;

    			}

    			// Null is preferable to undefined since undefined means.... it is undefined

    			return null;

    		}

    		const t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;

    		// Return if the ray never intersects the plane

    		return t >= 0 ? t : null;

    	}

    	intersectPlane( plane, target ) {

    		const t = this.distanceToPlane( plane );

    		if ( t === null ) {

    			return null;

    		}

    		return this.at( t, target );

    	}

    	intersectsPlane( plane ) {

    		// check if the ray lies on the plane first

    		const distToPoint = plane.distanceToPoint( this.origin );

    		if ( distToPoint === 0 ) {

    			return true;

    		}

    		const denominator = plane.normal.dot( this.direction );

    		if ( denominator * distToPoint < 0 ) {

    			return true;

    		}

    		// ray origin is behind the plane (and is pointing behind it)

    		return false;

    	}

    	intersectBox( box, target ) {

    		let tmin, tmax, tymin, tymax, tzmin, tzmax;

    		const invdirx = 1 / this.direction.x,
    			invdiry = 1 / this.direction.y,
    			invdirz = 1 / this.direction.z;

    		const origin = this.origin;

    		if ( invdirx >= 0 ) {

    			tmin = ( box.min.x - origin.x ) * invdirx;
    			tmax = ( box.max.x - origin.x ) * invdirx;

    		} else {

    			tmin = ( box.max.x - origin.x ) * invdirx;
    			tmax = ( box.min.x - origin.x ) * invdirx;

    		}

    		if ( invdiry >= 0 ) {

    			tymin = ( box.min.y - origin.y ) * invdiry;
    			tymax = ( box.max.y - origin.y ) * invdiry;

    		} else {

    			tymin = ( box.max.y - origin.y ) * invdiry;
    			tymax = ( box.min.y - origin.y ) * invdiry;

    		}

    		if ( ( tmin > tymax ) || ( tymin > tmax ) ) return null;

    		if ( tymin > tmin || isNaN( tmin ) ) tmin = tymin;

    		if ( tymax < tmax || isNaN( tmax ) ) tmax = tymax;

    		if ( invdirz >= 0 ) {

    			tzmin = ( box.min.z - origin.z ) * invdirz;
    			tzmax = ( box.max.z - origin.z ) * invdirz;

    		} else {

    			tzmin = ( box.max.z - origin.z ) * invdirz;
    			tzmax = ( box.min.z - origin.z ) * invdirz;

    		}

    		if ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return null;

    		if ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;

    		if ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;

    		//return point closest to the ray (positive side)

    		if ( tmax < 0 ) return null;

    		return this.at( tmin >= 0 ? tmin : tmax, target );

    	}

    	intersectsBox( box ) {

    		return this.intersectBox( box, _vector$a ) !== null;

    	}

    	intersectTriangle( a, b, c, backfaceCulling, target ) {

    		// Compute the offset origin, edges, and normal.

    		// from https://github.com/pmjoniak/GeometricTools/blob/master/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h

    		_edge1.subVectors( b, a );
    		_edge2.subVectors( c, a );
    		_normal$1.crossVectors( _edge1, _edge2 );

    		// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
    		// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
    		//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
    		//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
    		//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
    		let DdN = this.direction.dot( _normal$1 );
    		let sign;

    		if ( DdN > 0 ) {

    			if ( backfaceCulling ) return null;
    			sign = 1;

    		} else if ( DdN < 0 ) {

    			sign = - 1;
    			DdN = - DdN;

    		} else {

    			return null;

    		}

    		_diff.subVectors( this.origin, a );
    		const DdQxE2 = sign * this.direction.dot( _edge2.crossVectors( _diff, _edge2 ) );

    		// b1 < 0, no intersection
    		if ( DdQxE2 < 0 ) {

    			return null;

    		}

    		const DdE1xQ = sign * this.direction.dot( _edge1.cross( _diff ) );

    		// b2 < 0, no intersection
    		if ( DdE1xQ < 0 ) {

    			return null;

    		}

    		// b1+b2 > 1, no intersection
    		if ( DdQxE2 + DdE1xQ > DdN ) {

    			return null;

    		}

    		// Line intersects triangle, check if ray does.
    		const QdN = - sign * _diff.dot( _normal$1 );

    		// t < 0, no intersection
    		if ( QdN < 0 ) {

    			return null;

    		}

    		// Ray intersects triangle.
    		return this.at( QdN / DdN, target );

    	}

    	applyMatrix4( matrix4 ) {

    		this.origin.applyMatrix4( matrix4 );
    		this.direction.transformDirection( matrix4 );

    		return this;

    	}

    	equals( ray ) {

    		return ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );

    	}

    	clone() {

    		return new this.constructor().copy( this );

    	}

    }

    class Matrix4 {

    	constructor() {

    		Matrix4.prototype.isMatrix4 = true;

    		this.elements = [

    			1, 0, 0, 0,
    			0, 1, 0, 0,
    			0, 0, 1, 0,
    			0, 0, 0, 1

    		];

    	}

    	set( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {

    		const te = this.elements;

    		te[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;
    		te[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;
    		te[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;
    		te[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;

    		return this;

    	}

    	identity() {

    		this.set(

    			1, 0, 0, 0,
    			0, 1, 0, 0,
    			0, 0, 1, 0,
    			0, 0, 0, 1

    		);

    		return this;

    	}

    	clone() {

    		return new Matrix4().fromArray( this.elements );

    	}

    	copy( m ) {

    		const te = this.elements;
    		const me = m.elements;

    		te[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ]; te[ 3 ] = me[ 3 ];
    		te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ]; te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ];
    		te[ 8 ] = me[ 8 ]; te[ 9 ] = me[ 9 ]; te[ 10 ] = me[ 10 ]; te[ 11 ] = me[ 11 ];
    		te[ 12 ] = me[ 12 ]; te[ 13 ] = me[ 13 ]; te[ 14 ] = me[ 14 ]; te[ 15 ] = me[ 15 ];

    		return this;

    	}

    	copyPosition( m ) {

    		const te = this.elements, me = m.elements;

    		te[ 12 ] = me[ 12 ];
    		te[ 13 ] = me[ 13 ];
    		te[ 14 ] = me[ 14 ];

    		return this;

    	}

    	setFromMatrix3( m ) {

    		const me = m.elements;

    		this.set(

    			me[ 0 ], me[ 3 ], me[ 6 ], 0,
    			me[ 1 ], me[ 4 ], me[ 7 ], 0,
    			me[ 2 ], me[ 5 ], me[ 8 ], 0,
    			0, 0, 0, 1

    		);

    		return this;

    	}

    	extractBasis( xAxis, yAxis, zAxis ) {

    		xAxis.setFromMatrixColumn( this, 0 );
    		yAxis.setFromMatrixColumn( this, 1 );
    		zAxis.setFromMatrixColumn( this, 2 );

    		return this;

    	}

    	makeBasis( xAxis, yAxis, zAxis ) {

    		this.set(
    			xAxis.x, yAxis.x, zAxis.x, 0,
    			xAxis.y, yAxis.y, zAxis.y, 0,
    			xAxis.z, yAxis.z, zAxis.z, 0,
    			0, 0, 0, 1
    		);

    		return this;

    	}

    	extractRotation( m ) {

    		// this method does not support reflection matrices

    		const te = this.elements;
    		const me = m.elements;

    		const scaleX = 1 / _v1$5.setFromMatrixColumn( m, 0 ).length();
    		const scaleY = 1 / _v1$5.setFromMatrixColumn( m, 1 ).length();
    		const scaleZ = 1 / _v1$5.setFromMatrixColumn( m, 2 ).length();

    		te[ 0 ] = me[ 0 ] * scaleX;
    		te[ 1 ] = me[ 1 ] * scaleX;
    		te[ 2 ] = me[ 2 ] * scaleX;
    		te[ 3 ] = 0;

    		te[ 4 ] = me[ 4 ] * scaleY;
    		te[ 5 ] = me[ 5 ] * scaleY;
    		te[ 6 ] = me[ 6 ] * scaleY;
    		te[ 7 ] = 0;

    		te[ 8 ] = me[ 8 ] * scaleZ;
    		te[ 9 ] = me[ 9 ] * scaleZ;
    		te[ 10 ] = me[ 10 ] * scaleZ;
    		te[ 11 ] = 0;

    		te[ 12 ] = 0;
    		te[ 13 ] = 0;
    		te[ 14 ] = 0;
    		te[ 15 ] = 1;

    		return this;

    	}

    	makeRotationFromEuler( euler ) {

    		const te = this.elements;

    		const x = euler.x, y = euler.y, z = euler.z;
    		const a = Math.cos( x ), b = Math.sin( x );
    		const c = Math.cos( y ), d = Math.sin( y );
    		const e = Math.cos( z ), f = Math.sin( z );

    		if ( euler.order === 'XYZ' ) {

    			const ae = a * e, af = a * f, be = b * e, bf = b * f;

    			te[ 0 ] = c * e;
    			te[ 4 ] = - c * f;
    			te[ 8 ] = d;

    			te[ 1 ] = af + be * d;
    			te[ 5 ] = ae - bf * d;
    			te[ 9 ] = - b * c;

    			te[ 2 ] = bf - ae * d;
    			te[ 6 ] = be + af * d;
    			te[ 10 ] = a * c;

    		} else if ( euler.order === 'YXZ' ) {

    			const ce = c * e, cf = c * f, de = d * e, df = d * f;

    			te[ 0 ] = ce + df * b;
    			te[ 4 ] = de * b - cf;
    			te[ 8 ] = a * d;

    			te[ 1 ] = a * f;
    			te[ 5 ] = a * e;
    			te[ 9 ] = - b;

    			te[ 2 ] = cf * b - de;
    			te[ 6 ] = df + ce * b;
    			te[ 10 ] = a * c;

    		} else if ( euler.order === 'ZXY' ) {

    			const ce = c * e, cf = c * f, de = d * e, df = d * f;

    			te[ 0 ] = ce - df * b;
    			te[ 4 ] = - a * f;
    			te[ 8 ] = de + cf * b;

    			te[ 1 ] = cf + de * b;
    			te[ 5 ] = a * e;
    			te[ 9 ] = df - ce * b;

    			te[ 2 ] = - a * d;
    			te[ 6 ] = b;
    			te[ 10 ] = a * c;

    		} else if ( euler.order === 'ZYX' ) {

    			const ae = a * e, af = a * f, be = b * e, bf = b * f;

    			te[ 0 ] = c * e;
    			te[ 4 ] = be * d - af;
    			te[ 8 ] = ae * d + bf;

    			te[ 1 ] = c * f;
    			te[ 5 ] = bf * d + ae;
    			te[ 9 ] = af * d - be;

    			te[ 2 ] = - d;
    			te[ 6 ] = b * c;
    			te[ 10 ] = a * c;

    		} else if ( euler.order === 'YZX' ) {

    			const ac = a * c, ad = a * d, bc = b * c, bd = b * d;

    			te[ 0 ] = c * e;
    			te[ 4 ] = bd - ac * f;
    			te[ 8 ] = bc * f + ad;

    			te[ 1 ] = f;
    			te[ 5 ] = a * e;
    			te[ 9 ] = - b * e;

    			te[ 2 ] = - d * e;
    			te[ 6 ] = ad * f + bc;
    			te[ 10 ] = ac - bd * f;

    		} else if ( euler.order === 'XZY' ) {

    			const ac = a * c, ad = a * d, bc = b * c, bd = b * d;

    			te[ 0 ] = c * e;
    			te[ 4 ] = - f;
    			te[ 8 ] = d * e;

    			te[ 1 ] = ac * f + bd;
    			te[ 5 ] = a * e;
    			te[ 9 ] = ad * f - bc;

    			te[ 2 ] = bc * f - ad;
    			te[ 6 ] = b * e;
    			te[ 10 ] = bd * f + ac;

    		}

    		// bottom row
    		te[ 3 ] = 0;
    		te[ 7 ] = 0;
    		te[ 11 ] = 0;

    		// last column
    		te[ 12 ] = 0;
    		te[ 13 ] = 0;
    		te[ 14 ] = 0;
    		te[ 15 ] = 1;

    		return this;

    	}

    	makeRotationFromQuaternion( q ) {

    		return this.compose( _zero, q, _one );

    	}

    	lookAt( eye, target, up ) {

    		const te = this.elements;

    		_z.subVectors( eye, target );

    		if ( _z.lengthSq() === 0 ) {

    			// eye and target are in the same position

    			_z.z = 1;

    		}

    		_z.normalize();
    		_x.crossVectors( up, _z );

    		if ( _x.lengthSq() === 0 ) {

    			// up and z are parallel

    			if ( Math.abs( up.z ) === 1 ) {

    				_z.x += 0.0001;

    			} else {

    				_z.z += 0.0001;

    			}

    			_z.normalize();
    			_x.crossVectors( up, _z );

    		}

    		_x.normalize();
    		_y.crossVectors( _z, _x );

    		te[ 0 ] = _x.x; te[ 4 ] = _y.x; te[ 8 ] = _z.x;
    		te[ 1 ] = _x.y; te[ 5 ] = _y.y; te[ 9 ] = _z.y;
    		te[ 2 ] = _x.z; te[ 6 ] = _y.z; te[ 10 ] = _z.z;

    		return this;

    	}

    	multiply( m ) {

    		return this.multiplyMatrices( this, m );

    	}

    	premultiply( m ) {

    		return this.multiplyMatrices( m, this );

    	}

    	multiplyMatrices( a, b ) {

    		const ae = a.elements;
    		const be = b.elements;
    		const te = this.elements;

    		const a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];
    		const a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];
    		const a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];
    		const a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];

    		const b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];
    		const b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];
    		const b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];
    		const b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];

    		te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
    		te[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
    		te[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
    		te[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;

    		te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
    		te[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
    		te[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
    		te[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;

    		te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
    		te[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
    		te[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
    		te[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;

    		te[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
    		te[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
    		te[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
    		te[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;

    		return this;

    	}

    	multiplyScalar( s ) {

    		const te = this.elements;

    		te[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;
    		te[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;
    		te[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;
    		te[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;

    		return this;

    	}

    	determinant() {

    		const te = this.elements;

    		const n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];
    		const n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];
    		const n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];
    		const n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];

    		//TODO: make this more efficient
    		//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )

    		return (
    			n41 * (
    				+ n14 * n23 * n32
    				 - n13 * n24 * n32
    				 - n14 * n22 * n33
    				 + n12 * n24 * n33
    				 + n13 * n22 * n34
    				 - n12 * n23 * n34
    			) +
    			n42 * (
    				+ n11 * n23 * n34
    				 - n11 * n24 * n33
    				 + n14 * n21 * n33
    				 - n13 * n21 * n34
    				 + n13 * n24 * n31
    				 - n14 * n23 * n31
    			) +
    			n43 * (
    				+ n11 * n24 * n32
    				 - n11 * n22 * n34
    				 - n14 * n21 * n32
    				 + n12 * n21 * n34
    				 + n14 * n22 * n31
    				 - n12 * n24 * n31
    			) +
    			n44 * (
    				- n13 * n22 * n31
    				 - n11 * n23 * n32
    				 + n11 * n22 * n33
    				 + n13 * n21 * n32
    				 - n12 * n21 * n33
    				 + n12 * n23 * n31
    			)

    		);

    	}

    	transpose() {

    		const te = this.elements;
    		let tmp;

    		tmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;
    		tmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;
    		tmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;

    		tmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;
    		tmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;
    		tmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;

    		return this;

    	}

    	setPosition( x, y, z ) {

    		const te = this.elements;

    		if ( x.isVector3 ) {

    			te[ 12 ] = x.x;
    			te[ 13 ] = x.y;
    			te[ 14 ] = x.z;

    		} else {

    			te[ 12 ] = x;
    			te[ 13 ] = y;
    			te[ 14 ] = z;

    		}

    		return this;

    	}

    	invert() {

    		// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
    		const te = this.elements,

    			n11 = te[ 0 ], n21 = te[ 1 ], n31 = te[ 2 ], n41 = te[ 3 ],
    			n12 = te[ 4 ], n22 = te[ 5 ], n32 = te[ 6 ], n42 = te[ 7 ],
    			n13 = te[ 8 ], n23 = te[ 9 ], n33 = te[ 10 ], n43 = te[ 11 ],
    			n14 = te[ 12 ], n24 = te[ 13 ], n34 = te[ 14 ], n44 = te[ 15 ],

    			t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,
    			t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,
    			t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,
    			t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;

    		const det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;

    		if ( det === 0 ) return this.set( 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 );

    		const detInv = 1 / det;

    		te[ 0 ] = t11 * detInv;
    		te[ 1 ] = ( n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44 ) * detInv;
    		te[ 2 ] = ( n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44 ) * detInv;
    		te[ 3 ] = ( n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43 ) * detInv;

    		te[ 4 ] = t12 * detInv;
    		te[ 5 ] = ( n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44 ) * detInv;
    		te[ 6 ] = ( n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44 ) * detInv;
    		te[ 7 ] = ( n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43 ) * detInv;

    		te[ 8 ] = t13 * detInv;
    		te[ 9 ] = ( n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44 ) * detInv;
    		te[ 10 ] = ( n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44 ) * detInv;
    		te[ 11 ] = ( n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43 ) * detInv;

    		te[ 12 ] = t14 * detInv;
    		te[ 13 ] = ( n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34 ) * detInv;
    		te[ 14 ] = ( n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34 ) * detInv;
    		te[ 15 ] = ( n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33 ) * detInv;

    		return this;

    	}

    	scale( v ) {

    		const te = this.elements;
    		const x = v.x, y = v.y, z = v.z;

    		te[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;
    		te[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;
    		te[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;
    		te[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;

    		return this;

    	}

    	getMaxScaleOnAxis() {

    		const te = this.elements;

    		const scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];
    		const scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];
    		const scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];

    		return Math.sqrt( Math.max( scaleXSq, scaleYSq, scaleZSq ) );

    	}

    	makeTranslation( x, y, z ) {

    		this.set(

    			1, 0, 0, x,
    			0, 1, 0, y,
    			0, 0, 1, z,
    			0, 0, 0, 1

    		);

    		return this;

    	}

    	makeRotationX( theta ) {

    		const c = Math.cos( theta ), s = Math.sin( theta );

    		this.set(

    			1, 0, 0, 0,
    			0, c, - s, 0,
    			0, s, c, 0,
    			0, 0, 0, 1

    		);

    		return this;

    	}

    	makeRotationY( theta ) {

    		const c = Math.cos( theta ), s = Math.sin( theta );

    		this.set(

    			 c, 0, s, 0,
    			 0, 1, 0, 0,
    			- s, 0, c, 0,
    			 0, 0, 0, 1

    		);

    		return this;

    	}

    	makeRotationZ( theta ) {

    		const c = Math.cos( theta ), s = Math.sin( theta );

    		this.set(

    			c, - s, 0, 0,
    			s, c, 0, 0,
    			0, 0, 1, 0,
    			0, 0, 0, 1

    		);

    		return this;

    	}

    	makeRotationAxis( axis, angle ) {

    		// Based on http://www.gamedev.net/reference/articles/article1199.asp

    		const c = Math.cos( angle );
    		const s = Math.sin( angle );
    		const t = 1 - c;
    		const x = axis.x, y = axis.y, z = axis.z;
    		const tx = t * x, ty = t * y;

    		this.set(

    			tx * x + c, tx * y - s * z, tx * z + s * y, 0,
    			tx * y + s * z, ty * y + c, ty * z - s * x, 0,
    			tx * z - s * y, ty * z + s * x, t * z * z + c, 0,
    			0, 0, 0, 1

    		);

    		return this;

    	}

    	makeScale( x, y, z ) {

    		this.set(

    			x, 0, 0, 0,
    			0, y, 0, 0,
    			0, 0, z, 0,
    			0, 0, 0, 1

    		);

    		return this;

    	}

    	makeShear( xy, xz, yx, yz, zx, zy ) {

    		this.set(

    			1, yx, zx, 0,
    			xy, 1, zy, 0,
    			xz, yz, 1, 0,
    			0, 0, 0, 1

    		);

    		return this;

    	}

    	compose( position, quaternion, scale ) {

    		const te = this.elements;

    		const x = quaternion._x, y = quaternion._y, z = quaternion._z, w = quaternion._w;
    		const x2 = x + x,	y2 = y + y, z2 = z + z;
    		const xx = x * x2, xy = x * y2, xz = x * z2;
    		const yy = y * y2, yz = y * z2, zz = z * z2;
    		const wx = w * x2, wy = w * y2, wz = w * z2;

    		const sx = scale.x, sy = scale.y, sz = scale.z;

    		te[ 0 ] = ( 1 - ( yy + zz ) ) * sx;
    		te[ 1 ] = ( xy + wz ) * sx;
    		te[ 2 ] = ( xz - wy ) * sx;
    		te[ 3 ] = 0;

    		te[ 4 ] = ( xy - wz ) * sy;
    		te[ 5 ] = ( 1 - ( xx + zz ) ) * sy;
    		te[ 6 ] = ( yz + wx ) * sy;
    		te[ 7 ] = 0;

    		te[ 8 ] = ( xz + wy ) * sz;
    		te[ 9 ] = ( yz - wx ) * sz;
    		te[ 10 ] = ( 1 - ( xx + yy ) ) * sz;
    		te[ 11 ] = 0;

    		te[ 12 ] = position.x;
    		te[ 13 ] = position.y;
    		te[ 14 ] = position.z;
    		te[ 15 ] = 1;

    		return this;

    	}

    	decompose( position, quaternion, scale ) {

    		const te = this.elements;

    		let sx = _v1$5.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();
    		const sy = _v1$5.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();
    		const sz = _v1$5.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();

    		// if determine is negative, we need to invert one scale
    		const det = this.determinant();
    		if ( det < 0 ) sx = - sx;

    		position.x = te[ 12 ];
    		position.y = te[ 13 ];
    		position.z = te[ 14 ];

    		// scale the rotation part
    		_m1$2.copy( this );

    		const invSX = 1 / sx;
    		const invSY = 1 / sy;
    		const invSZ = 1 / sz;

    		_m1$2.elements[ 0 ] *= invSX;
    		_m1$2.elements[ 1 ] *= invSX;
    		_m1$2.elements[ 2 ] *= invSX;

    		_m1$2.elements[ 4 ] *= invSY;
    		_m1$2.elements[ 5 ] *= invSY;
    		_m1$2.elements[ 6 ] *= invSY;

    		_m1$2.elements[ 8 ] *= invSZ;
    		_m1$2.elements[ 9 ] *= invSZ;
    		_m1$2.elements[ 10 ] *= invSZ;

    		quaternion.setFromRotationMatrix( _m1$2 );

    		scale.x = sx;
    		scale.y = sy;
    		scale.z = sz;

    		return this;

    	}

    	makePerspective( left, right, top, bottom, near, far ) {

    		const te = this.elements;
    		const x = 2 * near / ( right - left );
    		const y = 2 * near / ( top - bottom );

    		const a = ( right + left ) / ( right - left );
    		const b = ( top + bottom ) / ( top - bottom );
    		const c = - ( far + near ) / ( far - near );
    		const d = - 2 * far * near / ( far - near );

    		te[ 0 ] = x;	te[ 4 ] = 0;	te[ 8 ] = a;	te[ 12 ] = 0;
    		te[ 1 ] = 0;	te[ 5 ] = y;	te[ 9 ] = b;	te[ 13 ] = 0;
    		te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = c;	te[ 14 ] = d;
    		te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = - 1;	te[ 15 ] = 0;

    		return this;

    	}

    	makeOrthographic( left, right, top, bottom, near, far ) {

    		const te = this.elements;
    		const w = 1.0 / ( right - left );
    		const h = 1.0 / ( top - bottom );
    		const p = 1.0 / ( far - near );

    		const x = ( right + left ) * w;
    		const y = ( top + bottom ) * h;
    		const z = ( far + near ) * p;

    		te[ 0 ] = 2 * w;	te[ 4 ] = 0;	te[ 8 ] = 0;	te[ 12 ] = - x;
    		te[ 1 ] = 0;	te[ 5 ] = 2 * h;	te[ 9 ] = 0;	te[ 13 ] = - y;
    		te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = - 2 * p;	te[ 14 ] = - z;
    		te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = 0;	te[ 15 ] = 1;

    		return this;

    	}

    	equals( matrix ) {

    		const te = this.elements;
    		const me = matrix.elements;

    		for ( let i = 0; i < 16; i ++ ) {

    			if ( te[ i ] !== me[ i ] ) return false;

    		}

    		return true;

    	}

    	fromArray( array, offset = 0 ) {

    		for ( let i = 0; i < 16; i ++ ) {

    			this.elements[ i ] = array[ i + offset ];

    		}

    		return this;

    	}

    	toArray( array = [], offset = 0 ) {

    		const te = this.elements;

    		array[ offset ] = te[ 0 ];
    		array[ offset + 1 ] = te[ 1 ];
    		array[ offset + 2 ] = te[ 2 ];
    		array[ offset + 3 ] = te[ 3 ];

    		array[ offset + 4 ] = te[ 4 ];
    		array[ offset + 5 ] = te[ 5 ];
    		array[ offset + 6 ] = te[ 6 ];
    		array[ offset + 7 ] = te[ 7 ];

    		array[ offset + 8 ] = te[ 8 ];
    		array[ offset + 9 ] = te[ 9 ];
    		array[ offset + 10 ] = te[ 10 ];
    		array[ offset + 11 ] = te[ 11 ];

    		array[ offset + 12 ] = te[ 12 ];
    		array[ offset + 13 ] = te[ 13 ];
    		array[ offset + 14 ] = te[ 14 ];
    		array[ offset + 15 ] = te[ 15 ];

    		return array;

    	}

    }

    const _v1$5 = /*@__PURE__*/ new Vector3();
    const _m1$2 = /*@__PURE__*/ new Matrix4();
    const _zero = /*@__PURE__*/ new Vector3( 0, 0, 0 );
    const _one = /*@__PURE__*/ new Vector3( 1, 1, 1 );
    const _x = /*@__PURE__*/ new Vector3();
    const _y = /*@__PURE__*/ new Vector3();
    const _z = /*@__PURE__*/ new Vector3();

    const _matrix$1 = /*@__PURE__*/ new Matrix4();
    const _quaternion$3 = /*@__PURE__*/ new Quaternion();

    class Euler {

    	constructor( x = 0, y = 0, z = 0, order = Euler.DefaultOrder ) {

    		this.isEuler = true;

    		this._x = x;
    		this._y = y;
    		this._z = z;
    		this._order = order;

    	}

    	get x() {

    		return this._x;

    	}

    	set x( value ) {

    		this._x = value;
    		this._onChangeCallback();

    	}

    	get y() {

    		return this._y;

    	}

    	set y( value ) {

    		this._y = value;
    		this._onChangeCallback();

    	}

    	get z() {

    		return this._z;

    	}

    	set z( value ) {

    		this._z = value;
    		this._onChangeCallback();

    	}

    	get order() {

    		return this._order;

    	}

    	set order( value ) {

    		this._order = value;
    		this._onChangeCallback();

    	}

    	set( x, y, z, order = this._order ) {

    		this._x = x;
    		this._y = y;
    		this._z = z;
    		this._order = order;

    		this._onChangeCallback();

    		return this;

    	}

    	clone() {

    		return new this.constructor( this._x, this._y, this._z, this._order );

    	}

    	copy( euler ) {

    		this._x = euler._x;
    		this._y = euler._y;
    		this._z = euler._z;
    		this._order = euler._order;

    		this._onChangeCallback();

    		return this;

    	}

    	setFromRotationMatrix( m, order = this._order, update = true ) {

    		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

    		const te = m.elements;
    		const m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];
    		const m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];
    		const m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

    		switch ( order ) {

    			case 'XYZ':

    				this._y = Math.asin( clamp$1( m13, - 1, 1 ) );

    				if ( Math.abs( m13 ) < 0.9999999 ) {

    					this._x = Math.atan2( - m23, m33 );
    					this._z = Math.atan2( - m12, m11 );

    				} else {

    					this._x = Math.atan2( m32, m22 );
    					this._z = 0;

    				}

    				break;

    			case 'YXZ':

    				this._x = Math.asin( - clamp$1( m23, - 1, 1 ) );

    				if ( Math.abs( m23 ) < 0.9999999 ) {

    					this._y = Math.atan2( m13, m33 );
    					this._z = Math.atan2( m21, m22 );

    				} else {

    					this._y = Math.atan2( - m31, m11 );
    					this._z = 0;

    				}

    				break;

    			case 'ZXY':

    				this._x = Math.asin( clamp$1( m32, - 1, 1 ) );

    				if ( Math.abs( m32 ) < 0.9999999 ) {

    					this._y = Math.atan2( - m31, m33 );
    					this._z = Math.atan2( - m12, m22 );

    				} else {

    					this._y = 0;
    					this._z = Math.atan2( m21, m11 );

    				}

    				break;

    			case 'ZYX':

    				this._y = Math.asin( - clamp$1( m31, - 1, 1 ) );

    				if ( Math.abs( m31 ) < 0.9999999 ) {

    					this._x = Math.atan2( m32, m33 );
    					this._z = Math.atan2( m21, m11 );

    				} else {

    					this._x = 0;
    					this._z = Math.atan2( - m12, m22 );

    				}

    				break;

    			case 'YZX':

    				this._z = Math.asin( clamp$1( m21, - 1, 1 ) );

    				if ( Math.abs( m21 ) < 0.9999999 ) {

    					this._x = Math.atan2( - m23, m22 );
    					this._y = Math.atan2( - m31, m11 );

    				} else {

    					this._x = 0;
    					this._y = Math.atan2( m13, m33 );

    				}

    				break;

    			case 'XZY':

    				this._z = Math.asin( - clamp$1( m12, - 1, 1 ) );

    				if ( Math.abs( m12 ) < 0.9999999 ) {

    					this._x = Math.atan2( m32, m22 );
    					this._y = Math.atan2( m13, m11 );

    				} else {

    					this._x = Math.atan2( - m23, m33 );
    					this._y = 0;

    				}

    				break;

    			default:

    				console.warn( 'THREE.Euler: .setFromRotationMatrix() encountered an unknown order: ' + order );

    		}

    		this._order = order;

    		if ( update === true ) this._onChangeCallback();

    		return this;

    	}

    	setFromQuaternion( q, order, update ) {

    		_matrix$1.makeRotationFromQuaternion( q );

    		return this.setFromRotationMatrix( _matrix$1, order, update );

    	}

    	setFromVector3( v, order = this._order ) {

    		return this.set( v.x, v.y, v.z, order );

    	}

    	reorder( newOrder ) {

    		// WARNING: this discards revolution information -bhouston

    		_quaternion$3.setFromEuler( this );

    		return this.setFromQuaternion( _quaternion$3, newOrder );

    	}

    	equals( euler ) {

    		return ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );

    	}

    	fromArray( array ) {

    		this._x = array[ 0 ];
    		this._y = array[ 1 ];
    		this._z = array[ 2 ];
    		if ( array[ 3 ] !== undefined ) this._order = array[ 3 ];

    		this._onChangeCallback();

    		return this;

    	}

    	toArray( array = [], offset = 0 ) {

    		array[ offset ] = this._x;
    		array[ offset + 1 ] = this._y;
    		array[ offset + 2 ] = this._z;
    		array[ offset + 3 ] = this._order;

    		return array;

    	}

    	_onChange( callback ) {

    		this._onChangeCallback = callback;

    		return this;

    	}

    	_onChangeCallback() {}

    	*[ Symbol.iterator ]() {

    		yield this._x;
    		yield this._y;
    		yield this._z;
    		yield this._order;

    	}

    	// @deprecated since r138, 02cf0df1cb4575d5842fef9c85bb5a89fe020d53

    	toVector3() {

    		console.error( 'THREE.Euler: .toVector3() has been removed. Use Vector3.setFromEuler() instead' );

    	}

    }

    Euler.DefaultOrder = 'XYZ';
    Euler.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];

    class Layers {

    	constructor() {

    		this.mask = 1 | 0;

    	}

    	set( channel ) {

    		this.mask = ( 1 << channel | 0 ) >>> 0;

    	}

    	enable( channel ) {

    		this.mask |= 1 << channel | 0;

    	}

    	enableAll() {

    		this.mask = 0xffffffff | 0;

    	}

    	toggle( channel ) {

    		this.mask ^= 1 << channel | 0;

    	}

    	disable( channel ) {

    		this.mask &= ~ ( 1 << channel | 0 );

    	}

    	disableAll() {

    		this.mask = 0;

    	}

    	test( layers ) {

    		return ( this.mask & layers.mask ) !== 0;

    	}

    	isEnabled( channel ) {

    		return ( this.mask & ( 1 << channel | 0 ) ) !== 0;

    	}

    }

    let _object3DId = 0;

    const _v1$4 = /*@__PURE__*/ new Vector3();
    const _q1 = /*@__PURE__*/ new Quaternion();
    const _m1$1 = /*@__PURE__*/ new Matrix4();
    const _target = /*@__PURE__*/ new Vector3();

    const _position$3 = /*@__PURE__*/ new Vector3();
    const _scale$2 = /*@__PURE__*/ new Vector3();
    const _quaternion$2 = /*@__PURE__*/ new Quaternion();

    const _xAxis = /*@__PURE__*/ new Vector3( 1, 0, 0 );
    const _yAxis = /*@__PURE__*/ new Vector3( 0, 1, 0 );
    const _zAxis = /*@__PURE__*/ new Vector3( 0, 0, 1 );

    const _addedEvent = { type: 'added' };
    const _removedEvent = { type: 'removed' };

    class Object3D extends EventDispatcher {

    	constructor() {

    		super();

    		this.isObject3D = true;

    		Object.defineProperty( this, 'id', { value: _object3DId ++ } );

    		this.uuid = generateUUID();

    		this.name = '';
    		this.type = 'Object3D';

    		this.parent = null;
    		this.children = [];

    		this.up = Object3D.DefaultUp.clone();

    		const position = new Vector3();
    		const rotation = new Euler();
    		const quaternion = new Quaternion();
    		const scale = new Vector3( 1, 1, 1 );

    		function onRotationChange() {

    			quaternion.setFromEuler( rotation, false );

    		}

    		function onQuaternionChange() {

    			rotation.setFromQuaternion( quaternion, undefined, false );

    		}

    		rotation._onChange( onRotationChange );
    		quaternion._onChange( onQuaternionChange );

    		Object.defineProperties( this, {
    			position: {
    				configurable: true,
    				enumerable: true,
    				value: position
    			},
    			rotation: {
    				configurable: true,
    				enumerable: true,
    				value: rotation
    			},
    			quaternion: {
    				configurable: true,
    				enumerable: true,
    				value: quaternion
    			},
    			scale: {
    				configurable: true,
    				enumerable: true,
    				value: scale
    			},
    			modelViewMatrix: {
    				value: new Matrix4()
    			},
    			normalMatrix: {
    				value: new Matrix3()
    			}
    		} );

    		this.matrix = new Matrix4();
    		this.matrixWorld = new Matrix4();

    		this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;
    		this.matrixWorldNeedsUpdate = false;

    		this.matrixWorldAutoUpdate = Object3D.DefaultMatrixWorldAutoUpdate; // checked by the renderer

    		this.layers = new Layers();
    		this.visible = true;

    		this.castShadow = false;
    		this.receiveShadow = false;

    		this.frustumCulled = true;
    		this.renderOrder = 0;

    		this.animations = [];

    		this.userData = {};

    	}

    	onBeforeRender( /* renderer, scene, camera, geometry, material, group */ ) {}

    	onAfterRender( /* renderer, scene, camera, geometry, material, group */ ) {}

    	applyMatrix4( matrix ) {

    		if ( this.matrixAutoUpdate ) this.updateMatrix();

    		this.matrix.premultiply( matrix );

    		this.matrix.decompose( this.position, this.quaternion, this.scale );

    	}

    	applyQuaternion( q ) {

    		this.quaternion.premultiply( q );

    		return this;

    	}

    	setRotationFromAxisAngle( axis, angle ) {

    		// assumes axis is normalized

    		this.quaternion.setFromAxisAngle( axis, angle );

    	}

    	setRotationFromEuler( euler ) {

    		this.quaternion.setFromEuler( euler, true );

    	}

    	setRotationFromMatrix( m ) {

    		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

    		this.quaternion.setFromRotationMatrix( m );

    	}

    	setRotationFromQuaternion( q ) {

    		// assumes q is normalized

    		this.quaternion.copy( q );

    	}

    	rotateOnAxis( axis, angle ) {

    		// rotate object on axis in object space
    		// axis is assumed to be normalized

    		_q1.setFromAxisAngle( axis, angle );

    		this.quaternion.multiply( _q1 );

    		return this;

    	}

    	rotateOnWorldAxis( axis, angle ) {

    		// rotate object on axis in world space
    		// axis is assumed to be normalized
    		// method assumes no rotated parent

    		_q1.setFromAxisAngle( axis, angle );

    		this.quaternion.premultiply( _q1 );

    		return this;

    	}

    	rotateX( angle ) {

    		return this.rotateOnAxis( _xAxis, angle );

    	}

    	rotateY( angle ) {

    		return this.rotateOnAxis( _yAxis, angle );

    	}

    	rotateZ( angle ) {

    		return this.rotateOnAxis( _zAxis, angle );

    	}

    	translateOnAxis( axis, distance ) {

    		// translate object by distance along axis in object space
    		// axis is assumed to be normalized

    		_v1$4.copy( axis ).applyQuaternion( this.quaternion );

    		this.position.add( _v1$4.multiplyScalar( distance ) );

    		return this;

    	}

    	translateX( distance ) {

    		return this.translateOnAxis( _xAxis, distance );

    	}

    	translateY( distance ) {

    		return this.translateOnAxis( _yAxis, distance );

    	}

    	translateZ( distance ) {

    		return this.translateOnAxis( _zAxis, distance );

    	}

    	localToWorld( vector ) {

    		return vector.applyMatrix4( this.matrixWorld );

    	}

    	worldToLocal( vector ) {

    		return vector.applyMatrix4( _m1$1.copy( this.matrixWorld ).invert() );

    	}

    	lookAt( x, y, z ) {

    		// This method does not support objects having non-uniformly-scaled parent(s)

    		if ( x.isVector3 ) {

    			_target.copy( x );

    		} else {

    			_target.set( x, y, z );

    		}

    		const parent = this.parent;

    		this.updateWorldMatrix( true, false );

    		_position$3.setFromMatrixPosition( this.matrixWorld );

    		if ( this.isCamera || this.isLight ) {

    			_m1$1.lookAt( _position$3, _target, this.up );

    		} else {

    			_m1$1.lookAt( _target, _position$3, this.up );

    		}

    		this.quaternion.setFromRotationMatrix( _m1$1 );

    		if ( parent ) {

    			_m1$1.extractRotation( parent.matrixWorld );
    			_q1.setFromRotationMatrix( _m1$1 );
    			this.quaternion.premultiply( _q1.invert() );

    		}

    	}

    	add( object ) {

    		if ( arguments.length > 1 ) {

    			for ( let i = 0; i < arguments.length; i ++ ) {

    				this.add( arguments[ i ] );

    			}

    			return this;

    		}

    		if ( object === this ) {

    			console.error( 'THREE.Object3D.add: object can\'t be added as a child of itself.', object );
    			return this;

    		}

    		if ( object && object.isObject3D ) {

    			if ( object.parent !== null ) {

    				object.parent.remove( object );

    			}

    			object.parent = this;
    			this.children.push( object );

    			object.dispatchEvent( _addedEvent );

    		} else {

    			console.error( 'THREE.Object3D.add: object not an instance of THREE.Object3D.', object );

    		}

    		return this;

    	}

    	remove( object ) {

    		if ( arguments.length > 1 ) {

    			for ( let i = 0; i < arguments.length; i ++ ) {

    				this.remove( arguments[ i ] );

    			}

    			return this;

    		}

    		const index = this.children.indexOf( object );

    		if ( index !== - 1 ) {

    			object.parent = null;
    			this.children.splice( index, 1 );

    			object.dispatchEvent( _removedEvent );

    		}

    		return this;

    	}

    	removeFromParent() {

    		const parent = this.parent;

    		if ( parent !== null ) {

    			parent.remove( this );

    		}

    		return this;

    	}

    	clear() {

    		for ( let i = 0; i < this.children.length; i ++ ) {

    			const object = this.children[ i ];

    			object.parent = null;

    			object.dispatchEvent( _removedEvent );

    		}

    		this.children.length = 0;

    		return this;


    	}

    	attach( object ) {

    		// adds object as a child of this, while maintaining the object's world transform

    		// Note: This method does not support scene graphs having non-uniformly-scaled nodes(s)

    		this.updateWorldMatrix( true, false );

    		_m1$1.copy( this.matrixWorld ).invert();

    		if ( object.parent !== null ) {

    			object.parent.updateWorldMatrix( true, false );

    			_m1$1.multiply( object.parent.matrixWorld );

    		}

    		object.applyMatrix4( _m1$1 );

    		this.add( object );

    		object.updateWorldMatrix( false, true );

    		return this;

    	}

    	getObjectById( id ) {

    		return this.getObjectByProperty( 'id', id );

    	}

    	getObjectByName( name ) {

    		return this.getObjectByProperty( 'name', name );

    	}

    	getObjectByProperty( name, value ) {

    		if ( this[ name ] === value ) return this;

    		for ( let i = 0, l = this.children.length; i < l; i ++ ) {

    			const child = this.children[ i ];
    			const object = child.getObjectByProperty( name, value );

    			if ( object !== undefined ) {

    				return object;

    			}

    		}

    		return undefined;

    	}

    	getWorldPosition( target ) {

    		this.updateWorldMatrix( true, false );

    		return target.setFromMatrixPosition( this.matrixWorld );

    	}

    	getWorldQuaternion( target ) {

    		this.updateWorldMatrix( true, false );

    		this.matrixWorld.decompose( _position$3, target, _scale$2 );

    		return target;

    	}

    	getWorldScale( target ) {

    		this.updateWorldMatrix( true, false );

    		this.matrixWorld.decompose( _position$3, _quaternion$2, target );

    		return target;

    	}

    	getWorldDirection( target ) {

    		this.updateWorldMatrix( true, false );

    		const e = this.matrixWorld.elements;

    		return target.set( e[ 8 ], e[ 9 ], e[ 10 ] ).normalize();

    	}

    	raycast( /* raycaster, intersects */ ) {}

    	traverse( callback ) {

    		callback( this );

    		const children = this.children;

    		for ( let i = 0, l = children.length; i < l; i ++ ) {

    			children[ i ].traverse( callback );

    		}

    	}

    	traverseVisible( callback ) {

    		if ( this.visible === false ) return;

    		callback( this );

    		const children = this.children;

    		for ( let i = 0, l = children.length; i < l; i ++ ) {

    			children[ i ].traverseVisible( callback );

    		}

    	}

    	traverseAncestors( callback ) {

    		const parent = this.parent;

    		if ( parent !== null ) {

    			callback( parent );

    			parent.traverseAncestors( callback );

    		}

    	}

    	updateMatrix() {

    		this.matrix.compose( this.position, this.quaternion, this.scale );

    		this.matrixWorldNeedsUpdate = true;

    	}

    	updateMatrixWorld( force ) {

    		if ( this.matrixAutoUpdate ) this.updateMatrix();

    		if ( this.matrixWorldNeedsUpdate || force ) {

    			if ( this.parent === null ) {

    				this.matrixWorld.copy( this.matrix );

    			} else {

    				this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

    			}

    			this.matrixWorldNeedsUpdate = false;

    			force = true;

    		}

    		// update children

    		const children = this.children;

    		for ( let i = 0, l = children.length; i < l; i ++ ) {

    			const child = children[ i ];

    			if ( child.matrixWorldAutoUpdate === true || force === true ) {

    				child.updateMatrixWorld( force );

    			}

    		}

    	}

    	updateWorldMatrix( updateParents, updateChildren ) {

    		const parent = this.parent;

    		if ( updateParents === true && parent !== null && parent.matrixWorldAutoUpdate === true ) {

    			parent.updateWorldMatrix( true, false );

    		}

    		if ( this.matrixAutoUpdate ) this.updateMatrix();

    		if ( this.parent === null ) {

    			this.matrixWorld.copy( this.matrix );

    		} else {

    			this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

    		}

    		// update children

    		if ( updateChildren === true ) {

    			const children = this.children;

    			for ( let i = 0, l = children.length; i < l; i ++ ) {

    				const child = children[ i ];

    				if ( child.matrixWorldAutoUpdate === true ) {

    					child.updateWorldMatrix( false, true );

    				}

    			}

    		}

    	}

    	toJSON( meta ) {

    		// meta is a string when called from JSON.stringify
    		const isRootObject = ( meta === undefined || typeof meta === 'string' );

    		const output = {};

    		// meta is a hash used to collect geometries, materials.
    		// not providing it implies that this is the root object
    		// being serialized.
    		if ( isRootObject ) {

    			// initialize meta obj
    			meta = {
    				geometries: {},
    				materials: {},
    				textures: {},
    				images: {},
    				shapes: {},
    				skeletons: {},
    				animations: {},
    				nodes: {}
    			};

    			output.metadata = {
    				version: 4.5,
    				type: 'Object',
    				generator: 'Object3D.toJSON'
    			};

    		}

    		// standard Object3D serialization

    		const object = {};

    		object.uuid = this.uuid;
    		object.type = this.type;

    		if ( this.name !== '' ) object.name = this.name;
    		if ( this.castShadow === true ) object.castShadow = true;
    		if ( this.receiveShadow === true ) object.receiveShadow = true;
    		if ( this.visible === false ) object.visible = false;
    		if ( this.frustumCulled === false ) object.frustumCulled = false;
    		if ( this.renderOrder !== 0 ) object.renderOrder = this.renderOrder;
    		if ( JSON.stringify( this.userData ) !== '{}' ) object.userData = this.userData;

    		object.layers = this.layers.mask;
    		object.matrix = this.matrix.toArray();

    		if ( this.matrixAutoUpdate === false ) object.matrixAutoUpdate = false;

    		// object specific properties

    		if ( this.isInstancedMesh ) {

    			object.type = 'InstancedMesh';
    			object.count = this.count;
    			object.instanceMatrix = this.instanceMatrix.toJSON();
    			if ( this.instanceColor !== null ) object.instanceColor = this.instanceColor.toJSON();

    		}

    		//

    		function serialize( library, element ) {

    			if ( library[ element.uuid ] === undefined ) {

    				library[ element.uuid ] = element.toJSON( meta );

    			}

    			return element.uuid;

    		}

    		if ( this.isScene ) {

    			if ( this.background ) {

    				if ( this.background.isColor ) {

    					object.background = this.background.toJSON();

    				} else if ( this.background.isTexture ) {

    					object.background = this.background.toJSON( meta ).uuid;

    				}

    			}

    			if ( this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== true ) {

    				object.environment = this.environment.toJSON( meta ).uuid;

    			}

    		} else if ( this.isMesh || this.isLine || this.isPoints ) {

    			object.geometry = serialize( meta.geometries, this.geometry );

    			const parameters = this.geometry.parameters;

    			if ( parameters !== undefined && parameters.shapes !== undefined ) {

    				const shapes = parameters.shapes;

    				if ( Array.isArray( shapes ) ) {

    					for ( let i = 0, l = shapes.length; i < l; i ++ ) {

    						const shape = shapes[ i ];

    						serialize( meta.shapes, shape );

    					}

    				} else {

    					serialize( meta.shapes, shapes );

    				}

    			}

    		}

    		if ( this.isSkinnedMesh ) {

    			object.bindMode = this.bindMode;
    			object.bindMatrix = this.bindMatrix.toArray();

    			if ( this.skeleton !== undefined ) {

    				serialize( meta.skeletons, this.skeleton );

    				object.skeleton = this.skeleton.uuid;

    			}

    		}

    		if ( this.material !== undefined ) {

    			if ( Array.isArray( this.material ) ) {

    				const uuids = [];

    				for ( let i = 0, l = this.material.length; i < l; i ++ ) {

    					uuids.push( serialize( meta.materials, this.material[ i ] ) );

    				}

    				object.material = uuids;

    			} else {

    				object.material = serialize( meta.materials, this.material );

    			}

    		}

    		//

    		if ( this.children.length > 0 ) {

    			object.children = [];

    			for ( let i = 0; i < this.children.length; i ++ ) {

    				object.children.push( this.children[ i ].toJSON( meta ).object );

    			}

    		}

    		//

    		if ( this.animations.length > 0 ) {

    			object.animations = [];

    			for ( let i = 0; i < this.animations.length; i ++ ) {

    				const animation = this.animations[ i ];

    				object.animations.push( serialize( meta.animations, animation ) );

    			}

    		}

    		if ( isRootObject ) {

    			const geometries = extractFromCache( meta.geometries );
    			const materials = extractFromCache( meta.materials );
    			const textures = extractFromCache( meta.textures );
    			const images = extractFromCache( meta.images );
    			const shapes = extractFromCache( meta.shapes );
    			const skeletons = extractFromCache( meta.skeletons );
    			const animations = extractFromCache( meta.animations );
    			const nodes = extractFromCache( meta.nodes );

    			if ( geometries.length > 0 ) output.geometries = geometries;
    			if ( materials.length > 0 ) output.materials = materials;
    			if ( textures.length > 0 ) output.textures = textures;
    			if ( images.length > 0 ) output.images = images;
    			if ( shapes.length > 0 ) output.shapes = shapes;
    			if ( skeletons.length > 0 ) output.skeletons = skeletons;
    			if ( animations.length > 0 ) output.animations = animations;
    			if ( nodes.length > 0 ) output.nodes = nodes;

    		}

    		output.object = object;

    		return output;

    		// extract data from the cache hash
    		// remove metadata on each item
    		// and return as array
    		function extractFromCache( cache ) {

    			const values = [];
    			for ( const key in cache ) {

    				const data = cache[ key ];
    				delete data.metadata;
    				values.push( data );

    			}

    			return values;

    		}

    	}

    	clone( recursive ) {

    		return new this.constructor().copy( this, recursive );

    	}

    	copy( source, recursive = true ) {

    		this.name = source.name;

    		this.up.copy( source.up );

    		this.position.copy( source.position );
    		this.rotation.order = source.rotation.order;
    		this.quaternion.copy( source.quaternion );
    		this.scale.copy( source.scale );

    		this.matrix.copy( source.matrix );
    		this.matrixWorld.copy( source.matrixWorld );

    		this.matrixAutoUpdate = source.matrixAutoUpdate;
    		this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;

    		this.matrixWorldAutoUpdate = source.matrixWorldAutoUpdate;

    		this.layers.mask = source.layers.mask;
    		this.visible = source.visible;

    		this.castShadow = source.castShadow;
    		this.receiveShadow = source.receiveShadow;

    		this.frustumCulled = source.frustumCulled;
    		this.renderOrder = source.renderOrder;

    		this.userData = JSON.parse( JSON.stringify( source.userData ) );

    		if ( recursive === true ) {

    			for ( let i = 0; i < source.children.length; i ++ ) {

    				const child = source.children[ i ];
    				this.add( child.clone() );

    			}

    		}

    		return this;

    	}

    }

    Object3D.DefaultUp = /*@__PURE__*/ new Vector3( 0, 1, 0 );
    Object3D.DefaultMatrixAutoUpdate = true;
    Object3D.DefaultMatrixWorldAutoUpdate = true;

    const _v0$1 = /*@__PURE__*/ new Vector3();
    const _v1$3 = /*@__PURE__*/ new Vector3();
    const _v2$2 = /*@__PURE__*/ new Vector3();
    const _v3$1 = /*@__PURE__*/ new Vector3();

    const _vab = /*@__PURE__*/ new Vector3();
    const _vac = /*@__PURE__*/ new Vector3();
    const _vbc = /*@__PURE__*/ new Vector3();
    const _vap = /*@__PURE__*/ new Vector3();
    const _vbp = /*@__PURE__*/ new Vector3();
    const _vcp = /*@__PURE__*/ new Vector3();

    class Triangle {

    	constructor( a = new Vector3(), b = new Vector3(), c = new Vector3() ) {

    		this.a = a;
    		this.b = b;
    		this.c = c;

    	}

    	static getNormal( a, b, c, target ) {

    		target.subVectors( c, b );
    		_v0$1.subVectors( a, b );
    		target.cross( _v0$1 );

    		const targetLengthSq = target.lengthSq();
    		if ( targetLengthSq > 0 ) {

    			return target.multiplyScalar( 1 / Math.sqrt( targetLengthSq ) );

    		}

    		return target.set( 0, 0, 0 );

    	}

    	// static/instance method to calculate barycentric coordinates
    	// based on: http://www.blackpawn.com/texts/pointinpoly/default.html
    	static getBarycoord( point, a, b, c, target ) {

    		_v0$1.subVectors( c, a );
    		_v1$3.subVectors( b, a );
    		_v2$2.subVectors( point, a );

    		const dot00 = _v0$1.dot( _v0$1 );
    		const dot01 = _v0$1.dot( _v1$3 );
    		const dot02 = _v0$1.dot( _v2$2 );
    		const dot11 = _v1$3.dot( _v1$3 );
    		const dot12 = _v1$3.dot( _v2$2 );

    		const denom = ( dot00 * dot11 - dot01 * dot01 );

    		// collinear or singular triangle
    		if ( denom === 0 ) {

    			// arbitrary location outside of triangle?
    			// not sure if this is the best idea, maybe should be returning undefined
    			return target.set( - 2, - 1, - 1 );

    		}

    		const invDenom = 1 / denom;
    		const u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;
    		const v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;

    		// barycentric coordinates must always sum to 1
    		return target.set( 1 - u - v, v, u );

    	}

    	static containsPoint( point, a, b, c ) {

    		this.getBarycoord( point, a, b, c, _v3$1 );

    		return ( _v3$1.x >= 0 ) && ( _v3$1.y >= 0 ) && ( ( _v3$1.x + _v3$1.y ) <= 1 );

    	}

    	static getUV( point, p1, p2, p3, uv1, uv2, uv3, target ) {

    		this.getBarycoord( point, p1, p2, p3, _v3$1 );

    		target.set( 0, 0 );
    		target.addScaledVector( uv1, _v3$1.x );
    		target.addScaledVector( uv2, _v3$1.y );
    		target.addScaledVector( uv3, _v3$1.z );

    		return target;

    	}

    	static isFrontFacing( a, b, c, direction ) {

    		_v0$1.subVectors( c, b );
    		_v1$3.subVectors( a, b );

    		// strictly front facing
    		return ( _v0$1.cross( _v1$3 ).dot( direction ) < 0 ) ? true : false;

    	}

    	set( a, b, c ) {

    		this.a.copy( a );
    		this.b.copy( b );
    		this.c.copy( c );

    		return this;

    	}

    	setFromPointsAndIndices( points, i0, i1, i2 ) {

    		this.a.copy( points[ i0 ] );
    		this.b.copy( points[ i1 ] );
    		this.c.copy( points[ i2 ] );

    		return this;

    	}

    	setFromAttributeAndIndices( attribute, i0, i1, i2 ) {

    		this.a.fromBufferAttribute( attribute, i0 );
    		this.b.fromBufferAttribute( attribute, i1 );
    		this.c.fromBufferAttribute( attribute, i2 );

    		return this;

    	}

    	clone() {

    		return new this.constructor().copy( this );

    	}

    	copy( triangle ) {

    		this.a.copy( triangle.a );
    		this.b.copy( triangle.b );
    		this.c.copy( triangle.c );

    		return this;

    	}

    	getArea() {

    		_v0$1.subVectors( this.c, this.b );
    		_v1$3.subVectors( this.a, this.b );

    		return _v0$1.cross( _v1$3 ).length() * 0.5;

    	}

    	getMidpoint( target ) {

    		return target.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );

    	}

    	getNormal( target ) {

    		return Triangle.getNormal( this.a, this.b, this.c, target );

    	}

    	getPlane( target ) {

    		return target.setFromCoplanarPoints( this.a, this.b, this.c );

    	}

    	getBarycoord( point, target ) {

    		return Triangle.getBarycoord( point, this.a, this.b, this.c, target );

    	}

    	getUV( point, uv1, uv2, uv3, target ) {

    		return Triangle.getUV( point, this.a, this.b, this.c, uv1, uv2, uv3, target );

    	}

    	containsPoint( point ) {

    		return Triangle.containsPoint( point, this.a, this.b, this.c );

    	}

    	isFrontFacing( direction ) {

    		return Triangle.isFrontFacing( this.a, this.b, this.c, direction );

    	}

    	intersectsBox( box ) {

    		return box.intersectsTriangle( this );

    	}

    	closestPointToPoint( p, target ) {

    		const a = this.a, b = this.b, c = this.c;
    		let v, w;

    		// algorithm thanks to Real-Time Collision Detection by Christer Ericson,
    		// published by Morgan Kaufmann Publishers, (c) 2005 Elsevier Inc.,
    		// under the accompanying license; see chapter 5.1.5 for detailed explanation.
    		// basically, we're distinguishing which of the voronoi regions of the triangle
    		// the point lies in with the minimum amount of redundant computation.

    		_vab.subVectors( b, a );
    		_vac.subVectors( c, a );
    		_vap.subVectors( p, a );
    		const d1 = _vab.dot( _vap );
    		const d2 = _vac.dot( _vap );
    		if ( d1 <= 0 && d2 <= 0 ) {

    			// vertex region of A; barycentric coords (1, 0, 0)
    			return target.copy( a );

    		}

    		_vbp.subVectors( p, b );
    		const d3 = _vab.dot( _vbp );
    		const d4 = _vac.dot( _vbp );
    		if ( d3 >= 0 && d4 <= d3 ) {

    			// vertex region of B; barycentric coords (0, 1, 0)
    			return target.copy( b );

    		}

    		const vc = d1 * d4 - d3 * d2;
    		if ( vc <= 0 && d1 >= 0 && d3 <= 0 ) {

    			v = d1 / ( d1 - d3 );
    			// edge region of AB; barycentric coords (1-v, v, 0)
    			return target.copy( a ).addScaledVector( _vab, v );

    		}

    		_vcp.subVectors( p, c );
    		const d5 = _vab.dot( _vcp );
    		const d6 = _vac.dot( _vcp );
    		if ( d6 >= 0 && d5 <= d6 ) {

    			// vertex region of C; barycentric coords (0, 0, 1)
    			return target.copy( c );

    		}

    		const vb = d5 * d2 - d1 * d6;
    		if ( vb <= 0 && d2 >= 0 && d6 <= 0 ) {

    			w = d2 / ( d2 - d6 );
    			// edge region of AC; barycentric coords (1-w, 0, w)
    			return target.copy( a ).addScaledVector( _vac, w );

    		}

    		const va = d3 * d6 - d5 * d4;
    		if ( va <= 0 && ( d4 - d3 ) >= 0 && ( d5 - d6 ) >= 0 ) {

    			_vbc.subVectors( c, b );
    			w = ( d4 - d3 ) / ( ( d4 - d3 ) + ( d5 - d6 ) );
    			// edge region of BC; barycentric coords (0, 1-w, w)
    			return target.copy( b ).addScaledVector( _vbc, w ); // edge region of BC

    		}

    		// face region
    		const denom = 1 / ( va + vb + vc );
    		// u = va * denom
    		v = vb * denom;
    		w = vc * denom;

    		return target.copy( a ).addScaledVector( _vab, v ).addScaledVector( _vac, w );

    	}

    	equals( triangle ) {

    		return triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );

    	}

    }

    let materialId = 0;

    class Material extends EventDispatcher {

    	constructor() {

    		super();

    		this.isMaterial = true;

    		Object.defineProperty( this, 'id', { value: materialId ++ } );

    		this.uuid = generateUUID();

    		this.name = '';
    		this.type = 'Material';

    		this.blending = NormalBlending;
    		this.side = FrontSide;
    		this.vertexColors = false;

    		this.opacity = 1;
    		this.transparent = false;

    		this.blendSrc = SrcAlphaFactor;
    		this.blendDst = OneMinusSrcAlphaFactor;
    		this.blendEquation = AddEquation;
    		this.blendSrcAlpha = null;
    		this.blendDstAlpha = null;
    		this.blendEquationAlpha = null;

    		this.depthFunc = LessEqualDepth;
    		this.depthTest = true;
    		this.depthWrite = true;

    		this.stencilWriteMask = 0xff;
    		this.stencilFunc = AlwaysStencilFunc;
    		this.stencilRef = 0;
    		this.stencilFuncMask = 0xff;
    		this.stencilFail = KeepStencilOp;
    		this.stencilZFail = KeepStencilOp;
    		this.stencilZPass = KeepStencilOp;
    		this.stencilWrite = false;

    		this.clippingPlanes = null;
    		this.clipIntersection = false;
    		this.clipShadows = false;

    		this.shadowSide = null;

    		this.colorWrite = true;

    		this.precision = null; // override the renderer's default precision for this material

    		this.polygonOffset = false;
    		this.polygonOffsetFactor = 0;
    		this.polygonOffsetUnits = 0;

    		this.dithering = false;

    		this.alphaToCoverage = false;
    		this.premultipliedAlpha = false;

    		this.visible = true;

    		this.toneMapped = true;

    		this.userData = {};

    		this.version = 0;

    		this._alphaTest = 0;

    	}

    	get alphaTest() {

    		return this._alphaTest;

    	}

    	set alphaTest( value ) {

    		if ( this._alphaTest > 0 !== value > 0 ) {

    			this.version ++;

    		}

    		this._alphaTest = value;

    	}

    	onBuild( /* shaderobject, renderer */ ) {}

    	onBeforeRender( /* renderer, scene, camera, geometry, object, group */ ) {}

    	onBeforeCompile( /* shaderobject, renderer */ ) {}

    	customProgramCacheKey() {

    		return this.onBeforeCompile.toString();

    	}

    	setValues( values ) {

    		if ( values === undefined ) return;

    		for ( const key in values ) {

    			const newValue = values[ key ];

    			if ( newValue === undefined ) {

    				console.warn( 'THREE.Material: \'' + key + '\' parameter is undefined.' );
    				continue;

    			}

    			const currentValue = this[ key ];

    			if ( currentValue === undefined ) {

    				console.warn( 'THREE.' + this.type + ': \'' + key + '\' is not a property of this material.' );
    				continue;

    			}

    			if ( currentValue && currentValue.isColor ) {

    				currentValue.set( newValue );

    			} else if ( ( currentValue && currentValue.isVector3 ) && ( newValue && newValue.isVector3 ) ) {

    				currentValue.copy( newValue );

    			} else {

    				this[ key ] = newValue;

    			}

    		}

    	}

    	toJSON( meta ) {

    		const isRootObject = ( meta === undefined || typeof meta === 'string' );

    		if ( isRootObject ) {

    			meta = {
    				textures: {},
    				images: {}
    			};

    		}

    		const data = {
    			metadata: {
    				version: 4.5,
    				type: 'Material',
    				generator: 'Material.toJSON'
    			}
    		};

    		// standard Material serialization
    		data.uuid = this.uuid;
    		data.type = this.type;

    		if ( this.name !== '' ) data.name = this.name;

    		if ( this.color && this.color.isColor ) data.color = this.color.getHex();

    		if ( this.roughness !== undefined ) data.roughness = this.roughness;
    		if ( this.metalness !== undefined ) data.metalness = this.metalness;

    		if ( this.sheen !== undefined ) data.sheen = this.sheen;
    		if ( this.sheenColor && this.sheenColor.isColor ) data.sheenColor = this.sheenColor.getHex();
    		if ( this.sheenRoughness !== undefined ) data.sheenRoughness = this.sheenRoughness;
    		if ( this.emissive && this.emissive.isColor ) data.emissive = this.emissive.getHex();
    		if ( this.emissiveIntensity && this.emissiveIntensity !== 1 ) data.emissiveIntensity = this.emissiveIntensity;

    		if ( this.specular && this.specular.isColor ) data.specular = this.specular.getHex();
    		if ( this.specularIntensity !== undefined ) data.specularIntensity = this.specularIntensity;
    		if ( this.specularColor && this.specularColor.isColor ) data.specularColor = this.specularColor.getHex();
    		if ( this.shininess !== undefined ) data.shininess = this.shininess;
    		if ( this.clearcoat !== undefined ) data.clearcoat = this.clearcoat;
    		if ( this.clearcoatRoughness !== undefined ) data.clearcoatRoughness = this.clearcoatRoughness;

    		if ( this.clearcoatMap && this.clearcoatMap.isTexture ) {

    			data.clearcoatMap = this.clearcoatMap.toJSON( meta ).uuid;

    		}

    		if ( this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture ) {

    			data.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON( meta ).uuid;

    		}

    		if ( this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture ) {

    			data.clearcoatNormalMap = this.clearcoatNormalMap.toJSON( meta ).uuid;
    			data.clearcoatNormalScale = this.clearcoatNormalScale.toArray();

    		}

    		if ( this.iridescence !== undefined ) data.iridescence = this.iridescence;
    		if ( this.iridescenceIOR !== undefined ) data.iridescenceIOR = this.iridescenceIOR;
    		if ( this.iridescenceThicknessRange !== undefined ) data.iridescenceThicknessRange = this.iridescenceThicknessRange;

    		if ( this.iridescenceMap && this.iridescenceMap.isTexture ) {

    			data.iridescenceMap = this.iridescenceMap.toJSON( meta ).uuid;

    		}

    		if ( this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture ) {

    			data.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON( meta ).uuid;

    		}

    		if ( this.map && this.map.isTexture ) data.map = this.map.toJSON( meta ).uuid;
    		if ( this.matcap && this.matcap.isTexture ) data.matcap = this.matcap.toJSON( meta ).uuid;
    		if ( this.alphaMap && this.alphaMap.isTexture ) data.alphaMap = this.alphaMap.toJSON( meta ).uuid;

    		if ( this.lightMap && this.lightMap.isTexture ) {

    			data.lightMap = this.lightMap.toJSON( meta ).uuid;
    			data.lightMapIntensity = this.lightMapIntensity;

    		}

    		if ( this.aoMap && this.aoMap.isTexture ) {

    			data.aoMap = this.aoMap.toJSON( meta ).uuid;
    			data.aoMapIntensity = this.aoMapIntensity;

    		}

    		if ( this.bumpMap && this.bumpMap.isTexture ) {

    			data.bumpMap = this.bumpMap.toJSON( meta ).uuid;
    			data.bumpScale = this.bumpScale;

    		}

    		if ( this.normalMap && this.normalMap.isTexture ) {

    			data.normalMap = this.normalMap.toJSON( meta ).uuid;
    			data.normalMapType = this.normalMapType;
    			data.normalScale = this.normalScale.toArray();

    		}

    		if ( this.displacementMap && this.displacementMap.isTexture ) {

    			data.displacementMap = this.displacementMap.toJSON( meta ).uuid;
    			data.displacementScale = this.displacementScale;
    			data.displacementBias = this.displacementBias;

    		}

    		if ( this.roughnessMap && this.roughnessMap.isTexture ) data.roughnessMap = this.roughnessMap.toJSON( meta ).uuid;
    		if ( this.metalnessMap && this.metalnessMap.isTexture ) data.metalnessMap = this.metalnessMap.toJSON( meta ).uuid;

    		if ( this.emissiveMap && this.emissiveMap.isTexture ) data.emissiveMap = this.emissiveMap.toJSON( meta ).uuid;
    		if ( this.specularMap && this.specularMap.isTexture ) data.specularMap = this.specularMap.toJSON( meta ).uuid;
    		if ( this.specularIntensityMap && this.specularIntensityMap.isTexture ) data.specularIntensityMap = this.specularIntensityMap.toJSON( meta ).uuid;
    		if ( this.specularColorMap && this.specularColorMap.isTexture ) data.specularColorMap = this.specularColorMap.toJSON( meta ).uuid;

    		if ( this.envMap && this.envMap.isTexture ) {

    			data.envMap = this.envMap.toJSON( meta ).uuid;

    			if ( this.combine !== undefined ) data.combine = this.combine;

    		}

    		if ( this.envMapIntensity !== undefined ) data.envMapIntensity = this.envMapIntensity;
    		if ( this.reflectivity !== undefined ) data.reflectivity = this.reflectivity;
    		if ( this.refractionRatio !== undefined ) data.refractionRatio = this.refractionRatio;

    		if ( this.gradientMap && this.gradientMap.isTexture ) {

    			data.gradientMap = this.gradientMap.toJSON( meta ).uuid;

    		}

    		if ( this.transmission !== undefined ) data.transmission = this.transmission;
    		if ( this.transmissionMap && this.transmissionMap.isTexture ) data.transmissionMap = this.transmissionMap.toJSON( meta ).uuid;
    		if ( this.thickness !== undefined ) data.thickness = this.thickness;
    		if ( this.thicknessMap && this.thicknessMap.isTexture ) data.thicknessMap = this.thicknessMap.toJSON( meta ).uuid;
    		if ( this.attenuationDistance !== undefined && this.attenuationDistance !== Infinity ) data.attenuationDistance = this.attenuationDistance;
    		if ( this.attenuationColor !== undefined ) data.attenuationColor = this.attenuationColor.getHex();

    		if ( this.size !== undefined ) data.size = this.size;
    		if ( this.shadowSide !== null ) data.shadowSide = this.shadowSide;
    		if ( this.sizeAttenuation !== undefined ) data.sizeAttenuation = this.sizeAttenuation;

    		if ( this.blending !== NormalBlending ) data.blending = this.blending;
    		if ( this.side !== FrontSide ) data.side = this.side;
    		if ( this.vertexColors ) data.vertexColors = true;

    		if ( this.opacity < 1 ) data.opacity = this.opacity;
    		if ( this.transparent === true ) data.transparent = this.transparent;

    		data.depthFunc = this.depthFunc;
    		data.depthTest = this.depthTest;
    		data.depthWrite = this.depthWrite;
    		data.colorWrite = this.colorWrite;

    		data.stencilWrite = this.stencilWrite;
    		data.stencilWriteMask = this.stencilWriteMask;
    		data.stencilFunc = this.stencilFunc;
    		data.stencilRef = this.stencilRef;
    		data.stencilFuncMask = this.stencilFuncMask;
    		data.stencilFail = this.stencilFail;
    		data.stencilZFail = this.stencilZFail;
    		data.stencilZPass = this.stencilZPass;

    		// rotation (SpriteMaterial)
    		if ( this.rotation !== undefined && this.rotation !== 0 ) data.rotation = this.rotation;

    		if ( this.polygonOffset === true ) data.polygonOffset = true;
    		if ( this.polygonOffsetFactor !== 0 ) data.polygonOffsetFactor = this.polygonOffsetFactor;
    		if ( this.polygonOffsetUnits !== 0 ) data.polygonOffsetUnits = this.polygonOffsetUnits;

    		if ( this.linewidth !== undefined && this.linewidth !== 1 ) data.linewidth = this.linewidth;
    		if ( this.dashSize !== undefined ) data.dashSize = this.dashSize;
    		if ( this.gapSize !== undefined ) data.gapSize = this.gapSize;
    		if ( this.scale !== undefined ) data.scale = this.scale;

    		if ( this.dithering === true ) data.dithering = true;

    		if ( this.alphaTest > 0 ) data.alphaTest = this.alphaTest;
    		if ( this.alphaToCoverage === true ) data.alphaToCoverage = this.alphaToCoverage;
    		if ( this.premultipliedAlpha === true ) data.premultipliedAlpha = this.premultipliedAlpha;

    		if ( this.wireframe === true ) data.wireframe = this.wireframe;
    		if ( this.wireframeLinewidth > 1 ) data.wireframeLinewidth = this.wireframeLinewidth;
    		if ( this.wireframeLinecap !== 'round' ) data.wireframeLinecap = this.wireframeLinecap;
    		if ( this.wireframeLinejoin !== 'round' ) data.wireframeLinejoin = this.wireframeLinejoin;

    		if ( this.flatShading === true ) data.flatShading = this.flatShading;

    		if ( this.visible === false ) data.visible = false;

    		if ( this.toneMapped === false ) data.toneMapped = false;

    		if ( this.fog === false ) data.fog = false;

    		if ( JSON.stringify( this.userData ) !== '{}' ) data.userData = this.userData;

    		// TODO: Copied from Object3D.toJSON

    		function extractFromCache( cache ) {

    			const values = [];

    			for ( const key in cache ) {

    				const data = cache[ key ];
    				delete data.metadata;
    				values.push( data );

    			}

    			return values;

    		}

    		if ( isRootObject ) {

    			const textures = extractFromCache( meta.textures );
    			const images = extractFromCache( meta.images );

    			if ( textures.length > 0 ) data.textures = textures;
    			if ( images.length > 0 ) data.images = images;

    		}

    		return data;

    	}

    	clone() {

    		return new this.constructor().copy( this );

    	}

    	copy( source ) {

    		this.name = source.name;

    		this.blending = source.blending;
    		this.side = source.side;
    		this.vertexColors = source.vertexColors;

    		this.opacity = source.opacity;
    		this.transparent = source.transparent;

    		this.blendSrc = source.blendSrc;
    		this.blendDst = source.blendDst;
    		this.blendEquation = source.blendEquation;
    		this.blendSrcAlpha = source.blendSrcAlpha;
    		this.blendDstAlpha = source.blendDstAlpha;
    		this.blendEquationAlpha = source.blendEquationAlpha;

    		this.depthFunc = source.depthFunc;
    		this.depthTest = source.depthTest;
    		this.depthWrite = source.depthWrite;

    		this.stencilWriteMask = source.stencilWriteMask;
    		this.stencilFunc = source.stencilFunc;
    		this.stencilRef = source.stencilRef;
    		this.stencilFuncMask = source.stencilFuncMask;
    		this.stencilFail = source.stencilFail;
    		this.stencilZFail = source.stencilZFail;
    		this.stencilZPass = source.stencilZPass;
    		this.stencilWrite = source.stencilWrite;

    		const srcPlanes = source.clippingPlanes;
    		let dstPlanes = null;

    		if ( srcPlanes !== null ) {

    			const n = srcPlanes.length;
    			dstPlanes = new Array( n );

    			for ( let i = 0; i !== n; ++ i ) {

    				dstPlanes[ i ] = srcPlanes[ i ].clone();

    			}

    		}

    		this.clippingPlanes = dstPlanes;
    		this.clipIntersection = source.clipIntersection;
    		this.clipShadows = source.clipShadows;

    		this.shadowSide = source.shadowSide;

    		this.colorWrite = source.colorWrite;

    		this.precision = source.precision;

    		this.polygonOffset = source.polygonOffset;
    		this.polygonOffsetFactor = source.polygonOffsetFactor;
    		this.polygonOffsetUnits = source.polygonOffsetUnits;

    		this.dithering = source.dithering;

    		this.alphaTest = source.alphaTest;
    		this.alphaToCoverage = source.alphaToCoverage;
    		this.premultipliedAlpha = source.premultipliedAlpha;

    		this.visible = source.visible;

    		this.toneMapped = source.toneMapped;

    		this.userData = JSON.parse( JSON.stringify( source.userData ) );

    		return this;

    	}

    	dispose() {

    		this.dispatchEvent( { type: 'dispose' } );

    	}

    	set needsUpdate( value ) {

    		if ( value === true ) this.version ++;

    	}

    }

    class MeshBasicMaterial extends Material {

    	constructor( parameters ) {

    		super();

    		this.isMeshBasicMaterial = true;

    		this.type = 'MeshBasicMaterial';

    		this.color = new Color$1( 0xffffff ); // emissive

    		this.map = null;

    		this.lightMap = null;
    		this.lightMapIntensity = 1.0;

    		this.aoMap = null;
    		this.aoMapIntensity = 1.0;

    		this.specularMap = null;

    		this.alphaMap = null;

    		this.envMap = null;
    		this.combine = MultiplyOperation;
    		this.reflectivity = 1;
    		this.refractionRatio = 0.98;

    		this.wireframe = false;
    		this.wireframeLinewidth = 1;
    		this.wireframeLinecap = 'round';
    		this.wireframeLinejoin = 'round';

    		this.fog = true;

    		this.setValues( parameters );

    	}

    	copy( source ) {

    		super.copy( source );

    		this.color.copy( source.color );

    		this.map = source.map;

    		this.lightMap = source.lightMap;
    		this.lightMapIntensity = source.lightMapIntensity;

    		this.aoMap = source.aoMap;
    		this.aoMapIntensity = source.aoMapIntensity;

    		this.specularMap = source.specularMap;

    		this.alphaMap = source.alphaMap;

    		this.envMap = source.envMap;
    		this.combine = source.combine;
    		this.reflectivity = source.reflectivity;
    		this.refractionRatio = source.refractionRatio;

    		this.wireframe = source.wireframe;
    		this.wireframeLinewidth = source.wireframeLinewidth;
    		this.wireframeLinecap = source.wireframeLinecap;
    		this.wireframeLinejoin = source.wireframeLinejoin;

    		this.fog = source.fog;

    		return this;

    	}

    }

    const _vector$9 = /*@__PURE__*/ new Vector3();
    const _vector2$1 = /*@__PURE__*/ new Vector2();

    class BufferAttribute {

    	constructor( array, itemSize, normalized ) {

    		if ( Array.isArray( array ) ) {

    			throw new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );

    		}

    		this.isBufferAttribute = true;

    		this.name = '';

    		this.array = array;
    		this.itemSize = itemSize;
    		this.count = array !== undefined ? array.length / itemSize : 0;
    		this.normalized = normalized === true;

    		this.usage = StaticDrawUsage;
    		this.updateRange = { offset: 0, count: - 1 };

    		this.version = 0;

    	}

    	onUploadCallback() {}

    	set needsUpdate( value ) {

    		if ( value === true ) this.version ++;

    	}

    	setUsage( value ) {

    		this.usage = value;

    		return this;

    	}

    	copy( source ) {

    		this.name = source.name;
    		this.array = new source.array.constructor( source.array );
    		this.itemSize = source.itemSize;
    		this.count = source.count;
    		this.normalized = source.normalized;

    		this.usage = source.usage;

    		return this;

    	}

    	copyAt( index1, attribute, index2 ) {

    		index1 *= this.itemSize;
    		index2 *= attribute.itemSize;

    		for ( let i = 0, l = this.itemSize; i < l; i ++ ) {

    			this.array[ index1 + i ] = attribute.array[ index2 + i ];

    		}

    		return this;

    	}

    	copyArray( array ) {

    		this.array.set( array );

    		return this;

    	}

    	applyMatrix3( m ) {

    		if ( this.itemSize === 2 ) {

    			for ( let i = 0, l = this.count; i < l; i ++ ) {

    				_vector2$1.fromBufferAttribute( this, i );
    				_vector2$1.applyMatrix3( m );

    				this.setXY( i, _vector2$1.x, _vector2$1.y );

    			}

    		} else if ( this.itemSize === 3 ) {

    			for ( let i = 0, l = this.count; i < l; i ++ ) {

    				_vector$9.fromBufferAttribute( this, i );
    				_vector$9.applyMatrix3( m );

    				this.setXYZ( i, _vector$9.x, _vector$9.y, _vector$9.z );

    			}

    		}

    		return this;

    	}

    	applyMatrix4( m ) {

    		for ( let i = 0, l = this.count; i < l; i ++ ) {

    			_vector$9.fromBufferAttribute( this, i );

    			_vector$9.applyMatrix4( m );

    			this.setXYZ( i, _vector$9.x, _vector$9.y, _vector$9.z );

    		}

    		return this;

    	}

    	applyNormalMatrix( m ) {

    		for ( let i = 0, l = this.count; i < l; i ++ ) {

    			_vector$9.fromBufferAttribute( this, i );

    			_vector$9.applyNormalMatrix( m );

    			this.setXYZ( i, _vector$9.x, _vector$9.y, _vector$9.z );

    		}

    		return this;

    	}

    	transformDirection( m ) {

    		for ( let i = 0, l = this.count; i < l; i ++ ) {

    			_vector$9.fromBufferAttribute( this, i );

    			_vector$9.transformDirection( m );

    			this.setXYZ( i, _vector$9.x, _vector$9.y, _vector$9.z );

    		}

    		return this;

    	}

    	set( value, offset = 0 ) {

    		// Matching BufferAttribute constructor, do not normalize the array.
    		this.array.set( value, offset );

    		return this;

    	}

    	getX( index ) {

    		let x = this.array[ index * this.itemSize ];

    		if ( this.normalized ) x = denormalize( x, this.array );

    		return x;

    	}

    	setX( index, x ) {

    		if ( this.normalized ) x = normalize$1( x, this.array );

    		this.array[ index * this.itemSize ] = x;

    		return this;

    	}

    	getY( index ) {

    		let y = this.array[ index * this.itemSize + 1 ];

    		if ( this.normalized ) y = denormalize( y, this.array );

    		return y;

    	}

    	setY( index, y ) {

    		if ( this.normalized ) y = normalize$1( y, this.array );

    		this.array[ index * this.itemSize + 1 ] = y;

    		return this;

    	}

    	getZ( index ) {

    		let z = this.array[ index * this.itemSize + 2 ];

    		if ( this.normalized ) z = denormalize( z, this.array );

    		return z;

    	}

    	setZ( index, z ) {

    		if ( this.normalized ) z = normalize$1( z, this.array );

    		this.array[ index * this.itemSize + 2 ] = z;

    		return this;

    	}

    	getW( index ) {

    		let w = this.array[ index * this.itemSize + 3 ];

    		if ( this.normalized ) w = denormalize( w, this.array );

    		return w;

    	}

    	setW( index, w ) {

    		if ( this.normalized ) w = normalize$1( w, this.array );

    		this.array[ index * this.itemSize + 3 ] = w;

    		return this;

    	}

    	setXY( index, x, y ) {

    		index *= this.itemSize;

    		if ( this.normalized ) {

    			x = normalize$1( x, this.array );
    			y = normalize$1( y, this.array );

    		}

    		this.array[ index + 0 ] = x;
    		this.array[ index + 1 ] = y;

    		return this;

    	}

    	setXYZ( index, x, y, z ) {

    		index *= this.itemSize;

    		if ( this.normalized ) {

    			x = normalize$1( x, this.array );
    			y = normalize$1( y, this.array );
    			z = normalize$1( z, this.array );

    		}

    		this.array[ index + 0 ] = x;
    		this.array[ index + 1 ] = y;
    		this.array[ index + 2 ] = z;

    		return this;

    	}

    	setXYZW( index, x, y, z, w ) {

    		index *= this.itemSize;

    		if ( this.normalized ) {

    			x = normalize$1( x, this.array );
    			y = normalize$1( y, this.array );
    			z = normalize$1( z, this.array );
    			w = normalize$1( w, this.array );

    		}

    		this.array[ index + 0 ] = x;
    		this.array[ index + 1 ] = y;
    		this.array[ index + 2 ] = z;
    		this.array[ index + 3 ] = w;

    		return this;

    	}

    	onUpload( callback ) {

    		this.onUploadCallback = callback;

    		return this;

    	}

    	clone() {

    		return new this.constructor( this.array, this.itemSize ).copy( this );

    	}

    	toJSON() {

    		const data = {
    			itemSize: this.itemSize,
    			type: this.array.constructor.name,
    			array: Array.from( this.array ),
    			normalized: this.normalized
    		};

    		if ( this.name !== '' ) data.name = this.name;
    		if ( this.usage !== StaticDrawUsage ) data.usage = this.usage;
    		if ( this.updateRange.offset !== 0 || this.updateRange.count !== - 1 ) data.updateRange = this.updateRange;

    		return data;

    	}

    	// @deprecated

    	copyColorsArray() {

    		console.error( 'THREE.BufferAttribute: copyColorsArray() was removed in r144.' );

    	}

    	copyVector2sArray() {

    		console.error( 'THREE.BufferAttribute: copyVector2sArray() was removed in r144.' );

    	}

    	copyVector3sArray() {

    		console.error( 'THREE.BufferAttribute: copyVector3sArray() was removed in r144.' );

    	}

    	copyVector4sArray() {

    		console.error( 'THREE.BufferAttribute: copyVector4sArray() was removed in r144.' );

    	}

    }

    class Uint16BufferAttribute extends BufferAttribute {

    	constructor( array, itemSize, normalized ) {

    		super( new Uint16Array( array ), itemSize, normalized );

    	}

    }

    class Uint32BufferAttribute extends BufferAttribute {

    	constructor( array, itemSize, normalized ) {

    		super( new Uint32Array( array ), itemSize, normalized );

    	}

    }


    class Float32BufferAttribute extends BufferAttribute {

    	constructor( array, itemSize, normalized ) {

    		super( new Float32Array( array ), itemSize, normalized );

    	}

    }

    let _id$1 = 0;

    const _m1 = /*@__PURE__*/ new Matrix4();
    const _obj = /*@__PURE__*/ new Object3D();
    const _offset = /*@__PURE__*/ new Vector3();
    const _box$1$1 = /*@__PURE__*/ new Box3();
    const _boxMorphTargets = /*@__PURE__*/ new Box3();
    const _vector$8 = /*@__PURE__*/ new Vector3();

    class BufferGeometry extends EventDispatcher {

    	constructor() {

    		super();

    		this.isBufferGeometry = true;

    		Object.defineProperty( this, 'id', { value: _id$1 ++ } );

    		this.uuid = generateUUID();

    		this.name = '';
    		this.type = 'BufferGeometry';

    		this.index = null;
    		this.attributes = {};

    		this.morphAttributes = {};
    		this.morphTargetsRelative = false;

    		this.groups = [];

    		this.boundingBox = null;
    		this.boundingSphere = null;

    		this.drawRange = { start: 0, count: Infinity };

    		this.userData = {};

    	}

    	getIndex() {

    		return this.index;

    	}

    	setIndex( index ) {

    		if ( Array.isArray( index ) ) {

    			this.index = new ( arrayNeedsUint32( index ) ? Uint32BufferAttribute : Uint16BufferAttribute )( index, 1 );

    		} else {

    			this.index = index;

    		}

    		return this;

    	}

    	getAttribute( name ) {

    		return this.attributes[ name ];

    	}

    	setAttribute( name, attribute ) {

    		this.attributes[ name ] = attribute;

    		return this;

    	}

    	deleteAttribute( name ) {

    		delete this.attributes[ name ];

    		return this;

    	}

    	hasAttribute( name ) {

    		return this.attributes[ name ] !== undefined;

    	}

    	addGroup( start, count, materialIndex = 0 ) {

    		this.groups.push( {

    			start: start,
    			count: count,
    			materialIndex: materialIndex

    		} );

    	}

    	clearGroups() {

    		this.groups = [];

    	}

    	setDrawRange( start, count ) {

    		this.drawRange.start = start;
    		this.drawRange.count = count;

    	}

    	applyMatrix4( matrix ) {

    		const position = this.attributes.position;

    		if ( position !== undefined ) {

    			position.applyMatrix4( matrix );

    			position.needsUpdate = true;

    		}

    		const normal = this.attributes.normal;

    		if ( normal !== undefined ) {

    			const normalMatrix = new Matrix3().getNormalMatrix( matrix );

    			normal.applyNormalMatrix( normalMatrix );

    			normal.needsUpdate = true;

    		}

    		const tangent = this.attributes.tangent;

    		if ( tangent !== undefined ) {

    			tangent.transformDirection( matrix );

    			tangent.needsUpdate = true;

    		}

    		if ( this.boundingBox !== null ) {

    			this.computeBoundingBox();

    		}

    		if ( this.boundingSphere !== null ) {

    			this.computeBoundingSphere();

    		}

    		return this;

    	}

    	applyQuaternion( q ) {

    		_m1.makeRotationFromQuaternion( q );

    		this.applyMatrix4( _m1 );

    		return this;

    	}

    	rotateX( angle ) {

    		// rotate geometry around world x-axis

    		_m1.makeRotationX( angle );

    		this.applyMatrix4( _m1 );

    		return this;

    	}

    	rotateY( angle ) {

    		// rotate geometry around world y-axis

    		_m1.makeRotationY( angle );

    		this.applyMatrix4( _m1 );

    		return this;

    	}

    	rotateZ( angle ) {

    		// rotate geometry around world z-axis

    		_m1.makeRotationZ( angle );

    		this.applyMatrix4( _m1 );

    		return this;

    	}

    	translate( x, y, z ) {

    		// translate geometry

    		_m1.makeTranslation( x, y, z );

    		this.applyMatrix4( _m1 );

    		return this;

    	}

    	scale( x, y, z ) {

    		// scale geometry

    		_m1.makeScale( x, y, z );

    		this.applyMatrix4( _m1 );

    		return this;

    	}

    	lookAt( vector ) {

    		_obj.lookAt( vector );

    		_obj.updateMatrix();

    		this.applyMatrix4( _obj.matrix );

    		return this;

    	}

    	center() {

    		this.computeBoundingBox();

    		this.boundingBox.getCenter( _offset ).negate();

    		this.translate( _offset.x, _offset.y, _offset.z );

    		return this;

    	}

    	setFromPoints( points ) {

    		const position = [];

    		for ( let i = 0, l = points.length; i < l; i ++ ) {

    			const point = points[ i ];
    			position.push( point.x, point.y, point.z || 0 );

    		}

    		this.setAttribute( 'position', new Float32BufferAttribute( position, 3 ) );

    		return this;

    	}

    	computeBoundingBox() {

    		if ( this.boundingBox === null ) {

    			this.boundingBox = new Box3();

    		}

    		const position = this.attributes.position;
    		const morphAttributesPosition = this.morphAttributes.position;

    		if ( position && position.isGLBufferAttribute ) {

    			console.error( 'THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this );

    			this.boundingBox.set(
    				new Vector3( - Infinity, - Infinity, - Infinity ),
    				new Vector3( + Infinity, + Infinity, + Infinity )
    			);

    			return;

    		}

    		if ( position !== undefined ) {

    			this.boundingBox.setFromBufferAttribute( position );

    			// process morph attributes if present

    			if ( morphAttributesPosition ) {

    				for ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {

    					const morphAttribute = morphAttributesPosition[ i ];
    					_box$1$1.setFromBufferAttribute( morphAttribute );

    					if ( this.morphTargetsRelative ) {

    						_vector$8.addVectors( this.boundingBox.min, _box$1$1.min );
    						this.boundingBox.expandByPoint( _vector$8 );

    						_vector$8.addVectors( this.boundingBox.max, _box$1$1.max );
    						this.boundingBox.expandByPoint( _vector$8 );

    					} else {

    						this.boundingBox.expandByPoint( _box$1$1.min );
    						this.boundingBox.expandByPoint( _box$1$1.max );

    					}

    				}

    			}

    		} else {

    			this.boundingBox.makeEmpty();

    		}

    		if ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {

    			console.error( 'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this );

    		}

    	}

    	computeBoundingSphere() {

    		if ( this.boundingSphere === null ) {

    			this.boundingSphere = new Sphere();

    		}

    		const position = this.attributes.position;
    		const morphAttributesPosition = this.morphAttributes.position;

    		if ( position && position.isGLBufferAttribute ) {

    			console.error( 'THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this );

    			this.boundingSphere.set( new Vector3(), Infinity );

    			return;

    		}

    		if ( position ) {

    			// first, find the center of the bounding sphere

    			const center = this.boundingSphere.center;

    			_box$1$1.setFromBufferAttribute( position );

    			// process morph attributes if present

    			if ( morphAttributesPosition ) {

    				for ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {

    					const morphAttribute = morphAttributesPosition[ i ];
    					_boxMorphTargets.setFromBufferAttribute( morphAttribute );

    					if ( this.morphTargetsRelative ) {

    						_vector$8.addVectors( _box$1$1.min, _boxMorphTargets.min );
    						_box$1$1.expandByPoint( _vector$8 );

    						_vector$8.addVectors( _box$1$1.max, _boxMorphTargets.max );
    						_box$1$1.expandByPoint( _vector$8 );

    					} else {

    						_box$1$1.expandByPoint( _boxMorphTargets.min );
    						_box$1$1.expandByPoint( _boxMorphTargets.max );

    					}

    				}

    			}

    			_box$1$1.getCenter( center );

    			// second, try to find a boundingSphere with a radius smaller than the
    			// boundingSphere of the boundingBox: sqrt(3) smaller in the best case

    			let maxRadiusSq = 0;

    			for ( let i = 0, il = position.count; i < il; i ++ ) {

    				_vector$8.fromBufferAttribute( position, i );

    				maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector$8 ) );

    			}

    			// process morph attributes if present

    			if ( morphAttributesPosition ) {

    				for ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {

    					const morphAttribute = morphAttributesPosition[ i ];
    					const morphTargetsRelative = this.morphTargetsRelative;

    					for ( let j = 0, jl = morphAttribute.count; j < jl; j ++ ) {

    						_vector$8.fromBufferAttribute( morphAttribute, j );

    						if ( morphTargetsRelative ) {

    							_offset.fromBufferAttribute( position, j );
    							_vector$8.add( _offset );

    						}

    						maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector$8 ) );

    					}

    				}

    			}

    			this.boundingSphere.radius = Math.sqrt( maxRadiusSq );

    			if ( isNaN( this.boundingSphere.radius ) ) {

    				console.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this );

    			}

    		}

    	}

    	computeTangents() {

    		const index = this.index;
    		const attributes = this.attributes;

    		// based on http://www.terathon.com/code/tangent.html
    		// (per vertex tangents)

    		if ( index === null ||
    			 attributes.position === undefined ||
    			 attributes.normal === undefined ||
    			 attributes.uv === undefined ) {

    			console.error( 'THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)' );
    			return;

    		}

    		const indices = index.array;
    		const positions = attributes.position.array;
    		const normals = attributes.normal.array;
    		const uvs = attributes.uv.array;

    		const nVertices = positions.length / 3;

    		if ( this.hasAttribute( 'tangent' ) === false ) {

    			this.setAttribute( 'tangent', new BufferAttribute( new Float32Array( 4 * nVertices ), 4 ) );

    		}

    		const tangents = this.getAttribute( 'tangent' ).array;

    		const tan1 = [], tan2 = [];

    		for ( let i = 0; i < nVertices; i ++ ) {

    			tan1[ i ] = new Vector3();
    			tan2[ i ] = new Vector3();

    		}

    		const vA = new Vector3(),
    			vB = new Vector3(),
    			vC = new Vector3(),

    			uvA = new Vector2(),
    			uvB = new Vector2(),
    			uvC = new Vector2(),

    			sdir = new Vector3(),
    			tdir = new Vector3();

    		function handleTriangle( a, b, c ) {

    			vA.fromArray( positions, a * 3 );
    			vB.fromArray( positions, b * 3 );
    			vC.fromArray( positions, c * 3 );

    			uvA.fromArray( uvs, a * 2 );
    			uvB.fromArray( uvs, b * 2 );
    			uvC.fromArray( uvs, c * 2 );

    			vB.sub( vA );
    			vC.sub( vA );

    			uvB.sub( uvA );
    			uvC.sub( uvA );

    			const r = 1.0 / ( uvB.x * uvC.y - uvC.x * uvB.y );

    			// silently ignore degenerate uv triangles having coincident or colinear vertices

    			if ( ! isFinite( r ) ) return;

    			sdir.copy( vB ).multiplyScalar( uvC.y ).addScaledVector( vC, - uvB.y ).multiplyScalar( r );
    			tdir.copy( vC ).multiplyScalar( uvB.x ).addScaledVector( vB, - uvC.x ).multiplyScalar( r );

    			tan1[ a ].add( sdir );
    			tan1[ b ].add( sdir );
    			tan1[ c ].add( sdir );

    			tan2[ a ].add( tdir );
    			tan2[ b ].add( tdir );
    			tan2[ c ].add( tdir );

    		}

    		let groups = this.groups;

    		if ( groups.length === 0 ) {

    			groups = [ {
    				start: 0,
    				count: indices.length
    			} ];

    		}

    		for ( let i = 0, il = groups.length; i < il; ++ i ) {

    			const group = groups[ i ];

    			const start = group.start;
    			const count = group.count;

    			for ( let j = start, jl = start + count; j < jl; j += 3 ) {

    				handleTriangle(
    					indices[ j + 0 ],
    					indices[ j + 1 ],
    					indices[ j + 2 ]
    				);

    			}

    		}

    		const tmp = new Vector3(), tmp2 = new Vector3();
    		const n = new Vector3(), n2 = new Vector3();

    		function handleVertex( v ) {

    			n.fromArray( normals, v * 3 );
    			n2.copy( n );

    			const t = tan1[ v ];

    			// Gram-Schmidt orthogonalize

    			tmp.copy( t );
    			tmp.sub( n.multiplyScalar( n.dot( t ) ) ).normalize();

    			// Calculate handedness

    			tmp2.crossVectors( n2, t );
    			const test = tmp2.dot( tan2[ v ] );
    			const w = ( test < 0.0 ) ? - 1.0 : 1.0;

    			tangents[ v * 4 ] = tmp.x;
    			tangents[ v * 4 + 1 ] = tmp.y;
    			tangents[ v * 4 + 2 ] = tmp.z;
    			tangents[ v * 4 + 3 ] = w;

    		}

    		for ( let i = 0, il = groups.length; i < il; ++ i ) {

    			const group = groups[ i ];

    			const start = group.start;
    			const count = group.count;

    			for ( let j = start, jl = start + count; j < jl; j += 3 ) {

    				handleVertex( indices[ j + 0 ] );
    				handleVertex( indices[ j + 1 ] );
    				handleVertex( indices[ j + 2 ] );

    			}

    		}

    	}

    	computeVertexNormals() {

    		const index = this.index;
    		const positionAttribute = this.getAttribute( 'position' );

    		if ( positionAttribute !== undefined ) {

    			let normalAttribute = this.getAttribute( 'normal' );

    			if ( normalAttribute === undefined ) {

    				normalAttribute = new BufferAttribute( new Float32Array( positionAttribute.count * 3 ), 3 );
    				this.setAttribute( 'normal', normalAttribute );

    			} else {

    				// reset existing normals to zero

    				for ( let i = 0, il = normalAttribute.count; i < il; i ++ ) {

    					normalAttribute.setXYZ( i, 0, 0, 0 );

    				}

    			}

    			const pA = new Vector3(), pB = new Vector3(), pC = new Vector3();
    			const nA = new Vector3(), nB = new Vector3(), nC = new Vector3();
    			const cb = new Vector3(), ab = new Vector3();

    			// indexed elements

    			if ( index ) {

    				for ( let i = 0, il = index.count; i < il; i += 3 ) {

    					const vA = index.getX( i + 0 );
    					const vB = index.getX( i + 1 );
    					const vC = index.getX( i + 2 );

    					pA.fromBufferAttribute( positionAttribute, vA );
    					pB.fromBufferAttribute( positionAttribute, vB );
    					pC.fromBufferAttribute( positionAttribute, vC );

    					cb.subVectors( pC, pB );
    					ab.subVectors( pA, pB );
    					cb.cross( ab );

    					nA.fromBufferAttribute( normalAttribute, vA );
    					nB.fromBufferAttribute( normalAttribute, vB );
    					nC.fromBufferAttribute( normalAttribute, vC );

    					nA.add( cb );
    					nB.add( cb );
    					nC.add( cb );

    					normalAttribute.setXYZ( vA, nA.x, nA.y, nA.z );
    					normalAttribute.setXYZ( vB, nB.x, nB.y, nB.z );
    					normalAttribute.setXYZ( vC, nC.x, nC.y, nC.z );

    				}

    			} else {

    				// non-indexed elements (unconnected triangle soup)

    				for ( let i = 0, il = positionAttribute.count; i < il; i += 3 ) {

    					pA.fromBufferAttribute( positionAttribute, i + 0 );
    					pB.fromBufferAttribute( positionAttribute, i + 1 );
    					pC.fromBufferAttribute( positionAttribute, i + 2 );

    					cb.subVectors( pC, pB );
    					ab.subVectors( pA, pB );
    					cb.cross( ab );

    					normalAttribute.setXYZ( i + 0, cb.x, cb.y, cb.z );
    					normalAttribute.setXYZ( i + 1, cb.x, cb.y, cb.z );
    					normalAttribute.setXYZ( i + 2, cb.x, cb.y, cb.z );

    				}

    			}

    			this.normalizeNormals();

    			normalAttribute.needsUpdate = true;

    		}

    	}

    	// @deprecated since r144

    	merge() {

    		console.error( 'THREE.BufferGeometry.merge() has been removed. Use THREE.BufferGeometryUtils.mergeBufferGeometries() instead.' );
    		return this;

    	}

    	normalizeNormals() {

    		const normals = this.attributes.normal;

    		for ( let i = 0, il = normals.count; i < il; i ++ ) {

    			_vector$8.fromBufferAttribute( normals, i );

    			_vector$8.normalize();

    			normals.setXYZ( i, _vector$8.x, _vector$8.y, _vector$8.z );

    		}

    	}

    	toNonIndexed() {

    		function convertBufferAttribute( attribute, indices ) {

    			const array = attribute.array;
    			const itemSize = attribute.itemSize;
    			const normalized = attribute.normalized;

    			const array2 = new array.constructor( indices.length * itemSize );

    			let index = 0, index2 = 0;

    			for ( let i = 0, l = indices.length; i < l; i ++ ) {

    				if ( attribute.isInterleavedBufferAttribute ) {

    					index = indices[ i ] * attribute.data.stride + attribute.offset;

    				} else {

    					index = indices[ i ] * itemSize;

    				}

    				for ( let j = 0; j < itemSize; j ++ ) {

    					array2[ index2 ++ ] = array[ index ++ ];

    				}

    			}

    			return new BufferAttribute( array2, itemSize, normalized );

    		}

    		//

    		if ( this.index === null ) {

    			console.warn( 'THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.' );
    			return this;

    		}

    		const geometry2 = new BufferGeometry();

    		const indices = this.index.array;
    		const attributes = this.attributes;

    		// attributes

    		for ( const name in attributes ) {

    			const attribute = attributes[ name ];

    			const newAttribute = convertBufferAttribute( attribute, indices );

    			geometry2.setAttribute( name, newAttribute );

    		}

    		// morph attributes

    		const morphAttributes = this.morphAttributes;

    		for ( const name in morphAttributes ) {

    			const morphArray = [];
    			const morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes

    			for ( let i = 0, il = morphAttribute.length; i < il; i ++ ) {

    				const attribute = morphAttribute[ i ];

    				const newAttribute = convertBufferAttribute( attribute, indices );

    				morphArray.push( newAttribute );

    			}

    			geometry2.morphAttributes[ name ] = morphArray;

    		}

    		geometry2.morphTargetsRelative = this.morphTargetsRelative;

    		// groups

    		const groups = this.groups;

    		for ( let i = 0, l = groups.length; i < l; i ++ ) {

    			const group = groups[ i ];
    			geometry2.addGroup( group.start, group.count, group.materialIndex );

    		}

    		return geometry2;

    	}

    	toJSON() {

    		const data = {
    			metadata: {
    				version: 4.5,
    				type: 'BufferGeometry',
    				generator: 'BufferGeometry.toJSON'
    			}
    		};

    		// standard BufferGeometry serialization

    		data.uuid = this.uuid;
    		data.type = this.type;
    		if ( this.name !== '' ) data.name = this.name;
    		if ( Object.keys( this.userData ).length > 0 ) data.userData = this.userData;

    		if ( this.parameters !== undefined ) {

    			const parameters = this.parameters;

    			for ( const key in parameters ) {

    				if ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];

    			}

    			return data;

    		}

    		// for simplicity the code assumes attributes are not shared across geometries, see #15811

    		data.data = { attributes: {} };

    		const index = this.index;

    		if ( index !== null ) {

    			data.data.index = {
    				type: index.array.constructor.name,
    				array: Array.prototype.slice.call( index.array )
    			};

    		}

    		const attributes = this.attributes;

    		for ( const key in attributes ) {

    			const attribute = attributes[ key ];

    			data.data.attributes[ key ] = attribute.toJSON( data.data );

    		}

    		const morphAttributes = {};
    		let hasMorphAttributes = false;

    		for ( const key in this.morphAttributes ) {

    			const attributeArray = this.morphAttributes[ key ];

    			const array = [];

    			for ( let i = 0, il = attributeArray.length; i < il; i ++ ) {

    				const attribute = attributeArray[ i ];

    				array.push( attribute.toJSON( data.data ) );

    			}

    			if ( array.length > 0 ) {

    				morphAttributes[ key ] = array;

    				hasMorphAttributes = true;

    			}

    		}

    		if ( hasMorphAttributes ) {

    			data.data.morphAttributes = morphAttributes;
    			data.data.morphTargetsRelative = this.morphTargetsRelative;

    		}

    		const groups = this.groups;

    		if ( groups.length > 0 ) {

    			data.data.groups = JSON.parse( JSON.stringify( groups ) );

    		}

    		const boundingSphere = this.boundingSphere;

    		if ( boundingSphere !== null ) {

    			data.data.boundingSphere = {
    				center: boundingSphere.center.toArray(),
    				radius: boundingSphere.radius
    			};

    		}

    		return data;

    	}

    	clone() {

    		 return new this.constructor().copy( this );

    	}

    	copy( source ) {

    		// reset

    		this.index = null;
    		this.attributes = {};
    		this.morphAttributes = {};
    		this.groups = [];
    		this.boundingBox = null;
    		this.boundingSphere = null;

    		// used for storing cloned, shared data

    		const data = {};

    		// name

    		this.name = source.name;

    		// index

    		const index = source.index;

    		if ( index !== null ) {

    			this.setIndex( index.clone( data ) );

    		}

    		// attributes

    		const attributes = source.attributes;

    		for ( const name in attributes ) {

    			const attribute = attributes[ name ];
    			this.setAttribute( name, attribute.clone( data ) );

    		}

    		// morph attributes

    		const morphAttributes = source.morphAttributes;

    		for ( const name in morphAttributes ) {

    			const array = [];
    			const morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes

    			for ( let i = 0, l = morphAttribute.length; i < l; i ++ ) {

    				array.push( morphAttribute[ i ].clone( data ) );

    			}

    			this.morphAttributes[ name ] = array;

    		}

    		this.morphTargetsRelative = source.morphTargetsRelative;

    		// groups

    		const groups = source.groups;

    		for ( let i = 0, l = groups.length; i < l; i ++ ) {

    			const group = groups[ i ];
    			this.addGroup( group.start, group.count, group.materialIndex );

    		}

    		// bounding box

    		const boundingBox = source.boundingBox;

    		if ( boundingBox !== null ) {

    			this.boundingBox = boundingBox.clone();

    		}

    		// bounding sphere

    		const boundingSphere = source.boundingSphere;

    		if ( boundingSphere !== null ) {

    			this.boundingSphere = boundingSphere.clone();

    		}

    		// draw range

    		this.drawRange.start = source.drawRange.start;
    		this.drawRange.count = source.drawRange.count;

    		// user data

    		this.userData = source.userData;

    		// geometry generator parameters

    		if ( source.parameters !== undefined ) this.parameters = Object.assign( {}, source.parameters );

    		return this;

    	}

    	dispose() {

    		this.dispatchEvent( { type: 'dispose' } );

    	}

    }

    const _inverseMatrix$2 = /*@__PURE__*/ new Matrix4();
    const _ray$2 = /*@__PURE__*/ new Ray();
    const _sphere$3 = /*@__PURE__*/ new Sphere();

    const _vA$1 = /*@__PURE__*/ new Vector3();
    const _vB$1 = /*@__PURE__*/ new Vector3();
    const _vC$1 = /*@__PURE__*/ new Vector3();

    const _tempA = /*@__PURE__*/ new Vector3();
    const _tempB = /*@__PURE__*/ new Vector3();
    const _tempC = /*@__PURE__*/ new Vector3();

    const _morphA = /*@__PURE__*/ new Vector3();
    const _morphB = /*@__PURE__*/ new Vector3();
    const _morphC = /*@__PURE__*/ new Vector3();

    const _uvA$1 = /*@__PURE__*/ new Vector2();
    const _uvB$1 = /*@__PURE__*/ new Vector2();
    const _uvC$1 = /*@__PURE__*/ new Vector2();

    const _intersectionPoint = /*@__PURE__*/ new Vector3();
    const _intersectionPointWorld = /*@__PURE__*/ new Vector3();

    class Mesh extends Object3D {

    	constructor( geometry = new BufferGeometry(), material = new MeshBasicMaterial() ) {

    		super();

    		this.isMesh = true;

    		this.type = 'Mesh';

    		this.geometry = geometry;
    		this.material = material;

    		this.updateMorphTargets();

    	}

    	copy( source, recursive ) {

    		super.copy( source, recursive );

    		if ( source.morphTargetInfluences !== undefined ) {

    			this.morphTargetInfluences = source.morphTargetInfluences.slice();

    		}

    		if ( source.morphTargetDictionary !== undefined ) {

    			this.morphTargetDictionary = Object.assign( {}, source.morphTargetDictionary );

    		}

    		this.material = source.material;
    		this.geometry = source.geometry;

    		return this;

    	}

    	updateMorphTargets() {

    		const geometry = this.geometry;

    		const morphAttributes = geometry.morphAttributes;
    		const keys = Object.keys( morphAttributes );

    		if ( keys.length > 0 ) {

    			const morphAttribute = morphAttributes[ keys[ 0 ] ];

    			if ( morphAttribute !== undefined ) {

    				this.morphTargetInfluences = [];
    				this.morphTargetDictionary = {};

    				for ( let m = 0, ml = morphAttribute.length; m < ml; m ++ ) {

    					const name = morphAttribute[ m ].name || String( m );

    					this.morphTargetInfluences.push( 0 );
    					this.morphTargetDictionary[ name ] = m;

    				}

    			}

    		}

    	}

    	raycast( raycaster, intersects ) {

    		const geometry = this.geometry;
    		const material = this.material;
    		const matrixWorld = this.matrixWorld;

    		if ( material === undefined ) return;

    		// Checking boundingSphere distance to ray

    		if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

    		_sphere$3.copy( geometry.boundingSphere );
    		_sphere$3.applyMatrix4( matrixWorld );

    		if ( raycaster.ray.intersectsSphere( _sphere$3 ) === false ) return;

    		//

    		_inverseMatrix$2.copy( matrixWorld ).invert();
    		_ray$2.copy( raycaster.ray ).applyMatrix4( _inverseMatrix$2 );

    		// Check boundingBox before continuing

    		if ( geometry.boundingBox !== null ) {

    			if ( _ray$2.intersectsBox( geometry.boundingBox ) === false ) return;

    		}

    		let intersection;

    		const index = geometry.index;
    		const position = geometry.attributes.position;
    		const morphPosition = geometry.morphAttributes.position;
    		const morphTargetsRelative = geometry.morphTargetsRelative;
    		const uv = geometry.attributes.uv;
    		const uv2 = geometry.attributes.uv2;
    		const groups = geometry.groups;
    		const drawRange = geometry.drawRange;

    		if ( index !== null ) {

    			// indexed buffer geometry

    			if ( Array.isArray( material ) ) {

    				for ( let i = 0, il = groups.length; i < il; i ++ ) {

    					const group = groups[ i ];
    					const groupMaterial = material[ group.materialIndex ];

    					const start = Math.max( group.start, drawRange.start );
    					const end = Math.min( index.count, Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) ) );

    					for ( let j = start, jl = end; j < jl; j += 3 ) {

    						const a = index.getX( j );
    						const b = index.getX( j + 1 );
    						const c = index.getX( j + 2 );

    						intersection = checkBufferGeometryIntersection( this, groupMaterial, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c );

    						if ( intersection ) {

    							intersection.faceIndex = Math.floor( j / 3 ); // triangle number in indexed buffer semantics
    							intersection.face.materialIndex = group.materialIndex;
    							intersects.push( intersection );

    						}

    					}

    				}

    			} else {

    				const start = Math.max( 0, drawRange.start );
    				const end = Math.min( index.count, ( drawRange.start + drawRange.count ) );

    				for ( let i = start, il = end; i < il; i += 3 ) {

    					const a = index.getX( i );
    					const b = index.getX( i + 1 );
    					const c = index.getX( i + 2 );

    					intersection = checkBufferGeometryIntersection( this, material, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c );

    					if ( intersection ) {

    						intersection.faceIndex = Math.floor( i / 3 ); // triangle number in indexed buffer semantics
    						intersects.push( intersection );

    					}

    				}

    			}

    		} else if ( position !== undefined ) {

    			// non-indexed buffer geometry

    			if ( Array.isArray( material ) ) {

    				for ( let i = 0, il = groups.length; i < il; i ++ ) {

    					const group = groups[ i ];
    					const groupMaterial = material[ group.materialIndex ];

    					const start = Math.max( group.start, drawRange.start );
    					const end = Math.min( position.count, Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) ) );

    					for ( let j = start, jl = end; j < jl; j += 3 ) {

    						const a = j;
    						const b = j + 1;
    						const c = j + 2;

    						intersection = checkBufferGeometryIntersection( this, groupMaterial, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c );

    						if ( intersection ) {

    							intersection.faceIndex = Math.floor( j / 3 ); // triangle number in non-indexed buffer semantics
    							intersection.face.materialIndex = group.materialIndex;
    							intersects.push( intersection );

    						}

    					}

    				}

    			} else {

    				const start = Math.max( 0, drawRange.start );
    				const end = Math.min( position.count, ( drawRange.start + drawRange.count ) );

    				for ( let i = start, il = end; i < il; i += 3 ) {

    					const a = i;
    					const b = i + 1;
    					const c = i + 2;

    					intersection = checkBufferGeometryIntersection( this, material, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c );

    					if ( intersection ) {

    						intersection.faceIndex = Math.floor( i / 3 ); // triangle number in non-indexed buffer semantics
    						intersects.push( intersection );

    					}

    				}

    			}

    		}

    	}

    }

    function checkIntersection( object, material, raycaster, ray, pA, pB, pC, point ) {

    	let intersect;

    	if ( material.side === BackSide ) {

    		intersect = ray.intersectTriangle( pC, pB, pA, true, point );

    	} else {

    		intersect = ray.intersectTriangle( pA, pB, pC, material.side !== DoubleSide, point );

    	}

    	if ( intersect === null ) return null;

    	_intersectionPointWorld.copy( point );
    	_intersectionPointWorld.applyMatrix4( object.matrixWorld );

    	const distance = raycaster.ray.origin.distanceTo( _intersectionPointWorld );

    	if ( distance < raycaster.near || distance > raycaster.far ) return null;

    	return {
    		distance: distance,
    		point: _intersectionPointWorld.clone(),
    		object: object
    	};

    }

    function checkBufferGeometryIntersection( object, material, raycaster, ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c ) {

    	_vA$1.fromBufferAttribute( position, a );
    	_vB$1.fromBufferAttribute( position, b );
    	_vC$1.fromBufferAttribute( position, c );

    	const morphInfluences = object.morphTargetInfluences;

    	if ( morphPosition && morphInfluences ) {

    		_morphA.set( 0, 0, 0 );
    		_morphB.set( 0, 0, 0 );
    		_morphC.set( 0, 0, 0 );

    		for ( let i = 0, il = morphPosition.length; i < il; i ++ ) {

    			const influence = morphInfluences[ i ];
    			const morphAttribute = morphPosition[ i ];

    			if ( influence === 0 ) continue;

    			_tempA.fromBufferAttribute( morphAttribute, a );
    			_tempB.fromBufferAttribute( morphAttribute, b );
    			_tempC.fromBufferAttribute( morphAttribute, c );

    			if ( morphTargetsRelative ) {

    				_morphA.addScaledVector( _tempA, influence );
    				_morphB.addScaledVector( _tempB, influence );
    				_morphC.addScaledVector( _tempC, influence );

    			} else {

    				_morphA.addScaledVector( _tempA.sub( _vA$1 ), influence );
    				_morphB.addScaledVector( _tempB.sub( _vB$1 ), influence );
    				_morphC.addScaledVector( _tempC.sub( _vC$1 ), influence );

    			}

    		}

    		_vA$1.add( _morphA );
    		_vB$1.add( _morphB );
    		_vC$1.add( _morphC );

    	}

    	if ( object.isSkinnedMesh ) {

    		object.boneTransform( a, _vA$1 );
    		object.boneTransform( b, _vB$1 );
    		object.boneTransform( c, _vC$1 );

    	}

    	const intersection = checkIntersection( object, material, raycaster, ray, _vA$1, _vB$1, _vC$1, _intersectionPoint );

    	if ( intersection ) {

    		if ( uv ) {

    			_uvA$1.fromBufferAttribute( uv, a );
    			_uvB$1.fromBufferAttribute( uv, b );
    			_uvC$1.fromBufferAttribute( uv, c );

    			intersection.uv = Triangle.getUV( _intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2() );

    		}

    		if ( uv2 ) {

    			_uvA$1.fromBufferAttribute( uv2, a );
    			_uvB$1.fromBufferAttribute( uv2, b );
    			_uvC$1.fromBufferAttribute( uv2, c );

    			intersection.uv2 = Triangle.getUV( _intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2() );

    		}

    		const face = {
    			a: a,
    			b: b,
    			c: c,
    			normal: new Vector3(),
    			materialIndex: 0
    		};

    		Triangle.getNormal( _vA$1, _vB$1, _vC$1, face.normal );

    		intersection.face = face;

    	}

    	return intersection;

    }

    class BoxGeometry extends BufferGeometry {

    	constructor( width = 1, height = 1, depth = 1, widthSegments = 1, heightSegments = 1, depthSegments = 1 ) {

    		super();

    		this.type = 'BoxGeometry';

    		this.parameters = {
    			width: width,
    			height: height,
    			depth: depth,
    			widthSegments: widthSegments,
    			heightSegments: heightSegments,
    			depthSegments: depthSegments
    		};

    		const scope = this;

    		// segments

    		widthSegments = Math.floor( widthSegments );
    		heightSegments = Math.floor( heightSegments );
    		depthSegments = Math.floor( depthSegments );

    		// buffers

    		const indices = [];
    		const vertices = [];
    		const normals = [];
    		const uvs = [];

    		// helper variables

    		let numberOfVertices = 0;
    		let groupStart = 0;

    		// build each side of the box geometry

    		buildPlane( 'z', 'y', 'x', - 1, - 1, depth, height, width, depthSegments, heightSegments, 0 ); // px
    		buildPlane( 'z', 'y', 'x', 1, - 1, depth, height, - width, depthSegments, heightSegments, 1 ); // nx
    		buildPlane( 'x', 'z', 'y', 1, 1, width, depth, height, widthSegments, depthSegments, 2 ); // py
    		buildPlane( 'x', 'z', 'y', 1, - 1, width, depth, - height, widthSegments, depthSegments, 3 ); // ny
    		buildPlane( 'x', 'y', 'z', 1, - 1, width, height, depth, widthSegments, heightSegments, 4 ); // pz
    		buildPlane( 'x', 'y', 'z', - 1, - 1, width, height, - depth, widthSegments, heightSegments, 5 ); // nz

    		// build geometry

    		this.setIndex( indices );
    		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
    		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
    		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

    		function buildPlane( u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex ) {

    			const segmentWidth = width / gridX;
    			const segmentHeight = height / gridY;

    			const widthHalf = width / 2;
    			const heightHalf = height / 2;
    			const depthHalf = depth / 2;

    			const gridX1 = gridX + 1;
    			const gridY1 = gridY + 1;

    			let vertexCounter = 0;
    			let groupCount = 0;

    			const vector = new Vector3();

    			// generate vertices, normals and uvs

    			for ( let iy = 0; iy < gridY1; iy ++ ) {

    				const y = iy * segmentHeight - heightHalf;

    				for ( let ix = 0; ix < gridX1; ix ++ ) {

    					const x = ix * segmentWidth - widthHalf;

    					// set values to correct vector component

    					vector[ u ] = x * udir;
    					vector[ v ] = y * vdir;
    					vector[ w ] = depthHalf;

    					// now apply vector to vertex buffer

    					vertices.push( vector.x, vector.y, vector.z );

    					// set values to correct vector component

    					vector[ u ] = 0;
    					vector[ v ] = 0;
    					vector[ w ] = depth > 0 ? 1 : - 1;

    					// now apply vector to normal buffer

    					normals.push( vector.x, vector.y, vector.z );

    					// uvs

    					uvs.push( ix / gridX );
    					uvs.push( 1 - ( iy / gridY ) );

    					// counters

    					vertexCounter += 1;

    				}

    			}

    			// indices

    			// 1. you need three indices to draw a single face
    			// 2. a single segment consists of two faces
    			// 3. so we need to generate six (2*3) indices per segment

    			for ( let iy = 0; iy < gridY; iy ++ ) {

    				for ( let ix = 0; ix < gridX; ix ++ ) {

    					const a = numberOfVertices + ix + gridX1 * iy;
    					const b = numberOfVertices + ix + gridX1 * ( iy + 1 );
    					const c = numberOfVertices + ( ix + 1 ) + gridX1 * ( iy + 1 );
    					const d = numberOfVertices + ( ix + 1 ) + gridX1 * iy;

    					// faces

    					indices.push( a, b, d );
    					indices.push( b, c, d );

    					// increase counter

    					groupCount += 6;

    				}

    			}

    			// add a group to the geometry. this will ensure multi material support

    			scope.addGroup( groupStart, groupCount, materialIndex );

    			// calculate new start value for groups

    			groupStart += groupCount;

    			// update total number of vertices

    			numberOfVertices += vertexCounter;

    		}

    	}

    	static fromJSON( data ) {

    		return new BoxGeometry( data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments );

    	}

    }

    /**
     * Uniform Utilities
     */

    function cloneUniforms( src ) {

    	const dst = {};

    	for ( const u in src ) {

    		dst[ u ] = {};

    		for ( const p in src[ u ] ) {

    			const property = src[ u ][ p ];

    			if ( property && ( property.isColor ||
    				property.isMatrix3 || property.isMatrix4 ||
    				property.isVector2 || property.isVector3 || property.isVector4 ||
    				property.isTexture || property.isQuaternion ) ) {

    				dst[ u ][ p ] = property.clone();

    			} else if ( Array.isArray( property ) ) {

    				dst[ u ][ p ] = property.slice();

    			} else {

    				dst[ u ][ p ] = property;

    			}

    		}

    	}

    	return dst;

    }

    function mergeUniforms( uniforms ) {

    	const merged = {};

    	for ( let u = 0; u < uniforms.length; u ++ ) {

    		const tmp = cloneUniforms( uniforms[ u ] );

    		for ( const p in tmp ) {

    			merged[ p ] = tmp[ p ];

    		}

    	}

    	return merged;

    }

    function cloneUniformsGroups( src ) {

    	const dst = [];

    	for ( let u = 0; u < src.length; u ++ ) {

    		dst.push( src[ u ].clone() );

    	}

    	return dst;

    }

    function getUnlitUniformColorSpace( renderer ) {

    	if ( renderer.getRenderTarget() === null ) {

    		// https://github.com/mrdoob/three.js/pull/23937#issuecomment-1111067398
    		return renderer.outputEncoding === sRGBEncoding ? SRGBColorSpace : LinearSRGBColorSpace;

    	}

    	return LinearSRGBColorSpace;

    }

    // Legacy

    const UniformsUtils = { clone: cloneUniforms, merge: mergeUniforms };

    var default_vertex = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";

    var default_fragment = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";

    class ShaderMaterial extends Material {

    	constructor( parameters ) {

    		super();

    		this.isShaderMaterial = true;

    		this.type = 'ShaderMaterial';

    		this.defines = {};
    		this.uniforms = {};
    		this.uniformsGroups = [];

    		this.vertexShader = default_vertex;
    		this.fragmentShader = default_fragment;

    		this.linewidth = 1;

    		this.wireframe = false;
    		this.wireframeLinewidth = 1;

    		this.fog = false; // set to use scene fog
    		this.lights = false; // set to use scene lights
    		this.clipping = false; // set to use user-defined clipping planes

    		this.extensions = {
    			derivatives: false, // set to use derivatives
    			fragDepth: false, // set to use fragment depth values
    			drawBuffers: false, // set to use draw buffers
    			shaderTextureLOD: false // set to use shader texture LOD
    		};

    		// When rendered geometry doesn't include these attributes but the material does,
    		// use these default values in WebGL. This avoids errors when buffer data is missing.
    		this.defaultAttributeValues = {
    			'color': [ 1, 1, 1 ],
    			'uv': [ 0, 0 ],
    			'uv2': [ 0, 0 ]
    		};

    		this.index0AttributeName = undefined;
    		this.uniformsNeedUpdate = false;

    		this.glslVersion = null;

    		if ( parameters !== undefined ) {

    			this.setValues( parameters );

    		}

    	}

    	copy( source ) {

    		super.copy( source );

    		this.fragmentShader = source.fragmentShader;
    		this.vertexShader = source.vertexShader;

    		this.uniforms = cloneUniforms( source.uniforms );
    		this.uniformsGroups = cloneUniformsGroups( source.uniformsGroups );

    		this.defines = Object.assign( {}, source.defines );

    		this.wireframe = source.wireframe;
    		this.wireframeLinewidth = source.wireframeLinewidth;

    		this.fog = source.fog;
    		this.lights = source.lights;
    		this.clipping = source.clipping;

    		this.extensions = Object.assign( {}, source.extensions );

    		this.glslVersion = source.glslVersion;

    		return this;

    	}

    	toJSON( meta ) {

    		const data = super.toJSON( meta );

    		data.glslVersion = this.glslVersion;
    		data.uniforms = {};

    		for ( const name in this.uniforms ) {

    			const uniform = this.uniforms[ name ];
    			const value = uniform.value;

    			if ( value && value.isTexture ) {

    				data.uniforms[ name ] = {
    					type: 't',
    					value: value.toJSON( meta ).uuid
    				};

    			} else if ( value && value.isColor ) {

    				data.uniforms[ name ] = {
    					type: 'c',
    					value: value.getHex()
    				};

    			} else if ( value && value.isVector2 ) {

    				data.uniforms[ name ] = {
    					type: 'v2',
    					value: value.toArray()
    				};

    			} else if ( value && value.isVector3 ) {

    				data.uniforms[ name ] = {
    					type: 'v3',
    					value: value.toArray()
    				};

    			} else if ( value && value.isVector4 ) {

    				data.uniforms[ name ] = {
    					type: 'v4',
    					value: value.toArray()
    				};

    			} else if ( value && value.isMatrix3 ) {

    				data.uniforms[ name ] = {
    					type: 'm3',
    					value: value.toArray()
    				};

    			} else if ( value && value.isMatrix4 ) {

    				data.uniforms[ name ] = {
    					type: 'm4',
    					value: value.toArray()
    				};

    			} else {

    				data.uniforms[ name ] = {
    					value: value
    				};

    				// note: the array variants v2v, v3v, v4v, m4v and tv are not supported so far

    			}

    		}

    		if ( Object.keys( this.defines ).length > 0 ) data.defines = this.defines;

    		data.vertexShader = this.vertexShader;
    		data.fragmentShader = this.fragmentShader;

    		const extensions = {};

    		for ( const key in this.extensions ) {

    			if ( this.extensions[ key ] === true ) extensions[ key ] = true;

    		}

    		if ( Object.keys( extensions ).length > 0 ) data.extensions = extensions;

    		return data;

    	}

    }

    class Camera extends Object3D {

    	constructor() {

    		super();

    		this.isCamera = true;

    		this.type = 'Camera';

    		this.matrixWorldInverse = new Matrix4();

    		this.projectionMatrix = new Matrix4();
    		this.projectionMatrixInverse = new Matrix4();

    	}

    	copy( source, recursive ) {

    		super.copy( source, recursive );

    		this.matrixWorldInverse.copy( source.matrixWorldInverse );

    		this.projectionMatrix.copy( source.projectionMatrix );
    		this.projectionMatrixInverse.copy( source.projectionMatrixInverse );

    		return this;

    	}

    	getWorldDirection( target ) {

    		this.updateWorldMatrix( true, false );

    		const e = this.matrixWorld.elements;

    		return target.set( - e[ 8 ], - e[ 9 ], - e[ 10 ] ).normalize();

    	}

    	updateMatrixWorld( force ) {

    		super.updateMatrixWorld( force );

    		this.matrixWorldInverse.copy( this.matrixWorld ).invert();

    	}

    	updateWorldMatrix( updateParents, updateChildren ) {

    		super.updateWorldMatrix( updateParents, updateChildren );

    		this.matrixWorldInverse.copy( this.matrixWorld ).invert();

    	}

    	clone() {

    		return new this.constructor().copy( this );

    	}

    }

    class PerspectiveCamera extends Camera {

    	constructor( fov = 50, aspect = 1, near = 0.1, far = 2000 ) {

    		super();

    		this.isPerspectiveCamera = true;

    		this.type = 'PerspectiveCamera';

    		this.fov = fov;
    		this.zoom = 1;

    		this.near = near;
    		this.far = far;
    		this.focus = 10;

    		this.aspect = aspect;
    		this.view = null;

    		this.filmGauge = 35;	// width of the film (default in millimeters)
    		this.filmOffset = 0;	// horizontal film offset (same unit as gauge)

    		this.updateProjectionMatrix();

    	}

    	copy( source, recursive ) {

    		super.copy( source, recursive );

    		this.fov = source.fov;
    		this.zoom = source.zoom;

    		this.near = source.near;
    		this.far = source.far;
    		this.focus = source.focus;

    		this.aspect = source.aspect;
    		this.view = source.view === null ? null : Object.assign( {}, source.view );

    		this.filmGauge = source.filmGauge;
    		this.filmOffset = source.filmOffset;

    		return this;

    	}

    	/**
    	 * Sets the FOV by focal length in respect to the current .filmGauge.
    	 *
    	 * The default film gauge is 35, so that the focal length can be specified for
    	 * a 35mm (full frame) camera.
    	 *
    	 * Values for focal length and film gauge must have the same unit.
    	 */
    	setFocalLength( focalLength ) {

    		/** see {@link http://www.bobatkins.com/photography/technical/field_of_view.html} */
    		const vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;

    		this.fov = RAD2DEG * 2 * Math.atan( vExtentSlope );
    		this.updateProjectionMatrix();

    	}

    	/**
    	 * Calculates the focal length from the current .fov and .filmGauge.
    	 */
    	getFocalLength() {

    		const vExtentSlope = Math.tan( DEG2RAD * 0.5 * this.fov );

    		return 0.5 * this.getFilmHeight() / vExtentSlope;

    	}

    	getEffectiveFOV() {

    		return RAD2DEG * 2 * Math.atan(
    			Math.tan( DEG2RAD * 0.5 * this.fov ) / this.zoom );

    	}

    	getFilmWidth() {

    		// film not completely covered in portrait format (aspect < 1)
    		return this.filmGauge * Math.min( this.aspect, 1 );

    	}

    	getFilmHeight() {

    		// film not completely covered in landscape format (aspect > 1)
    		return this.filmGauge / Math.max( this.aspect, 1 );

    	}

    	/**
    	 * Sets an offset in a larger frustum. This is useful for multi-window or
    	 * multi-monitor/multi-machine setups.
    	 *
    	 * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
    	 * the monitors are in grid like this
    	 *
    	 *   +---+---+---+
    	 *   | A | B | C |
    	 *   +---+---+---+
    	 *   | D | E | F |
    	 *   +---+---+---+
    	 *
    	 * then for each monitor you would call it like this
    	 *
    	 *   const w = 1920;
    	 *   const h = 1080;
    	 *   const fullWidth = w * 3;
    	 *   const fullHeight = h * 2;
    	 *
    	 *   --A--
    	 *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
    	 *   --B--
    	 *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
    	 *   --C--
    	 *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
    	 *   --D--
    	 *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
    	 *   --E--
    	 *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
    	 *   --F--
    	 *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
    	 *
    	 *   Note there is no reason monitors have to be the same size or in a grid.
    	 */
    	setViewOffset( fullWidth, fullHeight, x, y, width, height ) {

    		this.aspect = fullWidth / fullHeight;

    		if ( this.view === null ) {

    			this.view = {
    				enabled: true,
    				fullWidth: 1,
    				fullHeight: 1,
    				offsetX: 0,
    				offsetY: 0,
    				width: 1,
    				height: 1
    			};

    		}

    		this.view.enabled = true;
    		this.view.fullWidth = fullWidth;
    		this.view.fullHeight = fullHeight;
    		this.view.offsetX = x;
    		this.view.offsetY = y;
    		this.view.width = width;
    		this.view.height = height;

    		this.updateProjectionMatrix();

    	}

    	clearViewOffset() {

    		if ( this.view !== null ) {

    			this.view.enabled = false;

    		}

    		this.updateProjectionMatrix();

    	}

    	updateProjectionMatrix() {

    		const near = this.near;
    		let top = near * Math.tan( DEG2RAD * 0.5 * this.fov ) / this.zoom;
    		let height = 2 * top;
    		let width = this.aspect * height;
    		let left = - 0.5 * width;
    		const view = this.view;

    		if ( this.view !== null && this.view.enabled ) {

    			const fullWidth = view.fullWidth,
    				fullHeight = view.fullHeight;

    			left += view.offsetX * width / fullWidth;
    			top -= view.offsetY * height / fullHeight;
    			width *= view.width / fullWidth;
    			height *= view.height / fullHeight;

    		}

    		const skew = this.filmOffset;
    		if ( skew !== 0 ) left += near * skew / this.getFilmWidth();

    		this.projectionMatrix.makePerspective( left, left + width, top, top - height, near, this.far );

    		this.projectionMatrixInverse.copy( this.projectionMatrix ).invert();

    	}

    	toJSON( meta ) {

    		const data = super.toJSON( meta );

    		data.object.fov = this.fov;
    		data.object.zoom = this.zoom;

    		data.object.near = this.near;
    		data.object.far = this.far;
    		data.object.focus = this.focus;

    		data.object.aspect = this.aspect;

    		if ( this.view !== null ) data.object.view = Object.assign( {}, this.view );

    		data.object.filmGauge = this.filmGauge;
    		data.object.filmOffset = this.filmOffset;

    		return data;

    	}

    }

    const fov = - 90; // negative fov is not an error
    const aspect = 1;

    class CubeCamera extends Object3D {

    	constructor( near, far, renderTarget ) {

    		super();

    		this.type = 'CubeCamera';

    		this.renderTarget = renderTarget;

    		const cameraPX = new PerspectiveCamera( fov, aspect, near, far );
    		cameraPX.layers = this.layers;
    		cameraPX.up.set( 0, 1, 0 );
    		cameraPX.lookAt( 1, 0, 0 );
    		this.add( cameraPX );

    		const cameraNX = new PerspectiveCamera( fov, aspect, near, far );
    		cameraNX.layers = this.layers;
    		cameraNX.up.set( 0, 1, 0 );
    		cameraNX.lookAt( - 1, 0, 0 );
    		this.add( cameraNX );

    		const cameraPY = new PerspectiveCamera( fov, aspect, near, far );
    		cameraPY.layers = this.layers;
    		cameraPY.up.set( 0, 0, - 1 );
    		cameraPY.lookAt( 0, 1, 0 );
    		this.add( cameraPY );

    		const cameraNY = new PerspectiveCamera( fov, aspect, near, far );
    		cameraNY.layers = this.layers;
    		cameraNY.up.set( 0, 0, 1 );
    		cameraNY.lookAt( 0, - 1, 0 );
    		this.add( cameraNY );

    		const cameraPZ = new PerspectiveCamera( fov, aspect, near, far );
    		cameraPZ.layers = this.layers;
    		cameraPZ.up.set( 0, 1, 0 );
    		cameraPZ.lookAt( 0, 0, 1 );
    		this.add( cameraPZ );

    		const cameraNZ = new PerspectiveCamera( fov, aspect, near, far );
    		cameraNZ.layers = this.layers;
    		cameraNZ.up.set( 0, 1, 0 );
    		cameraNZ.lookAt( 0, 0, - 1 );
    		this.add( cameraNZ );

    	}

    	update( renderer, scene ) {

    		if ( this.parent === null ) this.updateMatrixWorld();

    		const renderTarget = this.renderTarget;

    		const [ cameraPX, cameraNX, cameraPY, cameraNY, cameraPZ, cameraNZ ] = this.children;

    		const currentRenderTarget = renderer.getRenderTarget();

    		const currentToneMapping = renderer.toneMapping;
    		const currentXrEnabled = renderer.xr.enabled;

    		renderer.toneMapping = NoToneMapping;
    		renderer.xr.enabled = false;

    		const generateMipmaps = renderTarget.texture.generateMipmaps;

    		renderTarget.texture.generateMipmaps = false;

    		renderer.setRenderTarget( renderTarget, 0 );
    		renderer.render( scene, cameraPX );

    		renderer.setRenderTarget( renderTarget, 1 );
    		renderer.render( scene, cameraNX );

    		renderer.setRenderTarget( renderTarget, 2 );
    		renderer.render( scene, cameraPY );

    		renderer.setRenderTarget( renderTarget, 3 );
    		renderer.render( scene, cameraNY );

    		renderer.setRenderTarget( renderTarget, 4 );
    		renderer.render( scene, cameraPZ );

    		renderTarget.texture.generateMipmaps = generateMipmaps;

    		renderer.setRenderTarget( renderTarget, 5 );
    		renderer.render( scene, cameraNZ );

    		renderer.setRenderTarget( currentRenderTarget );

    		renderer.toneMapping = currentToneMapping;
    		renderer.xr.enabled = currentXrEnabled;

    		renderTarget.texture.needsPMREMUpdate = true;

    	}

    }

    class CubeTexture extends Texture {

    	constructor( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {

    		images = images !== undefined ? images : [];
    		mapping = mapping !== undefined ? mapping : CubeReflectionMapping;

    		super( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );

    		this.isCubeTexture = true;

    		this.flipY = false;

    	}

    	get images() {

    		return this.image;

    	}

    	set images( value ) {

    		this.image = value;

    	}

    }

    class WebGLCubeRenderTarget extends WebGLRenderTarget {

    	constructor( size = 1, options = {} ) {

    		super( size, size, options );

    		this.isWebGLCubeRenderTarget = true;

    		const image = { width: size, height: size, depth: 1 };
    		const images = [ image, image, image, image, image, image ];

    		this.texture = new CubeTexture( images, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding );

    		// By convention -- likely based on the RenderMan spec from the 1990's -- cube maps are specified by WebGL (and three.js)
    		// in a coordinate system in which positive-x is to the right when looking up the positive-z axis -- in other words,
    		// in a left-handed coordinate system. By continuing this convention, preexisting cube maps continued to render correctly.

    		// three.js uses a right-handed coordinate system. So environment maps used in three.js appear to have px and nx swapped
    		// and the flag isRenderTargetTexture controls this conversion. The flip is not required when using WebGLCubeRenderTarget.texture
    		// as a cube texture (this is detected when isRenderTargetTexture is set to true for cube textures).

    		this.texture.isRenderTargetTexture = true;

    		this.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : false;
    		this.texture.minFilter = options.minFilter !== undefined ? options.minFilter : LinearFilter;

    	}

    	fromEquirectangularTexture( renderer, texture ) {

    		this.texture.type = texture.type;
    		this.texture.encoding = texture.encoding;

    		this.texture.generateMipmaps = texture.generateMipmaps;
    		this.texture.minFilter = texture.minFilter;
    		this.texture.magFilter = texture.magFilter;

    		const shader = {

    			uniforms: {
    				tEquirect: { value: null },
    			},

    			vertexShader: /* glsl */`

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,

    			fragmentShader: /* glsl */`

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
    		};

    		const geometry = new BoxGeometry( 5, 5, 5 );

    		const material = new ShaderMaterial( {

    			name: 'CubemapFromEquirect',

    			uniforms: cloneUniforms( shader.uniforms ),
    			vertexShader: shader.vertexShader,
    			fragmentShader: shader.fragmentShader,
    			side: BackSide,
    			blending: NoBlending

    		} );

    		material.uniforms.tEquirect.value = texture;

    		const mesh = new Mesh( geometry, material );

    		const currentMinFilter = texture.minFilter;

    		// Avoid blurred poles
    		if ( texture.minFilter === LinearMipmapLinearFilter ) texture.minFilter = LinearFilter;

    		const camera = new CubeCamera( 1, 10, this );
    		camera.update( renderer, mesh );

    		texture.minFilter = currentMinFilter;

    		mesh.geometry.dispose();
    		mesh.material.dispose();

    		return this;

    	}

    	clear( renderer, color, depth, stencil ) {

    		const currentRenderTarget = renderer.getRenderTarget();

    		for ( let i = 0; i < 6; i ++ ) {

    			renderer.setRenderTarget( this, i );

    			renderer.clear( color, depth, stencil );

    		}

    		renderer.setRenderTarget( currentRenderTarget );

    	}

    }

    const _vector1 = /*@__PURE__*/ new Vector3();
    const _vector2 = /*@__PURE__*/ new Vector3();
    const _normalMatrix = /*@__PURE__*/ new Matrix3();

    class Plane {

    	constructor( normal = new Vector3( 1, 0, 0 ), constant = 0 ) {

    		this.isPlane = true;

    		// normal is assumed to be normalized

    		this.normal = normal;
    		this.constant = constant;

    	}

    	set( normal, constant ) {

    		this.normal.copy( normal );
    		this.constant = constant;

    		return this;

    	}

    	setComponents( x, y, z, w ) {

    		this.normal.set( x, y, z );
    		this.constant = w;

    		return this;

    	}

    	setFromNormalAndCoplanarPoint( normal, point ) {

    		this.normal.copy( normal );
    		this.constant = - point.dot( this.normal );

    		return this;

    	}

    	setFromCoplanarPoints( a, b, c ) {

    		const normal = _vector1.subVectors( c, b ).cross( _vector2.subVectors( a, b ) ).normalize();

    		// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?

    		this.setFromNormalAndCoplanarPoint( normal, a );

    		return this;

    	}

    	copy( plane ) {

    		this.normal.copy( plane.normal );
    		this.constant = plane.constant;

    		return this;

    	}

    	normalize() {

    		// Note: will lead to a divide by zero if the plane is invalid.

    		const inverseNormalLength = 1.0 / this.normal.length();
    		this.normal.multiplyScalar( inverseNormalLength );
    		this.constant *= inverseNormalLength;

    		return this;

    	}

    	negate() {

    		this.constant *= - 1;
    		this.normal.negate();

    		return this;

    	}

    	distanceToPoint( point ) {

    		return this.normal.dot( point ) + this.constant;

    	}

    	distanceToSphere( sphere ) {

    		return this.distanceToPoint( sphere.center ) - sphere.radius;

    	}

    	projectPoint( point, target ) {

    		return target.copy( this.normal ).multiplyScalar( - this.distanceToPoint( point ) ).add( point );

    	}

    	intersectLine( line, target ) {

    		const direction = line.delta( _vector1 );

    		const denominator = this.normal.dot( direction );

    		if ( denominator === 0 ) {

    			// line is coplanar, return origin
    			if ( this.distanceToPoint( line.start ) === 0 ) {

    				return target.copy( line.start );

    			}

    			// Unsure if this is the correct method to handle this case.
    			return null;

    		}

    		const t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;

    		if ( t < 0 || t > 1 ) {

    			return null;

    		}

    		return target.copy( direction ).multiplyScalar( t ).add( line.start );

    	}

    	intersectsLine( line ) {

    		// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.

    		const startSign = this.distanceToPoint( line.start );
    		const endSign = this.distanceToPoint( line.end );

    		return ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );

    	}

    	intersectsBox( box ) {

    		return box.intersectsPlane( this );

    	}

    	intersectsSphere( sphere ) {

    		return sphere.intersectsPlane( this );

    	}

    	coplanarPoint( target ) {

    		return target.copy( this.normal ).multiplyScalar( - this.constant );

    	}

    	applyMatrix4( matrix, optionalNormalMatrix ) {

    		const normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix( matrix );

    		const referencePoint = this.coplanarPoint( _vector1 ).applyMatrix4( matrix );

    		const normal = this.normal.applyMatrix3( normalMatrix ).normalize();

    		this.constant = - referencePoint.dot( normal );

    		return this;

    	}

    	translate( offset ) {

    		this.constant -= offset.dot( this.normal );

    		return this;

    	}

    	equals( plane ) {

    		return plane.normal.equals( this.normal ) && ( plane.constant === this.constant );

    	}

    	clone() {

    		return new this.constructor().copy( this );

    	}

    }

    const _sphere$2 = /*@__PURE__*/ new Sphere();
    const _vector$7 = /*@__PURE__*/ new Vector3();

    class Frustum {

    	constructor( p0 = new Plane(), p1 = new Plane(), p2 = new Plane(), p3 = new Plane(), p4 = new Plane(), p5 = new Plane() ) {

    		this.planes = [ p0, p1, p2, p3, p4, p5 ];

    	}

    	set( p0, p1, p2, p3, p4, p5 ) {

    		const planes = this.planes;

    		planes[ 0 ].copy( p0 );
    		planes[ 1 ].copy( p1 );
    		planes[ 2 ].copy( p2 );
    		planes[ 3 ].copy( p3 );
    		planes[ 4 ].copy( p4 );
    		planes[ 5 ].copy( p5 );

    		return this;

    	}

    	copy( frustum ) {

    		const planes = this.planes;

    		for ( let i = 0; i < 6; i ++ ) {

    			planes[ i ].copy( frustum.planes[ i ] );

    		}

    		return this;

    	}

    	setFromProjectionMatrix( m ) {

    		const planes = this.planes;
    		const me = m.elements;
    		const me0 = me[ 0 ], me1 = me[ 1 ], me2 = me[ 2 ], me3 = me[ 3 ];
    		const me4 = me[ 4 ], me5 = me[ 5 ], me6 = me[ 6 ], me7 = me[ 7 ];
    		const me8 = me[ 8 ], me9 = me[ 9 ], me10 = me[ 10 ], me11 = me[ 11 ];
    		const me12 = me[ 12 ], me13 = me[ 13 ], me14 = me[ 14 ], me15 = me[ 15 ];

    		planes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();
    		planes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();
    		planes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();
    		planes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();
    		planes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();
    		planes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();

    		return this;

    	}

    	intersectsObject( object ) {

    		const geometry = object.geometry;

    		if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

    		_sphere$2.copy( geometry.boundingSphere ).applyMatrix4( object.matrixWorld );

    		return this.intersectsSphere( _sphere$2 );

    	}

    	intersectsSprite( sprite ) {

    		_sphere$2.center.set( 0, 0, 0 );
    		_sphere$2.radius = 0.7071067811865476;
    		_sphere$2.applyMatrix4( sprite.matrixWorld );

    		return this.intersectsSphere( _sphere$2 );

    	}

    	intersectsSphere( sphere ) {

    		const planes = this.planes;
    		const center = sphere.center;
    		const negRadius = - sphere.radius;

    		for ( let i = 0; i < 6; i ++ ) {

    			const distance = planes[ i ].distanceToPoint( center );

    			if ( distance < negRadius ) {

    				return false;

    			}

    		}

    		return true;

    	}

    	intersectsBox( box ) {

    		const planes = this.planes;

    		for ( let i = 0; i < 6; i ++ ) {

    			const plane = planes[ i ];

    			// corner at max distance

    			_vector$7.x = plane.normal.x > 0 ? box.max.x : box.min.x;
    			_vector$7.y = plane.normal.y > 0 ? box.max.y : box.min.y;
    			_vector$7.z = plane.normal.z > 0 ? box.max.z : box.min.z;

    			if ( plane.distanceToPoint( _vector$7 ) < 0 ) {

    				return false;

    			}

    		}

    		return true;

    	}

    	containsPoint( point ) {

    		const planes = this.planes;

    		for ( let i = 0; i < 6; i ++ ) {

    			if ( planes[ i ].distanceToPoint( point ) < 0 ) {

    				return false;

    			}

    		}

    		return true;

    	}

    	clone() {

    		return new this.constructor().copy( this );

    	}

    }

    function WebGLAnimation() {

    	let context = null;
    	let isAnimating = false;
    	let animationLoop = null;
    	let requestId = null;

    	function onAnimationFrame( time, frame ) {

    		animationLoop( time, frame );

    		requestId = context.requestAnimationFrame( onAnimationFrame );

    	}

    	return {

    		start: function () {

    			if ( isAnimating === true ) return;
    			if ( animationLoop === null ) return;

    			requestId = context.requestAnimationFrame( onAnimationFrame );

    			isAnimating = true;

    		},

    		stop: function () {

    			context.cancelAnimationFrame( requestId );

    			isAnimating = false;

    		},

    		setAnimationLoop: function ( callback ) {

    			animationLoop = callback;

    		},

    		setContext: function ( value ) {

    			context = value;

    		}

    	};

    }

    function WebGLAttributes( gl, capabilities ) {

    	const isWebGL2 = capabilities.isWebGL2;

    	const buffers = new WeakMap();

    	function createBuffer( attribute, bufferType ) {

    		const array = attribute.array;
    		const usage = attribute.usage;

    		const buffer = gl.createBuffer();

    		gl.bindBuffer( bufferType, buffer );
    		gl.bufferData( bufferType, array, usage );

    		attribute.onUploadCallback();

    		let type;

    		if ( array instanceof Float32Array ) {

    			type = 5126;

    		} else if ( array instanceof Uint16Array ) {

    			if ( attribute.isFloat16BufferAttribute ) {

    				if ( isWebGL2 ) {

    					type = 5131;

    				} else {

    					throw new Error( 'THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.' );

    				}

    			} else {

    				type = 5123;

    			}

    		} else if ( array instanceof Int16Array ) {

    			type = 5122;

    		} else if ( array instanceof Uint32Array ) {

    			type = 5125;

    		} else if ( array instanceof Int32Array ) {

    			type = 5124;

    		} else if ( array instanceof Int8Array ) {

    			type = 5120;

    		} else if ( array instanceof Uint8Array ) {

    			type = 5121;

    		} else if ( array instanceof Uint8ClampedArray ) {

    			type = 5121;

    		} else {

    			throw new Error( 'THREE.WebGLAttributes: Unsupported buffer data format: ' + array );

    		}

    		return {
    			buffer: buffer,
    			type: type,
    			bytesPerElement: array.BYTES_PER_ELEMENT,
    			version: attribute.version
    		};

    	}

    	function updateBuffer( buffer, attribute, bufferType ) {

    		const array = attribute.array;
    		const updateRange = attribute.updateRange;

    		gl.bindBuffer( bufferType, buffer );

    		if ( updateRange.count === - 1 ) {

    			// Not using update ranges

    			gl.bufferSubData( bufferType, 0, array );

    		} else {

    			if ( isWebGL2 ) {

    				gl.bufferSubData( bufferType, updateRange.offset * array.BYTES_PER_ELEMENT,
    					array, updateRange.offset, updateRange.count );

    			} else {

    				gl.bufferSubData( bufferType, updateRange.offset * array.BYTES_PER_ELEMENT,
    					array.subarray( updateRange.offset, updateRange.offset + updateRange.count ) );

    			}

    			updateRange.count = - 1; // reset range

    		}

    		attribute.onUploadCallback();

    	}

    	//

    	function get( attribute ) {

    		if ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;

    		return buffers.get( attribute );

    	}

    	function remove( attribute ) {

    		if ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;

    		const data = buffers.get( attribute );

    		if ( data ) {

    			gl.deleteBuffer( data.buffer );

    			buffers.delete( attribute );

    		}

    	}

    	function update( attribute, bufferType ) {

    		if ( attribute.isGLBufferAttribute ) {

    			const cached = buffers.get( attribute );

    			if ( ! cached || cached.version < attribute.version ) {

    				buffers.set( attribute, {
    					buffer: attribute.buffer,
    					type: attribute.type,
    					bytesPerElement: attribute.elementSize,
    					version: attribute.version
    				} );

    			}

    			return;

    		}

    		if ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;

    		const data = buffers.get( attribute );

    		if ( data === undefined ) {

    			buffers.set( attribute, createBuffer( attribute, bufferType ) );

    		} else if ( data.version < attribute.version ) {

    			updateBuffer( data.buffer, attribute, bufferType );

    			data.version = attribute.version;

    		}

    	}

    	return {

    		get: get,
    		remove: remove,
    		update: update

    	};

    }

    class PlaneGeometry extends BufferGeometry {

    	constructor( width = 1, height = 1, widthSegments = 1, heightSegments = 1 ) {

    		super();

    		this.type = 'PlaneGeometry';

    		this.parameters = {
    			width: width,
    			height: height,
    			widthSegments: widthSegments,
    			heightSegments: heightSegments
    		};

    		const width_half = width / 2;
    		const height_half = height / 2;

    		const gridX = Math.floor( widthSegments );
    		const gridY = Math.floor( heightSegments );

    		const gridX1 = gridX + 1;
    		const gridY1 = gridY + 1;

    		const segment_width = width / gridX;
    		const segment_height = height / gridY;

    		//

    		const indices = [];
    		const vertices = [];
    		const normals = [];
    		const uvs = [];

    		for ( let iy = 0; iy < gridY1; iy ++ ) {

    			const y = iy * segment_height - height_half;

    			for ( let ix = 0; ix < gridX1; ix ++ ) {

    				const x = ix * segment_width - width_half;

    				vertices.push( x, - y, 0 );

    				normals.push( 0, 0, 1 );

    				uvs.push( ix / gridX );
    				uvs.push( 1 - ( iy / gridY ) );

    			}

    		}

    		for ( let iy = 0; iy < gridY; iy ++ ) {

    			for ( let ix = 0; ix < gridX; ix ++ ) {

    				const a = ix + gridX1 * iy;
    				const b = ix + gridX1 * ( iy + 1 );
    				const c = ( ix + 1 ) + gridX1 * ( iy + 1 );
    				const d = ( ix + 1 ) + gridX1 * iy;

    				indices.push( a, b, d );
    				indices.push( b, c, d );

    			}

    		}

    		this.setIndex( indices );
    		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
    		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
    		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

    	}

    	static fromJSON( data ) {

    		return new PlaneGeometry( data.width, data.height, data.widthSegments, data.heightSegments );

    	}

    }

    var alphamap_fragment = "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif";

    var alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif";

    var alphatest_fragment = "#ifdef USE_ALPHATEST\n\tif ( diffuseColor.a < alphaTest ) discard;\n#endif";

    var alphatest_pars_fragment = "#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif";

    var aomap_fragment = "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif";

    var aomap_pars_fragment = "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif";

    var begin_vertex = "vec3 transformed = vec3( position );";

    var beginnormal_vertex = "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif";

    var bsdfs = "vec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( V * D );\n}\n#ifdef USE_IRIDESCENCE\n\tvec3 BRDF_GGX_Iridescence( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float iridescence, const in vec3 iridescenceFresnel, const in float roughness ) {\n\t\tfloat alpha = pow2( roughness );\n\t\tvec3 halfDir = normalize( lightDir + viewDir );\n\t\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\t\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\t\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\t\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\t\tvec3 F = mix( F_Schlick( f0, f90, dotVH ), iridescenceFresnel, iridescence );\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t\treturn F * ( V * D );\n\t}\n#endif\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif";

    var iridescence_fragment = "#ifdef USE_IRIDESCENCE\n\tconst mat3 XYZ_TO_REC709 = mat3(\n\t\t 3.2404542, -0.9692660,  0.0556434,\n\t\t-1.5371385,  1.8760108, -0.2040259,\n\t\t-0.4985314,  0.0415560,  1.0572252\n\t);\n\tvec3 Fresnel0ToIor( vec3 fresnel0 ) {\n\t\tvec3 sqrtF0 = sqrt( fresnel0 );\n\t\treturn ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n\t}\n\tvec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n\t}\n\tfloat IorToFresnel0( float transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));\n\t}\n\tvec3 evalSensitivity( float OPD, vec3 shift ) {\n\t\tfloat phase = 2.0 * PI * OPD * 1.0e-9;\n\t\tvec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n\t\tvec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n\t\tvec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n\t\tvec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );\n\t\txyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );\n\t\txyz /= 1.0685e-7;\n\t\tvec3 rgb = XYZ_TO_REC709 * xyz;\n\t\treturn rgb;\n\t}\n\tvec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n\t\tvec3 I;\n\t\tfloat iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n\t\tfloat sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\n\t\tfloat cosTheta2Sq = 1.0 - sinTheta2Sq;\n\t\tif ( cosTheta2Sq < 0.0 ) {\n\t\t\t return vec3( 1.0 );\n\t\t}\n\t\tfloat cosTheta2 = sqrt( cosTheta2Sq );\n\t\tfloat R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\n\t\tfloat R12 = F_Schlick( R0, 1.0, cosTheta1 );\n\t\tfloat R21 = R12;\n\t\tfloat T121 = 1.0 - R12;\n\t\tfloat phi12 = 0.0;\n\t\tif ( iridescenceIOR < outsideIOR ) phi12 = PI;\n\t\tfloat phi21 = PI - phi12;\n\t\tvec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );\t\tvec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );\n\t\tvec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );\n\t\tvec3 phi23 = vec3( 0.0 );\n\t\tif ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;\n\t\tif ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;\n\t\tif ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;\n\t\tfloat OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\n\t\tvec3 phi = vec3( phi21 ) + phi23;\n\t\tvec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\n\t\tvec3 r123 = sqrt( R123 );\n\t\tvec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n\t\tvec3 C0 = R12 + Rs;\n\t\tI = C0;\n\t\tvec3 Cm = Rs - T121;\n\t\tfor ( int m = 1; m <= 2; ++ m ) {\n\t\t\tCm *= r123;\n\t\t\tvec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n\t\t\tI += Cm * Sm;\n\t\t}\n\t\treturn max( I, vec3( 0.0 ) );\n\t}\n#endif";

    var bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = dFdx( surf_pos.xyz );\n\t\tvec3 vSigmaY = dFdy( surf_pos.xyz );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif";

    var clipping_planes_fragment = "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif";

    var clipping_planes_pars_fragment = "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif";

    var clipping_planes_pars_vertex = "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif";

    var clipping_planes_vertex = "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif";

    var color_fragment = "#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif";

    var color_pars_fragment = "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif";

    var color_pars_vertex = "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif";

    var color_vertex = "#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif";

    var common = "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\treturn dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}";

    var cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tuv.x += filterInt * 3.0 * cubeUV_minTileSize;\n\t\tuv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n\t\tuv.x *= CUBEUV_TEXEL_WIDTH;\n\t\tuv.y *= CUBEUV_TEXEL_HEIGHT;\n\t\t#ifdef texture2DGradEXT\n\t\t\treturn texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n\t\t#else\n\t\t\treturn texture2D( envMap, uv ).rgb;\n\t\t#endif\n\t}\n\t#define cubeUV_r0 1.0\n\t#define cubeUV_v0 0.339\n\t#define cubeUV_m0 - 2.0\n\t#define cubeUV_r1 0.8\n\t#define cubeUV_v1 0.276\n\t#define cubeUV_m1 - 1.0\n\t#define cubeUV_r4 0.4\n\t#define cubeUV_v4 0.046\n\t#define cubeUV_m4 2.0\n\t#define cubeUV_r5 0.305\n\t#define cubeUV_v5 0.016\n\t#define cubeUV_m5 3.0\n\t#define cubeUV_r6 0.21\n\t#define cubeUV_v6 0.0038\n\t#define cubeUV_m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= cubeUV_r1 ) {\n\t\t\tmip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;\n\t\t} else if ( roughness >= cubeUV_r4 ) {\n\t\t\tmip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;\n\t\t} else if ( roughness >= cubeUV_r5 ) {\n\t\t\tmip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;\n\t\t} else if ( roughness >= cubeUV_r6 ) {\n\t\t\tmip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif";

    var defaultnormal_vertex = "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif";

    var displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif";

    var displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif";

    var emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif";

    var emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif";

    var encodings_fragment = "gl_FragColor = linearToOutputTexel( gl_FragColor );";

    var encodings_pars_fragment = "vec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}";

    var envmap_fragment = "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif";

    var envmap_common_pars_fragment = "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif";

    var envmap_pars_fragment = "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif";

    var envmap_pars_vertex = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif";

    var envmap_vertex = "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif";

    var fog_vertex = "#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif";

    var fog_pars_vertex = "#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif";

    var fog_fragment = "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif";

    var fog_pars_fragment = "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif";

    var gradientmap_pars_fragment = "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn vec3( texture2D( gradientMap, coord ).r );\n\t#else\n\t\tvec2 fw = fwidth( coord ) * 0.5;\n\t\treturn mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );\n\t#endif\n}";

    var lightmap_fragment = "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\treflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif";

    var lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif";

    var lights_lambert_fragment = "LambertMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularStrength = specularStrength;";

    var lights_lambert_pars_fragment = "varying vec3 vViewPosition;\nstruct LambertMaterial {\n\tvec3 diffuseColor;\n\tfloat specularStrength;\n};\nvoid RE_Direct_Lambert( const in IncidentLight directLight, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Lambert\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Lambert";

    var lights_pars_begin = "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tif ( cutoffDistance > 0.0 ) {\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t}\n\t\treturn distanceFalloff;\n\t#else\n\t\tif ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\t\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t\t}\n\t\treturn 1.0;\n\t#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif";

    var envmap_physical_pars_fragment = "#if defined( USE_ENVMAP )\n\tvec3 getIBLIrradiance( const in vec3 normal ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 reflectVec = reflect( - viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n#endif";

    var lights_toon_fragment = "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;";

    var lights_toon_pars_fragment = "varying vec3 vViewPosition;\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon";

    var lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;";

    var lights_phong_pars_fragment = "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong";

    var lights_physical_fragment = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n\tmaterial.ior = ior;\n\t#ifdef SPECULAR\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularColorFactor = specularColor;\n\t\t#ifdef USE_SPECULARINTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;\n\t\t#endif\n\t\t#ifdef USE_SPECULARCOLORMAP\n\t\t\tspecularColorFactor *= texture2D( specularColorMap, vUv ).rgb;\n\t\t#endif\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\t#else\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularColorFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\t#endif\n\tmaterial.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_IRIDESCENCE\n\tmaterial.iridescence = iridescence;\n\tmaterial.iridescenceIOR = iridescenceIOR;\n\t#ifdef USE_IRIDESCENCEMAP\n\t\tmaterial.iridescence *= texture2D( iridescenceMap, vUv ).r;\n\t#endif\n\t#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\t\tmaterial.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vUv ).g + iridescenceThicknessMinimum;\n\t#else\n\t\tmaterial.iridescenceThickness = iridescenceThicknessMaximum;\n\t#endif\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheenColor;\n\t#ifdef USE_SHEENCOLORMAP\n\t\tmaterial.sheenColor *= texture2D( sheenColorMap, vUv ).rgb;\n\t#endif\n\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n\t#ifdef USE_SHEENROUGHNESSMAP\n\t\tmaterial.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;\n\t#endif\n#endif";

    var lights_physical_pars_fragment = "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_IRIDESCENCE\n\t\tfloat iridescence;\n\t\tfloat iridescenceIOR;\n\t\tfloat iridescenceThickness;\n\t\tvec3 iridescenceFresnel;\n\t\tvec3 iridescenceF0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\t#endif\n\t#ifdef IOR\n\t\tfloat ior;\n\t#endif\n\t#ifdef USE_TRANSMISSION\n\t\tfloat transmission;\n\t\tfloat transmissionAlpha;\n\t\tfloat thickness;\n\t\tfloat attenuationDistance;\n\t\tvec3 attenuationColor;\n\t#endif\n};\nvec3 clearcoatSpecular = vec3( 0.0 );\nvec3 sheenSpecular = vec3( 0.0 );\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat r2 = roughness * roughness;\n\tfloat a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n\tfloat b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n\tfloat DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n\treturn saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\treturn fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\n#ifdef USE_IRIDESCENCE\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#else\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#endif\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\t#ifdef USE_IRIDESCENCE\n\t\tvec3 Fr = mix( specularColor, iridescenceF0, iridescence );\n\t#else\n\t\tvec3 Fr = specularColor;\n\t#endif\n\tvec3 FssEss = Fr * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );\n\t#endif\n\t#ifdef USE_IRIDESCENCE\n\t\treflectedLight.directSpecular += irradiance * BRDF_GGX_Iridescence( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness );\n\t#else\n\t\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\t#ifdef USE_IRIDESCENCE\n\t\tcomputeMultiscatteringIridescence( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );\n\t#else\n\t\tcomputeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\t#endif\n\tvec3 totalScattering = singleScattering + multiScattering;\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}";

    var lights_fragment_begin = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef USE_CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\n\tfloat dotNVi = saturate( dot( normal, geometry.viewDir ) );\n\tif ( material.iridescenceThickness == 0.0 ) {\n\t\tmaterial.iridescence = 0.0;\n\t} else {\n\t\tmaterial.iridescence = saturate( material.iridescence );\n\t}\n\tif ( material.iridescence > 0.0 ) {\n\t\tmaterial.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n\t\tmaterial.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n\t}\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointLightInfo( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tvec4 spotColor;\n\tvec3 spotLightCoord;\n\tbool inSpotLightMap;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotLightInfo( spotLight, geometry, directLight );\n\t\t#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX\n\t\t#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS\n\t\t#else\n\t\t#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#endif\n\t\t#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )\n\t\t\tspotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;\n\t\t\tinSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );\n\t\t\tspotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );\n\t\t\tdirectLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;\n\t\t#endif\n\t\t#undef SPOT_LIGHT_MAP_INDEX\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif";

    var lights_fragment_maps = "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometry.normal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif";

    var lights_fragment_end = "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif";

    var logdepthbuf_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif";

    var logdepthbuf_pars_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif";

    var logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif";

    var logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif";

    var map_fragment = "#ifdef USE_MAP\n\tvec4 sampledDiffuseColor = texture2D( map, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tsampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n\t#endif\n\tdiffuseColor *= sampledDiffuseColor;\n#endif";

    var map_pars_fragment = "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif";

    var map_particle_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tdiffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif";

    var map_particle_pars_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif";

    var metalnessmap_fragment = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif";

    var metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif";

    var morphcolor_vertex = "#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n\tvColor *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t#if defined( USE_COLOR_ALPHA )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\t\t#elif defined( USE_COLOR )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\t\t#endif\n\t}\n#endif";

    var morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\t#endif\n#endif";

    var morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform ivec2 morphTargetsTextureSize;\n\t\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\t\t\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n\t\t\tint y = texelIndex / morphTargetsTextureSize.x;\n\t\t\tint x = texelIndex - y * morphTargetsTextureSize.x;\n\t\t\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\n\t\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\n\t\t}\n\t#else\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\t\t#else\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\t\t#endif\n\t#endif\n#endif";

    var morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t\t#endif\n\t#endif\n#endif";

    var normal_fragment_begin = "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = dFdx( vViewPosition );\n\tvec3 fdy = dFdy( vViewPosition );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * faceDirection;\n\t\t\tbitangent = bitangent * faceDirection;\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;";

    var normal_fragment_maps = "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif";

    var normal_pars_fragment = "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif";

    var normal_pars_vertex = "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif";

    var normal_vertex = "#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif";

    var normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n\t\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n\t}\n#endif";

    var clearcoat_normal_fragment_begin = "#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif";

    var clearcoat_normal_fragment_maps = "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n\t#endif\n#endif";

    var clearcoat_pars_fragment = "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif";

    var iridescence_pars_fragment = "#ifdef USE_IRIDESCENCEMAP\n\tuniform sampler2D iridescenceMap;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform sampler2D iridescenceThicknessMap;\n#endif";

    var output_fragment = "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= material.transmissionAlpha + 0.1;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );";

    var packing = "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec2 packDepthToRG( in highp float v ) {\n\treturn packDepthToRGBA( v ).yx;\n}\nfloat unpackRGToDepth( const in highp vec2 v ) {\n\treturn unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}";

    var premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif";

    var project_vertex = "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;";

    var dithering_fragment = "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif";

    var dithering_pars_fragment = "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif";

    var roughnessmap_fragment = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif";

    var roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif";

    var shadowmap_pars_fragment = "#if NUM_SPOT_LIGHT_COORDS > 0\n  varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#if NUM_SPOT_LIGHT_MAPS > 0\n  uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif";

    var shadowmap_pars_vertex = "#if NUM_SPOT_LIGHT_COORDS > 0\n  uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];\n  varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif";

    var shadowmap_vertex = "#if defined( USE_SHADOWMAP ) || ( NUM_SPOT_LIGHT_COORDS > 0 )\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_COORDS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_COORDS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition;\n\t\t#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t\tshadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;\n\t\t#endif\n\t\tvSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif";

    var shadowmask_pars_fragment = "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}";

    var skinbase_vertex = "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";

    var skinning_pars_vertex = "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\tuniform highp sampler2D boneTexture;\n\tuniform int boneTextureSize;\n\tmat4 getBoneMatrix( const in float i ) {\n\t\tfloat j = i * 4.0;\n\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\ty = dy * ( y + 0.5 );\n\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\treturn bone;\n\t}\n#endif";

    var skinning_vertex = "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif";

    var skinnormal_vertex = "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif";

    var specularmap_fragment = "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif";

    var specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif";

    var tonemapping_fragment = "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif";

    var tonemapping_pars_fragment = "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }";

    var transmission_fragment = "#ifdef USE_TRANSMISSION\n\tmaterial.transmission = transmission;\n\tmaterial.transmissionAlpha = 1.0;\n\tmaterial.thickness = thickness;\n\tmaterial.attenuationDistance = attenuationDistance;\n\tmaterial.attenuationColor = attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tmaterial.transmission *= texture2D( transmissionMap, vUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tmaterial.thickness *= texture2D( thicknessMap, vUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tvec4 transmission = getIBLVolumeRefraction(\n\t\tn, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,\n\t\tmaterial.attenuationColor, material.attenuationDistance );\n\tmaterial.transmissionAlpha = mix( material.transmissionAlpha, transmission.a, material.transmission );\n\ttotalDiffuse = mix( totalDiffuse, transmission.rgb, material.transmission );\n#endif";

    var transmission_pars_fragment = "#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec3 vWorldPosition;\n\tvec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness( const in float roughness, const in float ior ) {\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t}\n\tvec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n\t\tfloat framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\t#ifdef texture2DLodEXT\n\t\t\treturn texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#else\n\t\t\treturn texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#endif\n\t}\n\tvec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tif ( isinf( attenuationDistance ) ) {\n\t\t\treturn radiance;\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance * radiance;\n\t\t}\n\t}\n\tvec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n\t\tconst in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n\t\tconst in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,\n\t\tconst in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\trefractionCoords += 1.0;\n\t\trefractionCoords /= 2.0;\n\t\tvec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\tvec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );\n\t}\n#endif";

    var uv_pars_fragment = "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif";

    var uv_pars_vertex = "#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif";

    var uv_vertex = "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif";

    var uv2_pars_fragment = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif";

    var uv2_pars_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif";

    var uv2_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif";

    var worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif";

    const vertex$h = "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}";

    const fragment$h = "uniform sampler2D t2D;\nuniform float backgroundIntensity;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\ttexColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );\n\t#endif\n\ttexColor.rgb *= backgroundIntensity;\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";

    const vertex$g = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}";

    const fragment$g = "#ifdef ENVMAP_TYPE_CUBE\n\tuniform samplerCube envMap;\n#elif defined( ENVMAP_TYPE_CUBE_UV )\n\tuniform sampler2D envMap;\n#endif\nuniform float flipEnvMap;\nuniform float backgroundBlurriness;\nuniform float backgroundIntensity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 texColor = textureCube( envMap, vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 texColor = textureCubeUV( envMap, vWorldDirection, backgroundBlurriness );\n\t#else\n\t\tvec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t#endif\n\ttexColor.rgb *= backgroundIntensity;\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";

    const vertex$f = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}";

    const fragment$f = "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n\tvec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n\tgl_FragColor = texColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";

    const vertex$e = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}";

    const fragment$e = "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}";

    const vertex$d = "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}";

    const fragment$d = "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}";

    const vertex$c = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}";

    const fragment$c = "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";

    const vertex$b = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";

    const fragment$b = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}";

    const vertex$a = "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}";

    const fragment$a = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

    const vertex$9 = "#define LAMBERT\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

    const fragment$9 = "#define LAMBERT\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_lambert_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_lambert_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

    const vertex$8 = "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}";

    const fragment$8 = "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t#else\n\t\tvec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

    const vertex$7 = "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}";

    const fragment$7 = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n\t#ifdef OPAQUE\n\t\tgl_FragColor.a = 1.0;\n\t#endif\n}";

    const vertex$6 = "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

    const fragment$6 = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

    const vertex$5 = "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}";

    const fragment$5 = "#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularColor;\n\t#ifdef USE_SPECULARINTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n\t#ifdef USE_SPECULARCOLORMAP\n\t\tuniform sampler2D specularColorMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_IRIDESCENCE\n\tuniform float iridescence;\n\tuniform float iridescenceIOR;\n\tuniform float iridescenceThicknessMinimum;\n\tuniform float iridescenceThicknessMaximum;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenColor;\n\tuniform float sheenRoughness;\n\t#ifdef USE_SHEENCOLORMAP\n\t\tuniform sampler2D sheenColorMap;\n\t#endif\n\t#ifdef USE_SHEENROUGHNESSMAP\n\t\tuniform sampler2D sheenRoughnessMap;\n\t#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_SHEEN\n\t\tfloat sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n\t\toutgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;\n\t#endif\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

    const vertex$4 = "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

    const fragment$4 = "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

    const vertex$3 = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}";

    const fragment$3 = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}";

    const vertex$2 = "#include <common>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

    const fragment$2 = "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}";

    const vertex$1 = "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";

    const fragment$1 = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}";

    const ShaderChunk = {
    	alphamap_fragment: alphamap_fragment,
    	alphamap_pars_fragment: alphamap_pars_fragment,
    	alphatest_fragment: alphatest_fragment,
    	alphatest_pars_fragment: alphatest_pars_fragment,
    	aomap_fragment: aomap_fragment,
    	aomap_pars_fragment: aomap_pars_fragment,
    	begin_vertex: begin_vertex,
    	beginnormal_vertex: beginnormal_vertex,
    	bsdfs: bsdfs,
    	iridescence_fragment: iridescence_fragment,
    	bumpmap_pars_fragment: bumpmap_pars_fragment,
    	clipping_planes_fragment: clipping_planes_fragment,
    	clipping_planes_pars_fragment: clipping_planes_pars_fragment,
    	clipping_planes_pars_vertex: clipping_planes_pars_vertex,
    	clipping_planes_vertex: clipping_planes_vertex,
    	color_fragment: color_fragment,
    	color_pars_fragment: color_pars_fragment,
    	color_pars_vertex: color_pars_vertex,
    	color_vertex: color_vertex,
    	common: common,
    	cube_uv_reflection_fragment: cube_uv_reflection_fragment,
    	defaultnormal_vertex: defaultnormal_vertex,
    	displacementmap_pars_vertex: displacementmap_pars_vertex,
    	displacementmap_vertex: displacementmap_vertex,
    	emissivemap_fragment: emissivemap_fragment,
    	emissivemap_pars_fragment: emissivemap_pars_fragment,
    	encodings_fragment: encodings_fragment,
    	encodings_pars_fragment: encodings_pars_fragment,
    	envmap_fragment: envmap_fragment,
    	envmap_common_pars_fragment: envmap_common_pars_fragment,
    	envmap_pars_fragment: envmap_pars_fragment,
    	envmap_pars_vertex: envmap_pars_vertex,
    	envmap_physical_pars_fragment: envmap_physical_pars_fragment,
    	envmap_vertex: envmap_vertex,
    	fog_vertex: fog_vertex,
    	fog_pars_vertex: fog_pars_vertex,
    	fog_fragment: fog_fragment,
    	fog_pars_fragment: fog_pars_fragment,
    	gradientmap_pars_fragment: gradientmap_pars_fragment,
    	lightmap_fragment: lightmap_fragment,
    	lightmap_pars_fragment: lightmap_pars_fragment,
    	lights_lambert_fragment: lights_lambert_fragment,
    	lights_lambert_pars_fragment: lights_lambert_pars_fragment,
    	lights_pars_begin: lights_pars_begin,
    	lights_toon_fragment: lights_toon_fragment,
    	lights_toon_pars_fragment: lights_toon_pars_fragment,
    	lights_phong_fragment: lights_phong_fragment,
    	lights_phong_pars_fragment: lights_phong_pars_fragment,
    	lights_physical_fragment: lights_physical_fragment,
    	lights_physical_pars_fragment: lights_physical_pars_fragment,
    	lights_fragment_begin: lights_fragment_begin,
    	lights_fragment_maps: lights_fragment_maps,
    	lights_fragment_end: lights_fragment_end,
    	logdepthbuf_fragment: logdepthbuf_fragment,
    	logdepthbuf_pars_fragment: logdepthbuf_pars_fragment,
    	logdepthbuf_pars_vertex: logdepthbuf_pars_vertex,
    	logdepthbuf_vertex: logdepthbuf_vertex,
    	map_fragment: map_fragment,
    	map_pars_fragment: map_pars_fragment,
    	map_particle_fragment: map_particle_fragment,
    	map_particle_pars_fragment: map_particle_pars_fragment,
    	metalnessmap_fragment: metalnessmap_fragment,
    	metalnessmap_pars_fragment: metalnessmap_pars_fragment,
    	morphcolor_vertex: morphcolor_vertex,
    	morphnormal_vertex: morphnormal_vertex,
    	morphtarget_pars_vertex: morphtarget_pars_vertex,
    	morphtarget_vertex: morphtarget_vertex,
    	normal_fragment_begin: normal_fragment_begin,
    	normal_fragment_maps: normal_fragment_maps,
    	normal_pars_fragment: normal_pars_fragment,
    	normal_pars_vertex: normal_pars_vertex,
    	normal_vertex: normal_vertex,
    	normalmap_pars_fragment: normalmap_pars_fragment,
    	clearcoat_normal_fragment_begin: clearcoat_normal_fragment_begin,
    	clearcoat_normal_fragment_maps: clearcoat_normal_fragment_maps,
    	clearcoat_pars_fragment: clearcoat_pars_fragment,
    	iridescence_pars_fragment: iridescence_pars_fragment,
    	output_fragment: output_fragment,
    	packing: packing,
    	premultiplied_alpha_fragment: premultiplied_alpha_fragment,
    	project_vertex: project_vertex,
    	dithering_fragment: dithering_fragment,
    	dithering_pars_fragment: dithering_pars_fragment,
    	roughnessmap_fragment: roughnessmap_fragment,
    	roughnessmap_pars_fragment: roughnessmap_pars_fragment,
    	shadowmap_pars_fragment: shadowmap_pars_fragment,
    	shadowmap_pars_vertex: shadowmap_pars_vertex,
    	shadowmap_vertex: shadowmap_vertex,
    	shadowmask_pars_fragment: shadowmask_pars_fragment,
    	skinbase_vertex: skinbase_vertex,
    	skinning_pars_vertex: skinning_pars_vertex,
    	skinning_vertex: skinning_vertex,
    	skinnormal_vertex: skinnormal_vertex,
    	specularmap_fragment: specularmap_fragment,
    	specularmap_pars_fragment: specularmap_pars_fragment,
    	tonemapping_fragment: tonemapping_fragment,
    	tonemapping_pars_fragment: tonemapping_pars_fragment,
    	transmission_fragment: transmission_fragment,
    	transmission_pars_fragment: transmission_pars_fragment,
    	uv_pars_fragment: uv_pars_fragment,
    	uv_pars_vertex: uv_pars_vertex,
    	uv_vertex: uv_vertex,
    	uv2_pars_fragment: uv2_pars_fragment,
    	uv2_pars_vertex: uv2_pars_vertex,
    	uv2_vertex: uv2_vertex,
    	worldpos_vertex: worldpos_vertex,

    	background_vert: vertex$h,
    	background_frag: fragment$h,
    	backgroundCube_vert: vertex$g,
    	backgroundCube_frag: fragment$g,
    	cube_vert: vertex$f,
    	cube_frag: fragment$f,
    	depth_vert: vertex$e,
    	depth_frag: fragment$e,
    	distanceRGBA_vert: vertex$d,
    	distanceRGBA_frag: fragment$d,
    	equirect_vert: vertex$c,
    	equirect_frag: fragment$c,
    	linedashed_vert: vertex$b,
    	linedashed_frag: fragment$b,
    	meshbasic_vert: vertex$a,
    	meshbasic_frag: fragment$a,
    	meshlambert_vert: vertex$9,
    	meshlambert_frag: fragment$9,
    	meshmatcap_vert: vertex$8,
    	meshmatcap_frag: fragment$8,
    	meshnormal_vert: vertex$7,
    	meshnormal_frag: fragment$7,
    	meshphong_vert: vertex$6,
    	meshphong_frag: fragment$6,
    	meshphysical_vert: vertex$5,
    	meshphysical_frag: fragment$5,
    	meshtoon_vert: vertex$4,
    	meshtoon_frag: fragment$4,
    	points_vert: vertex$3,
    	points_frag: fragment$3,
    	shadow_vert: vertex$2,
    	shadow_frag: fragment$2,
    	sprite_vert: vertex$1,
    	sprite_frag: fragment$1
    };

    /**
     * Uniforms library for shared webgl shaders
     */

    const UniformsLib = {

    	common: {

    		diffuse: { value: /*@__PURE__*/ new Color$1( 0xffffff ) },
    		opacity: { value: 1.0 },

    		map: { value: null },
    		uvTransform: { value: /*@__PURE__*/ new Matrix3() },
    		uv2Transform: { value: /*@__PURE__*/ new Matrix3() },

    		alphaMap: { value: null },
    		alphaTest: { value: 0 }

    	},

    	specularmap: {

    		specularMap: { value: null },

    	},

    	envmap: {

    		envMap: { value: null },
    		flipEnvMap: { value: - 1 },
    		reflectivity: { value: 1.0 }, // basic, lambert, phong
    		ior: { value: 1.5 }, // physical
    		refractionRatio: { value: 0.98 }, // basic, lambert, phong

    	},

    	aomap: {

    		aoMap: { value: null },
    		aoMapIntensity: { value: 1 }

    	},

    	lightmap: {

    		lightMap: { value: null },
    		lightMapIntensity: { value: 1 }

    	},

    	emissivemap: {

    		emissiveMap: { value: null }

    	},

    	bumpmap: {

    		bumpMap: { value: null },
    		bumpScale: { value: 1 }

    	},

    	normalmap: {

    		normalMap: { value: null },
    		normalScale: { value: /*@__PURE__*/ new Vector2( 1, 1 ) }

    	},

    	displacementmap: {

    		displacementMap: { value: null },
    		displacementScale: { value: 1 },
    		displacementBias: { value: 0 }

    	},

    	roughnessmap: {

    		roughnessMap: { value: null }

    	},

    	metalnessmap: {

    		metalnessMap: { value: null }

    	},

    	gradientmap: {

    		gradientMap: { value: null }

    	},

    	fog: {

    		fogDensity: { value: 0.00025 },
    		fogNear: { value: 1 },
    		fogFar: { value: 2000 },
    		fogColor: { value: /*@__PURE__*/ new Color$1( 0xffffff ) }

    	},

    	lights: {

    		ambientLightColor: { value: [] },

    		lightProbe: { value: [] },

    		directionalLights: { value: [], properties: {
    			direction: {},
    			color: {}
    		} },

    		directionalLightShadows: { value: [], properties: {
    			shadowBias: {},
    			shadowNormalBias: {},
    			shadowRadius: {},
    			shadowMapSize: {}
    		} },

    		directionalShadowMap: { value: [] },
    		directionalShadowMatrix: { value: [] },

    		spotLights: { value: [], properties: {
    			color: {},
    			position: {},
    			direction: {},
    			distance: {},
    			coneCos: {},
    			penumbraCos: {},
    			decay: {}
    		} },

    		spotLightShadows: { value: [], properties: {
    			shadowBias: {},
    			shadowNormalBias: {},
    			shadowRadius: {},
    			shadowMapSize: {}
    		} },

    		spotLightMap: { value: [] },
    		spotShadowMap: { value: [] },
    		spotLightMatrix: { value: [] },

    		pointLights: { value: [], properties: {
    			color: {},
    			position: {},
    			decay: {},
    			distance: {}
    		} },

    		pointLightShadows: { value: [], properties: {
    			shadowBias: {},
    			shadowNormalBias: {},
    			shadowRadius: {},
    			shadowMapSize: {},
    			shadowCameraNear: {},
    			shadowCameraFar: {}
    		} },

    		pointShadowMap: { value: [] },
    		pointShadowMatrix: { value: [] },

    		hemisphereLights: { value: [], properties: {
    			direction: {},
    			skyColor: {},
    			groundColor: {}
    		} },

    		// TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
    		rectAreaLights: { value: [], properties: {
    			color: {},
    			position: {},
    			width: {},
    			height: {}
    		} },

    		ltc_1: { value: null },
    		ltc_2: { value: null }

    	},

    	points: {

    		diffuse: { value: /*@__PURE__*/ new Color$1( 0xffffff ) },
    		opacity: { value: 1.0 },
    		size: { value: 1.0 },
    		scale: { value: 1.0 },
    		map: { value: null },
    		alphaMap: { value: null },
    		alphaTest: { value: 0 },
    		uvTransform: { value: /*@__PURE__*/ new Matrix3() }

    	},

    	sprite: {

    		diffuse: { value: /*@__PURE__*/ new Color$1( 0xffffff ) },
    		opacity: { value: 1.0 },
    		center: { value: /*@__PURE__*/ new Vector2( 0.5, 0.5 ) },
    		rotation: { value: 0.0 },
    		map: { value: null },
    		alphaMap: { value: null },
    		alphaTest: { value: 0 },
    		uvTransform: { value: /*@__PURE__*/ new Matrix3() }

    	}

    };

    const ShaderLib = {

    	basic: {

    		uniforms: /*@__PURE__*/ mergeUniforms( [
    			UniformsLib.common,
    			UniformsLib.specularmap,
    			UniformsLib.envmap,
    			UniformsLib.aomap,
    			UniformsLib.lightmap,
    			UniformsLib.fog
    		] ),

    		vertexShader: ShaderChunk.meshbasic_vert,
    		fragmentShader: ShaderChunk.meshbasic_frag

    	},

    	lambert: {

    		uniforms: /*@__PURE__*/ mergeUniforms( [
    			UniformsLib.common,
    			UniformsLib.specularmap,
    			UniformsLib.envmap,
    			UniformsLib.aomap,
    			UniformsLib.lightmap,
    			UniformsLib.emissivemap,
    			UniformsLib.bumpmap,
    			UniformsLib.normalmap,
    			UniformsLib.displacementmap,
    			UniformsLib.fog,
    			UniformsLib.lights,
    			{
    				emissive: { value: /*@__PURE__*/ new Color$1( 0x000000 ) }
    			}
    		] ),

    		vertexShader: ShaderChunk.meshlambert_vert,
    		fragmentShader: ShaderChunk.meshlambert_frag

    	},

    	phong: {

    		uniforms: /*@__PURE__*/ mergeUniforms( [
    			UniformsLib.common,
    			UniformsLib.specularmap,
    			UniformsLib.envmap,
    			UniformsLib.aomap,
    			UniformsLib.lightmap,
    			UniformsLib.emissivemap,
    			UniformsLib.bumpmap,
    			UniformsLib.normalmap,
    			UniformsLib.displacementmap,
    			UniformsLib.fog,
    			UniformsLib.lights,
    			{
    				emissive: { value: /*@__PURE__*/ new Color$1( 0x000000 ) },
    				specular: { value: /*@__PURE__*/ new Color$1( 0x111111 ) },
    				shininess: { value: 30 }
    			}
    		] ),

    		vertexShader: ShaderChunk.meshphong_vert,
    		fragmentShader: ShaderChunk.meshphong_frag

    	},

    	standard: {

    		uniforms: /*@__PURE__*/ mergeUniforms( [
    			UniformsLib.common,
    			UniformsLib.envmap,
    			UniformsLib.aomap,
    			UniformsLib.lightmap,
    			UniformsLib.emissivemap,
    			UniformsLib.bumpmap,
    			UniformsLib.normalmap,
    			UniformsLib.displacementmap,
    			UniformsLib.roughnessmap,
    			UniformsLib.metalnessmap,
    			UniformsLib.fog,
    			UniformsLib.lights,
    			{
    				emissive: { value: /*@__PURE__*/ new Color$1( 0x000000 ) },
    				roughness: { value: 1.0 },
    				metalness: { value: 0.0 },
    				envMapIntensity: { value: 1 } // temporary
    			}
    		] ),

    		vertexShader: ShaderChunk.meshphysical_vert,
    		fragmentShader: ShaderChunk.meshphysical_frag

    	},

    	toon: {

    		uniforms: /*@__PURE__*/ mergeUniforms( [
    			UniformsLib.common,
    			UniformsLib.aomap,
    			UniformsLib.lightmap,
    			UniformsLib.emissivemap,
    			UniformsLib.bumpmap,
    			UniformsLib.normalmap,
    			UniformsLib.displacementmap,
    			UniformsLib.gradientmap,
    			UniformsLib.fog,
    			UniformsLib.lights,
    			{
    				emissive: { value: /*@__PURE__*/ new Color$1( 0x000000 ) }
    			}
    		] ),

    		vertexShader: ShaderChunk.meshtoon_vert,
    		fragmentShader: ShaderChunk.meshtoon_frag

    	},

    	matcap: {

    		uniforms: /*@__PURE__*/ mergeUniforms( [
    			UniformsLib.common,
    			UniformsLib.bumpmap,
    			UniformsLib.normalmap,
    			UniformsLib.displacementmap,
    			UniformsLib.fog,
    			{
    				matcap: { value: null }
    			}
    		] ),

    		vertexShader: ShaderChunk.meshmatcap_vert,
    		fragmentShader: ShaderChunk.meshmatcap_frag

    	},

    	points: {

    		uniforms: /*@__PURE__*/ mergeUniforms( [
    			UniformsLib.points,
    			UniformsLib.fog
    		] ),

    		vertexShader: ShaderChunk.points_vert,
    		fragmentShader: ShaderChunk.points_frag

    	},

    	dashed: {

    		uniforms: /*@__PURE__*/ mergeUniforms( [
    			UniformsLib.common,
    			UniformsLib.fog,
    			{
    				scale: { value: 1 },
    				dashSize: { value: 1 },
    				totalSize: { value: 2 }
    			}
    		] ),

    		vertexShader: ShaderChunk.linedashed_vert,
    		fragmentShader: ShaderChunk.linedashed_frag

    	},

    	depth: {

    		uniforms: /*@__PURE__*/ mergeUniforms( [
    			UniformsLib.common,
    			UniformsLib.displacementmap
    		] ),

    		vertexShader: ShaderChunk.depth_vert,
    		fragmentShader: ShaderChunk.depth_frag

    	},

    	normal: {

    		uniforms: /*@__PURE__*/ mergeUniforms( [
    			UniformsLib.common,
    			UniformsLib.bumpmap,
    			UniformsLib.normalmap,
    			UniformsLib.displacementmap,
    			{
    				opacity: { value: 1.0 }
    			}
    		] ),

    		vertexShader: ShaderChunk.meshnormal_vert,
    		fragmentShader: ShaderChunk.meshnormal_frag

    	},

    	sprite: {

    		uniforms: /*@__PURE__*/ mergeUniforms( [
    			UniformsLib.sprite,
    			UniformsLib.fog
    		] ),

    		vertexShader: ShaderChunk.sprite_vert,
    		fragmentShader: ShaderChunk.sprite_frag

    	},

    	background: {

    		uniforms: {
    			uvTransform: { value: /*@__PURE__*/ new Matrix3() },
    			t2D: { value: null },
    			backgroundIntensity: { value: 1 }
    		},

    		vertexShader: ShaderChunk.background_vert,
    		fragmentShader: ShaderChunk.background_frag

    	},

    	backgroundCube: {

    		uniforms: {
    			envMap: { value: null },
    			flipEnvMap: { value: - 1 },
    			backgroundBlurriness: { value: 0 },
    			backgroundIntensity: { value: 1 }
    		},

    		vertexShader: ShaderChunk.backgroundCube_vert,
    		fragmentShader: ShaderChunk.backgroundCube_frag

    	},

    	cube: {

    		uniforms: {
    			tCube: { value: null },
    			tFlip: { value: - 1 },
    			opacity: { value: 1.0 }
    		},

    		vertexShader: ShaderChunk.cube_vert,
    		fragmentShader: ShaderChunk.cube_frag

    	},

    	equirect: {

    		uniforms: {
    			tEquirect: { value: null },
    		},

    		vertexShader: ShaderChunk.equirect_vert,
    		fragmentShader: ShaderChunk.equirect_frag

    	},

    	distanceRGBA: {

    		uniforms: /*@__PURE__*/ mergeUniforms( [
    			UniformsLib.common,
    			UniformsLib.displacementmap,
    			{
    				referencePosition: { value: /*@__PURE__*/ new Vector3() },
    				nearDistance: { value: 1 },
    				farDistance: { value: 1000 }
    			}
    		] ),

    		vertexShader: ShaderChunk.distanceRGBA_vert,
    		fragmentShader: ShaderChunk.distanceRGBA_frag

    	},

    	shadow: {

    		uniforms: /*@__PURE__*/ mergeUniforms( [
    			UniformsLib.lights,
    			UniformsLib.fog,
    			{
    				color: { value: /*@__PURE__*/ new Color$1( 0x00000 ) },
    				opacity: { value: 1.0 }
    			},
    		] ),

    		vertexShader: ShaderChunk.shadow_vert,
    		fragmentShader: ShaderChunk.shadow_frag

    	}

    };

    ShaderLib.physical = {

    	uniforms: /*@__PURE__*/ mergeUniforms( [
    		ShaderLib.standard.uniforms,
    		{
    			clearcoat: { value: 0 },
    			clearcoatMap: { value: null },
    			clearcoatRoughness: { value: 0 },
    			clearcoatRoughnessMap: { value: null },
    			clearcoatNormalScale: { value: /*@__PURE__*/ new Vector2( 1, 1 ) },
    			clearcoatNormalMap: { value: null },
    			iridescence: { value: 0 },
    			iridescenceMap: { value: null },
    			iridescenceIOR: { value: 1.3 },
    			iridescenceThicknessMinimum: { value: 100 },
    			iridescenceThicknessMaximum: { value: 400 },
    			iridescenceThicknessMap: { value: null },
    			sheen: { value: 0 },
    			sheenColor: { value: /*@__PURE__*/ new Color$1( 0x000000 ) },
    			sheenColorMap: { value: null },
    			sheenRoughness: { value: 1 },
    			sheenRoughnessMap: { value: null },
    			transmission: { value: 0 },
    			transmissionMap: { value: null },
    			transmissionSamplerSize: { value: /*@__PURE__*/ new Vector2() },
    			transmissionSamplerMap: { value: null },
    			thickness: { value: 0 },
    			thicknessMap: { value: null },
    			attenuationDistance: { value: 0 },
    			attenuationColor: { value: /*@__PURE__*/ new Color$1( 0x000000 ) },
    			specularIntensity: { value: 1 },
    			specularIntensityMap: { value: null },
    			specularColor: { value: /*@__PURE__*/ new Color$1( 1, 1, 1 ) },
    			specularColorMap: { value: null },
    		}
    	] ),

    	vertexShader: ShaderChunk.meshphysical_vert,
    	fragmentShader: ShaderChunk.meshphysical_frag

    };

    const _rgb = { r: 0, b: 0, g: 0 };

    function WebGLBackground( renderer, cubemaps, cubeuvmaps, state, objects, alpha, premultipliedAlpha ) {

    	const clearColor = new Color$1( 0x000000 );
    	let clearAlpha = alpha === true ? 0 : 1;

    	let planeMesh;
    	let boxMesh;

    	let currentBackground = null;
    	let currentBackgroundVersion = 0;
    	let currentTonemapping = null;

    	function render( renderList, scene ) {

    		let forceClear = false;
    		let background = scene.isScene === true ? scene.background : null;

    		if ( background && background.isTexture ) {

    			const usePMREM = scene.backgroundBlurriness > 0; // use PMREM if the user wants to blur the background
    			background = ( usePMREM ? cubeuvmaps : cubemaps ).get( background );

    		}

    		// Ignore background in AR
    		// TODO: Reconsider this.

    		const xr = renderer.xr;
    		const session = xr.getSession && xr.getSession();

    		if ( session && session.environmentBlendMode === 'additive' ) {

    			background = null;

    		}

    		if ( background === null ) {

    			setClear( clearColor, clearAlpha );

    		} else if ( background && background.isColor ) {

    			setClear( background, 1 );
    			forceClear = true;

    		}

    		if ( renderer.autoClear || forceClear ) {

    			renderer.clear( renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil );

    		}

    		if ( background && ( background.isCubeTexture || background.mapping === CubeUVReflectionMapping ) ) {

    			if ( boxMesh === undefined ) {

    				boxMesh = new Mesh(
    					new BoxGeometry( 1, 1, 1 ),
    					new ShaderMaterial( {
    						name: 'BackgroundCubeMaterial',
    						uniforms: cloneUniforms( ShaderLib.backgroundCube.uniforms ),
    						vertexShader: ShaderLib.backgroundCube.vertexShader,
    						fragmentShader: ShaderLib.backgroundCube.fragmentShader,
    						side: BackSide,
    						depthTest: false,
    						depthWrite: false,
    						fog: false
    					} )
    				);

    				boxMesh.geometry.deleteAttribute( 'normal' );
    				boxMesh.geometry.deleteAttribute( 'uv' );

    				boxMesh.onBeforeRender = function ( renderer, scene, camera ) {

    					this.matrixWorld.copyPosition( camera.matrixWorld );

    				};

    				// add "envMap" material property so the renderer can evaluate it like for built-in materials
    				Object.defineProperty( boxMesh.material, 'envMap', {

    					get: function () {

    						return this.uniforms.envMap.value;

    					}

    				} );

    				objects.update( boxMesh );

    			}

    			boxMesh.material.uniforms.envMap.value = background;
    			boxMesh.material.uniforms.flipEnvMap.value = ( background.isCubeTexture && background.isRenderTargetTexture === false ) ? - 1 : 1;
    			boxMesh.material.uniforms.backgroundBlurriness.value = scene.backgroundBlurriness;
    			boxMesh.material.uniforms.backgroundIntensity.value = scene.backgroundIntensity;

    			if ( currentBackground !== background ||
    				currentBackgroundVersion !== background.version ||
    				currentTonemapping !== renderer.toneMapping ) {

    				boxMesh.material.needsUpdate = true;

    				currentBackground = background;
    				currentBackgroundVersion = background.version;
    				currentTonemapping = renderer.toneMapping;

    			}

    			boxMesh.layers.enableAll();

    			// push to the pre-sorted opaque render list
    			renderList.unshift( boxMesh, boxMesh.geometry, boxMesh.material, 0, 0, null );

    		} else if ( background && background.isTexture ) {

    			if ( planeMesh === undefined ) {

    				planeMesh = new Mesh(
    					new PlaneGeometry( 2, 2 ),
    					new ShaderMaterial( {
    						name: 'BackgroundMaterial',
    						uniforms: cloneUniforms( ShaderLib.background.uniforms ),
    						vertexShader: ShaderLib.background.vertexShader,
    						fragmentShader: ShaderLib.background.fragmentShader,
    						side: FrontSide,
    						depthTest: false,
    						depthWrite: false,
    						fog: false
    					} )
    				);

    				planeMesh.geometry.deleteAttribute( 'normal' );

    				// add "map" material property so the renderer can evaluate it like for built-in materials
    				Object.defineProperty( planeMesh.material, 'map', {

    					get: function () {

    						return this.uniforms.t2D.value;

    					}

    				} );

    				objects.update( planeMesh );

    			}

    			planeMesh.material.uniforms.t2D.value = background;
    			planeMesh.material.uniforms.backgroundIntensity.value = scene.backgroundIntensity;

    			if ( background.matrixAutoUpdate === true ) {

    				background.updateMatrix();

    			}

    			planeMesh.material.uniforms.uvTransform.value.copy( background.matrix );

    			if ( currentBackground !== background ||
    				currentBackgroundVersion !== background.version ||
    				currentTonemapping !== renderer.toneMapping ) {

    				planeMesh.material.needsUpdate = true;

    				currentBackground = background;
    				currentBackgroundVersion = background.version;
    				currentTonemapping = renderer.toneMapping;

    			}

    			planeMesh.layers.enableAll();

    			// push to the pre-sorted opaque render list
    			renderList.unshift( planeMesh, planeMesh.geometry, planeMesh.material, 0, 0, null );

    		}

    	}

    	function setClear( color, alpha ) {

    		color.getRGB( _rgb, getUnlitUniformColorSpace( renderer ) );

    		state.buffers.color.setClear( _rgb.r, _rgb.g, _rgb.b, alpha, premultipliedAlpha );

    	}

    	return {

    		getClearColor: function () {

    			return clearColor;

    		},
    		setClearColor: function ( color, alpha = 1 ) {

    			clearColor.set( color );
    			clearAlpha = alpha;
    			setClear( clearColor, clearAlpha );

    		},
    		getClearAlpha: function () {

    			return clearAlpha;

    		},
    		setClearAlpha: function ( alpha ) {

    			clearAlpha = alpha;
    			setClear( clearColor, clearAlpha );

    		},
    		render: render

    	};

    }

    function WebGLBindingStates( gl, extensions, attributes, capabilities ) {

    	const maxVertexAttributes = gl.getParameter( 34921 );

    	const extension = capabilities.isWebGL2 ? null : extensions.get( 'OES_vertex_array_object' );
    	const vaoAvailable = capabilities.isWebGL2 || extension !== null;

    	const bindingStates = {};

    	const defaultState = createBindingState( null );
    	let currentState = defaultState;
    	let forceUpdate = false;

    	function setup( object, material, program, geometry, index ) {

    		let updateBuffers = false;

    		if ( vaoAvailable ) {

    			const state = getBindingState( geometry, program, material );

    			if ( currentState !== state ) {

    				currentState = state;
    				bindVertexArrayObject( currentState.object );

    			}

    			updateBuffers = needsUpdate( object, geometry, program, index );

    			if ( updateBuffers ) saveCache( object, geometry, program, index );

    		} else {

    			const wireframe = ( material.wireframe === true );

    			if ( currentState.geometry !== geometry.id ||
    				currentState.program !== program.id ||
    				currentState.wireframe !== wireframe ) {

    				currentState.geometry = geometry.id;
    				currentState.program = program.id;
    				currentState.wireframe = wireframe;

    				updateBuffers = true;

    			}

    		}

    		if ( index !== null ) {

    			attributes.update( index, 34963 );

    		}

    		if ( updateBuffers || forceUpdate ) {

    			forceUpdate = false;

    			setupVertexAttributes( object, material, program, geometry );

    			if ( index !== null ) {

    				gl.bindBuffer( 34963, attributes.get( index ).buffer );

    			}

    		}

    	}

    	function createVertexArrayObject() {

    		if ( capabilities.isWebGL2 ) return gl.createVertexArray();

    		return extension.createVertexArrayOES();

    	}

    	function bindVertexArrayObject( vao ) {

    		if ( capabilities.isWebGL2 ) return gl.bindVertexArray( vao );

    		return extension.bindVertexArrayOES( vao );

    	}

    	function deleteVertexArrayObject( vao ) {

    		if ( capabilities.isWebGL2 ) return gl.deleteVertexArray( vao );

    		return extension.deleteVertexArrayOES( vao );

    	}

    	function getBindingState( geometry, program, material ) {

    		const wireframe = ( material.wireframe === true );

    		let programMap = bindingStates[ geometry.id ];

    		if ( programMap === undefined ) {

    			programMap = {};
    			bindingStates[ geometry.id ] = programMap;

    		}

    		let stateMap = programMap[ program.id ];

    		if ( stateMap === undefined ) {

    			stateMap = {};
    			programMap[ program.id ] = stateMap;

    		}

    		let state = stateMap[ wireframe ];

    		if ( state === undefined ) {

    			state = createBindingState( createVertexArrayObject() );
    			stateMap[ wireframe ] = state;

    		}

    		return state;

    	}

    	function createBindingState( vao ) {

    		const newAttributes = [];
    		const enabledAttributes = [];
    		const attributeDivisors = [];

    		for ( let i = 0; i < maxVertexAttributes; i ++ ) {

    			newAttributes[ i ] = 0;
    			enabledAttributes[ i ] = 0;
    			attributeDivisors[ i ] = 0;

    		}

    		return {

    			// for backward compatibility on non-VAO support browser
    			geometry: null,
    			program: null,
    			wireframe: false,

    			newAttributes: newAttributes,
    			enabledAttributes: enabledAttributes,
    			attributeDivisors: attributeDivisors,
    			object: vao,
    			attributes: {},
    			index: null

    		};

    	}

    	function needsUpdate( object, geometry, program, index ) {

    		const cachedAttributes = currentState.attributes;
    		const geometryAttributes = geometry.attributes;

    		let attributesNum = 0;

    		const programAttributes = program.getAttributes();

    		for ( const name in programAttributes ) {

    			const programAttribute = programAttributes[ name ];

    			if ( programAttribute.location >= 0 ) {

    				const cachedAttribute = cachedAttributes[ name ];
    				let geometryAttribute = geometryAttributes[ name ];

    				if ( geometryAttribute === undefined ) {

    					if ( name === 'instanceMatrix' && object.instanceMatrix ) geometryAttribute = object.instanceMatrix;
    					if ( name === 'instanceColor' && object.instanceColor ) geometryAttribute = object.instanceColor;

    				}

    				if ( cachedAttribute === undefined ) return true;

    				if ( cachedAttribute.attribute !== geometryAttribute ) return true;

    				if ( geometryAttribute && cachedAttribute.data !== geometryAttribute.data ) return true;

    				attributesNum ++;

    			}

    		}

    		if ( currentState.attributesNum !== attributesNum ) return true;

    		if ( currentState.index !== index ) return true;

    		return false;

    	}

    	function saveCache( object, geometry, program, index ) {

    		const cache = {};
    		const attributes = geometry.attributes;
    		let attributesNum = 0;

    		const programAttributes = program.getAttributes();

    		for ( const name in programAttributes ) {

    			const programAttribute = programAttributes[ name ];

    			if ( programAttribute.location >= 0 ) {

    				let attribute = attributes[ name ];

    				if ( attribute === undefined ) {

    					if ( name === 'instanceMatrix' && object.instanceMatrix ) attribute = object.instanceMatrix;
    					if ( name === 'instanceColor' && object.instanceColor ) attribute = object.instanceColor;

    				}

    				const data = {};
    				data.attribute = attribute;

    				if ( attribute && attribute.data ) {

    					data.data = attribute.data;

    				}

    				cache[ name ] = data;

    				attributesNum ++;

    			}

    		}

    		currentState.attributes = cache;
    		currentState.attributesNum = attributesNum;

    		currentState.index = index;

    	}

    	function initAttributes() {

    		const newAttributes = currentState.newAttributes;

    		for ( let i = 0, il = newAttributes.length; i < il; i ++ ) {

    			newAttributes[ i ] = 0;

    		}

    	}

    	function enableAttribute( attribute ) {

    		enableAttributeAndDivisor( attribute, 0 );

    	}

    	function enableAttributeAndDivisor( attribute, meshPerAttribute ) {

    		const newAttributes = currentState.newAttributes;
    		const enabledAttributes = currentState.enabledAttributes;
    		const attributeDivisors = currentState.attributeDivisors;

    		newAttributes[ attribute ] = 1;

    		if ( enabledAttributes[ attribute ] === 0 ) {

    			gl.enableVertexAttribArray( attribute );
    			enabledAttributes[ attribute ] = 1;

    		}

    		if ( attributeDivisors[ attribute ] !== meshPerAttribute ) {

    			const extension = capabilities.isWebGL2 ? gl : extensions.get( 'ANGLE_instanced_arrays' );

    			extension[ capabilities.isWebGL2 ? 'vertexAttribDivisor' : 'vertexAttribDivisorANGLE' ]( attribute, meshPerAttribute );
    			attributeDivisors[ attribute ] = meshPerAttribute;

    		}

    	}

    	function disableUnusedAttributes() {

    		const newAttributes = currentState.newAttributes;
    		const enabledAttributes = currentState.enabledAttributes;

    		for ( let i = 0, il = enabledAttributes.length; i < il; i ++ ) {

    			if ( enabledAttributes[ i ] !== newAttributes[ i ] ) {

    				gl.disableVertexAttribArray( i );
    				enabledAttributes[ i ] = 0;

    			}

    		}

    	}

    	function vertexAttribPointer( index, size, type, normalized, stride, offset ) {

    		if ( capabilities.isWebGL2 === true && ( type === 5124 || type === 5125 ) ) {

    			gl.vertexAttribIPointer( index, size, type, stride, offset );

    		} else {

    			gl.vertexAttribPointer( index, size, type, normalized, stride, offset );

    		}

    	}

    	function setupVertexAttributes( object, material, program, geometry ) {

    		if ( capabilities.isWebGL2 === false && ( object.isInstancedMesh || geometry.isInstancedBufferGeometry ) ) {

    			if ( extensions.get( 'ANGLE_instanced_arrays' ) === null ) return;

    		}

    		initAttributes();

    		const geometryAttributes = geometry.attributes;

    		const programAttributes = program.getAttributes();

    		const materialDefaultAttributeValues = material.defaultAttributeValues;

    		for ( const name in programAttributes ) {

    			const programAttribute = programAttributes[ name ];

    			if ( programAttribute.location >= 0 ) {

    				let geometryAttribute = geometryAttributes[ name ];

    				if ( geometryAttribute === undefined ) {

    					if ( name === 'instanceMatrix' && object.instanceMatrix ) geometryAttribute = object.instanceMatrix;
    					if ( name === 'instanceColor' && object.instanceColor ) geometryAttribute = object.instanceColor;

    				}

    				if ( geometryAttribute !== undefined ) {

    					const normalized = geometryAttribute.normalized;
    					const size = geometryAttribute.itemSize;

    					const attribute = attributes.get( geometryAttribute );

    					// TODO Attribute may not be available on context restore

    					if ( attribute === undefined ) continue;

    					const buffer = attribute.buffer;
    					const type = attribute.type;
    					const bytesPerElement = attribute.bytesPerElement;

    					if ( geometryAttribute.isInterleavedBufferAttribute ) {

    						const data = geometryAttribute.data;
    						const stride = data.stride;
    						const offset = geometryAttribute.offset;

    						if ( data.isInstancedInterleavedBuffer ) {

    							for ( let i = 0; i < programAttribute.locationSize; i ++ ) {

    								enableAttributeAndDivisor( programAttribute.location + i, data.meshPerAttribute );

    							}

    							if ( object.isInstancedMesh !== true && geometry._maxInstanceCount === undefined ) {

    								geometry._maxInstanceCount = data.meshPerAttribute * data.count;

    							}

    						} else {

    							for ( let i = 0; i < programAttribute.locationSize; i ++ ) {

    								enableAttribute( programAttribute.location + i );

    							}

    						}

    						gl.bindBuffer( 34962, buffer );

    						for ( let i = 0; i < programAttribute.locationSize; i ++ ) {

    							vertexAttribPointer(
    								programAttribute.location + i,
    								size / programAttribute.locationSize,
    								type,
    								normalized,
    								stride * bytesPerElement,
    								( offset + ( size / programAttribute.locationSize ) * i ) * bytesPerElement
    							);

    						}

    					} else {

    						if ( geometryAttribute.isInstancedBufferAttribute ) {

    							for ( let i = 0; i < programAttribute.locationSize; i ++ ) {

    								enableAttributeAndDivisor( programAttribute.location + i, geometryAttribute.meshPerAttribute );

    							}

    							if ( object.isInstancedMesh !== true && geometry._maxInstanceCount === undefined ) {

    								geometry._maxInstanceCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;

    							}

    						} else {

    							for ( let i = 0; i < programAttribute.locationSize; i ++ ) {

    								enableAttribute( programAttribute.location + i );

    							}

    						}

    						gl.bindBuffer( 34962, buffer );

    						for ( let i = 0; i < programAttribute.locationSize; i ++ ) {

    							vertexAttribPointer(
    								programAttribute.location + i,
    								size / programAttribute.locationSize,
    								type,
    								normalized,
    								size * bytesPerElement,
    								( size / programAttribute.locationSize ) * i * bytesPerElement
    							);

    						}

    					}

    				} else if ( materialDefaultAttributeValues !== undefined ) {

    					const value = materialDefaultAttributeValues[ name ];

    					if ( value !== undefined ) {

    						switch ( value.length ) {

    							case 2:
    								gl.vertexAttrib2fv( programAttribute.location, value );
    								break;

    							case 3:
    								gl.vertexAttrib3fv( programAttribute.location, value );
    								break;

    							case 4:
    								gl.vertexAttrib4fv( programAttribute.location, value );
    								break;

    							default:
    								gl.vertexAttrib1fv( programAttribute.location, value );

    						}

    					}

    				}

    			}

    		}

    		disableUnusedAttributes();

    	}

    	function dispose() {

    		reset();

    		for ( const geometryId in bindingStates ) {

    			const programMap = bindingStates[ geometryId ];

    			for ( const programId in programMap ) {

    				const stateMap = programMap[ programId ];

    				for ( const wireframe in stateMap ) {

    					deleteVertexArrayObject( stateMap[ wireframe ].object );

    					delete stateMap[ wireframe ];

    				}

    				delete programMap[ programId ];

    			}

    			delete bindingStates[ geometryId ];

    		}

    	}

    	function releaseStatesOfGeometry( geometry ) {

    		if ( bindingStates[ geometry.id ] === undefined ) return;

    		const programMap = bindingStates[ geometry.id ];

    		for ( const programId in programMap ) {

    			const stateMap = programMap[ programId ];

    			for ( const wireframe in stateMap ) {

    				deleteVertexArrayObject( stateMap[ wireframe ].object );

    				delete stateMap[ wireframe ];

    			}

    			delete programMap[ programId ];

    		}

    		delete bindingStates[ geometry.id ];

    	}

    	function releaseStatesOfProgram( program ) {

    		for ( const geometryId in bindingStates ) {

    			const programMap = bindingStates[ geometryId ];

    			if ( programMap[ program.id ] === undefined ) continue;

    			const stateMap = programMap[ program.id ];

    			for ( const wireframe in stateMap ) {

    				deleteVertexArrayObject( stateMap[ wireframe ].object );

    				delete stateMap[ wireframe ];

    			}

    			delete programMap[ program.id ];

    		}

    	}

    	function reset() {

    		resetDefaultState();
    		forceUpdate = true;

    		if ( currentState === defaultState ) return;

    		currentState = defaultState;
    		bindVertexArrayObject( currentState.object );

    	}

    	// for backward-compatibility

    	function resetDefaultState() {

    		defaultState.geometry = null;
    		defaultState.program = null;
    		defaultState.wireframe = false;

    	}

    	return {

    		setup: setup,
    		reset: reset,
    		resetDefaultState: resetDefaultState,
    		dispose: dispose,
    		releaseStatesOfGeometry: releaseStatesOfGeometry,
    		releaseStatesOfProgram: releaseStatesOfProgram,

    		initAttributes: initAttributes,
    		enableAttribute: enableAttribute,
    		disableUnusedAttributes: disableUnusedAttributes

    	};

    }

    function WebGLBufferRenderer( gl, extensions, info, capabilities ) {

    	const isWebGL2 = capabilities.isWebGL2;

    	let mode;

    	function setMode( value ) {

    		mode = value;

    	}

    	function render( start, count ) {

    		gl.drawArrays( mode, start, count );

    		info.update( count, mode, 1 );

    	}

    	function renderInstances( start, count, primcount ) {

    		if ( primcount === 0 ) return;

    		let extension, methodName;

    		if ( isWebGL2 ) {

    			extension = gl;
    			methodName = 'drawArraysInstanced';

    		} else {

    			extension = extensions.get( 'ANGLE_instanced_arrays' );
    			methodName = 'drawArraysInstancedANGLE';

    			if ( extension === null ) {

    				console.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
    				return;

    			}

    		}

    		extension[ methodName ]( mode, start, count, primcount );

    		info.update( count, mode, primcount );

    	}

    	//

    	this.setMode = setMode;
    	this.render = render;
    	this.renderInstances = renderInstances;

    }

    function WebGLCapabilities( gl, extensions, parameters ) {

    	let maxAnisotropy;

    	function getMaxAnisotropy() {

    		if ( maxAnisotropy !== undefined ) return maxAnisotropy;

    		if ( extensions.has( 'EXT_texture_filter_anisotropic' ) === true ) {

    			const extension = extensions.get( 'EXT_texture_filter_anisotropic' );

    			maxAnisotropy = gl.getParameter( extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT );

    		} else {

    			maxAnisotropy = 0;

    		}

    		return maxAnisotropy;

    	}

    	function getMaxPrecision( precision ) {

    		if ( precision === 'highp' ) {

    			if ( gl.getShaderPrecisionFormat( 35633, 36338 ).precision > 0 &&
    				gl.getShaderPrecisionFormat( 35632, 36338 ).precision > 0 ) {

    				return 'highp';

    			}

    			precision = 'mediump';

    		}

    		if ( precision === 'mediump' ) {

    			if ( gl.getShaderPrecisionFormat( 35633, 36337 ).precision > 0 &&
    				gl.getShaderPrecisionFormat( 35632, 36337 ).precision > 0 ) {

    				return 'mediump';

    			}

    		}

    		return 'lowp';

    	}

    	const isWebGL2 = ( typeof WebGL2RenderingContext !== 'undefined' && gl instanceof WebGL2RenderingContext ) ||
    		( typeof WebGL2ComputeRenderingContext !== 'undefined' && gl instanceof WebGL2ComputeRenderingContext );

    	let precision = parameters.precision !== undefined ? parameters.precision : 'highp';
    	const maxPrecision = getMaxPrecision( precision );

    	if ( maxPrecision !== precision ) {

    		console.warn( 'THREE.WebGLRenderer:', precision, 'not supported, using', maxPrecision, 'instead.' );
    		precision = maxPrecision;

    	}

    	const drawBuffers = isWebGL2 || extensions.has( 'WEBGL_draw_buffers' );

    	const logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;

    	const maxTextures = gl.getParameter( 34930 );
    	const maxVertexTextures = gl.getParameter( 35660 );
    	const maxTextureSize = gl.getParameter( 3379 );
    	const maxCubemapSize = gl.getParameter( 34076 );

    	const maxAttributes = gl.getParameter( 34921 );
    	const maxVertexUniforms = gl.getParameter( 36347 );
    	const maxVaryings = gl.getParameter( 36348 );
    	const maxFragmentUniforms = gl.getParameter( 36349 );

    	const vertexTextures = maxVertexTextures > 0;
    	const floatFragmentTextures = isWebGL2 || extensions.has( 'OES_texture_float' );
    	const floatVertexTextures = vertexTextures && floatFragmentTextures;

    	const maxSamples = isWebGL2 ? gl.getParameter( 36183 ) : 0;

    	return {

    		isWebGL2: isWebGL2,

    		drawBuffers: drawBuffers,

    		getMaxAnisotropy: getMaxAnisotropy,
    		getMaxPrecision: getMaxPrecision,

    		precision: precision,
    		logarithmicDepthBuffer: logarithmicDepthBuffer,

    		maxTextures: maxTextures,
    		maxVertexTextures: maxVertexTextures,
    		maxTextureSize: maxTextureSize,
    		maxCubemapSize: maxCubemapSize,

    		maxAttributes: maxAttributes,
    		maxVertexUniforms: maxVertexUniforms,
    		maxVaryings: maxVaryings,
    		maxFragmentUniforms: maxFragmentUniforms,

    		vertexTextures: vertexTextures,
    		floatFragmentTextures: floatFragmentTextures,
    		floatVertexTextures: floatVertexTextures,

    		maxSamples: maxSamples

    	};

    }

    function WebGLClipping( properties ) {

    	const scope = this;

    	let globalState = null,
    		numGlobalPlanes = 0,
    		localClippingEnabled = false,
    		renderingShadows = false;

    	const plane = new Plane(),
    		viewNormalMatrix = new Matrix3(),

    		uniform = { value: null, needsUpdate: false };

    	this.uniform = uniform;
    	this.numPlanes = 0;
    	this.numIntersection = 0;

    	this.init = function ( planes, enableLocalClipping, camera ) {

    		const enabled =
    			planes.length !== 0 ||
    			enableLocalClipping ||
    			// enable state of previous frame - the clipping code has to
    			// run another frame in order to reset the state:
    			numGlobalPlanes !== 0 ||
    			localClippingEnabled;

    		localClippingEnabled = enableLocalClipping;

    		globalState = projectPlanes( planes, camera, 0 );
    		numGlobalPlanes = planes.length;

    		return enabled;

    	};

    	this.beginShadows = function () {

    		renderingShadows = true;
    		projectPlanes( null );

    	};

    	this.endShadows = function () {

    		renderingShadows = false;
    		resetGlobalState();

    	};

    	this.setState = function ( material, camera, useCache ) {

    		const planes = material.clippingPlanes,
    			clipIntersection = material.clipIntersection,
    			clipShadows = material.clipShadows;

    		const materialProperties = properties.get( material );

    		if ( ! localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && ! clipShadows ) {

    			// there's no local clipping

    			if ( renderingShadows ) {

    				// there's no global clipping

    				projectPlanes( null );

    			} else {

    				resetGlobalState();

    			}

    		} else {

    			const nGlobal = renderingShadows ? 0 : numGlobalPlanes,
    				lGlobal = nGlobal * 4;

    			let dstArray = materialProperties.clippingState || null;

    			uniform.value = dstArray; // ensure unique state

    			dstArray = projectPlanes( planes, camera, lGlobal, useCache );

    			for ( let i = 0; i !== lGlobal; ++ i ) {

    				dstArray[ i ] = globalState[ i ];

    			}

    			materialProperties.clippingState = dstArray;
    			this.numIntersection = clipIntersection ? this.numPlanes : 0;
    			this.numPlanes += nGlobal;

    		}


    	};

    	function resetGlobalState() {

    		if ( uniform.value !== globalState ) {

    			uniform.value = globalState;
    			uniform.needsUpdate = numGlobalPlanes > 0;

    		}

    		scope.numPlanes = numGlobalPlanes;
    		scope.numIntersection = 0;

    	}

    	function projectPlanes( planes, camera, dstOffset, skipTransform ) {

    		const nPlanes = planes !== null ? planes.length : 0;
    		let dstArray = null;

    		if ( nPlanes !== 0 ) {

    			dstArray = uniform.value;

    			if ( skipTransform !== true || dstArray === null ) {

    				const flatSize = dstOffset + nPlanes * 4,
    					viewMatrix = camera.matrixWorldInverse;

    				viewNormalMatrix.getNormalMatrix( viewMatrix );

    				if ( dstArray === null || dstArray.length < flatSize ) {

    					dstArray = new Float32Array( flatSize );

    				}

    				for ( let i = 0, i4 = dstOffset; i !== nPlanes; ++ i, i4 += 4 ) {

    					plane.copy( planes[ i ] ).applyMatrix4( viewMatrix, viewNormalMatrix );

    					plane.normal.toArray( dstArray, i4 );
    					dstArray[ i4 + 3 ] = plane.constant;

    				}

    			}

    			uniform.value = dstArray;
    			uniform.needsUpdate = true;

    		}

    		scope.numPlanes = nPlanes;
    		scope.numIntersection = 0;

    		return dstArray;

    	}

    }

    function WebGLCubeMaps( renderer ) {

    	let cubemaps = new WeakMap();

    	function mapTextureMapping( texture, mapping ) {

    		if ( mapping === EquirectangularReflectionMapping ) {

    			texture.mapping = CubeReflectionMapping;

    		} else if ( mapping === EquirectangularRefractionMapping ) {

    			texture.mapping = CubeRefractionMapping;

    		}

    		return texture;

    	}

    	function get( texture ) {

    		if ( texture && texture.isTexture && texture.isRenderTargetTexture === false ) {

    			const mapping = texture.mapping;

    			if ( mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping ) {

    				if ( cubemaps.has( texture ) ) {

    					const cubemap = cubemaps.get( texture ).texture;
    					return mapTextureMapping( cubemap, texture.mapping );

    				} else {

    					const image = texture.image;

    					if ( image && image.height > 0 ) {

    						const renderTarget = new WebGLCubeRenderTarget( image.height / 2 );
    						renderTarget.fromEquirectangularTexture( renderer, texture );
    						cubemaps.set( texture, renderTarget );

    						texture.addEventListener( 'dispose', onTextureDispose );

    						return mapTextureMapping( renderTarget.texture, texture.mapping );

    					} else {

    						// image not yet ready. try the conversion next frame

    						return null;

    					}

    				}

    			}

    		}

    		return texture;

    	}

    	function onTextureDispose( event ) {

    		const texture = event.target;

    		texture.removeEventListener( 'dispose', onTextureDispose );

    		const cubemap = cubemaps.get( texture );

    		if ( cubemap !== undefined ) {

    			cubemaps.delete( texture );
    			cubemap.dispose();

    		}

    	}

    	function dispose() {

    		cubemaps = new WeakMap();

    	}

    	return {
    		get: get,
    		dispose: dispose
    	};

    }

    class OrthographicCamera extends Camera {

    	constructor( left = - 1, right = 1, top = 1, bottom = - 1, near = 0.1, far = 2000 ) {

    		super();

    		this.isOrthographicCamera = true;

    		this.type = 'OrthographicCamera';

    		this.zoom = 1;
    		this.view = null;

    		this.left = left;
    		this.right = right;
    		this.top = top;
    		this.bottom = bottom;

    		this.near = near;
    		this.far = far;

    		this.updateProjectionMatrix();

    	}

    	copy( source, recursive ) {

    		super.copy( source, recursive );

    		this.left = source.left;
    		this.right = source.right;
    		this.top = source.top;
    		this.bottom = source.bottom;
    		this.near = source.near;
    		this.far = source.far;

    		this.zoom = source.zoom;
    		this.view = source.view === null ? null : Object.assign( {}, source.view );

    		return this;

    	}

    	setViewOffset( fullWidth, fullHeight, x, y, width, height ) {

    		if ( this.view === null ) {

    			this.view = {
    				enabled: true,
    				fullWidth: 1,
    				fullHeight: 1,
    				offsetX: 0,
    				offsetY: 0,
    				width: 1,
    				height: 1
    			};

    		}

    		this.view.enabled = true;
    		this.view.fullWidth = fullWidth;
    		this.view.fullHeight = fullHeight;
    		this.view.offsetX = x;
    		this.view.offsetY = y;
    		this.view.width = width;
    		this.view.height = height;

    		this.updateProjectionMatrix();

    	}

    	clearViewOffset() {

    		if ( this.view !== null ) {

    			this.view.enabled = false;

    		}

    		this.updateProjectionMatrix();

    	}

    	updateProjectionMatrix() {

    		const dx = ( this.right - this.left ) / ( 2 * this.zoom );
    		const dy = ( this.top - this.bottom ) / ( 2 * this.zoom );
    		const cx = ( this.right + this.left ) / 2;
    		const cy = ( this.top + this.bottom ) / 2;

    		let left = cx - dx;
    		let right = cx + dx;
    		let top = cy + dy;
    		let bottom = cy - dy;

    		if ( this.view !== null && this.view.enabled ) {

    			const scaleW = ( this.right - this.left ) / this.view.fullWidth / this.zoom;
    			const scaleH = ( this.top - this.bottom ) / this.view.fullHeight / this.zoom;

    			left += scaleW * this.view.offsetX;
    			right = left + scaleW * this.view.width;
    			top -= scaleH * this.view.offsetY;
    			bottom = top - scaleH * this.view.height;

    		}

    		this.projectionMatrix.makeOrthographic( left, right, top, bottom, this.near, this.far );

    		this.projectionMatrixInverse.copy( this.projectionMatrix ).invert();

    	}

    	toJSON( meta ) {

    		const data = super.toJSON( meta );

    		data.object.zoom = this.zoom;
    		data.object.left = this.left;
    		data.object.right = this.right;
    		data.object.top = this.top;
    		data.object.bottom = this.bottom;
    		data.object.near = this.near;
    		data.object.far = this.far;

    		if ( this.view !== null ) data.object.view = Object.assign( {}, this.view );

    		return data;

    	}

    }

    const LOD_MIN = 4;

    // The standard deviations (radians) associated with the extra mips. These are
    // chosen to approximate a Trowbridge-Reitz distribution function times the
    // geometric shadowing function. These sigma values squared must match the
    // variance #defines in cube_uv_reflection_fragment.glsl.js.
    const EXTRA_LOD_SIGMA = [ 0.125, 0.215, 0.35, 0.446, 0.526, 0.582 ];

    // The maximum length of the blur for loop. Smaller sigmas will use fewer
    // samples and exit early, but not recompile the shader.
    const MAX_SAMPLES = 20;

    const _flatCamera = /*@__PURE__*/ new OrthographicCamera();
    const _clearColor = /*@__PURE__*/ new Color$1();
    let _oldTarget = null;

    // Golden Ratio
    const PHI = ( 1 + Math.sqrt( 5 ) ) / 2;
    const INV_PHI = 1 / PHI;

    // Vertices of a dodecahedron (except the opposites, which represent the
    // same axis), used as axis directions evenly spread on a sphere.
    const _axisDirections = [
    	/*@__PURE__*/ new Vector3( 1, 1, 1 ),
    	/*@__PURE__*/ new Vector3( - 1, 1, 1 ),
    	/*@__PURE__*/ new Vector3( 1, 1, - 1 ),
    	/*@__PURE__*/ new Vector3( - 1, 1, - 1 ),
    	/*@__PURE__*/ new Vector3( 0, PHI, INV_PHI ),
    	/*@__PURE__*/ new Vector3( 0, PHI, - INV_PHI ),
    	/*@__PURE__*/ new Vector3( INV_PHI, 0, PHI ),
    	/*@__PURE__*/ new Vector3( - INV_PHI, 0, PHI ),
    	/*@__PURE__*/ new Vector3( PHI, INV_PHI, 0 ),
    	/*@__PURE__*/ new Vector3( - PHI, INV_PHI, 0 ) ];

    /**
     * This class generates a Prefiltered, Mipmapped Radiance Environment Map
     * (PMREM) from a cubeMap environment texture. This allows different levels of
     * blur to be quickly accessed based on material roughness. It is packed into a
     * special CubeUV format that allows us to perform custom interpolation so that
     * we can support nonlinear formats such as RGBE. Unlike a traditional mipmap
     * chain, it only goes down to the LOD_MIN level (above), and then creates extra
     * even more filtered 'mips' at the same LOD_MIN resolution, associated with
     * higher roughness levels. In this way we maintain resolution to smoothly
     * interpolate diffuse lighting while limiting sampling computation.
     *
     * Paper: Fast, Accurate Image-Based Lighting
     * https://drive.google.com/file/d/15y8r_UpKlU9SvV4ILb0C3qCPecS8pvLz/view
    */

    class PMREMGenerator {

    	constructor( renderer ) {

    		this._renderer = renderer;
    		this._pingPongRenderTarget = null;

    		this._lodMax = 0;
    		this._cubeSize = 0;
    		this._lodPlanes = [];
    		this._sizeLods = [];
    		this._sigmas = [];

    		this._blurMaterial = null;
    		this._cubemapMaterial = null;
    		this._equirectMaterial = null;

    		this._compileMaterial( this._blurMaterial );

    	}

    	/**
    	 * Generates a PMREM from a supplied Scene, which can be faster than using an
    	 * image if networking bandwidth is low. Optional sigma specifies a blur radius
    	 * in radians to be applied to the scene before PMREM generation. Optional near
    	 * and far planes ensure the scene is rendered in its entirety (the cubeCamera
    	 * is placed at the origin).
    	 */
    	fromScene( scene, sigma = 0, near = 0.1, far = 100 ) {

    		_oldTarget = this._renderer.getRenderTarget();

    		this._setSize( 256 );

    		const cubeUVRenderTarget = this._allocateTargets();
    		cubeUVRenderTarget.depthBuffer = true;

    		this._sceneToCubeUV( scene, near, far, cubeUVRenderTarget );

    		if ( sigma > 0 ) {

    			this._blur( cubeUVRenderTarget, 0, 0, sigma );

    		}

    		this._applyPMREM( cubeUVRenderTarget );
    		this._cleanup( cubeUVRenderTarget );

    		return cubeUVRenderTarget;

    	}

    	/**
    	 * Generates a PMREM from an equirectangular texture, which can be either LDR
    	 * or HDR. The ideal input image size is 1k (1024 x 512),
    	 * as this matches best with the 256 x 256 cubemap output.
    	 */
    	fromEquirectangular( equirectangular, renderTarget = null ) {

    		return this._fromTexture( equirectangular, renderTarget );

    	}

    	/**
    	 * Generates a PMREM from an cubemap texture, which can be either LDR
    	 * or HDR. The ideal input cube size is 256 x 256,
    	 * as this matches best with the 256 x 256 cubemap output.
    	 */
    	fromCubemap( cubemap, renderTarget = null ) {

    		return this._fromTexture( cubemap, renderTarget );

    	}

    	/**
    	 * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during
    	 * your texture's network fetch for increased concurrency.
    	 */
    	compileCubemapShader() {

    		if ( this._cubemapMaterial === null ) {

    			this._cubemapMaterial = _getCubemapMaterial();
    			this._compileMaterial( this._cubemapMaterial );

    		}

    	}

    	/**
    	 * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during
    	 * your texture's network fetch for increased concurrency.
    	 */
    	compileEquirectangularShader() {

    		if ( this._equirectMaterial === null ) {

    			this._equirectMaterial = _getEquirectMaterial();
    			this._compileMaterial( this._equirectMaterial );

    		}

    	}

    	/**
    	 * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,
    	 * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on
    	 * one of them will cause any others to also become unusable.
    	 */
    	dispose() {

    		this._dispose();

    		if ( this._cubemapMaterial !== null ) this._cubemapMaterial.dispose();
    		if ( this._equirectMaterial !== null ) this._equirectMaterial.dispose();

    	}

    	// private interface

    	_setSize( cubeSize ) {

    		this._lodMax = Math.floor( Math.log2( cubeSize ) );
    		this._cubeSize = Math.pow( 2, this._lodMax );

    	}

    	_dispose() {

    		if ( this._blurMaterial !== null ) this._blurMaterial.dispose();

    		if ( this._pingPongRenderTarget !== null ) this._pingPongRenderTarget.dispose();

    		for ( let i = 0; i < this._lodPlanes.length; i ++ ) {

    			this._lodPlanes[ i ].dispose();

    		}

    	}

    	_cleanup( outputTarget ) {

    		this._renderer.setRenderTarget( _oldTarget );
    		outputTarget.scissorTest = false;
    		_setViewport( outputTarget, 0, 0, outputTarget.width, outputTarget.height );

    	}

    	_fromTexture( texture, renderTarget ) {

    		if ( texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping ) {

    			this._setSize( texture.image.length === 0 ? 16 : ( texture.image[ 0 ].width || texture.image[ 0 ].image.width ) );

    		} else { // Equirectangular

    			this._setSize( texture.image.width / 4 );

    		}

    		_oldTarget = this._renderer.getRenderTarget();

    		const cubeUVRenderTarget = renderTarget || this._allocateTargets();
    		this._textureToCubeUV( texture, cubeUVRenderTarget );
    		this._applyPMREM( cubeUVRenderTarget );
    		this._cleanup( cubeUVRenderTarget );

    		return cubeUVRenderTarget;

    	}

    	_allocateTargets() {

    		const width = 3 * Math.max( this._cubeSize, 16 * 7 );
    		const height = 4 * this._cubeSize;

    		const params = {
    			magFilter: LinearFilter,
    			minFilter: LinearFilter,
    			generateMipmaps: false,
    			type: HalfFloatType,
    			format: RGBAFormat,
    			encoding: LinearEncoding,
    			depthBuffer: false
    		};

    		const cubeUVRenderTarget = _createRenderTarget( width, height, params );

    		if ( this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== width ) {

    			if ( this._pingPongRenderTarget !== null ) {

    				this._dispose();

    			}

    			this._pingPongRenderTarget = _createRenderTarget( width, height, params );

    			const { _lodMax } = this;
    			( { sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas } = _createPlanes( _lodMax ) );

    			this._blurMaterial = _getBlurShader( _lodMax, width, height );

    		}

    		return cubeUVRenderTarget;

    	}

    	_compileMaterial( material ) {

    		const tmpMesh = new Mesh( this._lodPlanes[ 0 ], material );
    		this._renderer.compile( tmpMesh, _flatCamera );

    	}

    	_sceneToCubeUV( scene, near, far, cubeUVRenderTarget ) {

    		const fov = 90;
    		const aspect = 1;
    		const cubeCamera = new PerspectiveCamera( fov, aspect, near, far );
    		const upSign = [ 1, - 1, 1, 1, 1, 1 ];
    		const forwardSign = [ 1, 1, 1, - 1, - 1, - 1 ];
    		const renderer = this._renderer;

    		const originalAutoClear = renderer.autoClear;
    		const toneMapping = renderer.toneMapping;
    		renderer.getClearColor( _clearColor );

    		renderer.toneMapping = NoToneMapping;
    		renderer.autoClear = false;

    		const backgroundMaterial = new MeshBasicMaterial( {
    			name: 'PMREM.Background',
    			side: BackSide,
    			depthWrite: false,
    			depthTest: false,
    		} );

    		const backgroundBox = new Mesh( new BoxGeometry(), backgroundMaterial );

    		let useSolidColor = false;
    		const background = scene.background;

    		if ( background ) {

    			if ( background.isColor ) {

    				backgroundMaterial.color.copy( background );
    				scene.background = null;
    				useSolidColor = true;

    			}

    		} else {

    			backgroundMaterial.color.copy( _clearColor );
    			useSolidColor = true;

    		}

    		for ( let i = 0; i < 6; i ++ ) {

    			const col = i % 3;

    			if ( col === 0 ) {

    				cubeCamera.up.set( 0, upSign[ i ], 0 );
    				cubeCamera.lookAt( forwardSign[ i ], 0, 0 );

    			} else if ( col === 1 ) {

    				cubeCamera.up.set( 0, 0, upSign[ i ] );
    				cubeCamera.lookAt( 0, forwardSign[ i ], 0 );

    			} else {

    				cubeCamera.up.set( 0, upSign[ i ], 0 );
    				cubeCamera.lookAt( 0, 0, forwardSign[ i ] );

    			}

    			const size = this._cubeSize;

    			_setViewport( cubeUVRenderTarget, col * size, i > 2 ? size : 0, size, size );

    			renderer.setRenderTarget( cubeUVRenderTarget );

    			if ( useSolidColor ) {

    				renderer.render( backgroundBox, cubeCamera );

    			}

    			renderer.render( scene, cubeCamera );

    		}

    		backgroundBox.geometry.dispose();
    		backgroundBox.material.dispose();

    		renderer.toneMapping = toneMapping;
    		renderer.autoClear = originalAutoClear;
    		scene.background = background;

    	}

    	_textureToCubeUV( texture, cubeUVRenderTarget ) {

    		const renderer = this._renderer;

    		const isCubeTexture = ( texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping );

    		if ( isCubeTexture ) {

    			if ( this._cubemapMaterial === null ) {

    				this._cubemapMaterial = _getCubemapMaterial();

    			}

    			this._cubemapMaterial.uniforms.flipEnvMap.value = ( texture.isRenderTargetTexture === false ) ? - 1 : 1;

    		} else {

    			if ( this._equirectMaterial === null ) {

    				this._equirectMaterial = _getEquirectMaterial();

    			}

    		}

    		const material = isCubeTexture ? this._cubemapMaterial : this._equirectMaterial;
    		const mesh = new Mesh( this._lodPlanes[ 0 ], material );

    		const uniforms = material.uniforms;

    		uniforms[ 'envMap' ].value = texture;

    		const size = this._cubeSize;

    		_setViewport( cubeUVRenderTarget, 0, 0, 3 * size, 2 * size );

    		renderer.setRenderTarget( cubeUVRenderTarget );
    		renderer.render( mesh, _flatCamera );

    	}

    	_applyPMREM( cubeUVRenderTarget ) {

    		const renderer = this._renderer;
    		const autoClear = renderer.autoClear;
    		renderer.autoClear = false;

    		for ( let i = 1; i < this._lodPlanes.length; i ++ ) {

    			const sigma = Math.sqrt( this._sigmas[ i ] * this._sigmas[ i ] - this._sigmas[ i - 1 ] * this._sigmas[ i - 1 ] );

    			const poleAxis = _axisDirections[ ( i - 1 ) % _axisDirections.length ];

    			this._blur( cubeUVRenderTarget, i - 1, i, sigma, poleAxis );

    		}

    		renderer.autoClear = autoClear;

    	}

    	/**
    	 * This is a two-pass Gaussian blur for a cubemap. Normally this is done
    	 * vertically and horizontally, but this breaks down on a cube. Here we apply
    	 * the blur latitudinally (around the poles), and then longitudinally (towards
    	 * the poles) to approximate the orthogonally-separable blur. It is least
    	 * accurate at the poles, but still does a decent job.
    	 */
    	_blur( cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis ) {

    		const pingPongRenderTarget = this._pingPongRenderTarget;

    		this._halfBlur(
    			cubeUVRenderTarget,
    			pingPongRenderTarget,
    			lodIn,
    			lodOut,
    			sigma,
    			'latitudinal',
    			poleAxis );

    		this._halfBlur(
    			pingPongRenderTarget,
    			cubeUVRenderTarget,
    			lodOut,
    			lodOut,
    			sigma,
    			'longitudinal',
    			poleAxis );

    	}

    	_halfBlur( targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction, poleAxis ) {

    		const renderer = this._renderer;
    		const blurMaterial = this._blurMaterial;

    		if ( direction !== 'latitudinal' && direction !== 'longitudinal' ) {

    			console.error(
    				'blur direction must be either latitudinal or longitudinal!' );

    		}

    		// Number of standard deviations at which to cut off the discrete approximation.
    		const STANDARD_DEVIATIONS = 3;

    		const blurMesh = new Mesh( this._lodPlanes[ lodOut ], blurMaterial );
    		const blurUniforms = blurMaterial.uniforms;

    		const pixels = this._sizeLods[ lodIn ] - 1;
    		const radiansPerPixel = isFinite( sigmaRadians ) ? Math.PI / ( 2 * pixels ) : 2 * Math.PI / ( 2 * MAX_SAMPLES - 1 );
    		const sigmaPixels = sigmaRadians / radiansPerPixel;
    		const samples = isFinite( sigmaRadians ) ? 1 + Math.floor( STANDARD_DEVIATIONS * sigmaPixels ) : MAX_SAMPLES;

    		if ( samples > MAX_SAMPLES ) {

    			console.warn( `sigmaRadians, ${
				sigmaRadians}, is too large and will clip, as it requested ${
				samples} samples when the maximum is set to ${MAX_SAMPLES}` );

    		}

    		const weights = [];
    		let sum = 0;

    		for ( let i = 0; i < MAX_SAMPLES; ++ i ) {

    			const x = i / sigmaPixels;
    			const weight = Math.exp( - x * x / 2 );
    			weights.push( weight );

    			if ( i === 0 ) {

    				sum += weight;

    			} else if ( i < samples ) {

    				sum += 2 * weight;

    			}

    		}

    		for ( let i = 0; i < weights.length; i ++ ) {

    			weights[ i ] = weights[ i ] / sum;

    		}

    		blurUniforms[ 'envMap' ].value = targetIn.texture;
    		blurUniforms[ 'samples' ].value = samples;
    		blurUniforms[ 'weights' ].value = weights;
    		blurUniforms[ 'latitudinal' ].value = direction === 'latitudinal';

    		if ( poleAxis ) {

    			blurUniforms[ 'poleAxis' ].value = poleAxis;

    		}

    		const { _lodMax } = this;
    		blurUniforms[ 'dTheta' ].value = radiansPerPixel;
    		blurUniforms[ 'mipInt' ].value = _lodMax - lodIn;

    		const outputSize = this._sizeLods[ lodOut ];
    		const x = 3 * outputSize * ( lodOut > _lodMax - LOD_MIN ? lodOut - _lodMax + LOD_MIN : 0 );
    		const y = 4 * ( this._cubeSize - outputSize );

    		_setViewport( targetOut, x, y, 3 * outputSize, 2 * outputSize );
    		renderer.setRenderTarget( targetOut );
    		renderer.render( blurMesh, _flatCamera );

    	}

    }



    function _createPlanes( lodMax ) {

    	const lodPlanes = [];
    	const sizeLods = [];
    	const sigmas = [];

    	let lod = lodMax;

    	const totalLods = lodMax - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length;

    	for ( let i = 0; i < totalLods; i ++ ) {

    		const sizeLod = Math.pow( 2, lod );
    		sizeLods.push( sizeLod );
    		let sigma = 1.0 / sizeLod;

    		if ( i > lodMax - LOD_MIN ) {

    			sigma = EXTRA_LOD_SIGMA[ i - lodMax + LOD_MIN - 1 ];

    		} else if ( i === 0 ) {

    			sigma = 0;

    		}

    		sigmas.push( sigma );

    		const texelSize = 1.0 / ( sizeLod - 2 );
    		const min = - texelSize;
    		const max = 1 + texelSize;
    		const uv1 = [ min, min, max, min, max, max, min, min, max, max, min, max ];

    		const cubeFaces = 6;
    		const vertices = 6;
    		const positionSize = 3;
    		const uvSize = 2;
    		const faceIndexSize = 1;

    		const position = new Float32Array( positionSize * vertices * cubeFaces );
    		const uv = new Float32Array( uvSize * vertices * cubeFaces );
    		const faceIndex = new Float32Array( faceIndexSize * vertices * cubeFaces );

    		for ( let face = 0; face < cubeFaces; face ++ ) {

    			const x = ( face % 3 ) * 2 / 3 - 1;
    			const y = face > 2 ? 0 : - 1;
    			const coordinates = [
    				x, y, 0,
    				x + 2 / 3, y, 0,
    				x + 2 / 3, y + 1, 0,
    				x, y, 0,
    				x + 2 / 3, y + 1, 0,
    				x, y + 1, 0
    			];
    			position.set( coordinates, positionSize * vertices * face );
    			uv.set( uv1, uvSize * vertices * face );
    			const fill = [ face, face, face, face, face, face ];
    			faceIndex.set( fill, faceIndexSize * vertices * face );

    		}

    		const planes = new BufferGeometry();
    		planes.setAttribute( 'position', new BufferAttribute( position, positionSize ) );
    		planes.setAttribute( 'uv', new BufferAttribute( uv, uvSize ) );
    		planes.setAttribute( 'faceIndex', new BufferAttribute( faceIndex, faceIndexSize ) );
    		lodPlanes.push( planes );

    		if ( lod > LOD_MIN ) {

    			lod --;

    		}

    	}

    	return { lodPlanes, sizeLods, sigmas };

    }

    function _createRenderTarget( width, height, params ) {

    	const cubeUVRenderTarget = new WebGLRenderTarget( width, height, params );
    	cubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping;
    	cubeUVRenderTarget.texture.name = 'PMREM.cubeUv';
    	cubeUVRenderTarget.scissorTest = true;
    	return cubeUVRenderTarget;

    }

    function _setViewport( target, x, y, width, height ) {

    	target.viewport.set( x, y, width, height );
    	target.scissor.set( x, y, width, height );

    }

    function _getBlurShader( lodMax, width, height ) {

    	const weights = new Float32Array( MAX_SAMPLES );
    	const poleAxis = new Vector3( 0, 1, 0 );
    	const shaderMaterial = new ShaderMaterial( {

    		name: 'SphericalGaussianBlur',

    		defines: {
    			'n': MAX_SAMPLES,
    			'CUBEUV_TEXEL_WIDTH': 1.0 / width,
    			'CUBEUV_TEXEL_HEIGHT': 1.0 / height,
    			'CUBEUV_MAX_MIP': `${lodMax}.0`,
    		},

    		uniforms: {
    			'envMap': { value: null },
    			'samples': { value: 1 },
    			'weights': { value: weights },
    			'latitudinal': { value: false },
    			'dTheta': { value: 0 },
    			'mipInt': { value: 0 },
    			'poleAxis': { value: poleAxis }
    		},

    		vertexShader: _getCommonVertexShader(),

    		fragmentShader: /* glsl */`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,

    		blending: NoBlending,
    		depthTest: false,
    		depthWrite: false

    	} );

    	return shaderMaterial;

    }

    function _getEquirectMaterial() {

    	return new ShaderMaterial( {

    		name: 'EquirectangularToCubeUV',

    		uniforms: {
    			'envMap': { value: null }
    		},

    		vertexShader: _getCommonVertexShader(),

    		fragmentShader: /* glsl */`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,

    		blending: NoBlending,
    		depthTest: false,
    		depthWrite: false

    	} );

    }

    function _getCubemapMaterial() {

    	return new ShaderMaterial( {

    		name: 'CubemapToCubeUV',

    		uniforms: {
    			'envMap': { value: null },
    			'flipEnvMap': { value: - 1 }
    		},

    		vertexShader: _getCommonVertexShader(),

    		fragmentShader: /* glsl */`

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,

    		blending: NoBlending,
    		depthTest: false,
    		depthWrite: false

    	} );

    }

    function _getCommonVertexShader() {

    	return /* glsl */`

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`;

    }

    function WebGLCubeUVMaps( renderer ) {

    	let cubeUVmaps = new WeakMap();

    	let pmremGenerator = null;

    	function get( texture ) {

    		if ( texture && texture.isTexture ) {

    			const mapping = texture.mapping;

    			const isEquirectMap = ( mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping );
    			const isCubeMap = ( mapping === CubeReflectionMapping || mapping === CubeRefractionMapping );

    			// equirect/cube map to cubeUV conversion

    			if ( isEquirectMap || isCubeMap ) {

    				if ( texture.isRenderTargetTexture && texture.needsPMREMUpdate === true ) {

    					texture.needsPMREMUpdate = false;

    					let renderTarget = cubeUVmaps.get( texture );

    					if ( pmremGenerator === null ) pmremGenerator = new PMREMGenerator( renderer );

    					renderTarget = isEquirectMap ? pmremGenerator.fromEquirectangular( texture, renderTarget ) : pmremGenerator.fromCubemap( texture, renderTarget );
    					cubeUVmaps.set( texture, renderTarget );

    					return renderTarget.texture;

    				} else {

    					if ( cubeUVmaps.has( texture ) ) {

    						return cubeUVmaps.get( texture ).texture;

    					} else {

    						const image = texture.image;

    						if ( ( isEquirectMap && image && image.height > 0 ) || ( isCubeMap && image && isCubeTextureComplete( image ) ) ) {

    							if ( pmremGenerator === null ) pmremGenerator = new PMREMGenerator( renderer );

    							const renderTarget = isEquirectMap ? pmremGenerator.fromEquirectangular( texture ) : pmremGenerator.fromCubemap( texture );
    							cubeUVmaps.set( texture, renderTarget );

    							texture.addEventListener( 'dispose', onTextureDispose );

    							return renderTarget.texture;

    						} else {

    							// image not yet ready. try the conversion next frame

    							return null;

    						}

    					}

    				}

    			}

    		}

    		return texture;

    	}

    	function isCubeTextureComplete( image ) {

    		let count = 0;
    		const length = 6;

    		for ( let i = 0; i < length; i ++ ) {

    			if ( image[ i ] !== undefined ) count ++;

    		}

    		return count === length;


    	}

    	function onTextureDispose( event ) {

    		const texture = event.target;

    		texture.removeEventListener( 'dispose', onTextureDispose );

    		const cubemapUV = cubeUVmaps.get( texture );

    		if ( cubemapUV !== undefined ) {

    			cubeUVmaps.delete( texture );
    			cubemapUV.dispose();

    		}

    	}

    	function dispose() {

    		cubeUVmaps = new WeakMap();

    		if ( pmremGenerator !== null ) {

    			pmremGenerator.dispose();
    			pmremGenerator = null;

    		}

    	}

    	return {
    		get: get,
    		dispose: dispose
    	};

    }

    function WebGLExtensions( gl ) {

    	const extensions = {};

    	function getExtension( name ) {

    		if ( extensions[ name ] !== undefined ) {

    			return extensions[ name ];

    		}

    		let extension;

    		switch ( name ) {

    			case 'WEBGL_depth_texture':
    				extension = gl.getExtension( 'WEBGL_depth_texture' ) || gl.getExtension( 'MOZ_WEBGL_depth_texture' ) || gl.getExtension( 'WEBKIT_WEBGL_depth_texture' );
    				break;

    			case 'EXT_texture_filter_anisotropic':
    				extension = gl.getExtension( 'EXT_texture_filter_anisotropic' ) || gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) || gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );
    				break;

    			case 'WEBGL_compressed_texture_s3tc':
    				extension = gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );
    				break;

    			case 'WEBGL_compressed_texture_pvrtc':
    				extension = gl.getExtension( 'WEBGL_compressed_texture_pvrtc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_pvrtc' );
    				break;

    			default:
    				extension = gl.getExtension( name );

    		}

    		extensions[ name ] = extension;

    		return extension;

    	}

    	return {

    		has: function ( name ) {

    			return getExtension( name ) !== null;

    		},

    		init: function ( capabilities ) {

    			if ( capabilities.isWebGL2 ) {

    				getExtension( 'EXT_color_buffer_float' );

    			} else {

    				getExtension( 'WEBGL_depth_texture' );
    				getExtension( 'OES_texture_float' );
    				getExtension( 'OES_texture_half_float' );
    				getExtension( 'OES_texture_half_float_linear' );
    				getExtension( 'OES_standard_derivatives' );
    				getExtension( 'OES_element_index_uint' );
    				getExtension( 'OES_vertex_array_object' );
    				getExtension( 'ANGLE_instanced_arrays' );

    			}

    			getExtension( 'OES_texture_float_linear' );
    			getExtension( 'EXT_color_buffer_half_float' );
    			getExtension( 'WEBGL_multisampled_render_to_texture' );

    		},

    		get: function ( name ) {

    			const extension = getExtension( name );

    			if ( extension === null ) {

    				console.warn( 'THREE.WebGLRenderer: ' + name + ' extension not supported.' );

    			}

    			return extension;

    		}

    	};

    }

    function WebGLGeometries( gl, attributes, info, bindingStates ) {

    	const geometries = {};
    	const wireframeAttributes = new WeakMap();

    	function onGeometryDispose( event ) {

    		const geometry = event.target;

    		if ( geometry.index !== null ) {

    			attributes.remove( geometry.index );

    		}

    		for ( const name in geometry.attributes ) {

    			attributes.remove( geometry.attributes[ name ] );

    		}

    		geometry.removeEventListener( 'dispose', onGeometryDispose );

    		delete geometries[ geometry.id ];

    		const attribute = wireframeAttributes.get( geometry );

    		if ( attribute ) {

    			attributes.remove( attribute );
    			wireframeAttributes.delete( geometry );

    		}

    		bindingStates.releaseStatesOfGeometry( geometry );

    		if ( geometry.isInstancedBufferGeometry === true ) {

    			delete geometry._maxInstanceCount;

    		}

    		//

    		info.memory.geometries --;

    	}

    	function get( object, geometry ) {

    		if ( geometries[ geometry.id ] === true ) return geometry;

    		geometry.addEventListener( 'dispose', onGeometryDispose );

    		geometries[ geometry.id ] = true;

    		info.memory.geometries ++;

    		return geometry;

    	}

    	function update( geometry ) {

    		const geometryAttributes = geometry.attributes;

    		// Updating index buffer in VAO now. See WebGLBindingStates.

    		for ( const name in geometryAttributes ) {

    			attributes.update( geometryAttributes[ name ], 34962 );

    		}

    		// morph targets

    		const morphAttributes = geometry.morphAttributes;

    		for ( const name in morphAttributes ) {

    			const array = morphAttributes[ name ];

    			for ( let i = 0, l = array.length; i < l; i ++ ) {

    				attributes.update( array[ i ], 34962 );

    			}

    		}

    	}

    	function updateWireframeAttribute( geometry ) {

    		const indices = [];

    		const geometryIndex = geometry.index;
    		const geometryPosition = geometry.attributes.position;
    		let version = 0;

    		if ( geometryIndex !== null ) {

    			const array = geometryIndex.array;
    			version = geometryIndex.version;

    			for ( let i = 0, l = array.length; i < l; i += 3 ) {

    				const a = array[ i + 0 ];
    				const b = array[ i + 1 ];
    				const c = array[ i + 2 ];

    				indices.push( a, b, b, c, c, a );

    			}

    		} else {

    			const array = geometryPosition.array;
    			version = geometryPosition.version;

    			for ( let i = 0, l = ( array.length / 3 ) - 1; i < l; i += 3 ) {

    				const a = i + 0;
    				const b = i + 1;
    				const c = i + 2;

    				indices.push( a, b, b, c, c, a );

    			}

    		}

    		const attribute = new ( arrayNeedsUint32( indices ) ? Uint32BufferAttribute : Uint16BufferAttribute )( indices, 1 );
    		attribute.version = version;

    		// Updating index buffer in VAO now. See WebGLBindingStates

    		//

    		const previousAttribute = wireframeAttributes.get( geometry );

    		if ( previousAttribute ) attributes.remove( previousAttribute );

    		//

    		wireframeAttributes.set( geometry, attribute );

    	}

    	function getWireframeAttribute( geometry ) {

    		const currentAttribute = wireframeAttributes.get( geometry );

    		if ( currentAttribute ) {

    			const geometryIndex = geometry.index;

    			if ( geometryIndex !== null ) {

    				// if the attribute is obsolete, create a new one

    				if ( currentAttribute.version < geometryIndex.version ) {

    					updateWireframeAttribute( geometry );

    				}

    			}

    		} else {

    			updateWireframeAttribute( geometry );

    		}

    		return wireframeAttributes.get( geometry );

    	}

    	return {

    		get: get,
    		update: update,

    		getWireframeAttribute: getWireframeAttribute

    	};

    }

    function WebGLIndexedBufferRenderer( gl, extensions, info, capabilities ) {

    	const isWebGL2 = capabilities.isWebGL2;

    	let mode;

    	function setMode( value ) {

    		mode = value;

    	}

    	let type, bytesPerElement;

    	function setIndex( value ) {

    		type = value.type;
    		bytesPerElement = value.bytesPerElement;

    	}

    	function render( start, count ) {

    		gl.drawElements( mode, count, type, start * bytesPerElement );

    		info.update( count, mode, 1 );

    	}

    	function renderInstances( start, count, primcount ) {

    		if ( primcount === 0 ) return;

    		let extension, methodName;

    		if ( isWebGL2 ) {

    			extension = gl;
    			methodName = 'drawElementsInstanced';

    		} else {

    			extension = extensions.get( 'ANGLE_instanced_arrays' );
    			methodName = 'drawElementsInstancedANGLE';

    			if ( extension === null ) {

    				console.error( 'THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
    				return;

    			}

    		}

    		extension[ methodName ]( mode, count, type, start * bytesPerElement, primcount );

    		info.update( count, mode, primcount );

    	}

    	//

    	this.setMode = setMode;
    	this.setIndex = setIndex;
    	this.render = render;
    	this.renderInstances = renderInstances;

    }

    function WebGLInfo( gl ) {

    	const memory = {
    		geometries: 0,
    		textures: 0
    	};

    	const render = {
    		frame: 0,
    		calls: 0,
    		triangles: 0,
    		points: 0,
    		lines: 0
    	};

    	function update( count, mode, instanceCount ) {

    		render.calls ++;

    		switch ( mode ) {

    			case 4:
    				render.triangles += instanceCount * ( count / 3 );
    				break;

    			case 1:
    				render.lines += instanceCount * ( count / 2 );
    				break;

    			case 3:
    				render.lines += instanceCount * ( count - 1 );
    				break;

    			case 2:
    				render.lines += instanceCount * count;
    				break;

    			case 0:
    				render.points += instanceCount * count;
    				break;

    			default:
    				console.error( 'THREE.WebGLInfo: Unknown draw mode:', mode );
    				break;

    		}

    	}

    	function reset() {

    		render.frame ++;
    		render.calls = 0;
    		render.triangles = 0;
    		render.points = 0;
    		render.lines = 0;

    	}

    	return {
    		memory: memory,
    		render: render,
    		programs: null,
    		autoReset: true,
    		reset: reset,
    		update: update
    	};

    }

    function numericalSort( a, b ) {

    	return a[ 0 ] - b[ 0 ];

    }

    function absNumericalSort( a, b ) {

    	return Math.abs( b[ 1 ] ) - Math.abs( a[ 1 ] );

    }

    function WebGLMorphtargets( gl, capabilities, textures ) {

    	const influencesList = {};
    	const morphInfluences = new Float32Array( 8 );
    	const morphTextures = new WeakMap();
    	const morph = new Vector4();

    	const workInfluences = [];

    	for ( let i = 0; i < 8; i ++ ) {

    		workInfluences[ i ] = [ i, 0 ];

    	}

    	function update( object, geometry, material, program ) {

    		const objectInfluences = object.morphTargetInfluences;

    		if ( capabilities.isWebGL2 === true ) {

    			// instead of using attributes, the WebGL 2 code path encodes morph targets
    			// into an array of data textures. Each layer represents a single morph target.

    			const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
    			const morphTargetsCount = ( morphAttribute !== undefined ) ? morphAttribute.length : 0;

    			let entry = morphTextures.get( geometry );

    			if ( entry === undefined || entry.count !== morphTargetsCount ) {

    				if ( entry !== undefined ) entry.texture.dispose();

    				const hasMorphPosition = geometry.morphAttributes.position !== undefined;
    				const hasMorphNormals = geometry.morphAttributes.normal !== undefined;
    				const hasMorphColors = geometry.morphAttributes.color !== undefined;

    				const morphTargets = geometry.morphAttributes.position || [];
    				const morphNormals = geometry.morphAttributes.normal || [];
    				const morphColors = geometry.morphAttributes.color || [];

    				let vertexDataCount = 0;

    				if ( hasMorphPosition === true ) vertexDataCount = 1;
    				if ( hasMorphNormals === true ) vertexDataCount = 2;
    				if ( hasMorphColors === true ) vertexDataCount = 3;

    				let width = geometry.attributes.position.count * vertexDataCount;
    				let height = 1;

    				if ( width > capabilities.maxTextureSize ) {

    					height = Math.ceil( width / capabilities.maxTextureSize );
    					width = capabilities.maxTextureSize;

    				}

    				const buffer = new Float32Array( width * height * 4 * morphTargetsCount );

    				const texture = new DataArrayTexture( buffer, width, height, morphTargetsCount );
    				texture.type = FloatType;
    				texture.needsUpdate = true;

    				// fill buffer

    				const vertexDataStride = vertexDataCount * 4;

    				for ( let i = 0; i < morphTargetsCount; i ++ ) {

    					const morphTarget = morphTargets[ i ];
    					const morphNormal = morphNormals[ i ];
    					const morphColor = morphColors[ i ];

    					const offset = width * height * 4 * i;

    					for ( let j = 0; j < morphTarget.count; j ++ ) {

    						const stride = j * vertexDataStride;

    						if ( hasMorphPosition === true ) {

    							morph.fromBufferAttribute( morphTarget, j );

    							buffer[ offset + stride + 0 ] = morph.x;
    							buffer[ offset + stride + 1 ] = morph.y;
    							buffer[ offset + stride + 2 ] = morph.z;
    							buffer[ offset + stride + 3 ] = 0;

    						}

    						if ( hasMorphNormals === true ) {

    							morph.fromBufferAttribute( morphNormal, j );

    							buffer[ offset + stride + 4 ] = morph.x;
    							buffer[ offset + stride + 5 ] = morph.y;
    							buffer[ offset + stride + 6 ] = morph.z;
    							buffer[ offset + stride + 7 ] = 0;

    						}

    						if ( hasMorphColors === true ) {

    							morph.fromBufferAttribute( morphColor, j );

    							buffer[ offset + stride + 8 ] = morph.x;
    							buffer[ offset + stride + 9 ] = morph.y;
    							buffer[ offset + stride + 10 ] = morph.z;
    							buffer[ offset + stride + 11 ] = ( morphColor.itemSize === 4 ) ? morph.w : 1;

    						}

    					}

    				}

    				entry = {
    					count: morphTargetsCount,
    					texture: texture,
    					size: new Vector2( width, height )
    				};

    				morphTextures.set( geometry, entry );

    				function disposeTexture() {

    					texture.dispose();

    					morphTextures.delete( geometry );

    					geometry.removeEventListener( 'dispose', disposeTexture );

    				}

    				geometry.addEventListener( 'dispose', disposeTexture );

    			}

    			//

    			let morphInfluencesSum = 0;

    			for ( let i = 0; i < objectInfluences.length; i ++ ) {

    				morphInfluencesSum += objectInfluences[ i ];

    			}

    			const morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;

    			program.getUniforms().setValue( gl, 'morphTargetBaseInfluence', morphBaseInfluence );
    			program.getUniforms().setValue( gl, 'morphTargetInfluences', objectInfluences );

    			program.getUniforms().setValue( gl, 'morphTargetsTexture', entry.texture, textures );
    			program.getUniforms().setValue( gl, 'morphTargetsTextureSize', entry.size );


    		} else {

    			// When object doesn't have morph target influences defined, we treat it as a 0-length array
    			// This is important to make sure we set up morphTargetBaseInfluence / morphTargetInfluences

    			const length = objectInfluences === undefined ? 0 : objectInfluences.length;

    			let influences = influencesList[ geometry.id ];

    			if ( influences === undefined || influences.length !== length ) {

    				// initialise list

    				influences = [];

    				for ( let i = 0; i < length; i ++ ) {

    					influences[ i ] = [ i, 0 ];

    				}

    				influencesList[ geometry.id ] = influences;

    			}

    			// Collect influences

    			for ( let i = 0; i < length; i ++ ) {

    				const influence = influences[ i ];

    				influence[ 0 ] = i;
    				influence[ 1 ] = objectInfluences[ i ];

    			}

    			influences.sort( absNumericalSort );

    			for ( let i = 0; i < 8; i ++ ) {

    				if ( i < length && influences[ i ][ 1 ] ) {

    					workInfluences[ i ][ 0 ] = influences[ i ][ 0 ];
    					workInfluences[ i ][ 1 ] = influences[ i ][ 1 ];

    				} else {

    					workInfluences[ i ][ 0 ] = Number.MAX_SAFE_INTEGER;
    					workInfluences[ i ][ 1 ] = 0;

    				}

    			}

    			workInfluences.sort( numericalSort );

    			const morphTargets = geometry.morphAttributes.position;
    			const morphNormals = geometry.morphAttributes.normal;

    			let morphInfluencesSum = 0;

    			for ( let i = 0; i < 8; i ++ ) {

    				const influence = workInfluences[ i ];
    				const index = influence[ 0 ];
    				const value = influence[ 1 ];

    				if ( index !== Number.MAX_SAFE_INTEGER && value ) {

    					if ( morphTargets && geometry.getAttribute( 'morphTarget' + i ) !== morphTargets[ index ] ) {

    						geometry.setAttribute( 'morphTarget' + i, morphTargets[ index ] );

    					}

    					if ( morphNormals && geometry.getAttribute( 'morphNormal' + i ) !== morphNormals[ index ] ) {

    						geometry.setAttribute( 'morphNormal' + i, morphNormals[ index ] );

    					}

    					morphInfluences[ i ] = value;
    					morphInfluencesSum += value;

    				} else {

    					if ( morphTargets && geometry.hasAttribute( 'morphTarget' + i ) === true ) {

    						geometry.deleteAttribute( 'morphTarget' + i );

    					}

    					if ( morphNormals && geometry.hasAttribute( 'morphNormal' + i ) === true ) {

    						geometry.deleteAttribute( 'morphNormal' + i );

    					}

    					morphInfluences[ i ] = 0;

    				}

    			}

    			// GLSL shader uses formula baseinfluence * base + sum(target * influence)
    			// This allows us to switch between absolute morphs and relative morphs without changing shader code
    			// When baseinfluence = 1 - sum(influence), the above is equivalent to sum((target - base) * influence)
    			const morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;

    			program.getUniforms().setValue( gl, 'morphTargetBaseInfluence', morphBaseInfluence );
    			program.getUniforms().setValue( gl, 'morphTargetInfluences', morphInfluences );

    		}

    	}

    	return {

    		update: update

    	};

    }

    function WebGLObjects( gl, geometries, attributes, info ) {

    	let updateMap = new WeakMap();

    	function update( object ) {

    		const frame = info.render.frame;

    		const geometry = object.geometry;
    		const buffergeometry = geometries.get( object, geometry );

    		// Update once per frame

    		if ( updateMap.get( buffergeometry ) !== frame ) {

    			geometries.update( buffergeometry );

    			updateMap.set( buffergeometry, frame );

    		}

    		if ( object.isInstancedMesh ) {

    			if ( object.hasEventListener( 'dispose', onInstancedMeshDispose ) === false ) {

    				object.addEventListener( 'dispose', onInstancedMeshDispose );

    			}

    			attributes.update( object.instanceMatrix, 34962 );

    			if ( object.instanceColor !== null ) {

    				attributes.update( object.instanceColor, 34962 );

    			}

    		}

    		return buffergeometry;

    	}

    	function dispose() {

    		updateMap = new WeakMap();

    	}

    	function onInstancedMeshDispose( event ) {

    		const instancedMesh = event.target;

    		instancedMesh.removeEventListener( 'dispose', onInstancedMeshDispose );

    		attributes.remove( instancedMesh.instanceMatrix );

    		if ( instancedMesh.instanceColor !== null ) attributes.remove( instancedMesh.instanceColor );

    	}

    	return {

    		update: update,
    		dispose: dispose

    	};

    }

    /**
     * Uniforms of a program.
     * Those form a tree structure with a special top-level container for the root,
     * which you get by calling 'new WebGLUniforms( gl, program )'.
     *
     *
     * Properties of inner nodes including the top-level container:
     *
     * .seq - array of nested uniforms
     * .map - nested uniforms by name
     *
     *
     * Methods of all nodes except the top-level container:
     *
     * .setValue( gl, value, [textures] )
     *
     * 		uploads a uniform value(s)
     *  	the 'textures' parameter is needed for sampler uniforms
     *
     *
     * Static methods of the top-level container (textures factorizations):
     *
     * .upload( gl, seq, values, textures )
     *
     * 		sets uniforms in 'seq' to 'values[id].value'
     *
     * .seqWithValue( seq, values ) : filteredSeq
     *
     * 		filters 'seq' entries with corresponding entry in values
     *
     *
     * Methods of the top-level container (textures factorizations):
     *
     * .setValue( gl, name, value, textures )
     *
     * 		sets uniform with  name 'name' to 'value'
     *
     * .setOptional( gl, obj, prop )
     *
     * 		like .set for an optional property of the object
     *
     */

    const emptyTexture = /*@__PURE__*/ new Texture();
    const emptyArrayTexture = /*@__PURE__*/ new DataArrayTexture();
    const empty3dTexture = /*@__PURE__*/ new Data3DTexture();
    const emptyCubeTexture = /*@__PURE__*/ new CubeTexture();

    // --- Utilities ---

    // Array Caches (provide typed arrays for temporary by size)

    const arrayCacheF32 = [];
    const arrayCacheI32 = [];

    // Float32Array caches used for uploading Matrix uniforms

    const mat4array = new Float32Array( 16 );
    const mat3array = new Float32Array( 9 );
    const mat2array = new Float32Array( 4 );

    // Flattening for arrays of vectors and matrices

    function flatten$1( array, nBlocks, blockSize ) {

    	const firstElem = array[ 0 ];

    	if ( firstElem <= 0 || firstElem > 0 ) return array;
    	// unoptimized: ! isNaN( firstElem )
    	// see http://jacksondunstan.com/articles/983

    	const n = nBlocks * blockSize;
    	let r = arrayCacheF32[ n ];

    	if ( r === undefined ) {

    		r = new Float32Array( n );
    		arrayCacheF32[ n ] = r;

    	}

    	if ( nBlocks !== 0 ) {

    		firstElem.toArray( r, 0 );

    		for ( let i = 1, offset = 0; i !== nBlocks; ++ i ) {

    			offset += blockSize;
    			array[ i ].toArray( r, offset );

    		}

    	}

    	return r;

    }

    function arraysEqual( a, b ) {

    	if ( a.length !== b.length ) return false;

    	for ( let i = 0, l = a.length; i < l; i ++ ) {

    		if ( a[ i ] !== b[ i ] ) return false;

    	}

    	return true;

    }

    function copyArray( a, b ) {

    	for ( let i = 0, l = b.length; i < l; i ++ ) {

    		a[ i ] = b[ i ];

    	}

    }

    // Texture unit allocation

    function allocTexUnits( textures, n ) {

    	let r = arrayCacheI32[ n ];

    	if ( r === undefined ) {

    		r = new Int32Array( n );
    		arrayCacheI32[ n ] = r;

    	}

    	for ( let i = 0; i !== n; ++ i ) {

    		r[ i ] = textures.allocateTextureUnit();

    	}

    	return r;

    }

    // --- Setters ---

    // Note: Defining these methods externally, because they come in a bunch
    // and this way their names minify.

    // Single scalar

    function setValueV1f( gl, v ) {

    	const cache = this.cache;

    	if ( cache[ 0 ] === v ) return;

    	gl.uniform1f( this.addr, v );

    	cache[ 0 ] = v;

    }

    // Single float vector (from flat array or THREE.VectorN)

    function setValueV2f( gl, v ) {

    	const cache = this.cache;

    	if ( v.x !== undefined ) {

    		if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y ) {

    			gl.uniform2f( this.addr, v.x, v.y );

    			cache[ 0 ] = v.x;
    			cache[ 1 ] = v.y;

    		}

    	} else {

    		if ( arraysEqual( cache, v ) ) return;

    		gl.uniform2fv( this.addr, v );

    		copyArray( cache, v );

    	}

    }

    function setValueV3f( gl, v ) {

    	const cache = this.cache;

    	if ( v.x !== undefined ) {

    		if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z ) {

    			gl.uniform3f( this.addr, v.x, v.y, v.z );

    			cache[ 0 ] = v.x;
    			cache[ 1 ] = v.y;
    			cache[ 2 ] = v.z;

    		}

    	} else if ( v.r !== undefined ) {

    		if ( cache[ 0 ] !== v.r || cache[ 1 ] !== v.g || cache[ 2 ] !== v.b ) {

    			gl.uniform3f( this.addr, v.r, v.g, v.b );

    			cache[ 0 ] = v.r;
    			cache[ 1 ] = v.g;
    			cache[ 2 ] = v.b;

    		}

    	} else {

    		if ( arraysEqual( cache, v ) ) return;

    		gl.uniform3fv( this.addr, v );

    		copyArray( cache, v );

    	}

    }

    function setValueV4f( gl, v ) {

    	const cache = this.cache;

    	if ( v.x !== undefined ) {

    		if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z || cache[ 3 ] !== v.w ) {

    			gl.uniform4f( this.addr, v.x, v.y, v.z, v.w );

    			cache[ 0 ] = v.x;
    			cache[ 1 ] = v.y;
    			cache[ 2 ] = v.z;
    			cache[ 3 ] = v.w;

    		}

    	} else {

    		if ( arraysEqual( cache, v ) ) return;

    		gl.uniform4fv( this.addr, v );

    		copyArray( cache, v );

    	}

    }

    // Single matrix (from flat array or THREE.MatrixN)

    function setValueM2( gl, v ) {

    	const cache = this.cache;
    	const elements = v.elements;

    	if ( elements === undefined ) {

    		if ( arraysEqual( cache, v ) ) return;

    		gl.uniformMatrix2fv( this.addr, false, v );

    		copyArray( cache, v );

    	} else {

    		if ( arraysEqual( cache, elements ) ) return;

    		mat2array.set( elements );

    		gl.uniformMatrix2fv( this.addr, false, mat2array );

    		copyArray( cache, elements );

    	}

    }

    function setValueM3( gl, v ) {

    	const cache = this.cache;
    	const elements = v.elements;

    	if ( elements === undefined ) {

    		if ( arraysEqual( cache, v ) ) return;

    		gl.uniformMatrix3fv( this.addr, false, v );

    		copyArray( cache, v );

    	} else {

    		if ( arraysEqual( cache, elements ) ) return;

    		mat3array.set( elements );

    		gl.uniformMatrix3fv( this.addr, false, mat3array );

    		copyArray( cache, elements );

    	}

    }

    function setValueM4( gl, v ) {

    	const cache = this.cache;
    	const elements = v.elements;

    	if ( elements === undefined ) {

    		if ( arraysEqual( cache, v ) ) return;

    		gl.uniformMatrix4fv( this.addr, false, v );

    		copyArray( cache, v );

    	} else {

    		if ( arraysEqual( cache, elements ) ) return;

    		mat4array.set( elements );

    		gl.uniformMatrix4fv( this.addr, false, mat4array );

    		copyArray( cache, elements );

    	}

    }

    // Single integer / boolean

    function setValueV1i( gl, v ) {

    	const cache = this.cache;

    	if ( cache[ 0 ] === v ) return;

    	gl.uniform1i( this.addr, v );

    	cache[ 0 ] = v;

    }

    // Single integer / boolean vector (from flat array or THREE.VectorN)

    function setValueV2i( gl, v ) {

    	const cache = this.cache;

    	if ( v.x !== undefined ) {

    		if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y ) {

    			gl.uniform2i( this.addr, v.x, v.y );

    			cache[ 0 ] = v.x;
    			cache[ 1 ] = v.y;

    		}

    	} else {

    		if ( arraysEqual( cache, v ) ) return;

    		gl.uniform2iv( this.addr, v );

    		copyArray( cache, v );

    	}

    }

    function setValueV3i( gl, v ) {

    	const cache = this.cache;

    	if ( v.x !== undefined ) {

    		if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z ) {

    			gl.uniform3i( this.addr, v.x, v.y, v.z );

    			cache[ 0 ] = v.x;
    			cache[ 1 ] = v.y;
    			cache[ 2 ] = v.z;

    		}

    	} else {

    		if ( arraysEqual( cache, v ) ) return;

    		gl.uniform3iv( this.addr, v );

    		copyArray( cache, v );

    	}

    }

    function setValueV4i( gl, v ) {

    	const cache = this.cache;

    	if ( v.x !== undefined ) {

    		if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z || cache[ 3 ] !== v.w ) {

    			gl.uniform4i( this.addr, v.x, v.y, v.z, v.w );

    			cache[ 0 ] = v.x;
    			cache[ 1 ] = v.y;
    			cache[ 2 ] = v.z;
    			cache[ 3 ] = v.w;

    		}

    	} else {

    		if ( arraysEqual( cache, v ) ) return;

    		gl.uniform4iv( this.addr, v );

    		copyArray( cache, v );

    	}

    }

    // Single unsigned integer

    function setValueV1ui( gl, v ) {

    	const cache = this.cache;

    	if ( cache[ 0 ] === v ) return;

    	gl.uniform1ui( this.addr, v );

    	cache[ 0 ] = v;

    }

    // Single unsigned integer vector (from flat array or THREE.VectorN)

    function setValueV2ui( gl, v ) {

    	const cache = this.cache;

    	if ( v.x !== undefined ) {

    		if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y ) {

    			gl.uniform2ui( this.addr, v.x, v.y );

    			cache[ 0 ] = v.x;
    			cache[ 1 ] = v.y;

    		}

    	} else {

    		if ( arraysEqual( cache, v ) ) return;

    		gl.uniform2uiv( this.addr, v );

    		copyArray( cache, v );

    	}

    }

    function setValueV3ui( gl, v ) {

    	const cache = this.cache;

    	if ( v.x !== undefined ) {

    		if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z ) {

    			gl.uniform3ui( this.addr, v.x, v.y, v.z );

    			cache[ 0 ] = v.x;
    			cache[ 1 ] = v.y;
    			cache[ 2 ] = v.z;

    		}

    	} else {

    		if ( arraysEqual( cache, v ) ) return;

    		gl.uniform3uiv( this.addr, v );

    		copyArray( cache, v );

    	}

    }

    function setValueV4ui( gl, v ) {

    	const cache = this.cache;

    	if ( v.x !== undefined ) {

    		if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z || cache[ 3 ] !== v.w ) {

    			gl.uniform4ui( this.addr, v.x, v.y, v.z, v.w );

    			cache[ 0 ] = v.x;
    			cache[ 1 ] = v.y;
    			cache[ 2 ] = v.z;
    			cache[ 3 ] = v.w;

    		}

    	} else {

    		if ( arraysEqual( cache, v ) ) return;

    		gl.uniform4uiv( this.addr, v );

    		copyArray( cache, v );

    	}

    }


    // Single texture (2D / Cube)

    function setValueT1( gl, v, textures ) {

    	const cache = this.cache;
    	const unit = textures.allocateTextureUnit();

    	if ( cache[ 0 ] !== unit ) {

    		gl.uniform1i( this.addr, unit );
    		cache[ 0 ] = unit;

    	}

    	textures.setTexture2D( v || emptyTexture, unit );

    }

    function setValueT3D1( gl, v, textures ) {

    	const cache = this.cache;
    	const unit = textures.allocateTextureUnit();

    	if ( cache[ 0 ] !== unit ) {

    		gl.uniform1i( this.addr, unit );
    		cache[ 0 ] = unit;

    	}

    	textures.setTexture3D( v || empty3dTexture, unit );

    }

    function setValueT6( gl, v, textures ) {

    	const cache = this.cache;
    	const unit = textures.allocateTextureUnit();

    	if ( cache[ 0 ] !== unit ) {

    		gl.uniform1i( this.addr, unit );
    		cache[ 0 ] = unit;

    	}

    	textures.setTextureCube( v || emptyCubeTexture, unit );

    }

    function setValueT2DArray1( gl, v, textures ) {

    	const cache = this.cache;
    	const unit = textures.allocateTextureUnit();

    	if ( cache[ 0 ] !== unit ) {

    		gl.uniform1i( this.addr, unit );
    		cache[ 0 ] = unit;

    	}

    	textures.setTexture2DArray( v || emptyArrayTexture, unit );

    }

    // Helper to pick the right setter for the singular case

    function getSingularSetter( type ) {

    	switch ( type ) {

    		case 0x1406: return setValueV1f; // FLOAT
    		case 0x8b50: return setValueV2f; // _VEC2
    		case 0x8b51: return setValueV3f; // _VEC3
    		case 0x8b52: return setValueV4f; // _VEC4

    		case 0x8b5a: return setValueM2; // _MAT2
    		case 0x8b5b: return setValueM3; // _MAT3
    		case 0x8b5c: return setValueM4; // _MAT4

    		case 0x1404: case 0x8b56: return setValueV1i; // INT, BOOL
    		case 0x8b53: case 0x8b57: return setValueV2i; // _VEC2
    		case 0x8b54: case 0x8b58: return setValueV3i; // _VEC3
    		case 0x8b55: case 0x8b59: return setValueV4i; // _VEC4

    		case 0x1405: return setValueV1ui; // UINT
    		case 0x8dc6: return setValueV2ui; // _VEC2
    		case 0x8dc7: return setValueV3ui; // _VEC3
    		case 0x8dc8: return setValueV4ui; // _VEC4

    		case 0x8b5e: // SAMPLER_2D
    		case 0x8d66: // SAMPLER_EXTERNAL_OES
    		case 0x8dca: // INT_SAMPLER_2D
    		case 0x8dd2: // UNSIGNED_INT_SAMPLER_2D
    		case 0x8b62: // SAMPLER_2D_SHADOW
    			return setValueT1;

    		case 0x8b5f: // SAMPLER_3D
    		case 0x8dcb: // INT_SAMPLER_3D
    		case 0x8dd3: // UNSIGNED_INT_SAMPLER_3D
    			return setValueT3D1;

    		case 0x8b60: // SAMPLER_CUBE
    		case 0x8dcc: // INT_SAMPLER_CUBE
    		case 0x8dd4: // UNSIGNED_INT_SAMPLER_CUBE
    		case 0x8dc5: // SAMPLER_CUBE_SHADOW
    			return setValueT6;

    		case 0x8dc1: // SAMPLER_2D_ARRAY
    		case 0x8dcf: // INT_SAMPLER_2D_ARRAY
    		case 0x8dd7: // UNSIGNED_INT_SAMPLER_2D_ARRAY
    		case 0x8dc4: // SAMPLER_2D_ARRAY_SHADOW
    			return setValueT2DArray1;

    	}

    }


    // Array of scalars

    function setValueV1fArray( gl, v ) {

    	gl.uniform1fv( this.addr, v );

    }

    // Array of vectors (from flat array or array of THREE.VectorN)

    function setValueV2fArray( gl, v ) {

    	const data = flatten$1( v, this.size, 2 );

    	gl.uniform2fv( this.addr, data );

    }

    function setValueV3fArray( gl, v ) {

    	const data = flatten$1( v, this.size, 3 );

    	gl.uniform3fv( this.addr, data );

    }

    function setValueV4fArray( gl, v ) {

    	const data = flatten$1( v, this.size, 4 );

    	gl.uniform4fv( this.addr, data );

    }

    // Array of matrices (from flat array or array of THREE.MatrixN)

    function setValueM2Array( gl, v ) {

    	const data = flatten$1( v, this.size, 4 );

    	gl.uniformMatrix2fv( this.addr, false, data );

    }

    function setValueM3Array( gl, v ) {

    	const data = flatten$1( v, this.size, 9 );

    	gl.uniformMatrix3fv( this.addr, false, data );

    }

    function setValueM4Array( gl, v ) {

    	const data = flatten$1( v, this.size, 16 );

    	gl.uniformMatrix4fv( this.addr, false, data );

    }

    // Array of integer / boolean

    function setValueV1iArray( gl, v ) {

    	gl.uniform1iv( this.addr, v );

    }

    // Array of integer / boolean vectors (from flat array)

    function setValueV2iArray( gl, v ) {

    	gl.uniform2iv( this.addr, v );

    }

    function setValueV3iArray( gl, v ) {

    	gl.uniform3iv( this.addr, v );

    }

    function setValueV4iArray( gl, v ) {

    	gl.uniform4iv( this.addr, v );

    }

    // Array of unsigned integer

    function setValueV1uiArray( gl, v ) {

    	gl.uniform1uiv( this.addr, v );

    }

    // Array of unsigned integer vectors (from flat array)

    function setValueV2uiArray( gl, v ) {

    	gl.uniform2uiv( this.addr, v );

    }

    function setValueV3uiArray( gl, v ) {

    	gl.uniform3uiv( this.addr, v );

    }

    function setValueV4uiArray( gl, v ) {

    	gl.uniform4uiv( this.addr, v );

    }


    // Array of textures (2D / 3D / Cube / 2DArray)

    function setValueT1Array( gl, v, textures ) {

    	const cache = this.cache;

    	const n = v.length;

    	const units = allocTexUnits( textures, n );

    	if ( ! arraysEqual( cache, units ) ) {

    		gl.uniform1iv( this.addr, units );

    		copyArray( cache, units );

    	}

    	for ( let i = 0; i !== n; ++ i ) {

    		textures.setTexture2D( v[ i ] || emptyTexture, units[ i ] );

    	}

    }

    function setValueT3DArray( gl, v, textures ) {

    	const cache = this.cache;

    	const n = v.length;

    	const units = allocTexUnits( textures, n );

    	if ( ! arraysEqual( cache, units ) ) {

    		gl.uniform1iv( this.addr, units );

    		copyArray( cache, units );

    	}

    	for ( let i = 0; i !== n; ++ i ) {

    		textures.setTexture3D( v[ i ] || empty3dTexture, units[ i ] );

    	}

    }

    function setValueT6Array( gl, v, textures ) {

    	const cache = this.cache;

    	const n = v.length;

    	const units = allocTexUnits( textures, n );

    	if ( ! arraysEqual( cache, units ) ) {

    		gl.uniform1iv( this.addr, units );

    		copyArray( cache, units );

    	}

    	for ( let i = 0; i !== n; ++ i ) {

    		textures.setTextureCube( v[ i ] || emptyCubeTexture, units[ i ] );

    	}

    }

    function setValueT2DArrayArray( gl, v, textures ) {

    	const cache = this.cache;

    	const n = v.length;

    	const units = allocTexUnits( textures, n );

    	if ( ! arraysEqual( cache, units ) ) {

    		gl.uniform1iv( this.addr, units );

    		copyArray( cache, units );

    	}

    	for ( let i = 0; i !== n; ++ i ) {

    		textures.setTexture2DArray( v[ i ] || emptyArrayTexture, units[ i ] );

    	}

    }


    // Helper to pick the right setter for a pure (bottom-level) array

    function getPureArraySetter( type ) {

    	switch ( type ) {

    		case 0x1406: return setValueV1fArray; // FLOAT
    		case 0x8b50: return setValueV2fArray; // _VEC2
    		case 0x8b51: return setValueV3fArray; // _VEC3
    		case 0x8b52: return setValueV4fArray; // _VEC4

    		case 0x8b5a: return setValueM2Array; // _MAT2
    		case 0x8b5b: return setValueM3Array; // _MAT3
    		case 0x8b5c: return setValueM4Array; // _MAT4

    		case 0x1404: case 0x8b56: return setValueV1iArray; // INT, BOOL
    		case 0x8b53: case 0x8b57: return setValueV2iArray; // _VEC2
    		case 0x8b54: case 0x8b58: return setValueV3iArray; // _VEC3
    		case 0x8b55: case 0x8b59: return setValueV4iArray; // _VEC4

    		case 0x1405: return setValueV1uiArray; // UINT
    		case 0x8dc6: return setValueV2uiArray; // _VEC2
    		case 0x8dc7: return setValueV3uiArray; // _VEC3
    		case 0x8dc8: return setValueV4uiArray; // _VEC4

    		case 0x8b5e: // SAMPLER_2D
    		case 0x8d66: // SAMPLER_EXTERNAL_OES
    		case 0x8dca: // INT_SAMPLER_2D
    		case 0x8dd2: // UNSIGNED_INT_SAMPLER_2D
    		case 0x8b62: // SAMPLER_2D_SHADOW
    			return setValueT1Array;

    		case 0x8b5f: // SAMPLER_3D
    		case 0x8dcb: // INT_SAMPLER_3D
    		case 0x8dd3: // UNSIGNED_INT_SAMPLER_3D
    			return setValueT3DArray;

    		case 0x8b60: // SAMPLER_CUBE
    		case 0x8dcc: // INT_SAMPLER_CUBE
    		case 0x8dd4: // UNSIGNED_INT_SAMPLER_CUBE
    		case 0x8dc5: // SAMPLER_CUBE_SHADOW
    			return setValueT6Array;

    		case 0x8dc1: // SAMPLER_2D_ARRAY
    		case 0x8dcf: // INT_SAMPLER_2D_ARRAY
    		case 0x8dd7: // UNSIGNED_INT_SAMPLER_2D_ARRAY
    		case 0x8dc4: // SAMPLER_2D_ARRAY_SHADOW
    			return setValueT2DArrayArray;

    	}

    }

    // --- Uniform Classes ---

    class SingleUniform {

    	constructor( id, activeInfo, addr ) {

    		this.id = id;
    		this.addr = addr;
    		this.cache = [];
    		this.setValue = getSingularSetter( activeInfo.type );

    		// this.path = activeInfo.name; // DEBUG

    	}

    }

    class PureArrayUniform {

    	constructor( id, activeInfo, addr ) {

    		this.id = id;
    		this.addr = addr;
    		this.cache = [];
    		this.size = activeInfo.size;
    		this.setValue = getPureArraySetter( activeInfo.type );

    		// this.path = activeInfo.name; // DEBUG

    	}

    }

    class StructuredUniform {

    	constructor( id ) {

    		this.id = id;

    		this.seq = [];
    		this.map = {};

    	}

    	setValue( gl, value, textures ) {

    		const seq = this.seq;

    		for ( let i = 0, n = seq.length; i !== n; ++ i ) {

    			const u = seq[ i ];
    			u.setValue( gl, value[ u.id ], textures );

    		}

    	}

    }

    // --- Top-level ---

    // Parser - builds up the property tree from the path strings

    const RePathPart = /(\w+)(\])?(\[|\.)?/g;

    // extracts
    // 	- the identifier (member name or array index)
    //  - followed by an optional right bracket (found when array index)
    //  - followed by an optional left bracket or dot (type of subscript)
    //
    // Note: These portions can be read in a non-overlapping fashion and
    // allow straightforward parsing of the hierarchy that WebGL encodes
    // in the uniform names.

    function addUniform( container, uniformObject ) {

    	container.seq.push( uniformObject );
    	container.map[ uniformObject.id ] = uniformObject;

    }

    function parseUniform( activeInfo, addr, container ) {

    	const path = activeInfo.name,
    		pathLength = path.length;

    	// reset RegExp object, because of the early exit of a previous run
    	RePathPart.lastIndex = 0;

    	while ( true ) {

    		const match = RePathPart.exec( path ),
    			matchEnd = RePathPart.lastIndex;

    		let id = match[ 1 ];
    		const idIsIndex = match[ 2 ] === ']',
    			subscript = match[ 3 ];

    		if ( idIsIndex ) id = id | 0; // convert to integer

    		if ( subscript === undefined || subscript === '[' && matchEnd + 2 === pathLength ) {

    			// bare name or "pure" bottom-level array "[0]" suffix

    			addUniform( container, subscript === undefined ?
    				new SingleUniform( id, activeInfo, addr ) :
    				new PureArrayUniform( id, activeInfo, addr ) );

    			break;

    		} else {

    			// step into inner node / create it in case it doesn't exist

    			const map = container.map;
    			let next = map[ id ];

    			if ( next === undefined ) {

    				next = new StructuredUniform( id );
    				addUniform( container, next );

    			}

    			container = next;

    		}

    	}

    }

    // Root Container

    class WebGLUniforms {

    	constructor( gl, program ) {

    		this.seq = [];
    		this.map = {};

    		const n = gl.getProgramParameter( program, 35718 );

    		for ( let i = 0; i < n; ++ i ) {

    			const info = gl.getActiveUniform( program, i ),
    				addr = gl.getUniformLocation( program, info.name );

    			parseUniform( info, addr, this );

    		}

    	}

    	setValue( gl, name, value, textures ) {

    		const u = this.map[ name ];

    		if ( u !== undefined ) u.setValue( gl, value, textures );

    	}

    	setOptional( gl, object, name ) {

    		const v = object[ name ];

    		if ( v !== undefined ) this.setValue( gl, name, v );

    	}

    	static upload( gl, seq, values, textures ) {

    		for ( let i = 0, n = seq.length; i !== n; ++ i ) {

    			const u = seq[ i ],
    				v = values[ u.id ];

    			if ( v.needsUpdate !== false ) {

    				// note: always updating when .needsUpdate is undefined
    				u.setValue( gl, v.value, textures );

    			}

    		}

    	}

    	static seqWithValue( seq, values ) {

    		const r = [];

    		for ( let i = 0, n = seq.length; i !== n; ++ i ) {

    			const u = seq[ i ];
    			if ( u.id in values ) r.push( u );

    		}

    		return r;

    	}

    }

    function WebGLShader( gl, type, string ) {

    	const shader = gl.createShader( type );

    	gl.shaderSource( shader, string );
    	gl.compileShader( shader );

    	return shader;

    }

    let programIdCount = 0;

    function handleSource( string, errorLine ) {

    	const lines = string.split( '\n' );
    	const lines2 = [];

    	const from = Math.max( errorLine - 6, 0 );
    	const to = Math.min( errorLine + 6, lines.length );

    	for ( let i = from; i < to; i ++ ) {

    		const line = i + 1;
    		lines2.push( `${line === errorLine ? '>' : ' '} ${line}: ${lines[ i ]}` );

    	}

    	return lines2.join( '\n' );

    }

    function getEncodingComponents( encoding ) {

    	switch ( encoding ) {

    		case LinearEncoding:
    			return [ 'Linear', '( value )' ];
    		case sRGBEncoding:
    			return [ 'sRGB', '( value )' ];
    		default:
    			console.warn( 'THREE.WebGLProgram: Unsupported encoding:', encoding );
    			return [ 'Linear', '( value )' ];

    	}

    }

    function getShaderErrors( gl, shader, type ) {

    	const status = gl.getShaderParameter( shader, 35713 );
    	const errors = gl.getShaderInfoLog( shader ).trim();

    	if ( status && errors === '' ) return '';

    	const errorMatches = /ERROR: 0:(\d+)/.exec( errors );
    	if ( errorMatches ) {

    		// --enable-privileged-webgl-extension
    		// console.log( '**' + type + '**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );

    		const errorLine = parseInt( errorMatches[ 1 ] );
    		return type.toUpperCase() + '\n\n' + errors + '\n\n' + handleSource( gl.getShaderSource( shader ), errorLine );

    	} else {

    		return errors;

    	}

    }

    function getTexelEncodingFunction( functionName, encoding ) {

    	const components = getEncodingComponents( encoding );
    	return 'vec4 ' + functionName + '( vec4 value ) { return LinearTo' + components[ 0 ] + components[ 1 ] + '; }';

    }

    function getToneMappingFunction( functionName, toneMapping ) {

    	let toneMappingName;

    	switch ( toneMapping ) {

    		case LinearToneMapping:
    			toneMappingName = 'Linear';
    			break;

    		case ReinhardToneMapping:
    			toneMappingName = 'Reinhard';
    			break;

    		case CineonToneMapping:
    			toneMappingName = 'OptimizedCineon';
    			break;

    		case ACESFilmicToneMapping:
    			toneMappingName = 'ACESFilmic';
    			break;

    		case CustomToneMapping:
    			toneMappingName = 'Custom';
    			break;

    		default:
    			console.warn( 'THREE.WebGLProgram: Unsupported toneMapping:', toneMapping );
    			toneMappingName = 'Linear';

    	}

    	return 'vec3 ' + functionName + '( vec3 color ) { return ' + toneMappingName + 'ToneMapping( color ); }';

    }

    function generateExtensions( parameters ) {

    	const chunks = [
    		( parameters.extensionDerivatives || !! parameters.envMapCubeUVHeight || parameters.bumpMap || parameters.tangentSpaceNormalMap || parameters.clearcoatNormalMap || parameters.flatShading || parameters.shaderID === 'physical' ) ? '#extension GL_OES_standard_derivatives : enable' : '',
    		( parameters.extensionFragDepth || parameters.logarithmicDepthBuffer ) && parameters.rendererExtensionFragDepth ? '#extension GL_EXT_frag_depth : enable' : '',
    		( parameters.extensionDrawBuffers && parameters.rendererExtensionDrawBuffers ) ? '#extension GL_EXT_draw_buffers : require' : '',
    		( parameters.extensionShaderTextureLOD || parameters.envMap || parameters.transmission ) && parameters.rendererExtensionShaderTextureLod ? '#extension GL_EXT_shader_texture_lod : enable' : ''
    	];

    	return chunks.filter( filterEmptyLine ).join( '\n' );

    }

    function generateDefines( defines ) {

    	const chunks = [];

    	for ( const name in defines ) {

    		const value = defines[ name ];

    		if ( value === false ) continue;

    		chunks.push( '#define ' + name + ' ' + value );

    	}

    	return chunks.join( '\n' );

    }

    function fetchAttributeLocations( gl, program ) {

    	const attributes = {};

    	const n = gl.getProgramParameter( program, 35721 );

    	for ( let i = 0; i < n; i ++ ) {

    		const info = gl.getActiveAttrib( program, i );
    		const name = info.name;

    		let locationSize = 1;
    		if ( info.type === 35674 ) locationSize = 2;
    		if ( info.type === 35675 ) locationSize = 3;
    		if ( info.type === 35676 ) locationSize = 4;

    		// console.log( 'THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:', name, i );

    		attributes[ name ] = {
    			type: info.type,
    			location: gl.getAttribLocation( program, name ),
    			locationSize: locationSize
    		};

    	}

    	return attributes;

    }

    function filterEmptyLine( string ) {

    	return string !== '';

    }

    function replaceLightNums( string, parameters ) {

    	const numSpotLightCoords = parameters.numSpotLightShadows + parameters.numSpotLightMaps - parameters.numSpotLightShadowsWithMaps;

    	return string
    		.replace( /NUM_DIR_LIGHTS/g, parameters.numDirLights )
    		.replace( /NUM_SPOT_LIGHTS/g, parameters.numSpotLights )
    		.replace( /NUM_SPOT_LIGHT_MAPS/g, parameters.numSpotLightMaps )
    		.replace( /NUM_SPOT_LIGHT_COORDS/g, numSpotLightCoords )
    		.replace( /NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights )
    		.replace( /NUM_POINT_LIGHTS/g, parameters.numPointLights )
    		.replace( /NUM_HEMI_LIGHTS/g, parameters.numHemiLights )
    		.replace( /NUM_DIR_LIGHT_SHADOWS/g, parameters.numDirLightShadows )
    		.replace( /NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, parameters.numSpotLightShadowsWithMaps )
    		.replace( /NUM_SPOT_LIGHT_SHADOWS/g, parameters.numSpotLightShadows )
    		.replace( /NUM_POINT_LIGHT_SHADOWS/g, parameters.numPointLightShadows );

    }

    function replaceClippingPlaneNums( string, parameters ) {

    	return string
    		.replace( /NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes )
    		.replace( /UNION_CLIPPING_PLANES/g, ( parameters.numClippingPlanes - parameters.numClipIntersection ) );

    }

    // Resolve Includes

    const includePattern = /^[ \t]*#include +<([\w\d./]+)>/gm;

    function resolveIncludes( string ) {

    	return string.replace( includePattern, includeReplacer );

    }

    function includeReplacer( match, include ) {

    	const string = ShaderChunk[ include ];

    	if ( string === undefined ) {

    		throw new Error( 'Can not resolve #include <' + include + '>' );

    	}

    	return resolveIncludes( string );

    }

    // Unroll Loops

    const unrollLoopPattern = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;

    function unrollLoops( string ) {

    	return string.replace( unrollLoopPattern, loopReplacer );

    }

    function loopReplacer( match, start, end, snippet ) {

    	let string = '';

    	for ( let i = parseInt( start ); i < parseInt( end ); i ++ ) {

    		string += snippet
    			.replace( /\[\s*i\s*\]/g, '[ ' + i + ' ]' )
    			.replace( /UNROLLED_LOOP_INDEX/g, i );

    	}

    	return string;

    }

    //

    function generatePrecision( parameters ) {

    	let precisionstring = 'precision ' + parameters.precision + ' float;\nprecision ' + parameters.precision + ' int;';

    	if ( parameters.precision === 'highp' ) {

    		precisionstring += '\n#define HIGH_PRECISION';

    	} else if ( parameters.precision === 'mediump' ) {

    		precisionstring += '\n#define MEDIUM_PRECISION';

    	} else if ( parameters.precision === 'lowp' ) {

    		precisionstring += '\n#define LOW_PRECISION';

    	}

    	return precisionstring;

    }

    function generateShadowMapTypeDefine( parameters ) {

    	let shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';

    	if ( parameters.shadowMapType === PCFShadowMap ) {

    		shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';

    	} else if ( parameters.shadowMapType === PCFSoftShadowMap ) {

    		shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';

    	} else if ( parameters.shadowMapType === VSMShadowMap ) {

    		shadowMapTypeDefine = 'SHADOWMAP_TYPE_VSM';

    	}

    	return shadowMapTypeDefine;

    }

    function generateEnvMapTypeDefine( parameters ) {

    	let envMapTypeDefine = 'ENVMAP_TYPE_CUBE';

    	if ( parameters.envMap ) {

    		switch ( parameters.envMapMode ) {

    			case CubeReflectionMapping:
    			case CubeRefractionMapping:
    				envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
    				break;

    			case CubeUVReflectionMapping:
    				envMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';
    				break;

    		}

    	}

    	return envMapTypeDefine;

    }

    function generateEnvMapModeDefine( parameters ) {

    	let envMapModeDefine = 'ENVMAP_MODE_REFLECTION';

    	if ( parameters.envMap ) {

    		switch ( parameters.envMapMode ) {

    			case CubeRefractionMapping:

    				envMapModeDefine = 'ENVMAP_MODE_REFRACTION';
    				break;

    		}

    	}

    	return envMapModeDefine;

    }

    function generateEnvMapBlendingDefine( parameters ) {

    	let envMapBlendingDefine = 'ENVMAP_BLENDING_NONE';

    	if ( parameters.envMap ) {

    		switch ( parameters.combine ) {

    			case MultiplyOperation:
    				envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
    				break;

    			case MixOperation:
    				envMapBlendingDefine = 'ENVMAP_BLENDING_MIX';
    				break;

    			case AddOperation:
    				envMapBlendingDefine = 'ENVMAP_BLENDING_ADD';
    				break;

    		}

    	}

    	return envMapBlendingDefine;

    }

    function generateCubeUVSize( parameters ) {

    	const imageHeight = parameters.envMapCubeUVHeight;

    	if ( imageHeight === null ) return null;

    	const maxMip = Math.log2( imageHeight ) - 2;

    	const texelHeight = 1.0 / imageHeight;

    	const texelWidth = 1.0 / ( 3 * Math.max( Math.pow( 2, maxMip ), 7 * 16 ) );

    	return { texelWidth, texelHeight, maxMip };

    }

    function WebGLProgram( renderer, cacheKey, parameters, bindingStates ) {

    	// TODO Send this event to Three.js DevTools
    	// console.log( 'WebGLProgram', cacheKey );

    	const gl = renderer.getContext();

    	const defines = parameters.defines;

    	let vertexShader = parameters.vertexShader;
    	let fragmentShader = parameters.fragmentShader;

    	const shadowMapTypeDefine = generateShadowMapTypeDefine( parameters );
    	const envMapTypeDefine = generateEnvMapTypeDefine( parameters );
    	const envMapModeDefine = generateEnvMapModeDefine( parameters );
    	const envMapBlendingDefine = generateEnvMapBlendingDefine( parameters );
    	const envMapCubeUVSize = generateCubeUVSize( parameters );

    	const customExtensions = parameters.isWebGL2 ? '' : generateExtensions( parameters );

    	const customDefines = generateDefines( defines );

    	const program = gl.createProgram();

    	let prefixVertex, prefixFragment;
    	let versionString = parameters.glslVersion ? '#version ' + parameters.glslVersion + '\n' : '';

    	if ( parameters.isRawShaderMaterial ) {

    		prefixVertex = [

    			customDefines

    		].filter( filterEmptyLine ).join( '\n' );

    		if ( prefixVertex.length > 0 ) {

    			prefixVertex += '\n';

    		}

    		prefixFragment = [

    			customExtensions,
    			customDefines

    		].filter( filterEmptyLine ).join( '\n' );

    		if ( prefixFragment.length > 0 ) {

    			prefixFragment += '\n';

    		}

    	} else {

    		prefixVertex = [

    			generatePrecision( parameters ),

    			'#define SHADER_NAME ' + parameters.shaderName,

    			customDefines,

    			parameters.instancing ? '#define USE_INSTANCING' : '',
    			parameters.instancingColor ? '#define USE_INSTANCING_COLOR' : '',

    			parameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',

    			( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',
    			( parameters.useFog && parameters.fogExp2 ) ? '#define FOG_EXP2' : '',

    			parameters.map ? '#define USE_MAP' : '',
    			parameters.envMap ? '#define USE_ENVMAP' : '',
    			parameters.envMap ? '#define ' + envMapModeDefine : '',
    			parameters.lightMap ? '#define USE_LIGHTMAP' : '',
    			parameters.aoMap ? '#define USE_AOMAP' : '',
    			parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
    			parameters.bumpMap ? '#define USE_BUMPMAP' : '',
    			parameters.normalMap ? '#define USE_NORMALMAP' : '',
    			( parameters.normalMap && parameters.objectSpaceNormalMap ) ? '#define OBJECTSPACE_NORMALMAP' : '',
    			( parameters.normalMap && parameters.tangentSpaceNormalMap ) ? '#define TANGENTSPACE_NORMALMAP' : '',

    			parameters.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',
    			parameters.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '',
    			parameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',

    			parameters.iridescenceMap ? '#define USE_IRIDESCENCEMAP' : '',
    			parameters.iridescenceThicknessMap ? '#define USE_IRIDESCENCE_THICKNESSMAP' : '',

    			parameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '',

    			parameters.specularMap ? '#define USE_SPECULARMAP' : '',
    			parameters.specularIntensityMap ? '#define USE_SPECULARINTENSITYMAP' : '',
    			parameters.specularColorMap ? '#define USE_SPECULARCOLORMAP' : '',

    			parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
    			parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
    			parameters.alphaMap ? '#define USE_ALPHAMAP' : '',

    			parameters.transmission ? '#define USE_TRANSMISSION' : '',
    			parameters.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '',
    			parameters.thicknessMap ? '#define USE_THICKNESSMAP' : '',

    			parameters.sheenColorMap ? '#define USE_SHEENCOLORMAP' : '',
    			parameters.sheenRoughnessMap ? '#define USE_SHEENROUGHNESSMAP' : '',

    			parameters.vertexTangents ? '#define USE_TANGENT' : '',
    			parameters.vertexColors ? '#define USE_COLOR' : '',
    			parameters.vertexAlphas ? '#define USE_COLOR_ALPHA' : '',
    			parameters.vertexUvs ? '#define USE_UV' : '',
    			parameters.uvsVertexOnly ? '#define UVS_VERTEX_ONLY' : '',

    			parameters.flatShading ? '#define FLAT_SHADED' : '',

    			parameters.skinning ? '#define USE_SKINNING' : '',

    			parameters.morphTargets ? '#define USE_MORPHTARGETS' : '',
    			parameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '',
    			( parameters.morphColors && parameters.isWebGL2 ) ? '#define USE_MORPHCOLORS' : '',
    			( parameters.morphTargetsCount > 0 && parameters.isWebGL2 ) ? '#define MORPHTARGETS_TEXTURE' : '',
    			( parameters.morphTargetsCount > 0 && parameters.isWebGL2 ) ? '#define MORPHTARGETS_TEXTURE_STRIDE ' + parameters.morphTextureStride : '',
    			( parameters.morphTargetsCount > 0 && parameters.isWebGL2 ) ? '#define MORPHTARGETS_COUNT ' + parameters.morphTargetsCount : '',
    			parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
    			parameters.flipSided ? '#define FLIP_SIDED' : '',

    			parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
    			parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',

    			parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',

    			parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
    			( parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ) ? '#define USE_LOGDEPTHBUF_EXT' : '',

    			'uniform mat4 modelMatrix;',
    			'uniform mat4 modelViewMatrix;',
    			'uniform mat4 projectionMatrix;',
    			'uniform mat4 viewMatrix;',
    			'uniform mat3 normalMatrix;',
    			'uniform vec3 cameraPosition;',
    			'uniform bool isOrthographic;',

    			'#ifdef USE_INSTANCING',

    			'	attribute mat4 instanceMatrix;',

    			'#endif',

    			'#ifdef USE_INSTANCING_COLOR',

    			'	attribute vec3 instanceColor;',

    			'#endif',

    			'attribute vec3 position;',
    			'attribute vec3 normal;',
    			'attribute vec2 uv;',

    			'#ifdef USE_TANGENT',

    			'	attribute vec4 tangent;',

    			'#endif',

    			'#if defined( USE_COLOR_ALPHA )',

    			'	attribute vec4 color;',

    			'#elif defined( USE_COLOR )',

    			'	attribute vec3 color;',

    			'#endif',

    			'#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )',

    			'	attribute vec3 morphTarget0;',
    			'	attribute vec3 morphTarget1;',
    			'	attribute vec3 morphTarget2;',
    			'	attribute vec3 morphTarget3;',

    			'	#ifdef USE_MORPHNORMALS',

    			'		attribute vec3 morphNormal0;',
    			'		attribute vec3 morphNormal1;',
    			'		attribute vec3 morphNormal2;',
    			'		attribute vec3 morphNormal3;',

    			'	#else',

    			'		attribute vec3 morphTarget4;',
    			'		attribute vec3 morphTarget5;',
    			'		attribute vec3 morphTarget6;',
    			'		attribute vec3 morphTarget7;',

    			'	#endif',

    			'#endif',

    			'#ifdef USE_SKINNING',

    			'	attribute vec4 skinIndex;',
    			'	attribute vec4 skinWeight;',

    			'#endif',

    			'\n'

    		].filter( filterEmptyLine ).join( '\n' );

    		prefixFragment = [

    			customExtensions,

    			generatePrecision( parameters ),

    			'#define SHADER_NAME ' + parameters.shaderName,

    			customDefines,

    			( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',
    			( parameters.useFog && parameters.fogExp2 ) ? '#define FOG_EXP2' : '',

    			parameters.map ? '#define USE_MAP' : '',
    			parameters.matcap ? '#define USE_MATCAP' : '',
    			parameters.envMap ? '#define USE_ENVMAP' : '',
    			parameters.envMap ? '#define ' + envMapTypeDefine : '',
    			parameters.envMap ? '#define ' + envMapModeDefine : '',
    			parameters.envMap ? '#define ' + envMapBlendingDefine : '',
    			envMapCubeUVSize ? '#define CUBEUV_TEXEL_WIDTH ' + envMapCubeUVSize.texelWidth : '',
    			envMapCubeUVSize ? '#define CUBEUV_TEXEL_HEIGHT ' + envMapCubeUVSize.texelHeight : '',
    			envMapCubeUVSize ? '#define CUBEUV_MAX_MIP ' + envMapCubeUVSize.maxMip + '.0' : '',
    			parameters.lightMap ? '#define USE_LIGHTMAP' : '',
    			parameters.aoMap ? '#define USE_AOMAP' : '',
    			parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
    			parameters.bumpMap ? '#define USE_BUMPMAP' : '',
    			parameters.normalMap ? '#define USE_NORMALMAP' : '',
    			( parameters.normalMap && parameters.objectSpaceNormalMap ) ? '#define OBJECTSPACE_NORMALMAP' : '',
    			( parameters.normalMap && parameters.tangentSpaceNormalMap ) ? '#define TANGENTSPACE_NORMALMAP' : '',

    			parameters.clearcoat ? '#define USE_CLEARCOAT' : '',
    			parameters.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',
    			parameters.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '',
    			parameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',

    			parameters.iridescence ? '#define USE_IRIDESCENCE' : '',
    			parameters.iridescenceMap ? '#define USE_IRIDESCENCEMAP' : '',
    			parameters.iridescenceThicknessMap ? '#define USE_IRIDESCENCE_THICKNESSMAP' : '',

    			parameters.specularMap ? '#define USE_SPECULARMAP' : '',
    			parameters.specularIntensityMap ? '#define USE_SPECULARINTENSITYMAP' : '',
    			parameters.specularColorMap ? '#define USE_SPECULARCOLORMAP' : '',
    			parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
    			parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',

    			parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
    			parameters.alphaTest ? '#define USE_ALPHATEST' : '',

    			parameters.sheen ? '#define USE_SHEEN' : '',
    			parameters.sheenColorMap ? '#define USE_SHEENCOLORMAP' : '',
    			parameters.sheenRoughnessMap ? '#define USE_SHEENROUGHNESSMAP' : '',

    			parameters.transmission ? '#define USE_TRANSMISSION' : '',
    			parameters.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '',
    			parameters.thicknessMap ? '#define USE_THICKNESSMAP' : '',

    			parameters.decodeVideoTexture ? '#define DECODE_VIDEO_TEXTURE' : '',

    			parameters.vertexTangents ? '#define USE_TANGENT' : '',
    			parameters.vertexColors || parameters.instancingColor ? '#define USE_COLOR' : '',
    			parameters.vertexAlphas ? '#define USE_COLOR_ALPHA' : '',
    			parameters.vertexUvs ? '#define USE_UV' : '',
    			parameters.uvsVertexOnly ? '#define UVS_VERTEX_ONLY' : '',

    			parameters.gradientMap ? '#define USE_GRADIENTMAP' : '',

    			parameters.flatShading ? '#define FLAT_SHADED' : '',

    			parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
    			parameters.flipSided ? '#define FLIP_SIDED' : '',

    			parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
    			parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',

    			parameters.premultipliedAlpha ? '#define PREMULTIPLIED_ALPHA' : '',

    			parameters.physicallyCorrectLights ? '#define PHYSICALLY_CORRECT_LIGHTS' : '',

    			parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
    			( parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ) ? '#define USE_LOGDEPTHBUF_EXT' : '',

    			'uniform mat4 viewMatrix;',
    			'uniform vec3 cameraPosition;',
    			'uniform bool isOrthographic;',

    			( parameters.toneMapping !== NoToneMapping ) ? '#define TONE_MAPPING' : '',
    			( parameters.toneMapping !== NoToneMapping ) ? ShaderChunk[ 'tonemapping_pars_fragment' ] : '', // this code is required here because it is used by the toneMapping() function defined below
    			( parameters.toneMapping !== NoToneMapping ) ? getToneMappingFunction( 'toneMapping', parameters.toneMapping ) : '',

    			parameters.dithering ? '#define DITHERING' : '',
    			parameters.opaque ? '#define OPAQUE' : '',

    			ShaderChunk[ 'encodings_pars_fragment' ], // this code is required here because it is used by the various encoding/decoding function defined below
    			getTexelEncodingFunction( 'linearToOutputTexel', parameters.outputEncoding ),

    			parameters.useDepthPacking ? '#define DEPTH_PACKING ' + parameters.depthPacking : '',

    			'\n'

    		].filter( filterEmptyLine ).join( '\n' );

    	}

    	vertexShader = resolveIncludes( vertexShader );
    	vertexShader = replaceLightNums( vertexShader, parameters );
    	vertexShader = replaceClippingPlaneNums( vertexShader, parameters );

    	fragmentShader = resolveIncludes( fragmentShader );
    	fragmentShader = replaceLightNums( fragmentShader, parameters );
    	fragmentShader = replaceClippingPlaneNums( fragmentShader, parameters );

    	vertexShader = unrollLoops( vertexShader );
    	fragmentShader = unrollLoops( fragmentShader );

    	if ( parameters.isWebGL2 && parameters.isRawShaderMaterial !== true ) {

    		// GLSL 3.0 conversion for built-in materials and ShaderMaterial

    		versionString = '#version 300 es\n';

    		prefixVertex = [
    			'precision mediump sampler2DArray;',
    			'#define attribute in',
    			'#define varying out',
    			'#define texture2D texture'
    		].join( '\n' ) + '\n' + prefixVertex;

    		prefixFragment = [
    			'#define varying in',
    			( parameters.glslVersion === GLSL3 ) ? '' : 'layout(location = 0) out highp vec4 pc_fragColor;',
    			( parameters.glslVersion === GLSL3 ) ? '' : '#define gl_FragColor pc_fragColor',
    			'#define gl_FragDepthEXT gl_FragDepth',
    			'#define texture2D texture',
    			'#define textureCube texture',
    			'#define texture2DProj textureProj',
    			'#define texture2DLodEXT textureLod',
    			'#define texture2DProjLodEXT textureProjLod',
    			'#define textureCubeLodEXT textureLod',
    			'#define texture2DGradEXT textureGrad',
    			'#define texture2DProjGradEXT textureProjGrad',
    			'#define textureCubeGradEXT textureGrad'
    		].join( '\n' ) + '\n' + prefixFragment;

    	}

    	const vertexGlsl = versionString + prefixVertex + vertexShader;
    	const fragmentGlsl = versionString + prefixFragment + fragmentShader;

    	// console.log( '*VERTEX*', vertexGlsl );
    	// console.log( '*FRAGMENT*', fragmentGlsl );

    	const glVertexShader = WebGLShader( gl, 35633, vertexGlsl );
    	const glFragmentShader = WebGLShader( gl, 35632, fragmentGlsl );

    	gl.attachShader( program, glVertexShader );
    	gl.attachShader( program, glFragmentShader );

    	// Force a particular attribute to index 0.

    	if ( parameters.index0AttributeName !== undefined ) {

    		gl.bindAttribLocation( program, 0, parameters.index0AttributeName );

    	} else if ( parameters.morphTargets === true ) {

    		// programs with morphTargets displace position out of attribute 0
    		gl.bindAttribLocation( program, 0, 'position' );

    	}

    	gl.linkProgram( program );

    	// check for link errors
    	if ( renderer.debug.checkShaderErrors ) {

    		const programLog = gl.getProgramInfoLog( program ).trim();
    		const vertexLog = gl.getShaderInfoLog( glVertexShader ).trim();
    		const fragmentLog = gl.getShaderInfoLog( glFragmentShader ).trim();

    		let runnable = true;
    		let haveDiagnostics = true;

    		if ( gl.getProgramParameter( program, 35714 ) === false ) {

    			runnable = false;

    			const vertexErrors = getShaderErrors( gl, glVertexShader, 'vertex' );
    			const fragmentErrors = getShaderErrors( gl, glFragmentShader, 'fragment' );

    			console.error(
    				'THREE.WebGLProgram: Shader Error ' + gl.getError() + ' - ' +
    				'VALIDATE_STATUS ' + gl.getProgramParameter( program, 35715 ) + '\n\n' +
    				'Program Info Log: ' + programLog + '\n' +
    				vertexErrors + '\n' +
    				fragmentErrors
    			);

    		} else if ( programLog !== '' ) {

    			console.warn( 'THREE.WebGLProgram: Program Info Log:', programLog );

    		} else if ( vertexLog === '' || fragmentLog === '' ) {

    			haveDiagnostics = false;

    		}

    		if ( haveDiagnostics ) {

    			this.diagnostics = {

    				runnable: runnable,

    				programLog: programLog,

    				vertexShader: {

    					log: vertexLog,
    					prefix: prefixVertex

    				},

    				fragmentShader: {

    					log: fragmentLog,
    					prefix: prefixFragment

    				}

    			};

    		}

    	}

    	// Clean up

    	// Crashes in iOS9 and iOS10. #18402
    	// gl.detachShader( program, glVertexShader );
    	// gl.detachShader( program, glFragmentShader );

    	gl.deleteShader( glVertexShader );
    	gl.deleteShader( glFragmentShader );

    	// set up caching for uniform locations

    	let cachedUniforms;

    	this.getUniforms = function () {

    		if ( cachedUniforms === undefined ) {

    			cachedUniforms = new WebGLUniforms( gl, program );

    		}

    		return cachedUniforms;

    	};

    	// set up caching for attribute locations

    	let cachedAttributes;

    	this.getAttributes = function () {

    		if ( cachedAttributes === undefined ) {

    			cachedAttributes = fetchAttributeLocations( gl, program );

    		}

    		return cachedAttributes;

    	};

    	// free resource

    	this.destroy = function () {

    		bindingStates.releaseStatesOfProgram( this );

    		gl.deleteProgram( program );
    		this.program = undefined;

    	};

    	//

    	this.name = parameters.shaderName;
    	this.id = programIdCount ++;
    	this.cacheKey = cacheKey;
    	this.usedTimes = 1;
    	this.program = program;
    	this.vertexShader = glVertexShader;
    	this.fragmentShader = glFragmentShader;

    	return this;

    }

    let _id = 0;

    class WebGLShaderCache {

    	constructor() {

    		this.shaderCache = new Map();
    		this.materialCache = new Map();

    	}

    	update( material ) {

    		const vertexShader = material.vertexShader;
    		const fragmentShader = material.fragmentShader;

    		const vertexShaderStage = this._getShaderStage( vertexShader );
    		const fragmentShaderStage = this._getShaderStage( fragmentShader );

    		const materialShaders = this._getShaderCacheForMaterial( material );

    		if ( materialShaders.has( vertexShaderStage ) === false ) {

    			materialShaders.add( vertexShaderStage );
    			vertexShaderStage.usedTimes ++;

    		}

    		if ( materialShaders.has( fragmentShaderStage ) === false ) {

    			materialShaders.add( fragmentShaderStage );
    			fragmentShaderStage.usedTimes ++;

    		}

    		return this;

    	}

    	remove( material ) {

    		const materialShaders = this.materialCache.get( material );

    		for ( const shaderStage of materialShaders ) {

    			shaderStage.usedTimes --;

    			if ( shaderStage.usedTimes === 0 ) this.shaderCache.delete( shaderStage.code );

    		}

    		this.materialCache.delete( material );

    		return this;

    	}

    	getVertexShaderID( material ) {

    		return this._getShaderStage( material.vertexShader ).id;

    	}

    	getFragmentShaderID( material ) {

    		return this._getShaderStage( material.fragmentShader ).id;

    	}

    	dispose() {

    		this.shaderCache.clear();
    		this.materialCache.clear();

    	}

    	_getShaderCacheForMaterial( material ) {

    		const cache = this.materialCache;
    		let set = cache.get( material );

    		if ( set === undefined ) {

    			set = new Set();
    			cache.set( material, set );

    		}

    		return set;

    	}

    	_getShaderStage( code ) {

    		const cache = this.shaderCache;
    		let stage = cache.get( code );

    		if ( stage === undefined ) {

    			stage = new WebGLShaderStage( code );
    			cache.set( code, stage );

    		}

    		return stage;

    	}

    }

    class WebGLShaderStage {

    	constructor( code ) {

    		this.id = _id ++;

    		this.code = code;
    		this.usedTimes = 0;

    	}

    }

    function WebGLPrograms( renderer, cubemaps, cubeuvmaps, extensions, capabilities, bindingStates, clipping ) {

    	const _programLayers = new Layers();
    	const _customShaders = new WebGLShaderCache();
    	const programs = [];

    	const isWebGL2 = capabilities.isWebGL2;
    	const logarithmicDepthBuffer = capabilities.logarithmicDepthBuffer;
    	const vertexTextures = capabilities.vertexTextures;
    	let precision = capabilities.precision;

    	const shaderIDs = {
    		MeshDepthMaterial: 'depth',
    		MeshDistanceMaterial: 'distanceRGBA',
    		MeshNormalMaterial: 'normal',
    		MeshBasicMaterial: 'basic',
    		MeshLambertMaterial: 'lambert',
    		MeshPhongMaterial: 'phong',
    		MeshToonMaterial: 'toon',
    		MeshStandardMaterial: 'physical',
    		MeshPhysicalMaterial: 'physical',
    		MeshMatcapMaterial: 'matcap',
    		LineBasicMaterial: 'basic',
    		LineDashedMaterial: 'dashed',
    		PointsMaterial: 'points',
    		ShadowMaterial: 'shadow',
    		SpriteMaterial: 'sprite'
    	};

    	function getParameters( material, lights, shadows, scene, object ) {

    		const fog = scene.fog;
    		const geometry = object.geometry;
    		const environment = material.isMeshStandardMaterial ? scene.environment : null;

    		const envMap = ( material.isMeshStandardMaterial ? cubeuvmaps : cubemaps ).get( material.envMap || environment );
    		const envMapCubeUVHeight = ( !! envMap ) && ( envMap.mapping === CubeUVReflectionMapping ) ? envMap.image.height : null;

    		const shaderID = shaderIDs[ material.type ];

    		// heuristics to create shader parameters according to lights in the scene
    		// (not to blow over maxLights budget)

    		if ( material.precision !== null ) {

    			precision = capabilities.getMaxPrecision( material.precision );

    			if ( precision !== material.precision ) {

    				console.warn( 'THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.' );

    			}

    		}

    		//

    		const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
    		const morphTargetsCount = ( morphAttribute !== undefined ) ? morphAttribute.length : 0;

    		let morphTextureStride = 0;

    		if ( geometry.morphAttributes.position !== undefined ) morphTextureStride = 1;
    		if ( geometry.morphAttributes.normal !== undefined ) morphTextureStride = 2;
    		if ( geometry.morphAttributes.color !== undefined ) morphTextureStride = 3;

    		//

    		let vertexShader, fragmentShader;
    		let customVertexShaderID, customFragmentShaderID;

    		if ( shaderID ) {

    			const shader = ShaderLib[ shaderID ];

    			vertexShader = shader.vertexShader;
    			fragmentShader = shader.fragmentShader;

    		} else {

    			vertexShader = material.vertexShader;
    			fragmentShader = material.fragmentShader;

    			_customShaders.update( material );

    			customVertexShaderID = _customShaders.getVertexShaderID( material );
    			customFragmentShaderID = _customShaders.getFragmentShaderID( material );

    		}

    		const currentRenderTarget = renderer.getRenderTarget();

    		const useAlphaTest = material.alphaTest > 0;
    		const useClearcoat = material.clearcoat > 0;
    		const useIridescence = material.iridescence > 0;

    		const parameters = {

    			isWebGL2: isWebGL2,

    			shaderID: shaderID,
    			shaderName: material.type,

    			vertexShader: vertexShader,
    			fragmentShader: fragmentShader,
    			defines: material.defines,

    			customVertexShaderID: customVertexShaderID,
    			customFragmentShaderID: customFragmentShaderID,

    			isRawShaderMaterial: material.isRawShaderMaterial === true,
    			glslVersion: material.glslVersion,

    			precision: precision,

    			instancing: object.isInstancedMesh === true,
    			instancingColor: object.isInstancedMesh === true && object.instanceColor !== null,

    			supportsVertexTextures: vertexTextures,
    			outputEncoding: ( currentRenderTarget === null ) ? renderer.outputEncoding : ( currentRenderTarget.isXRRenderTarget === true ? currentRenderTarget.texture.encoding : LinearEncoding ),
    			map: !! material.map,
    			matcap: !! material.matcap,
    			envMap: !! envMap,
    			envMapMode: envMap && envMap.mapping,
    			envMapCubeUVHeight: envMapCubeUVHeight,
    			lightMap: !! material.lightMap,
    			aoMap: !! material.aoMap,
    			emissiveMap: !! material.emissiveMap,
    			bumpMap: !! material.bumpMap,
    			normalMap: !! material.normalMap,
    			objectSpaceNormalMap: material.normalMapType === ObjectSpaceNormalMap,
    			tangentSpaceNormalMap: material.normalMapType === TangentSpaceNormalMap,

    			decodeVideoTexture: !! material.map && ( material.map.isVideoTexture === true ) && ( material.map.encoding === sRGBEncoding ),

    			clearcoat: useClearcoat,
    			clearcoatMap: useClearcoat && !! material.clearcoatMap,
    			clearcoatRoughnessMap: useClearcoat && !! material.clearcoatRoughnessMap,
    			clearcoatNormalMap: useClearcoat && !! material.clearcoatNormalMap,

    			iridescence: useIridescence,
    			iridescenceMap: useIridescence && !! material.iridescenceMap,
    			iridescenceThicknessMap: useIridescence && !! material.iridescenceThicknessMap,

    			displacementMap: !! material.displacementMap,
    			roughnessMap: !! material.roughnessMap,
    			metalnessMap: !! material.metalnessMap,
    			specularMap: !! material.specularMap,
    			specularIntensityMap: !! material.specularIntensityMap,
    			specularColorMap: !! material.specularColorMap,

    			opaque: material.transparent === false && material.blending === NormalBlending,

    			alphaMap: !! material.alphaMap,
    			alphaTest: useAlphaTest,

    			gradientMap: !! material.gradientMap,

    			sheen: material.sheen > 0,
    			sheenColorMap: !! material.sheenColorMap,
    			sheenRoughnessMap: !! material.sheenRoughnessMap,

    			transmission: material.transmission > 0,
    			transmissionMap: !! material.transmissionMap,
    			thicknessMap: !! material.thicknessMap,

    			combine: material.combine,

    			vertexTangents: ( !! material.normalMap && !! geometry.attributes.tangent ),
    			vertexColors: material.vertexColors,
    			vertexAlphas: material.vertexColors === true && !! geometry.attributes.color && geometry.attributes.color.itemSize === 4,
    			vertexUvs: !! material.map || !! material.bumpMap || !! material.normalMap || !! material.specularMap || !! material.alphaMap || !! material.emissiveMap || !! material.roughnessMap || !! material.metalnessMap || !! material.clearcoatMap || !! material.clearcoatRoughnessMap || !! material.clearcoatNormalMap || !! material.iridescenceMap || !! material.iridescenceThicknessMap || !! material.displacementMap || !! material.transmissionMap || !! material.thicknessMap || !! material.specularIntensityMap || !! material.specularColorMap || !! material.sheenColorMap || !! material.sheenRoughnessMap,
    			uvsVertexOnly: ! ( !! material.map || !! material.bumpMap || !! material.normalMap || !! material.specularMap || !! material.alphaMap || !! material.emissiveMap || !! material.roughnessMap || !! material.metalnessMap || !! material.clearcoatNormalMap || !! material.iridescenceMap || !! material.iridescenceThicknessMap || material.transmission > 0 || !! material.transmissionMap || !! material.thicknessMap || !! material.specularIntensityMap || !! material.specularColorMap || material.sheen > 0 || !! material.sheenColorMap || !! material.sheenRoughnessMap ) && !! material.displacementMap,

    			fog: !! fog,
    			useFog: material.fog === true,
    			fogExp2: ( fog && fog.isFogExp2 ),

    			flatShading: !! material.flatShading,

    			sizeAttenuation: material.sizeAttenuation,
    			logarithmicDepthBuffer: logarithmicDepthBuffer,

    			skinning: object.isSkinnedMesh === true,

    			morphTargets: geometry.morphAttributes.position !== undefined,
    			morphNormals: geometry.morphAttributes.normal !== undefined,
    			morphColors: geometry.morphAttributes.color !== undefined,
    			morphTargetsCount: morphTargetsCount,
    			morphTextureStride: morphTextureStride,

    			numDirLights: lights.directional.length,
    			numPointLights: lights.point.length,
    			numSpotLights: lights.spot.length,
    			numSpotLightMaps: lights.spotLightMap.length,
    			numRectAreaLights: lights.rectArea.length,
    			numHemiLights: lights.hemi.length,

    			numDirLightShadows: lights.directionalShadowMap.length,
    			numPointLightShadows: lights.pointShadowMap.length,
    			numSpotLightShadows: lights.spotShadowMap.length,
    			numSpotLightShadowsWithMaps: lights.numSpotLightShadowsWithMaps,

    			numClippingPlanes: clipping.numPlanes,
    			numClipIntersection: clipping.numIntersection,

    			dithering: material.dithering,

    			shadowMapEnabled: renderer.shadowMap.enabled && shadows.length > 0,
    			shadowMapType: renderer.shadowMap.type,

    			toneMapping: material.toneMapped ? renderer.toneMapping : NoToneMapping,
    			physicallyCorrectLights: renderer.physicallyCorrectLights,

    			premultipliedAlpha: material.premultipliedAlpha,

    			doubleSided: material.side === DoubleSide,
    			flipSided: material.side === BackSide,

    			useDepthPacking: !! material.depthPacking,
    			depthPacking: material.depthPacking || 0,

    			index0AttributeName: material.index0AttributeName,

    			extensionDerivatives: material.extensions && material.extensions.derivatives,
    			extensionFragDepth: material.extensions && material.extensions.fragDepth,
    			extensionDrawBuffers: material.extensions && material.extensions.drawBuffers,
    			extensionShaderTextureLOD: material.extensions && material.extensions.shaderTextureLOD,

    			rendererExtensionFragDepth: isWebGL2 || extensions.has( 'EXT_frag_depth' ),
    			rendererExtensionDrawBuffers: isWebGL2 || extensions.has( 'WEBGL_draw_buffers' ),
    			rendererExtensionShaderTextureLod: isWebGL2 || extensions.has( 'EXT_shader_texture_lod' ),

    			customProgramCacheKey: material.customProgramCacheKey()

    		};

    		return parameters;

    	}

    	function getProgramCacheKey( parameters ) {

    		const array = [];

    		if ( parameters.shaderID ) {

    			array.push( parameters.shaderID );

    		} else {

    			array.push( parameters.customVertexShaderID );
    			array.push( parameters.customFragmentShaderID );

    		}

    		if ( parameters.defines !== undefined ) {

    			for ( const name in parameters.defines ) {

    				array.push( name );
    				array.push( parameters.defines[ name ] );

    			}

    		}

    		if ( parameters.isRawShaderMaterial === false ) {

    			getProgramCacheKeyParameters( array, parameters );
    			getProgramCacheKeyBooleans( array, parameters );
    			array.push( renderer.outputEncoding );

    		}

    		array.push( parameters.customProgramCacheKey );

    		return array.join();

    	}

    	function getProgramCacheKeyParameters( array, parameters ) {

    		array.push( parameters.precision );
    		array.push( parameters.outputEncoding );
    		array.push( parameters.envMapMode );
    		array.push( parameters.envMapCubeUVHeight );
    		array.push( parameters.combine );
    		array.push( parameters.vertexUvs );
    		array.push( parameters.fogExp2 );
    		array.push( parameters.sizeAttenuation );
    		array.push( parameters.morphTargetsCount );
    		array.push( parameters.morphAttributeCount );
    		array.push( parameters.numDirLights );
    		array.push( parameters.numPointLights );
    		array.push( parameters.numSpotLights );
    		array.push( parameters.numSpotLightMaps );
    		array.push( parameters.numHemiLights );
    		array.push( parameters.numRectAreaLights );
    		array.push( parameters.numDirLightShadows );
    		array.push( parameters.numPointLightShadows );
    		array.push( parameters.numSpotLightShadows );
    		array.push( parameters.numSpotLightShadowsWithMaps );
    		array.push( parameters.shadowMapType );
    		array.push( parameters.toneMapping );
    		array.push( parameters.numClippingPlanes );
    		array.push( parameters.numClipIntersection );
    		array.push( parameters.depthPacking );

    	}

    	function getProgramCacheKeyBooleans( array, parameters ) {

    		_programLayers.disableAll();

    		if ( parameters.isWebGL2 )
    			_programLayers.enable( 0 );
    		if ( parameters.supportsVertexTextures )
    			_programLayers.enable( 1 );
    		if ( parameters.instancing )
    			_programLayers.enable( 2 );
    		if ( parameters.instancingColor )
    			_programLayers.enable( 3 );
    		if ( parameters.map )
    			_programLayers.enable( 4 );
    		if ( parameters.matcap )
    			_programLayers.enable( 5 );
    		if ( parameters.envMap )
    			_programLayers.enable( 6 );
    		if ( parameters.lightMap )
    			_programLayers.enable( 7 );
    		if ( parameters.aoMap )
    			_programLayers.enable( 8 );
    		if ( parameters.emissiveMap )
    			_programLayers.enable( 9 );
    		if ( parameters.bumpMap )
    			_programLayers.enable( 10 );
    		if ( parameters.normalMap )
    			_programLayers.enable( 11 );
    		if ( parameters.objectSpaceNormalMap )
    			_programLayers.enable( 12 );
    		if ( parameters.tangentSpaceNormalMap )
    			_programLayers.enable( 13 );
    		if ( parameters.clearcoat )
    			_programLayers.enable( 14 );
    		if ( parameters.clearcoatMap )
    			_programLayers.enable( 15 );
    		if ( parameters.clearcoatRoughnessMap )
    			_programLayers.enable( 16 );
    		if ( parameters.clearcoatNormalMap )
    			_programLayers.enable( 17 );
    		if ( parameters.iridescence )
    			_programLayers.enable( 18 );
    		if ( parameters.iridescenceMap )
    			_programLayers.enable( 19 );
    		if ( parameters.iridescenceThicknessMap )
    			_programLayers.enable( 20 );
    		if ( parameters.displacementMap )
    			_programLayers.enable( 21 );
    		if ( parameters.specularMap )
    			_programLayers.enable( 22 );
    		if ( parameters.roughnessMap )
    			_programLayers.enable( 23 );
    		if ( parameters.metalnessMap )
    			_programLayers.enable( 24 );
    		if ( parameters.gradientMap )
    			_programLayers.enable( 25 );
    		if ( parameters.alphaMap )
    			_programLayers.enable( 26 );
    		if ( parameters.alphaTest )
    			_programLayers.enable( 27 );
    		if ( parameters.vertexColors )
    			_programLayers.enable( 28 );
    		if ( parameters.vertexAlphas )
    			_programLayers.enable( 29 );
    		if ( parameters.vertexUvs )
    			_programLayers.enable( 30 );
    		if ( parameters.vertexTangents )
    			_programLayers.enable( 31 );
    		if ( parameters.uvsVertexOnly )
    			_programLayers.enable( 32 );

    		array.push( _programLayers.mask );
    		_programLayers.disableAll();

    		if ( parameters.fog )
    			_programLayers.enable( 0 );
    		if ( parameters.useFog )
    			_programLayers.enable( 1 );
    		if ( parameters.flatShading )
    			_programLayers.enable( 2 );
    		if ( parameters.logarithmicDepthBuffer )
    			_programLayers.enable( 3 );
    		if ( parameters.skinning )
    			_programLayers.enable( 4 );
    		if ( parameters.morphTargets )
    			_programLayers.enable( 5 );
    		if ( parameters.morphNormals )
    			_programLayers.enable( 6 );
    		if ( parameters.morphColors )
    			_programLayers.enable( 7 );
    		if ( parameters.premultipliedAlpha )
    			_programLayers.enable( 8 );
    		if ( parameters.shadowMapEnabled )
    			_programLayers.enable( 9 );
    		if ( parameters.physicallyCorrectLights )
    			_programLayers.enable( 10 );
    		if ( parameters.doubleSided )
    			_programLayers.enable( 11 );
    		if ( parameters.flipSided )
    			_programLayers.enable( 12 );
    		if ( parameters.useDepthPacking )
    			_programLayers.enable( 13 );
    		if ( parameters.dithering )
    			_programLayers.enable( 14 );
    		if ( parameters.specularIntensityMap )
    			_programLayers.enable( 15 );
    		if ( parameters.specularColorMap )
    			_programLayers.enable( 16 );
    		if ( parameters.transmission )
    			_programLayers.enable( 17 );
    		if ( parameters.transmissionMap )
    			_programLayers.enable( 18 );
    		if ( parameters.thicknessMap )
    			_programLayers.enable( 19 );
    		if ( parameters.sheen )
    			_programLayers.enable( 20 );
    		if ( parameters.sheenColorMap )
    			_programLayers.enable( 21 );
    		if ( parameters.sheenRoughnessMap )
    			_programLayers.enable( 22 );
    		if ( parameters.decodeVideoTexture )
    			_programLayers.enable( 23 );
    		if ( parameters.opaque )
    			_programLayers.enable( 24 );

    		array.push( _programLayers.mask );

    	}

    	function getUniforms( material ) {

    		const shaderID = shaderIDs[ material.type ];
    		let uniforms;

    		if ( shaderID ) {

    			const shader = ShaderLib[ shaderID ];
    			uniforms = UniformsUtils.clone( shader.uniforms );

    		} else {

    			uniforms = material.uniforms;

    		}

    		return uniforms;

    	}

    	function acquireProgram( parameters, cacheKey ) {

    		let program;

    		// Check if code has been already compiled
    		for ( let p = 0, pl = programs.length; p < pl; p ++ ) {

    			const preexistingProgram = programs[ p ];

    			if ( preexistingProgram.cacheKey === cacheKey ) {

    				program = preexistingProgram;
    				++ program.usedTimes;

    				break;

    			}

    		}

    		if ( program === undefined ) {

    			program = new WebGLProgram( renderer, cacheKey, parameters, bindingStates );
    			programs.push( program );

    		}

    		return program;

    	}

    	function releaseProgram( program ) {

    		if ( -- program.usedTimes === 0 ) {

    			// Remove from unordered set
    			const i = programs.indexOf( program );
    			programs[ i ] = programs[ programs.length - 1 ];
    			programs.pop();

    			// Free WebGL resources
    			program.destroy();

    		}

    	}

    	function releaseShaderCache( material ) {

    		_customShaders.remove( material );

    	}

    	function dispose() {

    		_customShaders.dispose();

    	}

    	return {
    		getParameters: getParameters,
    		getProgramCacheKey: getProgramCacheKey,
    		getUniforms: getUniforms,
    		acquireProgram: acquireProgram,
    		releaseProgram: releaseProgram,
    		releaseShaderCache: releaseShaderCache,
    		// Exposed for resource monitoring & error feedback via renderer.info:
    		programs: programs,
    		dispose: dispose
    	};

    }

    function WebGLProperties() {

    	let properties = new WeakMap();

    	function get( object ) {

    		let map = properties.get( object );

    		if ( map === undefined ) {

    			map = {};
    			properties.set( object, map );

    		}

    		return map;

    	}

    	function remove( object ) {

    		properties.delete( object );

    	}

    	function update( object, key, value ) {

    		properties.get( object )[ key ] = value;

    	}

    	function dispose() {

    		properties = new WeakMap();

    	}

    	return {
    		get: get,
    		remove: remove,
    		update: update,
    		dispose: dispose
    	};

    }

    function painterSortStable( a, b ) {

    	if ( a.groupOrder !== b.groupOrder ) {

    		return a.groupOrder - b.groupOrder;

    	} else if ( a.renderOrder !== b.renderOrder ) {

    		return a.renderOrder - b.renderOrder;

    	} else if ( a.material.id !== b.material.id ) {

    		return a.material.id - b.material.id;

    	} else if ( a.z !== b.z ) {

    		return a.z - b.z;

    	} else {

    		return a.id - b.id;

    	}

    }

    function reversePainterSortStable( a, b ) {

    	if ( a.groupOrder !== b.groupOrder ) {

    		return a.groupOrder - b.groupOrder;

    	} else if ( a.renderOrder !== b.renderOrder ) {

    		return a.renderOrder - b.renderOrder;

    	} else if ( a.z !== b.z ) {

    		return b.z - a.z;

    	} else {

    		return a.id - b.id;

    	}

    }


    function WebGLRenderList() {

    	const renderItems = [];
    	let renderItemsIndex = 0;

    	const opaque = [];
    	const transmissive = [];
    	const transparent = [];

    	function init() {

    		renderItemsIndex = 0;

    		opaque.length = 0;
    		transmissive.length = 0;
    		transparent.length = 0;

    	}

    	function getNextRenderItem( object, geometry, material, groupOrder, z, group ) {

    		let renderItem = renderItems[ renderItemsIndex ];

    		if ( renderItem === undefined ) {

    			renderItem = {
    				id: object.id,
    				object: object,
    				geometry: geometry,
    				material: material,
    				groupOrder: groupOrder,
    				renderOrder: object.renderOrder,
    				z: z,
    				group: group
    			};

    			renderItems[ renderItemsIndex ] = renderItem;

    		} else {

    			renderItem.id = object.id;
    			renderItem.object = object;
    			renderItem.geometry = geometry;
    			renderItem.material = material;
    			renderItem.groupOrder = groupOrder;
    			renderItem.renderOrder = object.renderOrder;
    			renderItem.z = z;
    			renderItem.group = group;

    		}

    		renderItemsIndex ++;

    		return renderItem;

    	}

    	function push( object, geometry, material, groupOrder, z, group ) {

    		const renderItem = getNextRenderItem( object, geometry, material, groupOrder, z, group );

    		if ( material.transmission > 0.0 ) {

    			transmissive.push( renderItem );

    		} else if ( material.transparent === true ) {

    			transparent.push( renderItem );

    		} else {

    			opaque.push( renderItem );

    		}

    	}

    	function unshift( object, geometry, material, groupOrder, z, group ) {

    		const renderItem = getNextRenderItem( object, geometry, material, groupOrder, z, group );

    		if ( material.transmission > 0.0 ) {

    			transmissive.unshift( renderItem );

    		} else if ( material.transparent === true ) {

    			transparent.unshift( renderItem );

    		} else {

    			opaque.unshift( renderItem );

    		}

    	}

    	function sort( customOpaqueSort, customTransparentSort ) {

    		if ( opaque.length > 1 ) opaque.sort( customOpaqueSort || painterSortStable );
    		if ( transmissive.length > 1 ) transmissive.sort( customTransparentSort || reversePainterSortStable );
    		if ( transparent.length > 1 ) transparent.sort( customTransparentSort || reversePainterSortStable );

    	}

    	function finish() {

    		// Clear references from inactive renderItems in the list

    		for ( let i = renderItemsIndex, il = renderItems.length; i < il; i ++ ) {

    			const renderItem = renderItems[ i ];

    			if ( renderItem.id === null ) break;

    			renderItem.id = null;
    			renderItem.object = null;
    			renderItem.geometry = null;
    			renderItem.material = null;
    			renderItem.group = null;

    		}

    	}

    	return {

    		opaque: opaque,
    		transmissive: transmissive,
    		transparent: transparent,

    		init: init,
    		push: push,
    		unshift: unshift,
    		finish: finish,

    		sort: sort
    	};

    }

    function WebGLRenderLists() {

    	let lists = new WeakMap();

    	function get( scene, renderCallDepth ) {

    		const listArray = lists.get( scene );
    		let list;

    		if ( listArray === undefined ) {

    			list = new WebGLRenderList();
    			lists.set( scene, [ list ] );

    		} else {

    			if ( renderCallDepth >= listArray.length ) {

    				list = new WebGLRenderList();
    				listArray.push( list );

    			} else {

    				list = listArray[ renderCallDepth ];

    			}

    		}

    		return list;

    	}

    	function dispose() {

    		lists = new WeakMap();

    	}

    	return {
    		get: get,
    		dispose: dispose
    	};

    }

    function UniformsCache() {

    	const lights = {};

    	return {

    		get: function ( light ) {

    			if ( lights[ light.id ] !== undefined ) {

    				return lights[ light.id ];

    			}

    			let uniforms;

    			switch ( light.type ) {

    				case 'DirectionalLight':
    					uniforms = {
    						direction: new Vector3(),
    						color: new Color$1()
    					};
    					break;

    				case 'SpotLight':
    					uniforms = {
    						position: new Vector3(),
    						direction: new Vector3(),
    						color: new Color$1(),
    						distance: 0,
    						coneCos: 0,
    						penumbraCos: 0,
    						decay: 0
    					};
    					break;

    				case 'PointLight':
    					uniforms = {
    						position: new Vector3(),
    						color: new Color$1(),
    						distance: 0,
    						decay: 0
    					};
    					break;

    				case 'HemisphereLight':
    					uniforms = {
    						direction: new Vector3(),
    						skyColor: new Color$1(),
    						groundColor: new Color$1()
    					};
    					break;

    				case 'RectAreaLight':
    					uniforms = {
    						color: new Color$1(),
    						position: new Vector3(),
    						halfWidth: new Vector3(),
    						halfHeight: new Vector3()
    					};
    					break;

    			}

    			lights[ light.id ] = uniforms;

    			return uniforms;

    		}

    	};

    }

    function ShadowUniformsCache() {

    	const lights = {};

    	return {

    		get: function ( light ) {

    			if ( lights[ light.id ] !== undefined ) {

    				return lights[ light.id ];

    			}

    			let uniforms;

    			switch ( light.type ) {

    				case 'DirectionalLight':
    					uniforms = {
    						shadowBias: 0,
    						shadowNormalBias: 0,
    						shadowRadius: 1,
    						shadowMapSize: new Vector2()
    					};
    					break;

    				case 'SpotLight':
    					uniforms = {
    						shadowBias: 0,
    						shadowNormalBias: 0,
    						shadowRadius: 1,
    						shadowMapSize: new Vector2()
    					};
    					break;

    				case 'PointLight':
    					uniforms = {
    						shadowBias: 0,
    						shadowNormalBias: 0,
    						shadowRadius: 1,
    						shadowMapSize: new Vector2(),
    						shadowCameraNear: 1,
    						shadowCameraFar: 1000
    					};
    					break;

    				// TODO (abelnation): set RectAreaLight shadow uniforms

    			}

    			lights[ light.id ] = uniforms;

    			return uniforms;

    		}

    	};

    }



    let nextVersion = 0;

    function shadowCastingAndTexturingLightsFirst( lightA, lightB ) {

    	return ( lightB.castShadow ? 2 : 0 ) - ( lightA.castShadow ? 2 : 0 ) + ( lightB.map ? 1 : 0 ) - ( lightA.map ? 1 : 0 );

    }

    function WebGLLights( extensions, capabilities ) {

    	const cache = new UniformsCache();

    	const shadowCache = ShadowUniformsCache();

    	const state = {

    		version: 0,

    		hash: {
    			directionalLength: - 1,
    			pointLength: - 1,
    			spotLength: - 1,
    			rectAreaLength: - 1,
    			hemiLength: - 1,

    			numDirectionalShadows: - 1,
    			numPointShadows: - 1,
    			numSpotShadows: - 1,
    			numSpotMaps: - 1
    		},

    		ambient: [ 0, 0, 0 ],
    		probe: [],
    		directional: [],
    		directionalShadow: [],
    		directionalShadowMap: [],
    		directionalShadowMatrix: [],
    		spot: [],
    		spotLightMap: [],
    		spotShadow: [],
    		spotShadowMap: [],
    		spotLightMatrix: [],
    		rectArea: [],
    		rectAreaLTC1: null,
    		rectAreaLTC2: null,
    		point: [],
    		pointShadow: [],
    		pointShadowMap: [],
    		pointShadowMatrix: [],
    		hemi: [],
    		numSpotLightShadowsWithMaps: 0

    	};

    	for ( let i = 0; i < 9; i ++ ) state.probe.push( new Vector3() );

    	const vector3 = new Vector3();
    	const matrix4 = new Matrix4();
    	const matrix42 = new Matrix4();

    	function setup( lights, physicallyCorrectLights ) {

    		let r = 0, g = 0, b = 0;

    		for ( let i = 0; i < 9; i ++ ) state.probe[ i ].set( 0, 0, 0 );

    		let directionalLength = 0;
    		let pointLength = 0;
    		let spotLength = 0;
    		let rectAreaLength = 0;
    		let hemiLength = 0;

    		let numDirectionalShadows = 0;
    		let numPointShadows = 0;
    		let numSpotShadows = 0;
    		let numSpotMaps = 0;
    		let numSpotShadowsWithMaps = 0;

    		// ordering : [shadow casting + map texturing, map texturing, shadow casting, none ]
    		lights.sort( shadowCastingAndTexturingLightsFirst );

    		// artist-friendly light intensity scaling factor
    		const scaleFactor = ( physicallyCorrectLights !== true ) ? Math.PI : 1;

    		for ( let i = 0, l = lights.length; i < l; i ++ ) {

    			const light = lights[ i ];

    			const color = light.color;
    			const intensity = light.intensity;
    			const distance = light.distance;

    			const shadowMap = ( light.shadow && light.shadow.map ) ? light.shadow.map.texture : null;

    			if ( light.isAmbientLight ) {

    				r += color.r * intensity * scaleFactor;
    				g += color.g * intensity * scaleFactor;
    				b += color.b * intensity * scaleFactor;

    			} else if ( light.isLightProbe ) {

    				for ( let j = 0; j < 9; j ++ ) {

    					state.probe[ j ].addScaledVector( light.sh.coefficients[ j ], intensity );

    				}

    			} else if ( light.isDirectionalLight ) {

    				const uniforms = cache.get( light );

    				uniforms.color.copy( light.color ).multiplyScalar( light.intensity * scaleFactor );

    				if ( light.castShadow ) {

    					const shadow = light.shadow;

    					const shadowUniforms = shadowCache.get( light );

    					shadowUniforms.shadowBias = shadow.bias;
    					shadowUniforms.shadowNormalBias = shadow.normalBias;
    					shadowUniforms.shadowRadius = shadow.radius;
    					shadowUniforms.shadowMapSize = shadow.mapSize;

    					state.directionalShadow[ directionalLength ] = shadowUniforms;
    					state.directionalShadowMap[ directionalLength ] = shadowMap;
    					state.directionalShadowMatrix[ directionalLength ] = light.shadow.matrix;

    					numDirectionalShadows ++;

    				}

    				state.directional[ directionalLength ] = uniforms;

    				directionalLength ++;

    			} else if ( light.isSpotLight ) {

    				const uniforms = cache.get( light );

    				uniforms.position.setFromMatrixPosition( light.matrixWorld );

    				uniforms.color.copy( color ).multiplyScalar( intensity * scaleFactor );
    				uniforms.distance = distance;

    				uniforms.coneCos = Math.cos( light.angle );
    				uniforms.penumbraCos = Math.cos( light.angle * ( 1 - light.penumbra ) );
    				uniforms.decay = light.decay;

    				state.spot[ spotLength ] = uniforms;

    				const shadow = light.shadow;

    				if ( light.map ) {

    					state.spotLightMap[ numSpotMaps ] = light.map;
    					numSpotMaps ++;

    					// make sure the lightMatrix is up to date
    					// TODO : do it if required only
    					shadow.updateMatrices( light );

    					if ( light.castShadow ) numSpotShadowsWithMaps ++;

    				}

    				state.spotLightMatrix[ spotLength ] = shadow.matrix;

    				if ( light.castShadow ) {

    					const shadowUniforms = shadowCache.get( light );

    					shadowUniforms.shadowBias = shadow.bias;
    					shadowUniforms.shadowNormalBias = shadow.normalBias;
    					shadowUniforms.shadowRadius = shadow.radius;
    					shadowUniforms.shadowMapSize = shadow.mapSize;

    					state.spotShadow[ spotLength ] = shadowUniforms;
    					state.spotShadowMap[ spotLength ] = shadowMap;

    					numSpotShadows ++;

    				}

    				spotLength ++;

    			} else if ( light.isRectAreaLight ) {

    				const uniforms = cache.get( light );

    				uniforms.color.copy( color ).multiplyScalar( intensity );

    				uniforms.halfWidth.set( light.width * 0.5, 0.0, 0.0 );
    				uniforms.halfHeight.set( 0.0, light.height * 0.5, 0.0 );

    				state.rectArea[ rectAreaLength ] = uniforms;

    				rectAreaLength ++;

    			} else if ( light.isPointLight ) {

    				const uniforms = cache.get( light );

    				uniforms.color.copy( light.color ).multiplyScalar( light.intensity * scaleFactor );
    				uniforms.distance = light.distance;
    				uniforms.decay = light.decay;

    				if ( light.castShadow ) {

    					const shadow = light.shadow;

    					const shadowUniforms = shadowCache.get( light );

    					shadowUniforms.shadowBias = shadow.bias;
    					shadowUniforms.shadowNormalBias = shadow.normalBias;
    					shadowUniforms.shadowRadius = shadow.radius;
    					shadowUniforms.shadowMapSize = shadow.mapSize;
    					shadowUniforms.shadowCameraNear = shadow.camera.near;
    					shadowUniforms.shadowCameraFar = shadow.camera.far;

    					state.pointShadow[ pointLength ] = shadowUniforms;
    					state.pointShadowMap[ pointLength ] = shadowMap;
    					state.pointShadowMatrix[ pointLength ] = light.shadow.matrix;

    					numPointShadows ++;

    				}

    				state.point[ pointLength ] = uniforms;

    				pointLength ++;

    			} else if ( light.isHemisphereLight ) {

    				const uniforms = cache.get( light );

    				uniforms.skyColor.copy( light.color ).multiplyScalar( intensity * scaleFactor );
    				uniforms.groundColor.copy( light.groundColor ).multiplyScalar( intensity * scaleFactor );

    				state.hemi[ hemiLength ] = uniforms;

    				hemiLength ++;

    			}

    		}

    		if ( rectAreaLength > 0 ) {

    			if ( capabilities.isWebGL2 ) {

    				// WebGL 2

    				state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
    				state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;

    			} else {

    				// WebGL 1

    				if ( extensions.has( 'OES_texture_float_linear' ) === true ) {

    					state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
    					state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;

    				} else if ( extensions.has( 'OES_texture_half_float_linear' ) === true ) {

    					state.rectAreaLTC1 = UniformsLib.LTC_HALF_1;
    					state.rectAreaLTC2 = UniformsLib.LTC_HALF_2;

    				} else {

    					console.error( 'THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.' );

    				}

    			}

    		}

    		state.ambient[ 0 ] = r;
    		state.ambient[ 1 ] = g;
    		state.ambient[ 2 ] = b;

    		const hash = state.hash;

    		if ( hash.directionalLength !== directionalLength ||
    			hash.pointLength !== pointLength ||
    			hash.spotLength !== spotLength ||
    			hash.rectAreaLength !== rectAreaLength ||
    			hash.hemiLength !== hemiLength ||
    			hash.numDirectionalShadows !== numDirectionalShadows ||
    			hash.numPointShadows !== numPointShadows ||
    			hash.numSpotShadows !== numSpotShadows ||
    			hash.numSpotMaps !== numSpotMaps ) {

    			state.directional.length = directionalLength;
    			state.spot.length = spotLength;
    			state.rectArea.length = rectAreaLength;
    			state.point.length = pointLength;
    			state.hemi.length = hemiLength;

    			state.directionalShadow.length = numDirectionalShadows;
    			state.directionalShadowMap.length = numDirectionalShadows;
    			state.pointShadow.length = numPointShadows;
    			state.pointShadowMap.length = numPointShadows;
    			state.spotShadow.length = numSpotShadows;
    			state.spotShadowMap.length = numSpotShadows;
    			state.directionalShadowMatrix.length = numDirectionalShadows;
    			state.pointShadowMatrix.length = numPointShadows;
    			state.spotLightMatrix.length = numSpotShadows + numSpotMaps - numSpotShadowsWithMaps;
    			state.spotLightMap.length = numSpotMaps;
    			state.numSpotLightShadowsWithMaps = numSpotShadowsWithMaps;

    			hash.directionalLength = directionalLength;
    			hash.pointLength = pointLength;
    			hash.spotLength = spotLength;
    			hash.rectAreaLength = rectAreaLength;
    			hash.hemiLength = hemiLength;

    			hash.numDirectionalShadows = numDirectionalShadows;
    			hash.numPointShadows = numPointShadows;
    			hash.numSpotShadows = numSpotShadows;
    			hash.numSpotMaps = numSpotMaps;

    			state.version = nextVersion ++;

    		}

    	}

    	function setupView( lights, camera ) {

    		let directionalLength = 0;
    		let pointLength = 0;
    		let spotLength = 0;
    		let rectAreaLength = 0;
    		let hemiLength = 0;

    		const viewMatrix = camera.matrixWorldInverse;

    		for ( let i = 0, l = lights.length; i < l; i ++ ) {

    			const light = lights[ i ];

    			if ( light.isDirectionalLight ) {

    				const uniforms = state.directional[ directionalLength ];

    				uniforms.direction.setFromMatrixPosition( light.matrixWorld );
    				vector3.setFromMatrixPosition( light.target.matrixWorld );
    				uniforms.direction.sub( vector3 );
    				uniforms.direction.transformDirection( viewMatrix );

    				directionalLength ++;

    			} else if ( light.isSpotLight ) {

    				const uniforms = state.spot[ spotLength ];

    				uniforms.position.setFromMatrixPosition( light.matrixWorld );
    				uniforms.position.applyMatrix4( viewMatrix );

    				uniforms.direction.setFromMatrixPosition( light.matrixWorld );
    				vector3.setFromMatrixPosition( light.target.matrixWorld );
    				uniforms.direction.sub( vector3 );
    				uniforms.direction.transformDirection( viewMatrix );

    				spotLength ++;

    			} else if ( light.isRectAreaLight ) {

    				const uniforms = state.rectArea[ rectAreaLength ];

    				uniforms.position.setFromMatrixPosition( light.matrixWorld );
    				uniforms.position.applyMatrix4( viewMatrix );

    				// extract local rotation of light to derive width/height half vectors
    				matrix42.identity();
    				matrix4.copy( light.matrixWorld );
    				matrix4.premultiply( viewMatrix );
    				matrix42.extractRotation( matrix4 );

    				uniforms.halfWidth.set( light.width * 0.5, 0.0, 0.0 );
    				uniforms.halfHeight.set( 0.0, light.height * 0.5, 0.0 );

    				uniforms.halfWidth.applyMatrix4( matrix42 );
    				uniforms.halfHeight.applyMatrix4( matrix42 );

    				rectAreaLength ++;

    			} else if ( light.isPointLight ) {

    				const uniforms = state.point[ pointLength ];

    				uniforms.position.setFromMatrixPosition( light.matrixWorld );
    				uniforms.position.applyMatrix4( viewMatrix );

    				pointLength ++;

    			} else if ( light.isHemisphereLight ) {

    				const uniforms = state.hemi[ hemiLength ];

    				uniforms.direction.setFromMatrixPosition( light.matrixWorld );
    				uniforms.direction.transformDirection( viewMatrix );

    				hemiLength ++;

    			}

    		}

    	}

    	return {
    		setup: setup,
    		setupView: setupView,
    		state: state
    	};

    }

    function WebGLRenderState( extensions, capabilities ) {

    	const lights = new WebGLLights( extensions, capabilities );

    	const lightsArray = [];
    	const shadowsArray = [];

    	function init() {

    		lightsArray.length = 0;
    		shadowsArray.length = 0;

    	}

    	function pushLight( light ) {

    		lightsArray.push( light );

    	}

    	function pushShadow( shadowLight ) {

    		shadowsArray.push( shadowLight );

    	}

    	function setupLights( physicallyCorrectLights ) {

    		lights.setup( lightsArray, physicallyCorrectLights );

    	}

    	function setupLightsView( camera ) {

    		lights.setupView( lightsArray, camera );

    	}

    	const state = {
    		lightsArray: lightsArray,
    		shadowsArray: shadowsArray,

    		lights: lights
    	};

    	return {
    		init: init,
    		state: state,
    		setupLights: setupLights,
    		setupLightsView: setupLightsView,

    		pushLight: pushLight,
    		pushShadow: pushShadow
    	};

    }

    function WebGLRenderStates( extensions, capabilities ) {

    	let renderStates = new WeakMap();

    	function get( scene, renderCallDepth = 0 ) {

    		const renderStateArray = renderStates.get( scene );
    		let renderState;

    		if ( renderStateArray === undefined ) {

    			renderState = new WebGLRenderState( extensions, capabilities );
    			renderStates.set( scene, [ renderState ] );

    		} else {

    			if ( renderCallDepth >= renderStateArray.length ) {

    				renderState = new WebGLRenderState( extensions, capabilities );
    				renderStateArray.push( renderState );

    			} else {

    				renderState = renderStateArray[ renderCallDepth ];

    			}

    		}

    		return renderState;

    	}

    	function dispose() {

    		renderStates = new WeakMap();

    	}

    	return {
    		get: get,
    		dispose: dispose
    	};

    }

    class MeshDepthMaterial extends Material {

    	constructor( parameters ) {

    		super();

    		this.isMeshDepthMaterial = true;

    		this.type = 'MeshDepthMaterial';

    		this.depthPacking = BasicDepthPacking;

    		this.map = null;

    		this.alphaMap = null;

    		this.displacementMap = null;
    		this.displacementScale = 1;
    		this.displacementBias = 0;

    		this.wireframe = false;
    		this.wireframeLinewidth = 1;

    		this.setValues( parameters );

    	}

    	copy( source ) {

    		super.copy( source );

    		this.depthPacking = source.depthPacking;

    		this.map = source.map;

    		this.alphaMap = source.alphaMap;

    		this.displacementMap = source.displacementMap;
    		this.displacementScale = source.displacementScale;
    		this.displacementBias = source.displacementBias;

    		this.wireframe = source.wireframe;
    		this.wireframeLinewidth = source.wireframeLinewidth;

    		return this;

    	}

    }

    class MeshDistanceMaterial extends Material {

    	constructor( parameters ) {

    		super();

    		this.isMeshDistanceMaterial = true;

    		this.type = 'MeshDistanceMaterial';

    		this.referencePosition = new Vector3();
    		this.nearDistance = 1;
    		this.farDistance = 1000;

    		this.map = null;

    		this.alphaMap = null;

    		this.displacementMap = null;
    		this.displacementScale = 1;
    		this.displacementBias = 0;

    		this.setValues( parameters );

    	}

    	copy( source ) {

    		super.copy( source );

    		this.referencePosition.copy( source.referencePosition );
    		this.nearDistance = source.nearDistance;
    		this.farDistance = source.farDistance;

    		this.map = source.map;

    		this.alphaMap = source.alphaMap;

    		this.displacementMap = source.displacementMap;
    		this.displacementScale = source.displacementScale;
    		this.displacementBias = source.displacementBias;

    		return this;

    	}

    }

    const vertex = "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}";

    const fragment = "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tconst float samples = float( VSM_SAMPLES );\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}";

    function WebGLShadowMap( _renderer, _objects, _capabilities ) {

    	let _frustum = new Frustum();

    	const _shadowMapSize = new Vector2(),
    		_viewportSize = new Vector2(),

    		_viewport = new Vector4(),

    		_depthMaterial = new MeshDepthMaterial( { depthPacking: RGBADepthPacking } ),
    		_distanceMaterial = new MeshDistanceMaterial(),

    		_materialCache = {},

    		_maxTextureSize = _capabilities.maxTextureSize;

    	const shadowSide = { 0: BackSide, 1: FrontSide, 2: DoubleSide };

    	const shadowMaterialVertical = new ShaderMaterial( {
    		defines: {
    			VSM_SAMPLES: 8
    		},
    		uniforms: {
    			shadow_pass: { value: null },
    			resolution: { value: new Vector2() },
    			radius: { value: 4.0 }
    		},

    		vertexShader: vertex,
    		fragmentShader: fragment

    	} );

    	const shadowMaterialHorizontal = shadowMaterialVertical.clone();
    	shadowMaterialHorizontal.defines.HORIZONTAL_PASS = 1;

    	const fullScreenTri = new BufferGeometry();
    	fullScreenTri.setAttribute(
    		'position',
    		new BufferAttribute(
    			new Float32Array( [ - 1, - 1, 0.5, 3, - 1, 0.5, - 1, 3, 0.5 ] ),
    			3
    		)
    	);

    	const fullScreenMesh = new Mesh( fullScreenTri, shadowMaterialVertical );

    	const scope = this;

    	this.enabled = false;

    	this.autoUpdate = true;
    	this.needsUpdate = false;

    	this.type = PCFShadowMap;

    	this.render = function ( lights, scene, camera ) {

    		if ( scope.enabled === false ) return;
    		if ( scope.autoUpdate === false && scope.needsUpdate === false ) return;

    		if ( lights.length === 0 ) return;

    		const currentRenderTarget = _renderer.getRenderTarget();
    		const activeCubeFace = _renderer.getActiveCubeFace();
    		const activeMipmapLevel = _renderer.getActiveMipmapLevel();

    		const _state = _renderer.state;

    		// Set GL state for depth map.
    		_state.setBlending( NoBlending );
    		_state.buffers.color.setClear( 1, 1, 1, 1 );
    		_state.buffers.depth.setTest( true );
    		_state.setScissorTest( false );

    		// render depth map

    		for ( let i = 0, il = lights.length; i < il; i ++ ) {

    			const light = lights[ i ];
    			const shadow = light.shadow;

    			if ( shadow === undefined ) {

    				console.warn( 'THREE.WebGLShadowMap:', light, 'has no shadow.' );
    				continue;

    			}

    			if ( shadow.autoUpdate === false && shadow.needsUpdate === false ) continue;

    			_shadowMapSize.copy( shadow.mapSize );

    			const shadowFrameExtents = shadow.getFrameExtents();

    			_shadowMapSize.multiply( shadowFrameExtents );

    			_viewportSize.copy( shadow.mapSize );

    			if ( _shadowMapSize.x > _maxTextureSize || _shadowMapSize.y > _maxTextureSize ) {

    				if ( _shadowMapSize.x > _maxTextureSize ) {

    					_viewportSize.x = Math.floor( _maxTextureSize / shadowFrameExtents.x );
    					_shadowMapSize.x = _viewportSize.x * shadowFrameExtents.x;
    					shadow.mapSize.x = _viewportSize.x;

    				}

    				if ( _shadowMapSize.y > _maxTextureSize ) {

    					_viewportSize.y = Math.floor( _maxTextureSize / shadowFrameExtents.y );
    					_shadowMapSize.y = _viewportSize.y * shadowFrameExtents.y;
    					shadow.mapSize.y = _viewportSize.y;

    				}

    			}

    			if ( shadow.map === null ) {

    				const pars = ( this.type !== VSMShadowMap ) ? { minFilter: NearestFilter, magFilter: NearestFilter } : {};

    				shadow.map = new WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y, pars );
    				shadow.map.texture.name = light.name + '.shadowMap';

    				shadow.camera.updateProjectionMatrix();

    			}

    			_renderer.setRenderTarget( shadow.map );
    			_renderer.clear();

    			const viewportCount = shadow.getViewportCount();

    			for ( let vp = 0; vp < viewportCount; vp ++ ) {

    				const viewport = shadow.getViewport( vp );

    				_viewport.set(
    					_viewportSize.x * viewport.x,
    					_viewportSize.y * viewport.y,
    					_viewportSize.x * viewport.z,
    					_viewportSize.y * viewport.w
    				);

    				_state.viewport( _viewport );

    				shadow.updateMatrices( light, vp );

    				_frustum = shadow.getFrustum();

    				renderObject( scene, camera, shadow.camera, light, this.type );

    			}

    			// do blur pass for VSM

    			if ( shadow.isPointLightShadow !== true && this.type === VSMShadowMap ) {

    				VSMPass( shadow, camera );

    			}

    			shadow.needsUpdate = false;

    		}

    		scope.needsUpdate = false;

    		_renderer.setRenderTarget( currentRenderTarget, activeCubeFace, activeMipmapLevel );

    	};

    	function VSMPass( shadow, camera ) {

    		const geometry = _objects.update( fullScreenMesh );

    		if ( shadowMaterialVertical.defines.VSM_SAMPLES !== shadow.blurSamples ) {

    			shadowMaterialVertical.defines.VSM_SAMPLES = shadow.blurSamples;
    			shadowMaterialHorizontal.defines.VSM_SAMPLES = shadow.blurSamples;

    			shadowMaterialVertical.needsUpdate = true;
    			shadowMaterialHorizontal.needsUpdate = true;

    		}

    		if ( shadow.mapPass === null ) {

    			shadow.mapPass = new WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y );

    		}

    		// vertical pass

    		shadowMaterialVertical.uniforms.shadow_pass.value = shadow.map.texture;
    		shadowMaterialVertical.uniforms.resolution.value = shadow.mapSize;
    		shadowMaterialVertical.uniforms.radius.value = shadow.radius;
    		_renderer.setRenderTarget( shadow.mapPass );
    		_renderer.clear();
    		_renderer.renderBufferDirect( camera, null, geometry, shadowMaterialVertical, fullScreenMesh, null );

    		// horizontal pass

    		shadowMaterialHorizontal.uniforms.shadow_pass.value = shadow.mapPass.texture;
    		shadowMaterialHorizontal.uniforms.resolution.value = shadow.mapSize;
    		shadowMaterialHorizontal.uniforms.radius.value = shadow.radius;
    		_renderer.setRenderTarget( shadow.map );
    		_renderer.clear();
    		_renderer.renderBufferDirect( camera, null, geometry, shadowMaterialHorizontal, fullScreenMesh, null );

    	}

    	function getDepthMaterial( object, material, light, shadowCameraNear, shadowCameraFar, type ) {

    		let result = null;

    		const customMaterial = ( light.isPointLight === true ) ? object.customDistanceMaterial : object.customDepthMaterial;

    		if ( customMaterial !== undefined ) {

    			result = customMaterial;

    		} else {

    			result = ( light.isPointLight === true ) ? _distanceMaterial : _depthMaterial;

    		}

    		if ( ( _renderer.localClippingEnabled && material.clipShadows === true && Array.isArray( material.clippingPlanes ) && material.clippingPlanes.length !== 0 ) ||
    			( material.displacementMap && material.displacementScale !== 0 ) ||
    			( material.alphaMap && material.alphaTest > 0 ) ||
    			( material.map && material.alphaTest > 0 ) ) {

    			// in this case we need a unique material instance reflecting the
    			// appropriate state

    			const keyA = result.uuid, keyB = material.uuid;

    			let materialsForVariant = _materialCache[ keyA ];

    			if ( materialsForVariant === undefined ) {

    				materialsForVariant = {};
    				_materialCache[ keyA ] = materialsForVariant;

    			}

    			let cachedMaterial = materialsForVariant[ keyB ];

    			if ( cachedMaterial === undefined ) {

    				cachedMaterial = result.clone();
    				materialsForVariant[ keyB ] = cachedMaterial;

    			}

    			result = cachedMaterial;

    		}

    		result.visible = material.visible;
    		result.wireframe = material.wireframe;

    		if ( type === VSMShadowMap ) {

    			result.side = ( material.shadowSide !== null ) ? material.shadowSide : material.side;

    		} else {

    			result.side = ( material.shadowSide !== null ) ? material.shadowSide : shadowSide[ material.side ];

    		}

    		result.alphaMap = material.alphaMap;
    		result.alphaTest = material.alphaTest;
    		result.map = material.map;

    		result.clipShadows = material.clipShadows;
    		result.clippingPlanes = material.clippingPlanes;
    		result.clipIntersection = material.clipIntersection;

    		result.displacementMap = material.displacementMap;
    		result.displacementScale = material.displacementScale;
    		result.displacementBias = material.displacementBias;

    		result.wireframeLinewidth = material.wireframeLinewidth;
    		result.linewidth = material.linewidth;

    		if ( light.isPointLight === true && result.isMeshDistanceMaterial === true ) {

    			result.referencePosition.setFromMatrixPosition( light.matrixWorld );
    			result.nearDistance = shadowCameraNear;
    			result.farDistance = shadowCameraFar;

    		}

    		return result;

    	}

    	function renderObject( object, camera, shadowCamera, light, type ) {

    		if ( object.visible === false ) return;

    		const visible = object.layers.test( camera.layers );

    		if ( visible && ( object.isMesh || object.isLine || object.isPoints ) ) {

    			if ( ( object.castShadow || ( object.receiveShadow && type === VSMShadowMap ) ) && ( ! object.frustumCulled || _frustum.intersectsObject( object ) ) ) {

    				object.modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );

    				const geometry = _objects.update( object );
    				const material = object.material;

    				if ( Array.isArray( material ) ) {

    					const groups = geometry.groups;

    					for ( let k = 0, kl = groups.length; k < kl; k ++ ) {

    						const group = groups[ k ];
    						const groupMaterial = material[ group.materialIndex ];

    						if ( groupMaterial && groupMaterial.visible ) {

    							const depthMaterial = getDepthMaterial( object, groupMaterial, light, shadowCamera.near, shadowCamera.far, type );

    							_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, group );

    						}

    					}

    				} else if ( material.visible ) {

    					const depthMaterial = getDepthMaterial( object, material, light, shadowCamera.near, shadowCamera.far, type );

    					_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, null );

    				}

    			}

    		}

    		const children = object.children;

    		for ( let i = 0, l = children.length; i < l; i ++ ) {

    			renderObject( children[ i ], camera, shadowCamera, light, type );

    		}

    	}

    }

    function WebGLState( gl, extensions, capabilities ) {

    	const isWebGL2 = capabilities.isWebGL2;

    	function ColorBuffer() {

    		let locked = false;

    		const color = new Vector4();
    		let currentColorMask = null;
    		const currentColorClear = new Vector4( 0, 0, 0, 0 );

    		return {

    			setMask: function ( colorMask ) {

    				if ( currentColorMask !== colorMask && ! locked ) {

    					gl.colorMask( colorMask, colorMask, colorMask, colorMask );
    					currentColorMask = colorMask;

    				}

    			},

    			setLocked: function ( lock ) {

    				locked = lock;

    			},

    			setClear: function ( r, g, b, a, premultipliedAlpha ) {

    				if ( premultipliedAlpha === true ) {

    					r *= a; g *= a; b *= a;

    				}

    				color.set( r, g, b, a );

    				if ( currentColorClear.equals( color ) === false ) {

    					gl.clearColor( r, g, b, a );
    					currentColorClear.copy( color );

    				}

    			},

    			reset: function () {

    				locked = false;

    				currentColorMask = null;
    				currentColorClear.set( - 1, 0, 0, 0 ); // set to invalid state

    			}

    		};

    	}

    	function DepthBuffer() {

    		let locked = false;

    		let currentDepthMask = null;
    		let currentDepthFunc = null;
    		let currentDepthClear = null;

    		return {

    			setTest: function ( depthTest ) {

    				if ( depthTest ) {

    					enable( 2929 );

    				} else {

    					disable( 2929 );

    				}

    			},

    			setMask: function ( depthMask ) {

    				if ( currentDepthMask !== depthMask && ! locked ) {

    					gl.depthMask( depthMask );
    					currentDepthMask = depthMask;

    				}

    			},

    			setFunc: function ( depthFunc ) {

    				if ( currentDepthFunc !== depthFunc ) {

    					switch ( depthFunc ) {

    						case NeverDepth:

    							gl.depthFunc( 512 );
    							break;

    						case AlwaysDepth:

    							gl.depthFunc( 519 );
    							break;

    						case LessDepth:

    							gl.depthFunc( 513 );
    							break;

    						case LessEqualDepth:

    							gl.depthFunc( 515 );
    							break;

    						case EqualDepth:

    							gl.depthFunc( 514 );
    							break;

    						case GreaterEqualDepth:

    							gl.depthFunc( 518 );
    							break;

    						case GreaterDepth:

    							gl.depthFunc( 516 );
    							break;

    						case NotEqualDepth:

    							gl.depthFunc( 517 );
    							break;

    						default:

    							gl.depthFunc( 515 );

    					}

    					currentDepthFunc = depthFunc;

    				}

    			},

    			setLocked: function ( lock ) {

    				locked = lock;

    			},

    			setClear: function ( depth ) {

    				if ( currentDepthClear !== depth ) {

    					gl.clearDepth( depth );
    					currentDepthClear = depth;

    				}

    			},

    			reset: function () {

    				locked = false;

    				currentDepthMask = null;
    				currentDepthFunc = null;
    				currentDepthClear = null;

    			}

    		};

    	}

    	function StencilBuffer() {

    		let locked = false;

    		let currentStencilMask = null;
    		let currentStencilFunc = null;
    		let currentStencilRef = null;
    		let currentStencilFuncMask = null;
    		let currentStencilFail = null;
    		let currentStencilZFail = null;
    		let currentStencilZPass = null;
    		let currentStencilClear = null;

    		return {

    			setTest: function ( stencilTest ) {

    				if ( ! locked ) {

    					if ( stencilTest ) {

    						enable( 2960 );

    					} else {

    						disable( 2960 );

    					}

    				}

    			},

    			setMask: function ( stencilMask ) {

    				if ( currentStencilMask !== stencilMask && ! locked ) {

    					gl.stencilMask( stencilMask );
    					currentStencilMask = stencilMask;

    				}

    			},

    			setFunc: function ( stencilFunc, stencilRef, stencilMask ) {

    				if ( currentStencilFunc !== stencilFunc ||
    				     currentStencilRef !== stencilRef ||
    				     currentStencilFuncMask !== stencilMask ) {

    					gl.stencilFunc( stencilFunc, stencilRef, stencilMask );

    					currentStencilFunc = stencilFunc;
    					currentStencilRef = stencilRef;
    					currentStencilFuncMask = stencilMask;

    				}

    			},

    			setOp: function ( stencilFail, stencilZFail, stencilZPass ) {

    				if ( currentStencilFail !== stencilFail ||
    				     currentStencilZFail !== stencilZFail ||
    				     currentStencilZPass !== stencilZPass ) {

    					gl.stencilOp( stencilFail, stencilZFail, stencilZPass );

    					currentStencilFail = stencilFail;
    					currentStencilZFail = stencilZFail;
    					currentStencilZPass = stencilZPass;

    				}

    			},

    			setLocked: function ( lock ) {

    				locked = lock;

    			},

    			setClear: function ( stencil ) {

    				if ( currentStencilClear !== stencil ) {

    					gl.clearStencil( stencil );
    					currentStencilClear = stencil;

    				}

    			},

    			reset: function () {

    				locked = false;

    				currentStencilMask = null;
    				currentStencilFunc = null;
    				currentStencilRef = null;
    				currentStencilFuncMask = null;
    				currentStencilFail = null;
    				currentStencilZFail = null;
    				currentStencilZPass = null;
    				currentStencilClear = null;

    			}

    		};

    	}

    	//

    	const colorBuffer = new ColorBuffer();
    	const depthBuffer = new DepthBuffer();
    	const stencilBuffer = new StencilBuffer();

    	const uboBindings = new WeakMap();
    	const uboProgamMap = new WeakMap();

    	let enabledCapabilities = {};

    	let currentBoundFramebuffers = {};
    	let currentDrawbuffers = new WeakMap();
    	let defaultDrawbuffers = [];

    	let currentProgram = null;

    	let currentBlendingEnabled = false;
    	let currentBlending = null;
    	let currentBlendEquation = null;
    	let currentBlendSrc = null;
    	let currentBlendDst = null;
    	let currentBlendEquationAlpha = null;
    	let currentBlendSrcAlpha = null;
    	let currentBlendDstAlpha = null;
    	let currentPremultipledAlpha = false;

    	let currentFlipSided = null;
    	let currentCullFace = null;

    	let currentLineWidth = null;

    	let currentPolygonOffsetFactor = null;
    	let currentPolygonOffsetUnits = null;

    	const maxTextures = gl.getParameter( 35661 );

    	let lineWidthAvailable = false;
    	let version = 0;
    	const glVersion = gl.getParameter( 7938 );

    	if ( glVersion.indexOf( 'WebGL' ) !== - 1 ) {

    		version = parseFloat( /^WebGL (\d)/.exec( glVersion )[ 1 ] );
    		lineWidthAvailable = ( version >= 1.0 );

    	} else if ( glVersion.indexOf( 'OpenGL ES' ) !== - 1 ) {

    		version = parseFloat( /^OpenGL ES (\d)/.exec( glVersion )[ 1 ] );
    		lineWidthAvailable = ( version >= 2.0 );

    	}

    	let currentTextureSlot = null;
    	let currentBoundTextures = {};

    	const scissorParam = gl.getParameter( 3088 );
    	const viewportParam = gl.getParameter( 2978 );

    	const currentScissor = new Vector4().fromArray( scissorParam );
    	const currentViewport = new Vector4().fromArray( viewportParam );

    	function createTexture( type, target, count ) {

    		const data = new Uint8Array( 4 ); // 4 is required to match default unpack alignment of 4.
    		const texture = gl.createTexture();

    		gl.bindTexture( type, texture );
    		gl.texParameteri( type, 10241, 9728 );
    		gl.texParameteri( type, 10240, 9728 );

    		for ( let i = 0; i < count; i ++ ) {

    			gl.texImage2D( target + i, 0, 6408, 1, 1, 0, 6408, 5121, data );

    		}

    		return texture;

    	}

    	const emptyTextures = {};
    	emptyTextures[ 3553 ] = createTexture( 3553, 3553, 1 );
    	emptyTextures[ 34067 ] = createTexture( 34067, 34069, 6 );

    	// init

    	colorBuffer.setClear( 0, 0, 0, 1 );
    	depthBuffer.setClear( 1 );
    	stencilBuffer.setClear( 0 );

    	enable( 2929 );
    	depthBuffer.setFunc( LessEqualDepth );

    	setFlipSided( false );
    	setCullFace( CullFaceBack );
    	enable( 2884 );

    	setBlending( NoBlending );

    	//

    	function enable( id ) {

    		if ( enabledCapabilities[ id ] !== true ) {

    			gl.enable( id );
    			enabledCapabilities[ id ] = true;

    		}

    	}

    	function disable( id ) {

    		if ( enabledCapabilities[ id ] !== false ) {

    			gl.disable( id );
    			enabledCapabilities[ id ] = false;

    		}

    	}

    	function bindFramebuffer( target, framebuffer ) {

    		if ( currentBoundFramebuffers[ target ] !== framebuffer ) {

    			gl.bindFramebuffer( target, framebuffer );

    			currentBoundFramebuffers[ target ] = framebuffer;

    			if ( isWebGL2 ) {

    				// 36009 is equivalent to 36160

    				if ( target === 36009 ) {

    					currentBoundFramebuffers[ 36160 ] = framebuffer;

    				}

    				if ( target === 36160 ) {

    					currentBoundFramebuffers[ 36009 ] = framebuffer;

    				}

    			}

    			return true;

    		}

    		return false;

    	}

    	function drawBuffers( renderTarget, framebuffer ) {

    		let drawBuffers = defaultDrawbuffers;

    		let needsUpdate = false;

    		if ( renderTarget ) {

    			drawBuffers = currentDrawbuffers.get( framebuffer );

    			if ( drawBuffers === undefined ) {

    				drawBuffers = [];
    				currentDrawbuffers.set( framebuffer, drawBuffers );

    			}

    			if ( renderTarget.isWebGLMultipleRenderTargets ) {

    				const textures = renderTarget.texture;

    				if ( drawBuffers.length !== textures.length || drawBuffers[ 0 ] !== 36064 ) {

    					for ( let i = 0, il = textures.length; i < il; i ++ ) {

    						drawBuffers[ i ] = 36064 + i;

    					}

    					drawBuffers.length = textures.length;

    					needsUpdate = true;

    				}

    			} else {

    				if ( drawBuffers[ 0 ] !== 36064 ) {

    					drawBuffers[ 0 ] = 36064;

    					needsUpdate = true;

    				}

    			}

    		} else {

    			if ( drawBuffers[ 0 ] !== 1029 ) {

    				drawBuffers[ 0 ] = 1029;

    				needsUpdate = true;

    			}

    		}

    		if ( needsUpdate ) {

    			if ( capabilities.isWebGL2 ) {

    				gl.drawBuffers( drawBuffers );

    			} else {

    				extensions.get( 'WEBGL_draw_buffers' ).drawBuffersWEBGL( drawBuffers );

    			}

    		}


    	}

    	function useProgram( program ) {

    		if ( currentProgram !== program ) {

    			gl.useProgram( program );

    			currentProgram = program;

    			return true;

    		}

    		return false;

    	}

    	const equationToGL = {
    		[ AddEquation ]: 32774,
    		[ SubtractEquation ]: 32778,
    		[ ReverseSubtractEquation ]: 32779
    	};

    	if ( isWebGL2 ) {

    		equationToGL[ MinEquation ] = 32775;
    		equationToGL[ MaxEquation ] = 32776;

    	} else {

    		const extension = extensions.get( 'EXT_blend_minmax' );

    		if ( extension !== null ) {

    			equationToGL[ MinEquation ] = extension.MIN_EXT;
    			equationToGL[ MaxEquation ] = extension.MAX_EXT;

    		}

    	}

    	const factorToGL = {
    		[ ZeroFactor ]: 0,
    		[ OneFactor ]: 1,
    		[ SrcColorFactor ]: 768,
    		[ SrcAlphaFactor ]: 770,
    		[ SrcAlphaSaturateFactor ]: 776,
    		[ DstColorFactor ]: 774,
    		[ DstAlphaFactor ]: 772,
    		[ OneMinusSrcColorFactor ]: 769,
    		[ OneMinusSrcAlphaFactor ]: 771,
    		[ OneMinusDstColorFactor ]: 775,
    		[ OneMinusDstAlphaFactor ]: 773
    	};

    	function setBlending( blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha ) {

    		if ( blending === NoBlending ) {

    			if ( currentBlendingEnabled === true ) {

    				disable( 3042 );
    				currentBlendingEnabled = false;

    			}

    			return;

    		}

    		if ( currentBlendingEnabled === false ) {

    			enable( 3042 );
    			currentBlendingEnabled = true;

    		}

    		if ( blending !== CustomBlending ) {

    			if ( blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha ) {

    				if ( currentBlendEquation !== AddEquation || currentBlendEquationAlpha !== AddEquation ) {

    					gl.blendEquation( 32774 );

    					currentBlendEquation = AddEquation;
    					currentBlendEquationAlpha = AddEquation;

    				}

    				if ( premultipliedAlpha ) {

    					switch ( blending ) {

    						case NormalBlending:
    							gl.blendFuncSeparate( 1, 771, 1, 771 );
    							break;

    						case AdditiveBlending:
    							gl.blendFunc( 1, 1 );
    							break;

    						case SubtractiveBlending:
    							gl.blendFuncSeparate( 0, 769, 0, 1 );
    							break;

    						case MultiplyBlending:
    							gl.blendFuncSeparate( 0, 768, 0, 770 );
    							break;

    						default:
    							console.error( 'THREE.WebGLState: Invalid blending: ', blending );
    							break;

    					}

    				} else {

    					switch ( blending ) {

    						case NormalBlending:
    							gl.blendFuncSeparate( 770, 771, 1, 771 );
    							break;

    						case AdditiveBlending:
    							gl.blendFunc( 770, 1 );
    							break;

    						case SubtractiveBlending:
    							gl.blendFuncSeparate( 0, 769, 0, 1 );
    							break;

    						case MultiplyBlending:
    							gl.blendFunc( 0, 768 );
    							break;

    						default:
    							console.error( 'THREE.WebGLState: Invalid blending: ', blending );
    							break;

    					}

    				}

    				currentBlendSrc = null;
    				currentBlendDst = null;
    				currentBlendSrcAlpha = null;
    				currentBlendDstAlpha = null;

    				currentBlending = blending;
    				currentPremultipledAlpha = premultipliedAlpha;

    			}

    			return;

    		}

    		// custom blending

    		blendEquationAlpha = blendEquationAlpha || blendEquation;
    		blendSrcAlpha = blendSrcAlpha || blendSrc;
    		blendDstAlpha = blendDstAlpha || blendDst;

    		if ( blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha ) {

    			gl.blendEquationSeparate( equationToGL[ blendEquation ], equationToGL[ blendEquationAlpha ] );

    			currentBlendEquation = blendEquation;
    			currentBlendEquationAlpha = blendEquationAlpha;

    		}

    		if ( blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha ) {

    			gl.blendFuncSeparate( factorToGL[ blendSrc ], factorToGL[ blendDst ], factorToGL[ blendSrcAlpha ], factorToGL[ blendDstAlpha ] );

    			currentBlendSrc = blendSrc;
    			currentBlendDst = blendDst;
    			currentBlendSrcAlpha = blendSrcAlpha;
    			currentBlendDstAlpha = blendDstAlpha;

    		}

    		currentBlending = blending;
    		currentPremultipledAlpha = false;

    	}

    	function setMaterial( material, frontFaceCW ) {

    		material.side === DoubleSide
    			? disable( 2884 )
    			: enable( 2884 );

    		let flipSided = ( material.side === BackSide );
    		if ( frontFaceCW ) flipSided = ! flipSided;

    		setFlipSided( flipSided );

    		( material.blending === NormalBlending && material.transparent === false )
    			? setBlending( NoBlending )
    			: setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha );

    		depthBuffer.setFunc( material.depthFunc );
    		depthBuffer.setTest( material.depthTest );
    		depthBuffer.setMask( material.depthWrite );
    		colorBuffer.setMask( material.colorWrite );

    		const stencilWrite = material.stencilWrite;
    		stencilBuffer.setTest( stencilWrite );
    		if ( stencilWrite ) {

    			stencilBuffer.setMask( material.stencilWriteMask );
    			stencilBuffer.setFunc( material.stencilFunc, material.stencilRef, material.stencilFuncMask );
    			stencilBuffer.setOp( material.stencilFail, material.stencilZFail, material.stencilZPass );

    		}

    		setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );

    		material.alphaToCoverage === true
    			? enable( 32926 )
    			: disable( 32926 );

    	}

    	//

    	function setFlipSided( flipSided ) {

    		if ( currentFlipSided !== flipSided ) {

    			if ( flipSided ) {

    				gl.frontFace( 2304 );

    			} else {

    				gl.frontFace( 2305 );

    			}

    			currentFlipSided = flipSided;

    		}

    	}

    	function setCullFace( cullFace ) {

    		if ( cullFace !== CullFaceNone ) {

    			enable( 2884 );

    			if ( cullFace !== currentCullFace ) {

    				if ( cullFace === CullFaceBack ) {

    					gl.cullFace( 1029 );

    				} else if ( cullFace === CullFaceFront ) {

    					gl.cullFace( 1028 );

    				} else {

    					gl.cullFace( 1032 );

    				}

    			}

    		} else {

    			disable( 2884 );

    		}

    		currentCullFace = cullFace;

    	}

    	function setLineWidth( width ) {

    		if ( width !== currentLineWidth ) {

    			if ( lineWidthAvailable ) gl.lineWidth( width );

    			currentLineWidth = width;

    		}

    	}

    	function setPolygonOffset( polygonOffset, factor, units ) {

    		if ( polygonOffset ) {

    			enable( 32823 );

    			if ( currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units ) {

    				gl.polygonOffset( factor, units );

    				currentPolygonOffsetFactor = factor;
    				currentPolygonOffsetUnits = units;

    			}

    		} else {

    			disable( 32823 );

    		}

    	}

    	function setScissorTest( scissorTest ) {

    		if ( scissorTest ) {

    			enable( 3089 );

    		} else {

    			disable( 3089 );

    		}

    	}

    	// texture

    	function activeTexture( webglSlot ) {

    		if ( webglSlot === undefined ) webglSlot = 33984 + maxTextures - 1;

    		if ( currentTextureSlot !== webglSlot ) {

    			gl.activeTexture( webglSlot );
    			currentTextureSlot = webglSlot;

    		}

    	}

    	function bindTexture( webglType, webglTexture, webglSlot ) {

    		if ( webglSlot === undefined ) {

    			if ( currentTextureSlot === null ) {

    				webglSlot = 33984 + maxTextures - 1;

    			} else {

    				webglSlot = currentTextureSlot;

    			}

    		}

    		let boundTexture = currentBoundTextures[ webglSlot ];

    		if ( boundTexture === undefined ) {

    			boundTexture = { type: undefined, texture: undefined };
    			currentBoundTextures[ webglSlot ] = boundTexture;

    		}

    		if ( boundTexture.type !== webglType || boundTexture.texture !== webglTexture ) {

    			if ( currentTextureSlot !== webglSlot ) {

    				gl.activeTexture( webglSlot );
    				currentTextureSlot = webglSlot;

    			}

    			gl.bindTexture( webglType, webglTexture || emptyTextures[ webglType ] );

    			boundTexture.type = webglType;
    			boundTexture.texture = webglTexture;

    		}

    	}

    	function unbindTexture() {

    		const boundTexture = currentBoundTextures[ currentTextureSlot ];

    		if ( boundTexture !== undefined && boundTexture.type !== undefined ) {

    			gl.bindTexture( boundTexture.type, null );

    			boundTexture.type = undefined;
    			boundTexture.texture = undefined;

    		}

    	}

    	function compressedTexImage2D() {

    		try {

    			gl.compressedTexImage2D.apply( gl, arguments );

    		} catch ( error ) {

    			console.error( 'THREE.WebGLState:', error );

    		}

    	}

    	function compressedTexImage3D() {

    		try {

    			gl.compressedTexImage3D.apply( gl, arguments );

    		} catch ( error ) {

    			console.error( 'THREE.WebGLState:', error );

    		}

    	}

    	function texSubImage2D() {

    		try {

    			gl.texSubImage2D.apply( gl, arguments );

    		} catch ( error ) {

    			console.error( 'THREE.WebGLState:', error );

    		}

    	}

    	function texSubImage3D() {

    		try {

    			gl.texSubImage3D.apply( gl, arguments );

    		} catch ( error ) {

    			console.error( 'THREE.WebGLState:', error );

    		}

    	}

    	function compressedTexSubImage2D() {

    		try {

    			gl.compressedTexSubImage2D.apply( gl, arguments );

    		} catch ( error ) {

    			console.error( 'THREE.WebGLState:', error );

    		}

    	}

    	function compressedTexSubImage3D() {

    		try {

    			gl.compressedTexSubImage3D.apply( gl, arguments );

    		} catch ( error ) {

    			console.error( 'THREE.WebGLState:', error );

    		}

    	}

    	function texStorage2D() {

    		try {

    			gl.texStorage2D.apply( gl, arguments );

    		} catch ( error ) {

    			console.error( 'THREE.WebGLState:', error );

    		}

    	}

    	function texStorage3D() {

    		try {

    			gl.texStorage3D.apply( gl, arguments );

    		} catch ( error ) {

    			console.error( 'THREE.WebGLState:', error );

    		}

    	}

    	function texImage2D() {

    		try {

    			gl.texImage2D.apply( gl, arguments );

    		} catch ( error ) {

    			console.error( 'THREE.WebGLState:', error );

    		}

    	}

    	function texImage3D() {

    		try {

    			gl.texImage3D.apply( gl, arguments );

    		} catch ( error ) {

    			console.error( 'THREE.WebGLState:', error );

    		}

    	}

    	//

    	function scissor( scissor ) {

    		if ( currentScissor.equals( scissor ) === false ) {

    			gl.scissor( scissor.x, scissor.y, scissor.z, scissor.w );
    			currentScissor.copy( scissor );

    		}

    	}

    	function viewport( viewport ) {

    		if ( currentViewport.equals( viewport ) === false ) {

    			gl.viewport( viewport.x, viewport.y, viewport.z, viewport.w );
    			currentViewport.copy( viewport );

    		}

    	}

    	function updateUBOMapping( uniformsGroup, program ) {

    		let mapping = uboProgamMap.get( program );

    		if ( mapping === undefined ) {

    			mapping = new WeakMap();

    			uboProgamMap.set( program, mapping );

    		}

    		let blockIndex = mapping.get( uniformsGroup );

    		if ( blockIndex === undefined ) {

    			blockIndex = gl.getUniformBlockIndex( program, uniformsGroup.name );

    			mapping.set( uniformsGroup, blockIndex );

    		}

    	}

    	function uniformBlockBinding( uniformsGroup, program ) {

    		const mapping = uboProgamMap.get( program );
    		const blockIndex = mapping.get( uniformsGroup );

    		if ( uboBindings.get( uniformsGroup ) !== blockIndex ) {

    			// bind shader specific block index to global block point

    			gl.uniformBlockBinding( program, blockIndex, uniformsGroup.__bindingPointIndex );

    			uboBindings.set( uniformsGroup, blockIndex );

    		}

    	}

    	//

    	function reset() {

    		// reset state

    		gl.disable( 3042 );
    		gl.disable( 2884 );
    		gl.disable( 2929 );
    		gl.disable( 32823 );
    		gl.disable( 3089 );
    		gl.disable( 2960 );
    		gl.disable( 32926 );

    		gl.blendEquation( 32774 );
    		gl.blendFunc( 1, 0 );
    		gl.blendFuncSeparate( 1, 0, 1, 0 );

    		gl.colorMask( true, true, true, true );
    		gl.clearColor( 0, 0, 0, 0 );

    		gl.depthMask( true );
    		gl.depthFunc( 513 );
    		gl.clearDepth( 1 );

    		gl.stencilMask( 0xffffffff );
    		gl.stencilFunc( 519, 0, 0xffffffff );
    		gl.stencilOp( 7680, 7680, 7680 );
    		gl.clearStencil( 0 );

    		gl.cullFace( 1029 );
    		gl.frontFace( 2305 );

    		gl.polygonOffset( 0, 0 );

    		gl.activeTexture( 33984 );

    		gl.bindFramebuffer( 36160, null );

    		if ( isWebGL2 === true ) {

    			gl.bindFramebuffer( 36009, null );
    			gl.bindFramebuffer( 36008, null );

    		}

    		gl.useProgram( null );

    		gl.lineWidth( 1 );

    		gl.scissor( 0, 0, gl.canvas.width, gl.canvas.height );
    		gl.viewport( 0, 0, gl.canvas.width, gl.canvas.height );

    		// reset internals

    		enabledCapabilities = {};

    		currentTextureSlot = null;
    		currentBoundTextures = {};

    		currentBoundFramebuffers = {};
    		currentDrawbuffers = new WeakMap();
    		defaultDrawbuffers = [];

    		currentProgram = null;

    		currentBlendingEnabled = false;
    		currentBlending = null;
    		currentBlendEquation = null;
    		currentBlendSrc = null;
    		currentBlendDst = null;
    		currentBlendEquationAlpha = null;
    		currentBlendSrcAlpha = null;
    		currentBlendDstAlpha = null;
    		currentPremultipledAlpha = false;

    		currentFlipSided = null;
    		currentCullFace = null;

    		currentLineWidth = null;

    		currentPolygonOffsetFactor = null;
    		currentPolygonOffsetUnits = null;

    		currentScissor.set( 0, 0, gl.canvas.width, gl.canvas.height );
    		currentViewport.set( 0, 0, gl.canvas.width, gl.canvas.height );

    		colorBuffer.reset();
    		depthBuffer.reset();
    		stencilBuffer.reset();

    	}

    	return {

    		buffers: {
    			color: colorBuffer,
    			depth: depthBuffer,
    			stencil: stencilBuffer
    		},

    		enable: enable,
    		disable: disable,

    		bindFramebuffer: bindFramebuffer,
    		drawBuffers: drawBuffers,

    		useProgram: useProgram,

    		setBlending: setBlending,
    		setMaterial: setMaterial,

    		setFlipSided: setFlipSided,
    		setCullFace: setCullFace,

    		setLineWidth: setLineWidth,
    		setPolygonOffset: setPolygonOffset,

    		setScissorTest: setScissorTest,

    		activeTexture: activeTexture,
    		bindTexture: bindTexture,
    		unbindTexture: unbindTexture,
    		compressedTexImage2D: compressedTexImage2D,
    		compressedTexImage3D: compressedTexImage3D,
    		texImage2D: texImage2D,
    		texImage3D: texImage3D,

    		updateUBOMapping: updateUBOMapping,
    		uniformBlockBinding: uniformBlockBinding,

    		texStorage2D: texStorage2D,
    		texStorage3D: texStorage3D,
    		texSubImage2D: texSubImage2D,
    		texSubImage3D: texSubImage3D,
    		compressedTexSubImage2D: compressedTexSubImage2D,
    		compressedTexSubImage3D: compressedTexSubImage3D,

    		scissor: scissor,
    		viewport: viewport,

    		reset: reset

    	};

    }

    function WebGLTextures( _gl, extensions, state, properties, capabilities, utils, info ) {

    	const isWebGL2 = capabilities.isWebGL2;
    	const maxTextures = capabilities.maxTextures;
    	const maxCubemapSize = capabilities.maxCubemapSize;
    	const maxTextureSize = capabilities.maxTextureSize;
    	const maxSamples = capabilities.maxSamples;
    	const multisampledRTTExt = extensions.has( 'WEBGL_multisampled_render_to_texture' ) ? extensions.get( 'WEBGL_multisampled_render_to_texture' ) : null;
    	const supportsInvalidateFramebuffer = typeof navigator === 'undefined' ? false : /OculusBrowser/g.test( navigator.userAgent );

    	const _videoTextures = new WeakMap();
    	let _canvas;

    	const _sources = new WeakMap(); // maps WebglTexture objects to instances of Source

    	// cordova iOS (as of 5.0) still uses UIWebView, which provides OffscreenCanvas,
    	// also OffscreenCanvas.getContext("webgl"), but not OffscreenCanvas.getContext("2d")!
    	// Some implementations may only implement OffscreenCanvas partially (e.g. lacking 2d).

    	let useOffscreenCanvas = false;

    	try {

    		useOffscreenCanvas = typeof OffscreenCanvas !== 'undefined'
    			// eslint-disable-next-line compat/compat
    			&& ( new OffscreenCanvas( 1, 1 ).getContext( '2d' ) ) !== null;

    	} catch ( err ) {

    		// Ignore any errors

    	}

    	function createCanvas( width, height ) {

    		// Use OffscreenCanvas when available. Specially needed in web workers

    		return useOffscreenCanvas ?
    			// eslint-disable-next-line compat/compat
    			new OffscreenCanvas( width, height ) : createElementNS( 'canvas' );

    	}

    	function resizeImage( image, needsPowerOfTwo, needsNewCanvas, maxSize ) {

    		let scale = 1;

    		// handle case if texture exceeds max size

    		if ( image.width > maxSize || image.height > maxSize ) {

    			scale = maxSize / Math.max( image.width, image.height );

    		}

    		// only perform resize if necessary

    		if ( scale < 1 || needsPowerOfTwo === true ) {

    			// only perform resize for certain image types

    			if ( ( typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement ) ||
    				( typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement ) ||
    				( typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap ) ) {

    				const floor = needsPowerOfTwo ? floorPowerOfTwo : Math.floor;

    				const width = floor( scale * image.width );
    				const height = floor( scale * image.height );

    				if ( _canvas === undefined ) _canvas = createCanvas( width, height );

    				// cube textures can't reuse the same canvas

    				const canvas = needsNewCanvas ? createCanvas( width, height ) : _canvas;

    				canvas.width = width;
    				canvas.height = height;

    				const context = canvas.getContext( '2d' );
    				context.drawImage( image, 0, 0, width, height );

    				console.warn( 'THREE.WebGLRenderer: Texture has been resized from (' + image.width + 'x' + image.height + ') to (' + width + 'x' + height + ').' );

    				return canvas;

    			} else {

    				if ( 'data' in image ) {

    					console.warn( 'THREE.WebGLRenderer: Image in DataTexture is too big (' + image.width + 'x' + image.height + ').' );

    				}

    				return image;

    			}

    		}

    		return image;

    	}

    	function isPowerOfTwo$1( image ) {

    		return isPowerOfTwo( image.width ) && isPowerOfTwo( image.height );

    	}

    	function textureNeedsPowerOfTwo( texture ) {

    		if ( isWebGL2 ) return false;

    		return ( texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ) ||
    			( texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter );

    	}

    	function textureNeedsGenerateMipmaps( texture, supportsMips ) {

    		return texture.generateMipmaps && supportsMips &&
    			texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;

    	}

    	function generateMipmap( target ) {

    		_gl.generateMipmap( target );

    	}

    	function getInternalFormat( internalFormatName, glFormat, glType, encoding, forceLinearEncoding = false ) {

    		if ( isWebGL2 === false ) return glFormat;

    		if ( internalFormatName !== null ) {

    			if ( _gl[ internalFormatName ] !== undefined ) return _gl[ internalFormatName ];

    			console.warn( 'THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format \'' + internalFormatName + '\'' );

    		}

    		let internalFormat = glFormat;

    		if ( glFormat === 6403 ) {

    			if ( glType === 5126 ) internalFormat = 33326;
    			if ( glType === 5131 ) internalFormat = 33325;
    			if ( glType === 5121 ) internalFormat = 33321;

    		}

    		if ( glFormat === 33319 ) {

    			if ( glType === 5126 ) internalFormat = 33328;
    			if ( glType === 5131 ) internalFormat = 33327;
    			if ( glType === 5121 ) internalFormat = 33323;

    		}

    		if ( glFormat === 6408 ) {

    			if ( glType === 5126 ) internalFormat = 34836;
    			if ( glType === 5131 ) internalFormat = 34842;
    			if ( glType === 5121 ) internalFormat = ( encoding === sRGBEncoding && forceLinearEncoding === false ) ? 35907 : 32856;
    			if ( glType === 32819 ) internalFormat = 32854;
    			if ( glType === 32820 ) internalFormat = 32855;

    		}

    		if ( internalFormat === 33325 || internalFormat === 33326 ||
    			internalFormat === 33327 || internalFormat === 33328 ||
    			internalFormat === 34842 || internalFormat === 34836 ) {

    			extensions.get( 'EXT_color_buffer_float' );

    		}

    		return internalFormat;

    	}

    	function getMipLevels( texture, image, supportsMips ) {

    		if ( textureNeedsGenerateMipmaps( texture, supportsMips ) === true || ( texture.isFramebufferTexture && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter ) ) {

    			return Math.log2( Math.max( image.width, image.height ) ) + 1;

    		} else if ( texture.mipmaps !== undefined && texture.mipmaps.length > 0 ) {

    			// user-defined mipmaps

    			return texture.mipmaps.length;

    		} else if ( texture.isCompressedTexture && Array.isArray( texture.image ) ) {

    			return image.mipmaps.length;

    		} else {

    			// texture without mipmaps (only base level)

    			return 1;

    		}

    	}

    	// Fallback filters for non-power-of-2 textures

    	function filterFallback( f ) {

    		if ( f === NearestFilter || f === NearestMipmapNearestFilter || f === NearestMipmapLinearFilter ) {

    			return 9728;

    		}

    		return 9729;

    	}

    	//

    	function onTextureDispose( event ) {

    		const texture = event.target;

    		texture.removeEventListener( 'dispose', onTextureDispose );

    		deallocateTexture( texture );

    		if ( texture.isVideoTexture ) {

    			_videoTextures.delete( texture );

    		}

    	}

    	function onRenderTargetDispose( event ) {

    		const renderTarget = event.target;

    		renderTarget.removeEventListener( 'dispose', onRenderTargetDispose );

    		deallocateRenderTarget( renderTarget );

    	}

    	//

    	function deallocateTexture( texture ) {

    		const textureProperties = properties.get( texture );

    		if ( textureProperties.__webglInit === undefined ) return;

    		// check if it's necessary to remove the WebGLTexture object

    		const source = texture.source;
    		const webglTextures = _sources.get( source );

    		if ( webglTextures ) {

    			const webglTexture = webglTextures[ textureProperties.__cacheKey ];
    			webglTexture.usedTimes --;

    			// the WebGLTexture object is not used anymore, remove it

    			if ( webglTexture.usedTimes === 0 ) {

    				deleteTexture( texture );

    			}

    			// remove the weak map entry if no WebGLTexture uses the source anymore

    			if ( Object.keys( webglTextures ).length === 0 ) {

    				_sources.delete( source );

    			}

    		}

    		properties.remove( texture );

    	}

    	function deleteTexture( texture ) {

    		const textureProperties = properties.get( texture );
    		_gl.deleteTexture( textureProperties.__webglTexture );

    		const source = texture.source;
    		const webglTextures = _sources.get( source );
    		delete webglTextures[ textureProperties.__cacheKey ];

    		info.memory.textures --;

    	}

    	function deallocateRenderTarget( renderTarget ) {

    		const texture = renderTarget.texture;

    		const renderTargetProperties = properties.get( renderTarget );
    		const textureProperties = properties.get( texture );

    		if ( textureProperties.__webglTexture !== undefined ) {

    			_gl.deleteTexture( textureProperties.__webglTexture );

    			info.memory.textures --;

    		}

    		if ( renderTarget.depthTexture ) {

    			renderTarget.depthTexture.dispose();

    		}

    		if ( renderTarget.isWebGLCubeRenderTarget ) {

    			for ( let i = 0; i < 6; i ++ ) {

    				_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer[ i ] );
    				if ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer[ i ] );

    			}

    		} else {

    			_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer );
    			if ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer );
    			if ( renderTargetProperties.__webglMultisampledFramebuffer ) _gl.deleteFramebuffer( renderTargetProperties.__webglMultisampledFramebuffer );

    			if ( renderTargetProperties.__webglColorRenderbuffer ) {

    				for ( let i = 0; i < renderTargetProperties.__webglColorRenderbuffer.length; i ++ ) {

    					if ( renderTargetProperties.__webglColorRenderbuffer[ i ] ) _gl.deleteRenderbuffer( renderTargetProperties.__webglColorRenderbuffer[ i ] );

    				}

    			}

    			if ( renderTargetProperties.__webglDepthRenderbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthRenderbuffer );

    		}

    		if ( renderTarget.isWebGLMultipleRenderTargets ) {

    			for ( let i = 0, il = texture.length; i < il; i ++ ) {

    				const attachmentProperties = properties.get( texture[ i ] );

    				if ( attachmentProperties.__webglTexture ) {

    					_gl.deleteTexture( attachmentProperties.__webglTexture );

    					info.memory.textures --;

    				}

    				properties.remove( texture[ i ] );

    			}

    		}

    		properties.remove( texture );
    		properties.remove( renderTarget );

    	}

    	//

    	let textureUnits = 0;

    	function resetTextureUnits() {

    		textureUnits = 0;

    	}

    	function allocateTextureUnit() {

    		const textureUnit = textureUnits;

    		if ( textureUnit >= maxTextures ) {

    			console.warn( 'THREE.WebGLTextures: Trying to use ' + textureUnit + ' texture units while this GPU supports only ' + maxTextures );

    		}

    		textureUnits += 1;

    		return textureUnit;

    	}

    	function getTextureCacheKey( texture ) {

    		const array = [];

    		array.push( texture.wrapS );
    		array.push( texture.wrapT );
    		array.push( texture.wrapR || 0 );
    		array.push( texture.magFilter );
    		array.push( texture.minFilter );
    		array.push( texture.anisotropy );
    		array.push( texture.internalFormat );
    		array.push( texture.format );
    		array.push( texture.type );
    		array.push( texture.generateMipmaps );
    		array.push( texture.premultiplyAlpha );
    		array.push( texture.flipY );
    		array.push( texture.unpackAlignment );
    		array.push( texture.encoding );

    		return array.join();

    	}

    	//

    	function setTexture2D( texture, slot ) {

    		const textureProperties = properties.get( texture );

    		if ( texture.isVideoTexture ) updateVideoTexture( texture );

    		if ( texture.isRenderTargetTexture === false && texture.version > 0 && textureProperties.__version !== texture.version ) {

    			const image = texture.image;

    			if ( image === null ) {

    				console.warn( 'THREE.WebGLRenderer: Texture marked for update but no image data found.' );

    			} else if ( image.complete === false ) {

    				console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is incomplete' );

    			} else {

    				uploadTexture( textureProperties, texture, slot );
    				return;

    			}

    		}

    		state.bindTexture( 3553, textureProperties.__webglTexture, 33984 + slot );

    	}

    	function setTexture2DArray( texture, slot ) {

    		const textureProperties = properties.get( texture );

    		if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

    			uploadTexture( textureProperties, texture, slot );
    			return;

    		}

    		state.bindTexture( 35866, textureProperties.__webglTexture, 33984 + slot );

    	}

    	function setTexture3D( texture, slot ) {

    		const textureProperties = properties.get( texture );

    		if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

    			uploadTexture( textureProperties, texture, slot );
    			return;

    		}

    		state.bindTexture( 32879, textureProperties.__webglTexture, 33984 + slot );

    	}

    	function setTextureCube( texture, slot ) {

    		const textureProperties = properties.get( texture );

    		if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

    			uploadCubeTexture( textureProperties, texture, slot );
    			return;

    		}

    		state.bindTexture( 34067, textureProperties.__webglTexture, 33984 + slot );

    	}

    	const wrappingToGL = {
    		[ RepeatWrapping ]: 10497,
    		[ ClampToEdgeWrapping ]: 33071,
    		[ MirroredRepeatWrapping ]: 33648
    	};

    	const filterToGL = {
    		[ NearestFilter ]: 9728,
    		[ NearestMipmapNearestFilter ]: 9984,
    		[ NearestMipmapLinearFilter ]: 9986,

    		[ LinearFilter ]: 9729,
    		[ LinearMipmapNearestFilter ]: 9985,
    		[ LinearMipmapLinearFilter ]: 9987
    	};

    	function setTextureParameters( textureType, texture, supportsMips ) {

    		if ( supportsMips ) {

    			_gl.texParameteri( textureType, 10242, wrappingToGL[ texture.wrapS ] );
    			_gl.texParameteri( textureType, 10243, wrappingToGL[ texture.wrapT ] );

    			if ( textureType === 32879 || textureType === 35866 ) {

    				_gl.texParameteri( textureType, 32882, wrappingToGL[ texture.wrapR ] );

    			}

    			_gl.texParameteri( textureType, 10240, filterToGL[ texture.magFilter ] );
    			_gl.texParameteri( textureType, 10241, filterToGL[ texture.minFilter ] );

    		} else {

    			_gl.texParameteri( textureType, 10242, 33071 );
    			_gl.texParameteri( textureType, 10243, 33071 );

    			if ( textureType === 32879 || textureType === 35866 ) {

    				_gl.texParameteri( textureType, 32882, 33071 );

    			}

    			if ( texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ) {

    				console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.' );

    			}

    			_gl.texParameteri( textureType, 10240, filterFallback( texture.magFilter ) );
    			_gl.texParameteri( textureType, 10241, filterFallback( texture.minFilter ) );

    			if ( texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter ) {

    				console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.' );

    			}

    		}

    		if ( extensions.has( 'EXT_texture_filter_anisotropic' ) === true ) {

    			const extension = extensions.get( 'EXT_texture_filter_anisotropic' );

    			if ( texture.type === FloatType && extensions.has( 'OES_texture_float_linear' ) === false ) return; // verify extension for WebGL 1 and WebGL 2
    			if ( isWebGL2 === false && ( texture.type === HalfFloatType && extensions.has( 'OES_texture_half_float_linear' ) === false ) ) return; // verify extension for WebGL 1 only

    			if ( texture.anisotropy > 1 || properties.get( texture ).__currentAnisotropy ) {

    				_gl.texParameterf( textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, capabilities.getMaxAnisotropy() ) );
    				properties.get( texture ).__currentAnisotropy = texture.anisotropy;

    			}

    		}

    	}

    	function initTexture( textureProperties, texture ) {

    		let forceUpload = false;

    		if ( textureProperties.__webglInit === undefined ) {

    			textureProperties.__webglInit = true;

    			texture.addEventListener( 'dispose', onTextureDispose );

    		}

    		// create Source <-> WebGLTextures mapping if necessary

    		const source = texture.source;
    		let webglTextures = _sources.get( source );

    		if ( webglTextures === undefined ) {

    			webglTextures = {};
    			_sources.set( source, webglTextures );

    		}

    		// check if there is already a WebGLTexture object for the given texture parameters

    		const textureCacheKey = getTextureCacheKey( texture );

    		if ( textureCacheKey !== textureProperties.__cacheKey ) {

    			// if not, create a new instance of WebGLTexture

    			if ( webglTextures[ textureCacheKey ] === undefined ) {

    				// create new entry

    				webglTextures[ textureCacheKey ] = {
    					texture: _gl.createTexture(),
    					usedTimes: 0
    				};

    				info.memory.textures ++;

    				// when a new instance of WebGLTexture was created, a texture upload is required
    				// even if the image contents are identical

    				forceUpload = true;

    			}

    			webglTextures[ textureCacheKey ].usedTimes ++;

    			// every time the texture cache key changes, it's necessary to check if an instance of
    			// WebGLTexture can be deleted in order to avoid a memory leak.

    			const webglTexture = webglTextures[ textureProperties.__cacheKey ];

    			if ( webglTexture !== undefined ) {

    				webglTextures[ textureProperties.__cacheKey ].usedTimes --;

    				if ( webglTexture.usedTimes === 0 ) {

    					deleteTexture( texture );

    				}

    			}

    			// store references to cache key and WebGLTexture object

    			textureProperties.__cacheKey = textureCacheKey;
    			textureProperties.__webglTexture = webglTextures[ textureCacheKey ].texture;

    		}

    		return forceUpload;

    	}

    	function uploadTexture( textureProperties, texture, slot ) {

    		let textureType = 3553;

    		if ( texture.isDataArrayTexture || texture.isCompressedArrayTexture ) textureType = 35866;
    		if ( texture.isData3DTexture ) textureType = 32879;

    		const forceUpload = initTexture( textureProperties, texture );
    		const source = texture.source;

    		state.bindTexture( textureType, textureProperties.__webglTexture, 33984 + slot );

    		const sourceProperties = properties.get( source );

    		if ( source.version !== sourceProperties.__version || forceUpload === true ) {

    			state.activeTexture( 33984 + slot );

    			_gl.pixelStorei( 37440, texture.flipY );
    			_gl.pixelStorei( 37441, texture.premultiplyAlpha );
    			_gl.pixelStorei( 3317, texture.unpackAlignment );
    			_gl.pixelStorei( 37443, 0 );

    			const needsPowerOfTwo = textureNeedsPowerOfTwo( texture ) && isPowerOfTwo$1( texture.image ) === false;
    			let image = resizeImage( texture.image, needsPowerOfTwo, false, maxTextureSize );
    			image = verifyColorSpace( texture, image );

    			const supportsMips = isPowerOfTwo$1( image ) || isWebGL2,
    				glFormat = utils.convert( texture.format, texture.encoding );

    			let glType = utils.convert( texture.type ),
    				glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType, texture.encoding, texture.isVideoTexture );

    			setTextureParameters( textureType, texture, supportsMips );

    			let mipmap;
    			const mipmaps = texture.mipmaps;

    			const useTexStorage = ( isWebGL2 && texture.isVideoTexture !== true );
    			const allocateMemory = ( sourceProperties.__version === undefined ) || ( forceUpload === true );
    			const levels = getMipLevels( texture, image, supportsMips );

    			if ( texture.isDepthTexture ) {

    				// populate depth texture with dummy data

    				glInternalFormat = 6402;

    				if ( isWebGL2 ) {

    					if ( texture.type === FloatType ) {

    						glInternalFormat = 36012;

    					} else if ( texture.type === UnsignedIntType ) {

    						glInternalFormat = 33190;

    					} else if ( texture.type === UnsignedInt248Type ) {

    						glInternalFormat = 35056;

    					} else {

    						glInternalFormat = 33189; // WebGL2 requires sized internalformat for glTexImage2D

    					}

    				} else {

    					if ( texture.type === FloatType ) {

    						console.error( 'WebGLRenderer: Floating point depth texture requires WebGL2.' );

    					}

    				}

    				// validation checks for WebGL 1

    				if ( texture.format === DepthFormat && glInternalFormat === 6402 ) {

    					// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
    					// DEPTH_COMPONENT and type is not UNSIGNED_SHORT or UNSIGNED_INT
    					// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
    					if ( texture.type !== UnsignedShortType && texture.type !== UnsignedIntType ) {

    						console.warn( 'THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.' );

    						texture.type = UnsignedIntType;
    						glType = utils.convert( texture.type );

    					}

    				}

    				if ( texture.format === DepthStencilFormat && glInternalFormat === 6402 ) {

    					// Depth stencil textures need the DEPTH_STENCIL internal format
    					// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
    					glInternalFormat = 34041;

    					// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
    					// DEPTH_STENCIL and type is not UNSIGNED_INT_24_8_WEBGL.
    					// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
    					if ( texture.type !== UnsignedInt248Type ) {

    						console.warn( 'THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.' );

    						texture.type = UnsignedInt248Type;
    						glType = utils.convert( texture.type );

    					}

    				}

    				//

    				if ( allocateMemory ) {

    					if ( useTexStorage ) {

    						state.texStorage2D( 3553, 1, glInternalFormat, image.width, image.height );

    					} else {

    						state.texImage2D( 3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null );

    					}

    				}

    			} else if ( texture.isDataTexture ) {

    				// use manually created mipmaps if available
    				// if there are no manual mipmaps
    				// set 0 level mipmap and then use GL to generate other mipmap levels

    				if ( mipmaps.length > 0 && supportsMips ) {

    					if ( useTexStorage && allocateMemory ) {

    						state.texStorage2D( 3553, levels, glInternalFormat, mipmaps[ 0 ].width, mipmaps[ 0 ].height );

    					}

    					for ( let i = 0, il = mipmaps.length; i < il; i ++ ) {

    						mipmap = mipmaps[ i ];

    						if ( useTexStorage ) {

    							state.texSubImage2D( 3553, i, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data );

    						} else {

    							state.texImage2D( 3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

    						}

    					}

    					texture.generateMipmaps = false;

    				} else {

    					if ( useTexStorage ) {

    						if ( allocateMemory ) {

    							state.texStorage2D( 3553, levels, glInternalFormat, image.width, image.height );

    						}

    						state.texSubImage2D( 3553, 0, 0, 0, image.width, image.height, glFormat, glType, image.data );

    					} else {

    						state.texImage2D( 3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, image.data );

    					}

    				}

    			} else if ( texture.isCompressedTexture ) {

    				if ( texture.isCompressedArrayTexture ) {

    					if ( useTexStorage && allocateMemory ) {

    						state.texStorage3D( 35866, levels, glInternalFormat, mipmaps[ 0 ].width, mipmaps[ 0 ].height, image.depth );

    					}

    					for ( let i = 0, il = mipmaps.length; i < il; i ++ ) {

    						mipmap = mipmaps[ i ];

    						if ( texture.format !== RGBAFormat ) {

    							if ( glFormat !== null ) {

    								if ( useTexStorage ) {

    									state.compressedTexSubImage3D( 35866, i, 0, 0, 0, mipmap.width, mipmap.height, image.depth, glFormat, mipmap.data, 0, 0 );

    								} else {

    									state.compressedTexImage3D( 35866, i, glInternalFormat, mipmap.width, mipmap.height, image.depth, 0, mipmap.data, 0, 0 );

    								}

    							} else {

    								console.warn( 'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()' );

    							}

    						} else {

    							if ( useTexStorage ) {

    								state.texSubImage3D( 35866, i, 0, 0, 0, mipmap.width, mipmap.height, image.depth, glFormat, glType, mipmap.data );

    							} else {

    								state.texImage3D( 35866, i, glInternalFormat, mipmap.width, mipmap.height, image.depth, 0, glFormat, glType, mipmap.data );

    							}

    						}

    					}

    				} else {

    					if ( useTexStorage && allocateMemory ) {

    						state.texStorage2D( 3553, levels, glInternalFormat, mipmaps[ 0 ].width, mipmaps[ 0 ].height );

    					}

    					for ( let i = 0, il = mipmaps.length; i < il; i ++ ) {

    						mipmap = mipmaps[ i ];

    						if ( texture.format !== RGBAFormat ) {

    							if ( glFormat !== null ) {

    								if ( useTexStorage ) {

    									state.compressedTexSubImage2D( 3553, i, 0, 0, mipmap.width, mipmap.height, glFormat, mipmap.data );

    								} else {

    									state.compressedTexImage2D( 3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data );

    								}

    							} else {

    								console.warn( 'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()' );

    							}

    						} else {

    							if ( useTexStorage ) {

    								state.texSubImage2D( 3553, i, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data );

    							} else {

    								state.texImage2D( 3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

    							}

    						}

    					}

    				}

    			} else if ( texture.isDataArrayTexture ) {

    				if ( useTexStorage ) {

    					if ( allocateMemory ) {

    						state.texStorage3D( 35866, levels, glInternalFormat, image.width, image.height, image.depth );

    					}

    					state.texSubImage3D( 35866, 0, 0, 0, 0, image.width, image.height, image.depth, glFormat, glType, image.data );

    				} else {

    					state.texImage3D( 35866, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data );

    				}

    			} else if ( texture.isData3DTexture ) {

    				if ( useTexStorage ) {

    					if ( allocateMemory ) {

    						state.texStorage3D( 32879, levels, glInternalFormat, image.width, image.height, image.depth );

    					}

    					state.texSubImage3D( 32879, 0, 0, 0, 0, image.width, image.height, image.depth, glFormat, glType, image.data );

    				} else {

    					state.texImage3D( 32879, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data );

    				}

    			} else if ( texture.isFramebufferTexture ) {

    				if ( allocateMemory ) {

    					if ( useTexStorage ) {

    						state.texStorage2D( 3553, levels, glInternalFormat, image.width, image.height );

    					} else {

    						let width = image.width, height = image.height;

    						for ( let i = 0; i < levels; i ++ ) {

    							state.texImage2D( 3553, i, glInternalFormat, width, height, 0, glFormat, glType, null );

    							width >>= 1;
    							height >>= 1;

    						}

    					}

    				}

    			} else {

    				// regular Texture (image, video, canvas)

    				// use manually created mipmaps if available
    				// if there are no manual mipmaps
    				// set 0 level mipmap and then use GL to generate other mipmap levels

    				if ( mipmaps.length > 0 && supportsMips ) {

    					if ( useTexStorage && allocateMemory ) {

    						state.texStorage2D( 3553, levels, glInternalFormat, mipmaps[ 0 ].width, mipmaps[ 0 ].height );

    					}

    					for ( let i = 0, il = mipmaps.length; i < il; i ++ ) {

    						mipmap = mipmaps[ i ];

    						if ( useTexStorage ) {

    							state.texSubImage2D( 3553, i, 0, 0, glFormat, glType, mipmap );

    						} else {

    							state.texImage2D( 3553, i, glInternalFormat, glFormat, glType, mipmap );

    						}

    					}

    					texture.generateMipmaps = false;

    				} else {

    					if ( useTexStorage ) {

    						if ( allocateMemory ) {

    							state.texStorage2D( 3553, levels, glInternalFormat, image.width, image.height );

    						}

    						state.texSubImage2D( 3553, 0, 0, 0, glFormat, glType, image );

    					} else {

    						state.texImage2D( 3553, 0, glInternalFormat, glFormat, glType, image );

    					}

    				}

    			}

    			if ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {

    				generateMipmap( textureType );

    			}

    			sourceProperties.__version = source.version;

    			if ( texture.onUpdate ) texture.onUpdate( texture );

    		}

    		textureProperties.__version = texture.version;

    	}

    	function uploadCubeTexture( textureProperties, texture, slot ) {

    		if ( texture.image.length !== 6 ) return;

    		const forceUpload = initTexture( textureProperties, texture );
    		const source = texture.source;

    		state.bindTexture( 34067, textureProperties.__webglTexture, 33984 + slot );

    		const sourceProperties = properties.get( source );

    		if ( source.version !== sourceProperties.__version || forceUpload === true ) {

    			state.activeTexture( 33984 + slot );

    			_gl.pixelStorei( 37440, texture.flipY );
    			_gl.pixelStorei( 37441, texture.premultiplyAlpha );
    			_gl.pixelStorei( 3317, texture.unpackAlignment );
    			_gl.pixelStorei( 37443, 0 );

    			const isCompressed = ( texture.isCompressedTexture || texture.image[ 0 ].isCompressedTexture );
    			const isDataTexture = ( texture.image[ 0 ] && texture.image[ 0 ].isDataTexture );

    			const cubeImage = [];

    			for ( let i = 0; i < 6; i ++ ) {

    				if ( ! isCompressed && ! isDataTexture ) {

    					cubeImage[ i ] = resizeImage( texture.image[ i ], false, true, maxCubemapSize );

    				} else {

    					cubeImage[ i ] = isDataTexture ? texture.image[ i ].image : texture.image[ i ];

    				}

    				cubeImage[ i ] = verifyColorSpace( texture, cubeImage[ i ] );

    			}

    			const image = cubeImage[ 0 ],
    				supportsMips = isPowerOfTwo$1( image ) || isWebGL2,
    				glFormat = utils.convert( texture.format, texture.encoding ),
    				glType = utils.convert( texture.type ),
    				glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType, texture.encoding );

    			const useTexStorage = ( isWebGL2 && texture.isVideoTexture !== true );
    			const allocateMemory = ( sourceProperties.__version === undefined ) || ( forceUpload === true );
    			let levels = getMipLevels( texture, image, supportsMips );

    			setTextureParameters( 34067, texture, supportsMips );

    			let mipmaps;

    			if ( isCompressed ) {

    				if ( useTexStorage && allocateMemory ) {

    					state.texStorage2D( 34067, levels, glInternalFormat, image.width, image.height );

    				}

    				for ( let i = 0; i < 6; i ++ ) {

    					mipmaps = cubeImage[ i ].mipmaps;

    					for ( let j = 0; j < mipmaps.length; j ++ ) {

    						const mipmap = mipmaps[ j ];

    						if ( texture.format !== RGBAFormat ) {

    							if ( glFormat !== null ) {

    								if ( useTexStorage ) {

    									state.compressedTexSubImage2D( 34069 + i, j, 0, 0, mipmap.width, mipmap.height, glFormat, mipmap.data );

    								} else {

    									state.compressedTexImage2D( 34069 + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data );

    								}

    							} else {

    								console.warn( 'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()' );

    							}

    						} else {

    							if ( useTexStorage ) {

    								state.texSubImage2D( 34069 + i, j, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data );

    							} else {

    								state.texImage2D( 34069 + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

    							}

    						}

    					}

    				}

    			} else {

    				mipmaps = texture.mipmaps;

    				if ( useTexStorage && allocateMemory ) {

    					// TODO: Uniformly handle mipmap definitions
    					// Normal textures and compressed cube textures define base level + mips with their mipmap array
    					// Uncompressed cube textures use their mipmap array only for mips (no base level)

    					if ( mipmaps.length > 0 ) levels ++;

    					state.texStorage2D( 34067, levels, glInternalFormat, cubeImage[ 0 ].width, cubeImage[ 0 ].height );

    				}

    				for ( let i = 0; i < 6; i ++ ) {

    					if ( isDataTexture ) {

    						if ( useTexStorage ) {

    							state.texSubImage2D( 34069 + i, 0, 0, 0, cubeImage[ i ].width, cubeImage[ i ].height, glFormat, glType, cubeImage[ i ].data );

    						} else {

    							state.texImage2D( 34069 + i, 0, glInternalFormat, cubeImage[ i ].width, cubeImage[ i ].height, 0, glFormat, glType, cubeImage[ i ].data );

    						}

    						for ( let j = 0; j < mipmaps.length; j ++ ) {

    							const mipmap = mipmaps[ j ];
    							const mipmapImage = mipmap.image[ i ].image;

    							if ( useTexStorage ) {

    								state.texSubImage2D( 34069 + i, j + 1, 0, 0, mipmapImage.width, mipmapImage.height, glFormat, glType, mipmapImage.data );

    							} else {

    								state.texImage2D( 34069 + i, j + 1, glInternalFormat, mipmapImage.width, mipmapImage.height, 0, glFormat, glType, mipmapImage.data );

    							}

    						}

    					} else {

    						if ( useTexStorage ) {

    							state.texSubImage2D( 34069 + i, 0, 0, 0, glFormat, glType, cubeImage[ i ] );

    						} else {

    							state.texImage2D( 34069 + i, 0, glInternalFormat, glFormat, glType, cubeImage[ i ] );

    						}

    						for ( let j = 0; j < mipmaps.length; j ++ ) {

    							const mipmap = mipmaps[ j ];

    							if ( useTexStorage ) {

    								state.texSubImage2D( 34069 + i, j + 1, 0, 0, glFormat, glType, mipmap.image[ i ] );

    							} else {

    								state.texImage2D( 34069 + i, j + 1, glInternalFormat, glFormat, glType, mipmap.image[ i ] );

    							}

    						}

    					}

    				}

    			}

    			if ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {

    				// We assume images for cube map have the same size.
    				generateMipmap( 34067 );

    			}

    			sourceProperties.__version = source.version;

    			if ( texture.onUpdate ) texture.onUpdate( texture );

    		}

    		textureProperties.__version = texture.version;

    	}

    	// Render targets

    	// Setup storage for target texture and bind it to correct framebuffer
    	function setupFrameBufferTexture( framebuffer, renderTarget, texture, attachment, textureTarget ) {

    		const glFormat = utils.convert( texture.format, texture.encoding );
    		const glType = utils.convert( texture.type );
    		const glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType, texture.encoding );
    		const renderTargetProperties = properties.get( renderTarget );

    		if ( ! renderTargetProperties.__hasExternalTextures ) {

    			if ( textureTarget === 32879 || textureTarget === 35866 ) {

    				state.texImage3D( textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, renderTarget.depth, 0, glFormat, glType, null );

    			} else {

    				state.texImage2D( textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );

    			}

    		}

    		state.bindFramebuffer( 36160, framebuffer );

    		if ( useMultisampledRTT( renderTarget ) ) {

    			multisampledRTTExt.framebufferTexture2DMultisampleEXT( 36160, attachment, textureTarget, properties.get( texture ).__webglTexture, 0, getRenderTargetSamples( renderTarget ) );

    		} else if ( textureTarget === 3553 || ( textureTarget >= 34069 && textureTarget <= 34074 ) ) { // see #24753

    			_gl.framebufferTexture2D( 36160, attachment, textureTarget, properties.get( texture ).__webglTexture, 0 );

    		}

    		state.bindFramebuffer( 36160, null );

    	}


    	// Setup storage for internal depth/stencil buffers and bind to correct framebuffer
    	function setupRenderBufferStorage( renderbuffer, renderTarget, isMultisample ) {

    		_gl.bindRenderbuffer( 36161, renderbuffer );

    		if ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {

    			let glInternalFormat = 33189;

    			if ( isMultisample || useMultisampledRTT( renderTarget ) ) {

    				const depthTexture = renderTarget.depthTexture;

    				if ( depthTexture && depthTexture.isDepthTexture ) {

    					if ( depthTexture.type === FloatType ) {

    						glInternalFormat = 36012;

    					} else if ( depthTexture.type === UnsignedIntType ) {

    						glInternalFormat = 33190;

    					}

    				}

    				const samples = getRenderTargetSamples( renderTarget );

    				if ( useMultisampledRTT( renderTarget ) ) {

    					multisampledRTTExt.renderbufferStorageMultisampleEXT( 36161, samples, glInternalFormat, renderTarget.width, renderTarget.height );

    				} else {

    					_gl.renderbufferStorageMultisample( 36161, samples, glInternalFormat, renderTarget.width, renderTarget.height );

    				}

    			} else {

    				_gl.renderbufferStorage( 36161, glInternalFormat, renderTarget.width, renderTarget.height );

    			}

    			_gl.framebufferRenderbuffer( 36160, 36096, 36161, renderbuffer );

    		} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {

    			const samples = getRenderTargetSamples( renderTarget );

    			if ( isMultisample && useMultisampledRTT( renderTarget ) === false ) {

    				_gl.renderbufferStorageMultisample( 36161, samples, 35056, renderTarget.width, renderTarget.height );

    			} else if ( useMultisampledRTT( renderTarget ) ) {

    				multisampledRTTExt.renderbufferStorageMultisampleEXT( 36161, samples, 35056, renderTarget.width, renderTarget.height );

    			} else {

    				_gl.renderbufferStorage( 36161, 34041, renderTarget.width, renderTarget.height );

    			}


    			_gl.framebufferRenderbuffer( 36160, 33306, 36161, renderbuffer );

    		} else {

    			const textures = renderTarget.isWebGLMultipleRenderTargets === true ? renderTarget.texture : [ renderTarget.texture ];

    			for ( let i = 0; i < textures.length; i ++ ) {

    				const texture = textures[ i ];

    				const glFormat = utils.convert( texture.format, texture.encoding );
    				const glType = utils.convert( texture.type );
    				const glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType, texture.encoding );
    				const samples = getRenderTargetSamples( renderTarget );

    				if ( isMultisample && useMultisampledRTT( renderTarget ) === false ) {

    					_gl.renderbufferStorageMultisample( 36161, samples, glInternalFormat, renderTarget.width, renderTarget.height );

    				} else if ( useMultisampledRTT( renderTarget ) ) {

    					multisampledRTTExt.renderbufferStorageMultisampleEXT( 36161, samples, glInternalFormat, renderTarget.width, renderTarget.height );

    				} else {

    					_gl.renderbufferStorage( 36161, glInternalFormat, renderTarget.width, renderTarget.height );

    				}

    			}

    		}

    		_gl.bindRenderbuffer( 36161, null );

    	}

    	// Setup resources for a Depth Texture for a FBO (needs an extension)
    	function setupDepthTexture( framebuffer, renderTarget ) {

    		const isCube = ( renderTarget && renderTarget.isWebGLCubeRenderTarget );
    		if ( isCube ) throw new Error( 'Depth Texture with cube render targets is not supported' );

    		state.bindFramebuffer( 36160, framebuffer );

    		if ( ! ( renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture ) ) {

    			throw new Error( 'renderTarget.depthTexture must be an instance of THREE.DepthTexture' );

    		}

    		// upload an empty depth texture with framebuffer size
    		if ( ! properties.get( renderTarget.depthTexture ).__webglTexture ||
    				renderTarget.depthTexture.image.width !== renderTarget.width ||
    				renderTarget.depthTexture.image.height !== renderTarget.height ) {

    			renderTarget.depthTexture.image.width = renderTarget.width;
    			renderTarget.depthTexture.image.height = renderTarget.height;
    			renderTarget.depthTexture.needsUpdate = true;

    		}

    		setTexture2D( renderTarget.depthTexture, 0 );

    		const webglDepthTexture = properties.get( renderTarget.depthTexture ).__webglTexture;
    		const samples = getRenderTargetSamples( renderTarget );

    		if ( renderTarget.depthTexture.format === DepthFormat ) {

    			if ( useMultisampledRTT( renderTarget ) ) {

    				multisampledRTTExt.framebufferTexture2DMultisampleEXT( 36160, 36096, 3553, webglDepthTexture, 0, samples );

    			} else {

    				_gl.framebufferTexture2D( 36160, 36096, 3553, webglDepthTexture, 0 );

    			}

    		} else if ( renderTarget.depthTexture.format === DepthStencilFormat ) {

    			if ( useMultisampledRTT( renderTarget ) ) {

    				multisampledRTTExt.framebufferTexture2DMultisampleEXT( 36160, 33306, 3553, webglDepthTexture, 0, samples );

    			} else {

    				_gl.framebufferTexture2D( 36160, 33306, 3553, webglDepthTexture, 0 );

    			}

    		} else {

    			throw new Error( 'Unknown depthTexture format' );

    		}

    	}

    	// Setup GL resources for a non-texture depth buffer
    	function setupDepthRenderbuffer( renderTarget ) {

    		const renderTargetProperties = properties.get( renderTarget );
    		const isCube = ( renderTarget.isWebGLCubeRenderTarget === true );

    		if ( renderTarget.depthTexture && ! renderTargetProperties.__autoAllocateDepthBuffer ) {

    			if ( isCube ) throw new Error( 'target.depthTexture not supported in Cube render targets' );

    			setupDepthTexture( renderTargetProperties.__webglFramebuffer, renderTarget );

    		} else {

    			if ( isCube ) {

    				renderTargetProperties.__webglDepthbuffer = [];

    				for ( let i = 0; i < 6; i ++ ) {

    					state.bindFramebuffer( 36160, renderTargetProperties.__webglFramebuffer[ i ] );
    					renderTargetProperties.__webglDepthbuffer[ i ] = _gl.createRenderbuffer();
    					setupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer[ i ], renderTarget, false );

    				}

    			} else {

    				state.bindFramebuffer( 36160, renderTargetProperties.__webglFramebuffer );
    				renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
    				setupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer, renderTarget, false );

    			}

    		}

    		state.bindFramebuffer( 36160, null );

    	}

    	// rebind framebuffer with external textures
    	function rebindTextures( renderTarget, colorTexture, depthTexture ) {

    		const renderTargetProperties = properties.get( renderTarget );

    		if ( colorTexture !== undefined ) {

    			setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, renderTarget.texture, 36064, 3553 );

    		}

    		if ( depthTexture !== undefined ) {

    			setupDepthRenderbuffer( renderTarget );

    		}

    	}

    	// Set up GL resources for the render target
    	function setupRenderTarget( renderTarget ) {

    		const texture = renderTarget.texture;

    		const renderTargetProperties = properties.get( renderTarget );
    		const textureProperties = properties.get( texture );

    		renderTarget.addEventListener( 'dispose', onRenderTargetDispose );

    		if ( renderTarget.isWebGLMultipleRenderTargets !== true ) {

    			if ( textureProperties.__webglTexture === undefined ) {

    				textureProperties.__webglTexture = _gl.createTexture();

    			}

    			textureProperties.__version = texture.version;
    			info.memory.textures ++;

    		}

    		const isCube = ( renderTarget.isWebGLCubeRenderTarget === true );
    		const isMultipleRenderTargets = ( renderTarget.isWebGLMultipleRenderTargets === true );
    		const supportsMips = isPowerOfTwo$1( renderTarget ) || isWebGL2;

    		// Setup framebuffer

    		if ( isCube ) {

    			renderTargetProperties.__webglFramebuffer = [];

    			for ( let i = 0; i < 6; i ++ ) {

    				renderTargetProperties.__webglFramebuffer[ i ] = _gl.createFramebuffer();

    			}

    		} else {

    			renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();

    			if ( isMultipleRenderTargets ) {

    				if ( capabilities.drawBuffers ) {

    					const textures = renderTarget.texture;

    					for ( let i = 0, il = textures.length; i < il; i ++ ) {

    						const attachmentProperties = properties.get( textures[ i ] );

    						if ( attachmentProperties.__webglTexture === undefined ) {

    							attachmentProperties.__webglTexture = _gl.createTexture();

    							info.memory.textures ++;

    						}

    					}

    				} else {

    					console.warn( 'THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.' );

    				}

    			}

    			if ( ( isWebGL2 && renderTarget.samples > 0 ) && useMultisampledRTT( renderTarget ) === false ) {

    				const textures = isMultipleRenderTargets ? texture : [ texture ];

    				renderTargetProperties.__webglMultisampledFramebuffer = _gl.createFramebuffer();
    				renderTargetProperties.__webglColorRenderbuffer = [];

    				state.bindFramebuffer( 36160, renderTargetProperties.__webglMultisampledFramebuffer );

    				for ( let i = 0; i < textures.length; i ++ ) {

    					const texture = textures[ i ];
    					renderTargetProperties.__webglColorRenderbuffer[ i ] = _gl.createRenderbuffer();

    					_gl.bindRenderbuffer( 36161, renderTargetProperties.__webglColorRenderbuffer[ i ] );

    					const glFormat = utils.convert( texture.format, texture.encoding );
    					const glType = utils.convert( texture.type );
    					const glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType, texture.encoding, renderTarget.isXRRenderTarget === true );
    					const samples = getRenderTargetSamples( renderTarget );
    					_gl.renderbufferStorageMultisample( 36161, samples, glInternalFormat, renderTarget.width, renderTarget.height );

    					_gl.framebufferRenderbuffer( 36160, 36064 + i, 36161, renderTargetProperties.__webglColorRenderbuffer[ i ] );

    				}

    				_gl.bindRenderbuffer( 36161, null );

    				if ( renderTarget.depthBuffer ) {

    					renderTargetProperties.__webglDepthRenderbuffer = _gl.createRenderbuffer();
    					setupRenderBufferStorage( renderTargetProperties.__webglDepthRenderbuffer, renderTarget, true );

    				}

    				state.bindFramebuffer( 36160, null );

    			}

    		}

    		// Setup color buffer

    		if ( isCube ) {

    			state.bindTexture( 34067, textureProperties.__webglTexture );
    			setTextureParameters( 34067, texture, supportsMips );

    			for ( let i = 0; i < 6; i ++ ) {

    				setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer[ i ], renderTarget, texture, 36064, 34069 + i );

    			}

    			if ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {

    				generateMipmap( 34067 );

    			}

    			state.unbindTexture();

    		} else if ( isMultipleRenderTargets ) {

    			const textures = renderTarget.texture;

    			for ( let i = 0, il = textures.length; i < il; i ++ ) {

    				const attachment = textures[ i ];
    				const attachmentProperties = properties.get( attachment );

    				state.bindTexture( 3553, attachmentProperties.__webglTexture );
    				setTextureParameters( 3553, attachment, supportsMips );
    				setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, attachment, 36064 + i, 3553 );

    				if ( textureNeedsGenerateMipmaps( attachment, supportsMips ) ) {

    					generateMipmap( 3553 );

    				}

    			}

    			state.unbindTexture();

    		} else {

    			let glTextureType = 3553;

    			if ( renderTarget.isWebGL3DRenderTarget || renderTarget.isWebGLArrayRenderTarget ) {

    				if ( isWebGL2 ) {

    					glTextureType = renderTarget.isWebGL3DRenderTarget ? 32879 : 35866;

    				} else {

    					console.error( 'THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.' );

    				}

    			}

    			state.bindTexture( glTextureType, textureProperties.__webglTexture );
    			setTextureParameters( glTextureType, texture, supportsMips );
    			setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, texture, 36064, glTextureType );

    			if ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {

    				generateMipmap( glTextureType );

    			}

    			state.unbindTexture();

    		}

    		// Setup depth and stencil buffers

    		if ( renderTarget.depthBuffer ) {

    			setupDepthRenderbuffer( renderTarget );

    		}

    	}

    	function updateRenderTargetMipmap( renderTarget ) {

    		const supportsMips = isPowerOfTwo$1( renderTarget ) || isWebGL2;

    		const textures = renderTarget.isWebGLMultipleRenderTargets === true ? renderTarget.texture : [ renderTarget.texture ];

    		for ( let i = 0, il = textures.length; i < il; i ++ ) {

    			const texture = textures[ i ];

    			if ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {

    				const target = renderTarget.isWebGLCubeRenderTarget ? 34067 : 3553;
    				const webglTexture = properties.get( texture ).__webglTexture;

    				state.bindTexture( target, webglTexture );
    				generateMipmap( target );
    				state.unbindTexture();

    			}

    		}

    	}

    	function updateMultisampleRenderTarget( renderTarget ) {

    		if ( ( isWebGL2 && renderTarget.samples > 0 ) && useMultisampledRTT( renderTarget ) === false ) {

    			const textures = renderTarget.isWebGLMultipleRenderTargets ? renderTarget.texture : [ renderTarget.texture ];
    			const width = renderTarget.width;
    			const height = renderTarget.height;
    			let mask = 16384;
    			const invalidationArray = [];
    			const depthStyle = renderTarget.stencilBuffer ? 33306 : 36096;
    			const renderTargetProperties = properties.get( renderTarget );
    			const isMultipleRenderTargets = ( renderTarget.isWebGLMultipleRenderTargets === true );

    			// If MRT we need to remove FBO attachments
    			if ( isMultipleRenderTargets ) {

    				for ( let i = 0; i < textures.length; i ++ ) {

    					state.bindFramebuffer( 36160, renderTargetProperties.__webglMultisampledFramebuffer );
    					_gl.framebufferRenderbuffer( 36160, 36064 + i, 36161, null );

    					state.bindFramebuffer( 36160, renderTargetProperties.__webglFramebuffer );
    					_gl.framebufferTexture2D( 36009, 36064 + i, 3553, null, 0 );

    				}

    			}

    			state.bindFramebuffer( 36008, renderTargetProperties.__webglMultisampledFramebuffer );
    			state.bindFramebuffer( 36009, renderTargetProperties.__webglFramebuffer );

    			for ( let i = 0; i < textures.length; i ++ ) {

    				invalidationArray.push( 36064 + i );

    				if ( renderTarget.depthBuffer ) {

    					invalidationArray.push( depthStyle );

    				}

    				const ignoreDepthValues = ( renderTargetProperties.__ignoreDepthValues !== undefined ) ? renderTargetProperties.__ignoreDepthValues : false;

    				if ( ignoreDepthValues === false ) {

    					if ( renderTarget.depthBuffer ) mask |= 256;
    					if ( renderTarget.stencilBuffer ) mask |= 1024;

    				}

    				if ( isMultipleRenderTargets ) {

    					_gl.framebufferRenderbuffer( 36008, 36064, 36161, renderTargetProperties.__webglColorRenderbuffer[ i ] );

    				}

    				if ( ignoreDepthValues === true ) {

    					_gl.invalidateFramebuffer( 36008, [ depthStyle ] );
    					_gl.invalidateFramebuffer( 36009, [ depthStyle ] );

    				}

    				if ( isMultipleRenderTargets ) {

    					const webglTexture = properties.get( textures[ i ] ).__webglTexture;
    					_gl.framebufferTexture2D( 36009, 36064, 3553, webglTexture, 0 );

    				}

    				_gl.blitFramebuffer( 0, 0, width, height, 0, 0, width, height, mask, 9728 );

    				if ( supportsInvalidateFramebuffer ) {

    					_gl.invalidateFramebuffer( 36008, invalidationArray );

    				}


    			}

    			state.bindFramebuffer( 36008, null );
    			state.bindFramebuffer( 36009, null );

    			// If MRT since pre-blit we removed the FBO we need to reconstruct the attachments
    			if ( isMultipleRenderTargets ) {

    				for ( let i = 0; i < textures.length; i ++ ) {

    					state.bindFramebuffer( 36160, renderTargetProperties.__webglMultisampledFramebuffer );
    					_gl.framebufferRenderbuffer( 36160, 36064 + i, 36161, renderTargetProperties.__webglColorRenderbuffer[ i ] );

    					const webglTexture = properties.get( textures[ i ] ).__webglTexture;

    					state.bindFramebuffer( 36160, renderTargetProperties.__webglFramebuffer );
    					_gl.framebufferTexture2D( 36009, 36064 + i, 3553, webglTexture, 0 );

    				}

    			}

    			state.bindFramebuffer( 36009, renderTargetProperties.__webglMultisampledFramebuffer );

    		}

    	}

    	function getRenderTargetSamples( renderTarget ) {

    		return Math.min( maxSamples, renderTarget.samples );

    	}

    	function useMultisampledRTT( renderTarget ) {

    		const renderTargetProperties = properties.get( renderTarget );

    		return isWebGL2 && renderTarget.samples > 0 && extensions.has( 'WEBGL_multisampled_render_to_texture' ) === true && renderTargetProperties.__useRenderToTexture !== false;

    	}

    	function updateVideoTexture( texture ) {

    		const frame = info.render.frame;

    		// Check the last frame we updated the VideoTexture

    		if ( _videoTextures.get( texture ) !== frame ) {

    			_videoTextures.set( texture, frame );
    			texture.update();

    		}

    	}

    	function verifyColorSpace( texture, image ) {

    		const encoding = texture.encoding;
    		const format = texture.format;
    		const type = texture.type;

    		if ( texture.isCompressedTexture === true || texture.isVideoTexture === true || texture.format === _SRGBAFormat ) return image;

    		if ( encoding !== LinearEncoding ) {

    			// sRGB

    			if ( encoding === sRGBEncoding ) {

    				if ( isWebGL2 === false ) {

    					// in WebGL 1, try to use EXT_sRGB extension and unsized formats

    					if ( extensions.has( 'EXT_sRGB' ) === true && format === RGBAFormat ) {

    						texture.format = _SRGBAFormat;

    						// it's not possible to generate mips in WebGL 1 with this extension

    						texture.minFilter = LinearFilter;
    						texture.generateMipmaps = false;

    					} else {

    						// slow fallback (CPU decode)

    						image = ImageUtils.sRGBToLinear( image );

    					}

    				} else {

    					// in WebGL 2 uncompressed textures can only be sRGB encoded if they have the RGBA8 format

    					if ( format !== RGBAFormat || type !== UnsignedByteType ) {

    						console.warn( 'THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.' );

    					}

    				}

    			} else {

    				console.error( 'THREE.WebGLTextures: Unsupported texture encoding:', encoding );

    			}

    		}

    		return image;

    	}

    	//

    	this.allocateTextureUnit = allocateTextureUnit;
    	this.resetTextureUnits = resetTextureUnits;

    	this.setTexture2D = setTexture2D;
    	this.setTexture2DArray = setTexture2DArray;
    	this.setTexture3D = setTexture3D;
    	this.setTextureCube = setTextureCube;
    	this.rebindTextures = rebindTextures;
    	this.setupRenderTarget = setupRenderTarget;
    	this.updateRenderTargetMipmap = updateRenderTargetMipmap;
    	this.updateMultisampleRenderTarget = updateMultisampleRenderTarget;
    	this.setupDepthRenderbuffer = setupDepthRenderbuffer;
    	this.setupFrameBufferTexture = setupFrameBufferTexture;
    	this.useMultisampledRTT = useMultisampledRTT;

    }

    function WebGLUtils( gl, extensions, capabilities ) {

    	const isWebGL2 = capabilities.isWebGL2;

    	function convert( p, encoding = null ) {

    		let extension;

    		if ( p === UnsignedByteType ) return 5121;
    		if ( p === UnsignedShort4444Type ) return 32819;
    		if ( p === UnsignedShort5551Type ) return 32820;

    		if ( p === ByteType ) return 5120;
    		if ( p === ShortType ) return 5122;
    		if ( p === UnsignedShortType ) return 5123;
    		if ( p === IntType ) return 5124;
    		if ( p === UnsignedIntType ) return 5125;
    		if ( p === FloatType ) return 5126;

    		if ( p === HalfFloatType ) {

    			if ( isWebGL2 ) return 5131;

    			extension = extensions.get( 'OES_texture_half_float' );

    			if ( extension !== null ) {

    				return extension.HALF_FLOAT_OES;

    			} else {

    				return null;

    			}

    		}

    		if ( p === AlphaFormat ) return 6406;
    		if ( p === RGBAFormat ) return 6408;
    		if ( p === LuminanceFormat ) return 6409;
    		if ( p === LuminanceAlphaFormat ) return 6410;
    		if ( p === DepthFormat ) return 6402;
    		if ( p === DepthStencilFormat ) return 34041;

    		// @deprecated since r137

    		if ( p === RGBFormat ) {

    			console.warn( 'THREE.WebGLRenderer: THREE.RGBFormat has been removed. Use THREE.RGBAFormat instead. https://github.com/mrdoob/three.js/pull/23228' );
    			return 6408;

    		}

    		// WebGL 1 sRGB fallback

    		if ( p === _SRGBAFormat ) {

    			extension = extensions.get( 'EXT_sRGB' );

    			if ( extension !== null ) {

    				return extension.SRGB_ALPHA_EXT;

    			} else {

    				return null;

    			}

    		}

    		// WebGL2 formats.

    		if ( p === RedFormat ) return 6403;
    		if ( p === RedIntegerFormat ) return 36244;
    		if ( p === RGFormat ) return 33319;
    		if ( p === RGIntegerFormat ) return 33320;
    		if ( p === RGBAIntegerFormat ) return 36249;

    		// S3TC

    		if ( p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format || p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format ) {

    			if ( encoding === sRGBEncoding ) {

    				extension = extensions.get( 'WEBGL_compressed_texture_s3tc_srgb' );

    				if ( extension !== null ) {

    					if ( p === RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_SRGB_S3TC_DXT1_EXT;
    					if ( p === RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
    					if ( p === RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
    					if ( p === RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;

    				} else {

    					return null;

    				}

    			} else {

    				extension = extensions.get( 'WEBGL_compressed_texture_s3tc' );

    				if ( extension !== null ) {

    					if ( p === RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
    					if ( p === RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
    					if ( p === RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
    					if ( p === RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;

    				} else {

    					return null;

    				}

    			}

    		}

    		// PVRTC

    		if ( p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format || p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format ) {

    			extension = extensions.get( 'WEBGL_compressed_texture_pvrtc' );

    			if ( extension !== null ) {

    				if ( p === RGB_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
    				if ( p === RGB_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
    				if ( p === RGBA_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
    				if ( p === RGBA_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;

    			} else {

    				return null;

    			}

    		}

    		// ETC1

    		if ( p === RGB_ETC1_Format ) {

    			extension = extensions.get( 'WEBGL_compressed_texture_etc1' );

    			if ( extension !== null ) {

    				return extension.COMPRESSED_RGB_ETC1_WEBGL;

    			} else {

    				return null;

    			}

    		}

    		// ETC2

    		if ( p === RGB_ETC2_Format || p === RGBA_ETC2_EAC_Format ) {

    			extension = extensions.get( 'WEBGL_compressed_texture_etc' );

    			if ( extension !== null ) {

    				if ( p === RGB_ETC2_Format ) return ( encoding === sRGBEncoding ) ? extension.COMPRESSED_SRGB8_ETC2 : extension.COMPRESSED_RGB8_ETC2;
    				if ( p === RGBA_ETC2_EAC_Format ) return ( encoding === sRGBEncoding ) ? extension.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : extension.COMPRESSED_RGBA8_ETC2_EAC;

    			} else {

    				return null;

    			}

    		}

    		// ASTC

    		if ( p === RGBA_ASTC_4x4_Format || p === RGBA_ASTC_5x4_Format || p === RGBA_ASTC_5x5_Format ||
    			p === RGBA_ASTC_6x5_Format || p === RGBA_ASTC_6x6_Format || p === RGBA_ASTC_8x5_Format ||
    			p === RGBA_ASTC_8x6_Format || p === RGBA_ASTC_8x8_Format || p === RGBA_ASTC_10x5_Format ||
    			p === RGBA_ASTC_10x6_Format || p === RGBA_ASTC_10x8_Format || p === RGBA_ASTC_10x10_Format ||
    			p === RGBA_ASTC_12x10_Format || p === RGBA_ASTC_12x12_Format ) {

    			extension = extensions.get( 'WEBGL_compressed_texture_astc' );

    			if ( extension !== null ) {

    				if ( p === RGBA_ASTC_4x4_Format ) return ( encoding === sRGBEncoding ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : extension.COMPRESSED_RGBA_ASTC_4x4_KHR;
    				if ( p === RGBA_ASTC_5x4_Format ) return ( encoding === sRGBEncoding ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : extension.COMPRESSED_RGBA_ASTC_5x4_KHR;
    				if ( p === RGBA_ASTC_5x5_Format ) return ( encoding === sRGBEncoding ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : extension.COMPRESSED_RGBA_ASTC_5x5_KHR;
    				if ( p === RGBA_ASTC_6x5_Format ) return ( encoding === sRGBEncoding ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : extension.COMPRESSED_RGBA_ASTC_6x5_KHR;
    				if ( p === RGBA_ASTC_6x6_Format ) return ( encoding === sRGBEncoding ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : extension.COMPRESSED_RGBA_ASTC_6x6_KHR;
    				if ( p === RGBA_ASTC_8x5_Format ) return ( encoding === sRGBEncoding ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : extension.COMPRESSED_RGBA_ASTC_8x5_KHR;
    				if ( p === RGBA_ASTC_8x6_Format ) return ( encoding === sRGBEncoding ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : extension.COMPRESSED_RGBA_ASTC_8x6_KHR;
    				if ( p === RGBA_ASTC_8x8_Format ) return ( encoding === sRGBEncoding ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : extension.COMPRESSED_RGBA_ASTC_8x8_KHR;
    				if ( p === RGBA_ASTC_10x5_Format ) return ( encoding === sRGBEncoding ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : extension.COMPRESSED_RGBA_ASTC_10x5_KHR;
    				if ( p === RGBA_ASTC_10x6_Format ) return ( encoding === sRGBEncoding ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : extension.COMPRESSED_RGBA_ASTC_10x6_KHR;
    				if ( p === RGBA_ASTC_10x8_Format ) return ( encoding === sRGBEncoding ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : extension.COMPRESSED_RGBA_ASTC_10x8_KHR;
    				if ( p === RGBA_ASTC_10x10_Format ) return ( encoding === sRGBEncoding ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : extension.COMPRESSED_RGBA_ASTC_10x10_KHR;
    				if ( p === RGBA_ASTC_12x10_Format ) return ( encoding === sRGBEncoding ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : extension.COMPRESSED_RGBA_ASTC_12x10_KHR;
    				if ( p === RGBA_ASTC_12x12_Format ) return ( encoding === sRGBEncoding ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : extension.COMPRESSED_RGBA_ASTC_12x12_KHR;

    			} else {

    				return null;

    			}

    		}

    		// BPTC

    		if ( p === RGBA_BPTC_Format ) {

    			extension = extensions.get( 'EXT_texture_compression_bptc' );

    			if ( extension !== null ) {

    				if ( p === RGBA_BPTC_Format ) return ( encoding === sRGBEncoding ) ? extension.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : extension.COMPRESSED_RGBA_BPTC_UNORM_EXT;

    			} else {

    				return null;

    			}

    		}

    		//

    		if ( p === UnsignedInt248Type ) {

    			if ( isWebGL2 ) return 34042;

    			extension = extensions.get( 'WEBGL_depth_texture' );

    			if ( extension !== null ) {

    				return extension.UNSIGNED_INT_24_8_WEBGL;

    			} else {

    				return null;

    			}

    		}

    		// if "p" can't be resolved, assume the user defines a WebGL constant as a string (fallback/workaround for packed RGB formats)

    		return ( gl[ p ] !== undefined ) ? gl[ p ] : null;

    	}

    	return { convert: convert };

    }

    class ArrayCamera extends PerspectiveCamera {

    	constructor( array = [] ) {

    		super();

    		this.isArrayCamera = true;

    		this.cameras = array;

    	}

    }

    class Group$1 extends Object3D {

    	constructor() {

    		super();

    		this.isGroup = true;

    		this.type = 'Group';

    	}

    }

    const _moveEvent = { type: 'move' };

    class WebXRController {

    	constructor() {

    		this._targetRay = null;
    		this._grip = null;
    		this._hand = null;

    	}

    	getHandSpace() {

    		if ( this._hand === null ) {

    			this._hand = new Group$1();
    			this._hand.matrixAutoUpdate = false;
    			this._hand.visible = false;

    			this._hand.joints = {};
    			this._hand.inputState = { pinching: false };

    		}

    		return this._hand;

    	}

    	getTargetRaySpace() {

    		if ( this._targetRay === null ) {

    			this._targetRay = new Group$1();
    			this._targetRay.matrixAutoUpdate = false;
    			this._targetRay.visible = false;
    			this._targetRay.hasLinearVelocity = false;
    			this._targetRay.linearVelocity = new Vector3();
    			this._targetRay.hasAngularVelocity = false;
    			this._targetRay.angularVelocity = new Vector3();

    		}

    		return this._targetRay;

    	}

    	getGripSpace() {

    		if ( this._grip === null ) {

    			this._grip = new Group$1();
    			this._grip.matrixAutoUpdate = false;
    			this._grip.visible = false;
    			this._grip.hasLinearVelocity = false;
    			this._grip.linearVelocity = new Vector3();
    			this._grip.hasAngularVelocity = false;
    			this._grip.angularVelocity = new Vector3();

    		}

    		return this._grip;

    	}

    	dispatchEvent( event ) {

    		if ( this._targetRay !== null ) {

    			this._targetRay.dispatchEvent( event );

    		}

    		if ( this._grip !== null ) {

    			this._grip.dispatchEvent( event );

    		}

    		if ( this._hand !== null ) {

    			this._hand.dispatchEvent( event );

    		}

    		return this;

    	}

    	connect( inputSource ) {

    		if ( inputSource && inputSource.hand ) {

    			const hand = this._hand;

    			if ( hand ) {

    				for ( const inputjoint of inputSource.hand.values() ) {

    					// Initialize hand with joints when connected
    					this._getHandJoint( hand, inputjoint );

    				}

    			}

    		}

    		this.dispatchEvent( { type: 'connected', data: inputSource } );

    		return this;

    	}

    	disconnect( inputSource ) {

    		this.dispatchEvent( { type: 'disconnected', data: inputSource } );

    		if ( this._targetRay !== null ) {

    			this._targetRay.visible = false;

    		}

    		if ( this._grip !== null ) {

    			this._grip.visible = false;

    		}

    		if ( this._hand !== null ) {

    			this._hand.visible = false;

    		}

    		return this;

    	}

    	update( inputSource, frame, referenceSpace ) {

    		let inputPose = null;
    		let gripPose = null;
    		let handPose = null;

    		const targetRay = this._targetRay;
    		const grip = this._grip;
    		const hand = this._hand;

    		if ( inputSource && frame.session.visibilityState !== 'visible-blurred' ) {

    			if ( hand && inputSource.hand ) {

    				handPose = true;

    				for ( const inputjoint of inputSource.hand.values() ) {

    					// Update the joints groups with the XRJoint poses
    					const jointPose = frame.getJointPose( inputjoint, referenceSpace );

    					// The transform of this joint will be updated with the joint pose on each frame
    					const joint = this._getHandJoint( hand, inputjoint );

    					if ( jointPose !== null ) {

    						joint.matrix.fromArray( jointPose.transform.matrix );
    						joint.matrix.decompose( joint.position, joint.rotation, joint.scale );
    						joint.jointRadius = jointPose.radius;

    					}

    					joint.visible = jointPose !== null;

    				}

    				// Custom events

    				// Check pinchz
    				const indexTip = hand.joints[ 'index-finger-tip' ];
    				const thumbTip = hand.joints[ 'thumb-tip' ];
    				const distance = indexTip.position.distanceTo( thumbTip.position );

    				const distanceToPinch = 0.02;
    				const threshold = 0.005;

    				if ( hand.inputState.pinching && distance > distanceToPinch + threshold ) {

    					hand.inputState.pinching = false;
    					this.dispatchEvent( {
    						type: 'pinchend',
    						handedness: inputSource.handedness,
    						target: this
    					} );

    				} else if ( ! hand.inputState.pinching && distance <= distanceToPinch - threshold ) {

    					hand.inputState.pinching = true;
    					this.dispatchEvent( {
    						type: 'pinchstart',
    						handedness: inputSource.handedness,
    						target: this
    					} );

    				}

    			} else {

    				if ( grip !== null && inputSource.gripSpace ) {

    					gripPose = frame.getPose( inputSource.gripSpace, referenceSpace );

    					if ( gripPose !== null ) {

    						grip.matrix.fromArray( gripPose.transform.matrix );
    						grip.matrix.decompose( grip.position, grip.rotation, grip.scale );

    						if ( gripPose.linearVelocity ) {

    							grip.hasLinearVelocity = true;
    							grip.linearVelocity.copy( gripPose.linearVelocity );

    						} else {

    							grip.hasLinearVelocity = false;

    						}

    						if ( gripPose.angularVelocity ) {

    							grip.hasAngularVelocity = true;
    							grip.angularVelocity.copy( gripPose.angularVelocity );

    						} else {

    							grip.hasAngularVelocity = false;

    						}

    					}

    				}

    			}

    			if ( targetRay !== null ) {

    				inputPose = frame.getPose( inputSource.targetRaySpace, referenceSpace );

    				// Some runtimes (namely Vive Cosmos with Vive OpenXR Runtime) have only grip space and ray space is equal to it
    				if ( inputPose === null && gripPose !== null ) {

    					inputPose = gripPose;

    				}

    				if ( inputPose !== null ) {

    					targetRay.matrix.fromArray( inputPose.transform.matrix );
    					targetRay.matrix.decompose( targetRay.position, targetRay.rotation, targetRay.scale );

    					if ( inputPose.linearVelocity ) {

    						targetRay.hasLinearVelocity = true;
    						targetRay.linearVelocity.copy( inputPose.linearVelocity );

    					} else {

    						targetRay.hasLinearVelocity = false;

    					}

    					if ( inputPose.angularVelocity ) {

    						targetRay.hasAngularVelocity = true;
    						targetRay.angularVelocity.copy( inputPose.angularVelocity );

    					} else {

    						targetRay.hasAngularVelocity = false;

    					}

    					this.dispatchEvent( _moveEvent );

    				}

    			}


    		}

    		if ( targetRay !== null ) {

    			targetRay.visible = ( inputPose !== null );

    		}

    		if ( grip !== null ) {

    			grip.visible = ( gripPose !== null );

    		}

    		if ( hand !== null ) {

    			hand.visible = ( handPose !== null );

    		}

    		return this;

    	}

    	// private method

    	_getHandJoint( hand, inputjoint ) {

    		if ( hand.joints[ inputjoint.jointName ] === undefined ) {

    			const joint = new Group$1();
    			joint.matrixAutoUpdate = false;
    			joint.visible = false;
    			hand.joints[ inputjoint.jointName ] = joint;

    			hand.add( joint );

    		}

    		return hand.joints[ inputjoint.jointName ];

    	}

    }

    class DepthTexture extends Texture {

    	constructor( width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format ) {

    		format = format !== undefined ? format : DepthFormat;

    		if ( format !== DepthFormat && format !== DepthStencilFormat ) {

    			throw new Error( 'DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat' );

    		}

    		if ( type === undefined && format === DepthFormat ) type = UnsignedIntType;
    		if ( type === undefined && format === DepthStencilFormat ) type = UnsignedInt248Type;

    		super( null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

    		this.isDepthTexture = true;

    		this.image = { width: width, height: height };

    		this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
    		this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;

    		this.flipY = false;
    		this.generateMipmaps = false;

    	}


    }

    class WebXRManager extends EventDispatcher {

    	constructor( renderer, gl ) {

    		super();

    		const scope = this;

    		let session = null;
    		let framebufferScaleFactor = 1.0;

    		let referenceSpace = null;
    		let referenceSpaceType = 'local-floor';
    		let customReferenceSpace = null;

    		let pose = null;
    		let glBinding = null;
    		let glProjLayer = null;
    		let glBaseLayer = null;
    		let xrFrame = null;
    		const attributes = gl.getContextAttributes();
    		let initialRenderTarget = null;
    		let newRenderTarget = null;

    		const controllers = [];
    		const controllerInputSources = [];

    		const planes = new Set();
    		const planesLastChangedTimes = new Map();

    		//

    		const cameraL = new PerspectiveCamera();
    		cameraL.layers.enable( 1 );
    		cameraL.viewport = new Vector4();

    		const cameraR = new PerspectiveCamera();
    		cameraR.layers.enable( 2 );
    		cameraR.viewport = new Vector4();

    		const cameras = [ cameraL, cameraR ];

    		const cameraVR = new ArrayCamera();
    		cameraVR.layers.enable( 1 );
    		cameraVR.layers.enable( 2 );

    		let _currentDepthNear = null;
    		let _currentDepthFar = null;

    		//

    		this.cameraAutoUpdate = true;
    		this.enabled = false;

    		this.isPresenting = false;

    		this.getController = function ( index ) {

    			let controller = controllers[ index ];

    			if ( controller === undefined ) {

    				controller = new WebXRController();
    				controllers[ index ] = controller;

    			}

    			return controller.getTargetRaySpace();

    		};

    		this.getControllerGrip = function ( index ) {

    			let controller = controllers[ index ];

    			if ( controller === undefined ) {

    				controller = new WebXRController();
    				controllers[ index ] = controller;

    			}

    			return controller.getGripSpace();

    		};

    		this.getHand = function ( index ) {

    			let controller = controllers[ index ];

    			if ( controller === undefined ) {

    				controller = new WebXRController();
    				controllers[ index ] = controller;

    			}

    			return controller.getHandSpace();

    		};

    		//

    		function onSessionEvent( event ) {

    			const controllerIndex = controllerInputSources.indexOf( event.inputSource );

    			if ( controllerIndex === - 1 ) {

    				return;

    			}

    			const controller = controllers[ controllerIndex ];

    			if ( controller !== undefined ) {

    				controller.dispatchEvent( { type: event.type, data: event.inputSource } );

    			}

    		}

    		function onSessionEnd() {

    			session.removeEventListener( 'select', onSessionEvent );
    			session.removeEventListener( 'selectstart', onSessionEvent );
    			session.removeEventListener( 'selectend', onSessionEvent );
    			session.removeEventListener( 'squeeze', onSessionEvent );
    			session.removeEventListener( 'squeezestart', onSessionEvent );
    			session.removeEventListener( 'squeezeend', onSessionEvent );
    			session.removeEventListener( 'end', onSessionEnd );
    			session.removeEventListener( 'inputsourceschange', onInputSourcesChange );

    			for ( let i = 0; i < controllers.length; i ++ ) {

    				const inputSource = controllerInputSources[ i ];

    				if ( inputSource === null ) continue;

    				controllerInputSources[ i ] = null;

    				controllers[ i ].disconnect( inputSource );

    			}

    			_currentDepthNear = null;
    			_currentDepthFar = null;

    			// restore framebuffer/rendering state

    			renderer.setRenderTarget( initialRenderTarget );

    			glBaseLayer = null;
    			glProjLayer = null;
    			glBinding = null;
    			session = null;
    			newRenderTarget = null;

    			//

    			animation.stop();

    			scope.isPresenting = false;

    			scope.dispatchEvent( { type: 'sessionend' } );

    		}

    		this.setFramebufferScaleFactor = function ( value ) {

    			framebufferScaleFactor = value;

    			if ( scope.isPresenting === true ) {

    				console.warn( 'THREE.WebXRManager: Cannot change framebuffer scale while presenting.' );

    			}

    		};

    		this.setReferenceSpaceType = function ( value ) {

    			referenceSpaceType = value;

    			if ( scope.isPresenting === true ) {

    				console.warn( 'THREE.WebXRManager: Cannot change reference space type while presenting.' );

    			}

    		};

    		this.getReferenceSpace = function () {

    			return customReferenceSpace || referenceSpace;

    		};

    		this.setReferenceSpace = function ( space ) {

    			customReferenceSpace = space;

    		};

    		this.getBaseLayer = function () {

    			return glProjLayer !== null ? glProjLayer : glBaseLayer;

    		};

    		this.getBinding = function () {

    			return glBinding;

    		};

    		this.getFrame = function () {

    			return xrFrame;

    		};

    		this.getSession = function () {

    			return session;

    		};

    		this.setSession = async function ( value ) {

    			session = value;

    			if ( session !== null ) {

    				initialRenderTarget = renderer.getRenderTarget();

    				session.addEventListener( 'select', onSessionEvent );
    				session.addEventListener( 'selectstart', onSessionEvent );
    				session.addEventListener( 'selectend', onSessionEvent );
    				session.addEventListener( 'squeeze', onSessionEvent );
    				session.addEventListener( 'squeezestart', onSessionEvent );
    				session.addEventListener( 'squeezeend', onSessionEvent );
    				session.addEventListener( 'end', onSessionEnd );
    				session.addEventListener( 'inputsourceschange', onInputSourcesChange );

    				if ( attributes.xrCompatible !== true ) {

    					await gl.makeXRCompatible();

    				}

    				if ( ( session.renderState.layers === undefined ) || ( renderer.capabilities.isWebGL2 === false ) ) {

    					const layerInit = {
    						antialias: ( session.renderState.layers === undefined ) ? attributes.antialias : true,
    						alpha: attributes.alpha,
    						depth: attributes.depth,
    						stencil: attributes.stencil,
    						framebufferScaleFactor: framebufferScaleFactor
    					};

    					glBaseLayer = new XRWebGLLayer( session, gl, layerInit );

    					session.updateRenderState( { baseLayer: glBaseLayer } );

    					newRenderTarget = new WebGLRenderTarget(
    						glBaseLayer.framebufferWidth,
    						glBaseLayer.framebufferHeight,
    						{
    							format: RGBAFormat,
    							type: UnsignedByteType,
    							encoding: renderer.outputEncoding,
    							stencilBuffer: attributes.stencil
    						}
    					);

    				} else {

    					let depthFormat = null;
    					let depthType = null;
    					let glDepthFormat = null;

    					if ( attributes.depth ) {

    						glDepthFormat = attributes.stencil ? 35056 : 33190;
    						depthFormat = attributes.stencil ? DepthStencilFormat : DepthFormat;
    						depthType = attributes.stencil ? UnsignedInt248Type : UnsignedIntType;

    					}

    					const projectionlayerInit = {
    						colorFormat: 32856,
    						depthFormat: glDepthFormat,
    						scaleFactor: framebufferScaleFactor
    					};

    					glBinding = new XRWebGLBinding( session, gl );

    					glProjLayer = glBinding.createProjectionLayer( projectionlayerInit );

    					session.updateRenderState( { layers: [ glProjLayer ] } );

    					newRenderTarget = new WebGLRenderTarget(
    						glProjLayer.textureWidth,
    						glProjLayer.textureHeight,
    						{
    							format: RGBAFormat,
    							type: UnsignedByteType,
    							depthTexture: new DepthTexture( glProjLayer.textureWidth, glProjLayer.textureHeight, depthType, undefined, undefined, undefined, undefined, undefined, undefined, depthFormat ),
    							stencilBuffer: attributes.stencil,
    							encoding: renderer.outputEncoding,
    							samples: attributes.antialias ? 4 : 0
    						} );

    					const renderTargetProperties = renderer.properties.get( newRenderTarget );
    					renderTargetProperties.__ignoreDepthValues = glProjLayer.ignoreDepthValues;

    				}

    				newRenderTarget.isXRRenderTarget = true; // TODO Remove this when possible, see #23278

    				// Set foveation to maximum.
    				this.setFoveation( 1.0 );

    				customReferenceSpace = null;
    				referenceSpace = await session.requestReferenceSpace( referenceSpaceType );

    				animation.setContext( session );
    				animation.start();

    				scope.isPresenting = true;

    				scope.dispatchEvent( { type: 'sessionstart' } );

    			}

    		};

    		function onInputSourcesChange( event ) {

    			// Notify disconnected

    			for ( let i = 0; i < event.removed.length; i ++ ) {

    				const inputSource = event.removed[ i ];
    				const index = controllerInputSources.indexOf( inputSource );

    				if ( index >= 0 ) {

    					controllerInputSources[ index ] = null;
    					controllers[ index ].disconnect( inputSource );

    				}

    			}

    			// Notify connected

    			for ( let i = 0; i < event.added.length; i ++ ) {

    				const inputSource = event.added[ i ];

    				let controllerIndex = controllerInputSources.indexOf( inputSource );

    				if ( controllerIndex === - 1 ) {

    					// Assign input source a controller that currently has no input source

    					for ( let i = 0; i < controllers.length; i ++ ) {

    						if ( i >= controllerInputSources.length ) {

    							controllerInputSources.push( inputSource );
    							controllerIndex = i;
    							break;

    						} else if ( controllerInputSources[ i ] === null ) {

    							controllerInputSources[ i ] = inputSource;
    							controllerIndex = i;
    							break;

    						}

    					}

    					// If all controllers do currently receive input we ignore new ones

    					if ( controllerIndex === - 1 ) break;

    				}

    				const controller = controllers[ controllerIndex ];

    				if ( controller ) {

    					controller.connect( inputSource );

    				}

    			}

    		}

    		//

    		const cameraLPos = new Vector3();
    		const cameraRPos = new Vector3();

    		/**
    		 * Assumes 2 cameras that are parallel and share an X-axis, and that
    		 * the cameras' projection and world matrices have already been set.
    		 * And that near and far planes are identical for both cameras.
    		 * Visualization of this technique: https://computergraphics.stackexchange.com/a/4765
    		 */
    		function setProjectionFromUnion( camera, cameraL, cameraR ) {

    			cameraLPos.setFromMatrixPosition( cameraL.matrixWorld );
    			cameraRPos.setFromMatrixPosition( cameraR.matrixWorld );

    			const ipd = cameraLPos.distanceTo( cameraRPos );

    			const projL = cameraL.projectionMatrix.elements;
    			const projR = cameraR.projectionMatrix.elements;

    			// VR systems will have identical far and near planes, and
    			// most likely identical top and bottom frustum extents.
    			// Use the left camera for these values.
    			const near = projL[ 14 ] / ( projL[ 10 ] - 1 );
    			const far = projL[ 14 ] / ( projL[ 10 ] + 1 );
    			const topFov = ( projL[ 9 ] + 1 ) / projL[ 5 ];
    			const bottomFov = ( projL[ 9 ] - 1 ) / projL[ 5 ];

    			const leftFov = ( projL[ 8 ] - 1 ) / projL[ 0 ];
    			const rightFov = ( projR[ 8 ] + 1 ) / projR[ 0 ];
    			const left = near * leftFov;
    			const right = near * rightFov;

    			// Calculate the new camera's position offset from the
    			// left camera. xOffset should be roughly half `ipd`.
    			const zOffset = ipd / ( - leftFov + rightFov );
    			const xOffset = zOffset * - leftFov;

    			// TODO: Better way to apply this offset?
    			cameraL.matrixWorld.decompose( camera.position, camera.quaternion, camera.scale );
    			camera.translateX( xOffset );
    			camera.translateZ( zOffset );
    			camera.matrixWorld.compose( camera.position, camera.quaternion, camera.scale );
    			camera.matrixWorldInverse.copy( camera.matrixWorld ).invert();

    			// Find the union of the frustum values of the cameras and scale
    			// the values so that the near plane's position does not change in world space,
    			// although must now be relative to the new union camera.
    			const near2 = near + zOffset;
    			const far2 = far + zOffset;
    			const left2 = left - xOffset;
    			const right2 = right + ( ipd - xOffset );
    			const top2 = topFov * far / far2 * near2;
    			const bottom2 = bottomFov * far / far2 * near2;

    			camera.projectionMatrix.makePerspective( left2, right2, top2, bottom2, near2, far2 );

    		}

    		function updateCamera( camera, parent ) {

    			if ( parent === null ) {

    				camera.matrixWorld.copy( camera.matrix );

    			} else {

    				camera.matrixWorld.multiplyMatrices( parent.matrixWorld, camera.matrix );

    			}

    			camera.matrixWorldInverse.copy( camera.matrixWorld ).invert();

    		}

    		this.updateCamera = function ( camera ) {

    			if ( session === null ) return;

    			cameraVR.near = cameraR.near = cameraL.near = camera.near;
    			cameraVR.far = cameraR.far = cameraL.far = camera.far;

    			if ( _currentDepthNear !== cameraVR.near || _currentDepthFar !== cameraVR.far ) {

    				// Note that the new renderState won't apply until the next frame. See #18320

    				session.updateRenderState( {
    					depthNear: cameraVR.near,
    					depthFar: cameraVR.far
    				} );

    				_currentDepthNear = cameraVR.near;
    				_currentDepthFar = cameraVR.far;

    			}

    			const parent = camera.parent;
    			const cameras = cameraVR.cameras;

    			updateCamera( cameraVR, parent );

    			for ( let i = 0; i < cameras.length; i ++ ) {

    				updateCamera( cameras[ i ], parent );

    			}

    			cameraVR.matrixWorld.decompose( cameraVR.position, cameraVR.quaternion, cameraVR.scale );

    			// update user camera and its children

    			camera.matrix.copy( cameraVR.matrix );
    			camera.matrix.decompose( camera.position, camera.quaternion, camera.scale );

    			const children = camera.children;

    			for ( let i = 0, l = children.length; i < l; i ++ ) {

    				children[ i ].updateMatrixWorld( true );

    			}

    			// update projection matrix for proper view frustum culling

    			if ( cameras.length === 2 ) {

    				setProjectionFromUnion( cameraVR, cameraL, cameraR );

    			} else {

    				// assume single camera setup (AR)

    				cameraVR.projectionMatrix.copy( cameraL.projectionMatrix );

    			}

    		};

    		this.getCamera = function () {

    			return cameraVR;

    		};

    		this.getFoveation = function () {

    			if ( glProjLayer !== null ) {

    				return glProjLayer.fixedFoveation;

    			}

    			if ( glBaseLayer !== null ) {

    				return glBaseLayer.fixedFoveation;

    			}

    			return undefined;

    		};

    		this.setFoveation = function ( foveation ) {

    			// 0 = no foveation = full resolution
    			// 1 = maximum foveation = the edges render at lower resolution

    			if ( glProjLayer !== null ) {

    				glProjLayer.fixedFoveation = foveation;

    			}

    			if ( glBaseLayer !== null && glBaseLayer.fixedFoveation !== undefined ) {

    				glBaseLayer.fixedFoveation = foveation;

    			}

    		};

    		this.getPlanes = function () {

    			return planes;

    		};

    		// Animation Loop

    		let onAnimationFrameCallback = null;

    		function onAnimationFrame( time, frame ) {

    			pose = frame.getViewerPose( customReferenceSpace || referenceSpace );
    			xrFrame = frame;

    			if ( pose !== null ) {

    				const views = pose.views;

    				if ( glBaseLayer !== null ) {

    					renderer.setRenderTargetFramebuffer( newRenderTarget, glBaseLayer.framebuffer );
    					renderer.setRenderTarget( newRenderTarget );

    				}

    				let cameraVRNeedsUpdate = false;

    				// check if it's necessary to rebuild cameraVR's camera list

    				if ( views.length !== cameraVR.cameras.length ) {

    					cameraVR.cameras.length = 0;
    					cameraVRNeedsUpdate = true;

    				}

    				for ( let i = 0; i < views.length; i ++ ) {

    					const view = views[ i ];

    					let viewport = null;

    					if ( glBaseLayer !== null ) {

    						viewport = glBaseLayer.getViewport( view );

    					} else {

    						const glSubImage = glBinding.getViewSubImage( glProjLayer, view );
    						viewport = glSubImage.viewport;

    						// For side-by-side projection, we only produce a single texture for both eyes.
    						if ( i === 0 ) {

    							renderer.setRenderTargetTextures(
    								newRenderTarget,
    								glSubImage.colorTexture,
    								glProjLayer.ignoreDepthValues ? undefined : glSubImage.depthStencilTexture );

    							renderer.setRenderTarget( newRenderTarget );

    						}

    					}

    					let camera = cameras[ i ];

    					if ( camera === undefined ) {

    						camera = new PerspectiveCamera();
    						camera.layers.enable( i );
    						camera.viewport = new Vector4();
    						cameras[ i ] = camera;

    					}

    					camera.matrix.fromArray( view.transform.matrix );
    					camera.projectionMatrix.fromArray( view.projectionMatrix );
    					camera.viewport.set( viewport.x, viewport.y, viewport.width, viewport.height );

    					if ( i === 0 ) {

    						cameraVR.matrix.copy( camera.matrix );

    					}

    					if ( cameraVRNeedsUpdate === true ) {

    						cameraVR.cameras.push( camera );

    					}

    				}

    			}

    			//

    			for ( let i = 0; i < controllers.length; i ++ ) {

    				const inputSource = controllerInputSources[ i ];
    				const controller = controllers[ i ];

    				if ( inputSource !== null && controller !== undefined ) {

    					controller.update( inputSource, frame, customReferenceSpace || referenceSpace );

    				}

    			}

    			if ( onAnimationFrameCallback ) onAnimationFrameCallback( time, frame );

    			if ( frame.detectedPlanes ) {

    				scope.dispatchEvent( { type: 'planesdetected', data: frame.detectedPlanes } );

    				let planesToRemove = null;

    				for ( const plane of planes ) {

    					if ( ! frame.detectedPlanes.has( plane ) ) {

    						if ( planesToRemove === null ) {

    							planesToRemove = [];

    						}

    						planesToRemove.push( plane );

    					}

    				}

    				if ( planesToRemove !== null ) {

    					for ( const plane of planesToRemove ) {

    						planes.delete( plane );
    						planesLastChangedTimes.delete( plane );
    						scope.dispatchEvent( { type: 'planeremoved', data: plane } );

    					}

    				}

    				for ( const plane of frame.detectedPlanes ) {

    					if ( ! planes.has( plane ) ) {

    						planes.add( plane );
    						planesLastChangedTimes.set( plane, frame.lastChangedTime );
    						scope.dispatchEvent( { type: 'planeadded', data: plane } );

    					} else {

    						const lastKnownTime = planesLastChangedTimes.get( plane );

    						if ( plane.lastChangedTime > lastKnownTime ) {

    							planesLastChangedTimes.set( plane, plane.lastChangedTime );
    							scope.dispatchEvent( { type: 'planechanged', data: plane } );

    						}

    					}

    				}

    			}

    			xrFrame = null;

    		}

    		const animation = new WebGLAnimation();

    		animation.setAnimationLoop( onAnimationFrame );

    		this.setAnimationLoop = function ( callback ) {

    			onAnimationFrameCallback = callback;

    		};

    		this.dispose = function () {};

    	}

    }

    function WebGLMaterials( renderer, properties ) {

    	function refreshFogUniforms( uniforms, fog ) {

    		fog.color.getRGB( uniforms.fogColor.value, getUnlitUniformColorSpace( renderer ) );

    		if ( fog.isFog ) {

    			uniforms.fogNear.value = fog.near;
    			uniforms.fogFar.value = fog.far;

    		} else if ( fog.isFogExp2 ) {

    			uniforms.fogDensity.value = fog.density;

    		}

    	}

    	function refreshMaterialUniforms( uniforms, material, pixelRatio, height, transmissionRenderTarget ) {

    		if ( material.isMeshBasicMaterial ) {

    			refreshUniformsCommon( uniforms, material );

    		} else if ( material.isMeshLambertMaterial ) {

    			refreshUniformsCommon( uniforms, material );

    		} else if ( material.isMeshToonMaterial ) {

    			refreshUniformsCommon( uniforms, material );
    			refreshUniformsToon( uniforms, material );

    		} else if ( material.isMeshPhongMaterial ) {

    			refreshUniformsCommon( uniforms, material );
    			refreshUniformsPhong( uniforms, material );

    		} else if ( material.isMeshStandardMaterial ) {

    			refreshUniformsCommon( uniforms, material );
    			refreshUniformsStandard( uniforms, material );

    			if ( material.isMeshPhysicalMaterial ) {

    				refreshUniformsPhysical( uniforms, material, transmissionRenderTarget );

    			}

    		} else if ( material.isMeshMatcapMaterial ) {

    			refreshUniformsCommon( uniforms, material );
    			refreshUniformsMatcap( uniforms, material );

    		} else if ( material.isMeshDepthMaterial ) {

    			refreshUniformsCommon( uniforms, material );

    		} else if ( material.isMeshDistanceMaterial ) {

    			refreshUniformsCommon( uniforms, material );
    			refreshUniformsDistance( uniforms, material );

    		} else if ( material.isMeshNormalMaterial ) {

    			refreshUniformsCommon( uniforms, material );

    		} else if ( material.isLineBasicMaterial ) {

    			refreshUniformsLine( uniforms, material );

    			if ( material.isLineDashedMaterial ) {

    				refreshUniformsDash( uniforms, material );

    			}

    		} else if ( material.isPointsMaterial ) {

    			refreshUniformsPoints( uniforms, material, pixelRatio, height );

    		} else if ( material.isSpriteMaterial ) {

    			refreshUniformsSprites( uniforms, material );

    		} else if ( material.isShadowMaterial ) {

    			uniforms.color.value.copy( material.color );
    			uniforms.opacity.value = material.opacity;

    		} else if ( material.isShaderMaterial ) {

    			material.uniformsNeedUpdate = false; // #15581

    		}

    	}

    	function refreshUniformsCommon( uniforms, material ) {

    		uniforms.opacity.value = material.opacity;

    		if ( material.color ) {

    			uniforms.diffuse.value.copy( material.color );

    		}

    		if ( material.emissive ) {

    			uniforms.emissive.value.copy( material.emissive ).multiplyScalar( material.emissiveIntensity );

    		}

    		if ( material.map ) {

    			uniforms.map.value = material.map;

    		}

    		if ( material.alphaMap ) {

    			uniforms.alphaMap.value = material.alphaMap;

    		}

    		if ( material.bumpMap ) {

    			uniforms.bumpMap.value = material.bumpMap;
    			uniforms.bumpScale.value = material.bumpScale;
    			if ( material.side === BackSide ) uniforms.bumpScale.value *= - 1;

    		}

    		if ( material.displacementMap ) {

    			uniforms.displacementMap.value = material.displacementMap;
    			uniforms.displacementScale.value = material.displacementScale;
    			uniforms.displacementBias.value = material.displacementBias;

    		}

    		if ( material.emissiveMap ) {

    			uniforms.emissiveMap.value = material.emissiveMap;

    		}

    		if ( material.normalMap ) {

    			uniforms.normalMap.value = material.normalMap;
    			uniforms.normalScale.value.copy( material.normalScale );
    			if ( material.side === BackSide ) uniforms.normalScale.value.negate();

    		}

    		if ( material.specularMap ) {

    			uniforms.specularMap.value = material.specularMap;

    		}

    		if ( material.alphaTest > 0 ) {

    			uniforms.alphaTest.value = material.alphaTest;

    		}

    		const envMap = properties.get( material ).envMap;

    		if ( envMap ) {

    			uniforms.envMap.value = envMap;

    			uniforms.flipEnvMap.value = ( envMap.isCubeTexture && envMap.isRenderTargetTexture === false ) ? - 1 : 1;

    			uniforms.reflectivity.value = material.reflectivity;
    			uniforms.ior.value = material.ior;
    			uniforms.refractionRatio.value = material.refractionRatio;

    		}

    		if ( material.lightMap ) {

    			uniforms.lightMap.value = material.lightMap;

    			// artist-friendly light intensity scaling factor
    			const scaleFactor = ( renderer.physicallyCorrectLights !== true ) ? Math.PI : 1;

    			uniforms.lightMapIntensity.value = material.lightMapIntensity * scaleFactor;

    		}

    		if ( material.aoMap ) {

    			uniforms.aoMap.value = material.aoMap;
    			uniforms.aoMapIntensity.value = material.aoMapIntensity;

    		}

    		// uv repeat and offset setting priorities
    		// 1. color map
    		// 2. specular map
    		// 3. displacementMap map
    		// 4. normal map
    		// 5. bump map
    		// 6. roughnessMap map
    		// 7. metalnessMap map
    		// 8. alphaMap map
    		// 9. emissiveMap map
    		// 10. clearcoat map
    		// 11. clearcoat normal map
    		// 12. clearcoat roughnessMap map
    		// 13. iridescence map
    		// 14. iridescence thickness map
    		// 15. specular intensity map
    		// 16. specular tint map
    		// 17. transmission map
    		// 18. thickness map

    		let uvScaleMap;

    		if ( material.map ) {

    			uvScaleMap = material.map;

    		} else if ( material.specularMap ) {

    			uvScaleMap = material.specularMap;

    		} else if ( material.displacementMap ) {

    			uvScaleMap = material.displacementMap;

    		} else if ( material.normalMap ) {

    			uvScaleMap = material.normalMap;

    		} else if ( material.bumpMap ) {

    			uvScaleMap = material.bumpMap;

    		} else if ( material.roughnessMap ) {

    			uvScaleMap = material.roughnessMap;

    		} else if ( material.metalnessMap ) {

    			uvScaleMap = material.metalnessMap;

    		} else if ( material.alphaMap ) {

    			uvScaleMap = material.alphaMap;

    		} else if ( material.emissiveMap ) {

    			uvScaleMap = material.emissiveMap;

    		} else if ( material.clearcoatMap ) {

    			uvScaleMap = material.clearcoatMap;

    		} else if ( material.clearcoatNormalMap ) {

    			uvScaleMap = material.clearcoatNormalMap;

    		} else if ( material.clearcoatRoughnessMap ) {

    			uvScaleMap = material.clearcoatRoughnessMap;

    		} else if ( material.iridescenceMap ) {

    			uvScaleMap = material.iridescenceMap;

    		} else if ( material.iridescenceThicknessMap ) {

    			uvScaleMap = material.iridescenceThicknessMap;

    		} else if ( material.specularIntensityMap ) {

    			uvScaleMap = material.specularIntensityMap;

    		} else if ( material.specularColorMap ) {

    			uvScaleMap = material.specularColorMap;

    		} else if ( material.transmissionMap ) {

    			uvScaleMap = material.transmissionMap;

    		} else if ( material.thicknessMap ) {

    			uvScaleMap = material.thicknessMap;

    		} else if ( material.sheenColorMap ) {

    			uvScaleMap = material.sheenColorMap;

    		} else if ( material.sheenRoughnessMap ) {

    			uvScaleMap = material.sheenRoughnessMap;

    		}

    		if ( uvScaleMap !== undefined ) {

    			// backwards compatibility
    			if ( uvScaleMap.isWebGLRenderTarget ) {

    				uvScaleMap = uvScaleMap.texture;

    			}

    			if ( uvScaleMap.matrixAutoUpdate === true ) {

    				uvScaleMap.updateMatrix();

    			}

    			uniforms.uvTransform.value.copy( uvScaleMap.matrix );

    		}

    		// uv repeat and offset setting priorities for uv2
    		// 1. ao map
    		// 2. light map

    		let uv2ScaleMap;

    		if ( material.aoMap ) {

    			uv2ScaleMap = material.aoMap;

    		} else if ( material.lightMap ) {

    			uv2ScaleMap = material.lightMap;

    		}

    		if ( uv2ScaleMap !== undefined ) {

    			// backwards compatibility
    			if ( uv2ScaleMap.isWebGLRenderTarget ) {

    				uv2ScaleMap = uv2ScaleMap.texture;

    			}

    			if ( uv2ScaleMap.matrixAutoUpdate === true ) {

    				uv2ScaleMap.updateMatrix();

    			}

    			uniforms.uv2Transform.value.copy( uv2ScaleMap.matrix );

    		}

    	}

    	function refreshUniformsLine( uniforms, material ) {

    		uniforms.diffuse.value.copy( material.color );
    		uniforms.opacity.value = material.opacity;

    	}

    	function refreshUniformsDash( uniforms, material ) {

    		uniforms.dashSize.value = material.dashSize;
    		uniforms.totalSize.value = material.dashSize + material.gapSize;
    		uniforms.scale.value = material.scale;

    	}

    	function refreshUniformsPoints( uniforms, material, pixelRatio, height ) {

    		uniforms.diffuse.value.copy( material.color );
    		uniforms.opacity.value = material.opacity;
    		uniforms.size.value = material.size * pixelRatio;
    		uniforms.scale.value = height * 0.5;

    		if ( material.map ) {

    			uniforms.map.value = material.map;

    		}

    		if ( material.alphaMap ) {

    			uniforms.alphaMap.value = material.alphaMap;

    		}

    		if ( material.alphaTest > 0 ) {

    			uniforms.alphaTest.value = material.alphaTest;

    		}

    		// uv repeat and offset setting priorities
    		// 1. color map
    		// 2. alpha map

    		let uvScaleMap;

    		if ( material.map ) {

    			uvScaleMap = material.map;

    		} else if ( material.alphaMap ) {

    			uvScaleMap = material.alphaMap;

    		}

    		if ( uvScaleMap !== undefined ) {

    			if ( uvScaleMap.matrixAutoUpdate === true ) {

    				uvScaleMap.updateMatrix();

    			}

    			uniforms.uvTransform.value.copy( uvScaleMap.matrix );

    		}

    	}

    	function refreshUniformsSprites( uniforms, material ) {

    		uniforms.diffuse.value.copy( material.color );
    		uniforms.opacity.value = material.opacity;
    		uniforms.rotation.value = material.rotation;

    		if ( material.map ) {

    			uniforms.map.value = material.map;

    		}

    		if ( material.alphaMap ) {

    			uniforms.alphaMap.value = material.alphaMap;

    		}

    		if ( material.alphaTest > 0 ) {

    			uniforms.alphaTest.value = material.alphaTest;

    		}

    		// uv repeat and offset setting priorities
    		// 1. color map
    		// 2. alpha map

    		let uvScaleMap;

    		if ( material.map ) {

    			uvScaleMap = material.map;

    		} else if ( material.alphaMap ) {

    			uvScaleMap = material.alphaMap;

    		}

    		if ( uvScaleMap !== undefined ) {

    			if ( uvScaleMap.matrixAutoUpdate === true ) {

    				uvScaleMap.updateMatrix();

    			}

    			uniforms.uvTransform.value.copy( uvScaleMap.matrix );

    		}

    	}

    	function refreshUniformsPhong( uniforms, material ) {

    		uniforms.specular.value.copy( material.specular );
    		uniforms.shininess.value = Math.max( material.shininess, 1e-4 ); // to prevent pow( 0.0, 0.0 )

    	}

    	function refreshUniformsToon( uniforms, material ) {

    		if ( material.gradientMap ) {

    			uniforms.gradientMap.value = material.gradientMap;

    		}

    	}

    	function refreshUniformsStandard( uniforms, material ) {

    		uniforms.roughness.value = material.roughness;
    		uniforms.metalness.value = material.metalness;

    		if ( material.roughnessMap ) {

    			uniforms.roughnessMap.value = material.roughnessMap;

    		}

    		if ( material.metalnessMap ) {

    			uniforms.metalnessMap.value = material.metalnessMap;

    		}

    		const envMap = properties.get( material ).envMap;

    		if ( envMap ) {

    			//uniforms.envMap.value = material.envMap; // part of uniforms common
    			uniforms.envMapIntensity.value = material.envMapIntensity;

    		}

    	}

    	function refreshUniformsPhysical( uniforms, material, transmissionRenderTarget ) {

    		uniforms.ior.value = material.ior; // also part of uniforms common

    		if ( material.sheen > 0 ) {

    			uniforms.sheenColor.value.copy( material.sheenColor ).multiplyScalar( material.sheen );

    			uniforms.sheenRoughness.value = material.sheenRoughness;

    			if ( material.sheenColorMap ) {

    				uniforms.sheenColorMap.value = material.sheenColorMap;

    			}

    			if ( material.sheenRoughnessMap ) {

    				uniforms.sheenRoughnessMap.value = material.sheenRoughnessMap;

    			}

    		}

    		if ( material.clearcoat > 0 ) {

    			uniforms.clearcoat.value = material.clearcoat;
    			uniforms.clearcoatRoughness.value = material.clearcoatRoughness;

    			if ( material.clearcoatMap ) {

    				uniforms.clearcoatMap.value = material.clearcoatMap;

    			}

    			if ( material.clearcoatRoughnessMap ) {

    				uniforms.clearcoatRoughnessMap.value = material.clearcoatRoughnessMap;

    			}

    			if ( material.clearcoatNormalMap ) {

    				uniforms.clearcoatNormalScale.value.copy( material.clearcoatNormalScale );
    				uniforms.clearcoatNormalMap.value = material.clearcoatNormalMap;

    				if ( material.side === BackSide ) {

    					uniforms.clearcoatNormalScale.value.negate();

    				}

    			}

    		}

    		if ( material.iridescence > 0 ) {

    			uniforms.iridescence.value = material.iridescence;
    			uniforms.iridescenceIOR.value = material.iridescenceIOR;
    			uniforms.iridescenceThicknessMinimum.value = material.iridescenceThicknessRange[ 0 ];
    			uniforms.iridescenceThicknessMaximum.value = material.iridescenceThicknessRange[ 1 ];

    			if ( material.iridescenceMap ) {

    				uniforms.iridescenceMap.value = material.iridescenceMap;

    			}

    			if ( material.iridescenceThicknessMap ) {

    				uniforms.iridescenceThicknessMap.value = material.iridescenceThicknessMap;

    			}

    		}

    		if ( material.transmission > 0 ) {

    			uniforms.transmission.value = material.transmission;
    			uniforms.transmissionSamplerMap.value = transmissionRenderTarget.texture;
    			uniforms.transmissionSamplerSize.value.set( transmissionRenderTarget.width, transmissionRenderTarget.height );

    			if ( material.transmissionMap ) {

    				uniforms.transmissionMap.value = material.transmissionMap;

    			}

    			uniforms.thickness.value = material.thickness;

    			if ( material.thicknessMap ) {

    				uniforms.thicknessMap.value = material.thicknessMap;

    			}

    			uniforms.attenuationDistance.value = material.attenuationDistance;
    			uniforms.attenuationColor.value.copy( material.attenuationColor );

    		}

    		uniforms.specularIntensity.value = material.specularIntensity;
    		uniforms.specularColor.value.copy( material.specularColor );

    		if ( material.specularIntensityMap ) {

    			uniforms.specularIntensityMap.value = material.specularIntensityMap;

    		}

    		if ( material.specularColorMap ) {

    			uniforms.specularColorMap.value = material.specularColorMap;

    		}

    	}

    	function refreshUniformsMatcap( uniforms, material ) {

    		if ( material.matcap ) {

    			uniforms.matcap.value = material.matcap;

    		}

    	}

    	function refreshUniformsDistance( uniforms, material ) {

    		uniforms.referencePosition.value.copy( material.referencePosition );
    		uniforms.nearDistance.value = material.nearDistance;
    		uniforms.farDistance.value = material.farDistance;

    	}

    	return {
    		refreshFogUniforms: refreshFogUniforms,
    		refreshMaterialUniforms: refreshMaterialUniforms
    	};

    }

    function WebGLUniformsGroups( gl, info, capabilities, state ) {

    	let buffers = {};
    	let updateList = {};
    	let allocatedBindingPoints = [];

    	const maxBindingPoints = ( capabilities.isWebGL2 ) ? gl.getParameter( 35375 ) : 0; // binding points are global whereas block indices are per shader program

    	function bind( uniformsGroup, program ) {

    		const webglProgram = program.program;
    		state.uniformBlockBinding( uniformsGroup, webglProgram );

    	}

    	function update( uniformsGroup, program ) {

    		let buffer = buffers[ uniformsGroup.id ];

    		if ( buffer === undefined ) {

    			prepareUniformsGroup( uniformsGroup );

    			buffer = createBuffer( uniformsGroup );
    			buffers[ uniformsGroup.id ] = buffer;

    			uniformsGroup.addEventListener( 'dispose', onUniformsGroupsDispose );

    		}

    		// ensure to update the binding points/block indices mapping for this program

    		const webglProgram = program.program;
    		state.updateUBOMapping( uniformsGroup, webglProgram );

    		// update UBO once per frame

    		const frame = info.render.frame;

    		if ( updateList[ uniformsGroup.id ] !== frame ) {

    			updateBufferData( uniformsGroup );

    			updateList[ uniformsGroup.id ] = frame;

    		}

    	}

    	function createBuffer( uniformsGroup ) {

    		// the setup of an UBO is independent of a particular shader program but global

    		const bindingPointIndex = allocateBindingPointIndex();
    		uniformsGroup.__bindingPointIndex = bindingPointIndex;

    		const buffer = gl.createBuffer();
    		const size = uniformsGroup.__size;
    		const usage = uniformsGroup.usage;

    		gl.bindBuffer( 35345, buffer );
    		gl.bufferData( 35345, size, usage );
    		gl.bindBuffer( 35345, null );
    		gl.bindBufferBase( 35345, bindingPointIndex, buffer );

    		return buffer;

    	}

    	function allocateBindingPointIndex() {

    		for ( let i = 0; i < maxBindingPoints; i ++ ) {

    			if ( allocatedBindingPoints.indexOf( i ) === - 1 ) {

    				allocatedBindingPoints.push( i );
    				return i;

    			}

    		}

    		console.error( 'THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached.' );

    		return 0;

    	}

    	function updateBufferData( uniformsGroup ) {

    		const buffer = buffers[ uniformsGroup.id ];
    		const uniforms = uniformsGroup.uniforms;
    		const cache = uniformsGroup.__cache;

    		gl.bindBuffer( 35345, buffer );

    		for ( let i = 0, il = uniforms.length; i < il; i ++ ) {

    			const uniform = uniforms[ i ];

    			// partly update the buffer if necessary

    			if ( hasUniformChanged( uniform, i, cache ) === true ) {

    				const value = uniform.value;
    				const offset = uniform.__offset;

    				if ( typeof value === 'number' ) {

    					uniform.__data[ 0 ] = value;
    					gl.bufferSubData( 35345, offset, uniform.__data );

    				} else {

    					if ( uniform.value.isMatrix3 ) {

    						// manually converting 3x3 to 3x4

    						uniform.__data[ 0 ] = uniform.value.elements[ 0 ];
    						uniform.__data[ 1 ] = uniform.value.elements[ 1 ];
    						uniform.__data[ 2 ] = uniform.value.elements[ 2 ];
    						uniform.__data[ 3 ] = uniform.value.elements[ 0 ];
    						uniform.__data[ 4 ] = uniform.value.elements[ 3 ];
    						uniform.__data[ 5 ] = uniform.value.elements[ 4 ];
    						uniform.__data[ 6 ] = uniform.value.elements[ 5 ];
    						uniform.__data[ 7 ] = uniform.value.elements[ 0 ];
    						uniform.__data[ 8 ] = uniform.value.elements[ 6 ];
    						uniform.__data[ 9 ] = uniform.value.elements[ 7 ];
    						uniform.__data[ 10 ] = uniform.value.elements[ 8 ];
    						uniform.__data[ 11 ] = uniform.value.elements[ 0 ];

    					} else {

    						value.toArray( uniform.__data );

    					}

    					gl.bufferSubData( 35345, offset, uniform.__data );

    				}

    			}

    		}

    		gl.bindBuffer( 35345, null );

    	}

    	function hasUniformChanged( uniform, index, cache ) {

    		const value = uniform.value;

    		if ( cache[ index ] === undefined ) {

    			// cache entry does not exist so far

    			if ( typeof value === 'number' ) {

    				cache[ index ] = value;

    			} else {

    				cache[ index ] = value.clone();

    			}

    			return true;

    		} else {

    			// compare current value with cached entry

    			if ( typeof value === 'number' ) {

    				if ( cache[ index ] !== value ) {

    					cache[ index ] = value;
    					return true;

    				}

    			} else {

    				const cachedObject = cache[ index ];

    				if ( cachedObject.equals( value ) === false ) {

    					cachedObject.copy( value );
    					return true;

    				}

    			}

    		}

    		return false;

    	}

    	function prepareUniformsGroup( uniformsGroup ) {

    		// determine total buffer size according to the STD140 layout
    		// Hint: STD140 is the only supported layout in WebGL 2

    		const uniforms = uniformsGroup.uniforms;

    		let offset = 0; // global buffer offset in bytes
    		const chunkSize = 16; // size of a chunk in bytes
    		let chunkOffset = 0; // offset within a single chunk in bytes

    		for ( let i = 0, l = uniforms.length; i < l; i ++ ) {

    			const uniform = uniforms[ i ];
    			const info = getUniformSize( uniform );

    			// the following two properties will be used for partial buffer updates

    			uniform.__data = new Float32Array( info.storage / Float32Array.BYTES_PER_ELEMENT );
    			uniform.__offset = offset;

    			//

    			if ( i > 0 ) {

    				chunkOffset = offset % chunkSize;

    				const remainingSizeInChunk = chunkSize - chunkOffset;

    				// check for chunk overflow

    				if ( chunkOffset !== 0 && ( remainingSizeInChunk - info.boundary ) < 0 ) {

    					// add padding and adjust offset

    					offset += ( chunkSize - chunkOffset );
    					uniform.__offset = offset;

    				}

    			}

    			offset += info.storage;

    		}

    		// ensure correct final padding

    		chunkOffset = offset % chunkSize;

    		if ( chunkOffset > 0 ) offset += ( chunkSize - chunkOffset );

    		//

    		uniformsGroup.__size = offset;
    		uniformsGroup.__cache = {};

    		return this;

    	}

    	function getUniformSize( uniform ) {

    		const value = uniform.value;

    		const info = {
    			boundary: 0, // bytes
    			storage: 0 // bytes
    		};

    		// determine sizes according to STD140

    		if ( typeof value === 'number' ) {

    			// float/int

    			info.boundary = 4;
    			info.storage = 4;

    		} else if ( value.isVector2 ) {

    			// vec2

    			info.boundary = 8;
    			info.storage = 8;

    		} else if ( value.isVector3 || value.isColor ) {

    			// vec3

    			info.boundary = 16;
    			info.storage = 12; // evil: vec3 must start on a 16-byte boundary but it only consumes 12 bytes

    		} else if ( value.isVector4 ) {

    			// vec4

    			info.boundary = 16;
    			info.storage = 16;

    		} else if ( value.isMatrix3 ) {

    			// mat3 (in STD140 a 3x3 matrix is represented as 3x4)

    			info.boundary = 48;
    			info.storage = 48;

    		} else if ( value.isMatrix4 ) {

    			// mat4

    			info.boundary = 64;
    			info.storage = 64;

    		} else if ( value.isTexture ) {

    			console.warn( 'THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.' );

    		} else {

    			console.warn( 'THREE.WebGLRenderer: Unsupported uniform value type.', value );

    		}

    		return info;

    	}

    	function onUniformsGroupsDispose( event ) {

    		const uniformsGroup = event.target;

    		uniformsGroup.removeEventListener( 'dispose', onUniformsGroupsDispose );

    		const index = allocatedBindingPoints.indexOf( uniformsGroup.__bindingPointIndex );
    		allocatedBindingPoints.splice( index, 1 );

    		gl.deleteBuffer( buffers[ uniformsGroup.id ] );

    		delete buffers[ uniformsGroup.id ];
    		delete updateList[ uniformsGroup.id ];

    	}

    	function dispose() {

    		for ( const id in buffers ) {

    			gl.deleteBuffer( buffers[ id ] );

    		}

    		allocatedBindingPoints = [];
    		buffers = {};
    		updateList = {};

    	}

    	return {

    		bind: bind,
    		update: update,

    		dispose: dispose

    	};

    }

    function createCanvasElement() {

    	const canvas = createElementNS( 'canvas' );
    	canvas.style.display = 'block';
    	return canvas;

    }

    function WebGLRenderer( parameters = {} ) {

    	this.isWebGLRenderer = true;

    	const _canvas = parameters.canvas !== undefined ? parameters.canvas : createCanvasElement(),
    		_context = parameters.context !== undefined ? parameters.context : null,

    		_depth = parameters.depth !== undefined ? parameters.depth : true,
    		_stencil = parameters.stencil !== undefined ? parameters.stencil : true,
    		_antialias = parameters.antialias !== undefined ? parameters.antialias : false,
    		_premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,
    		_preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false,
    		_powerPreference = parameters.powerPreference !== undefined ? parameters.powerPreference : 'default',
    		_failIfMajorPerformanceCaveat = parameters.failIfMajorPerformanceCaveat !== undefined ? parameters.failIfMajorPerformanceCaveat : false;

    	let _alpha;

    	if ( _context !== null ) {

    		_alpha = _context.getContextAttributes().alpha;

    	} else {

    		_alpha = parameters.alpha !== undefined ? parameters.alpha : false;

    	}

    	let currentRenderList = null;
    	let currentRenderState = null;

    	// render() can be called from within a callback triggered by another render.
    	// We track this so that the nested render call gets its list and state isolated from the parent render call.

    	const renderListStack = [];
    	const renderStateStack = [];

    	// public properties

    	this.domElement = _canvas;

    	// Debug configuration container
    	this.debug = {

    		/**
    		 * Enables error checking and reporting when shader programs are being compiled
    		 * @type {boolean}
    		 */
    		checkShaderErrors: true
    	};

    	// clearing

    	this.autoClear = true;
    	this.autoClearColor = true;
    	this.autoClearDepth = true;
    	this.autoClearStencil = true;

    	// scene graph

    	this.sortObjects = true;

    	// user-defined clipping

    	this.clippingPlanes = [];
    	this.localClippingEnabled = false;

    	// physically based shading

    	this.outputEncoding = LinearEncoding;

    	// physical lights

    	this.physicallyCorrectLights = false;

    	// tone mapping

    	this.toneMapping = NoToneMapping;
    	this.toneMappingExposure = 1.0;

    	// internal properties

    	const _this = this;

    	let _isContextLost = false;

    	// internal state cache

    	let _currentActiveCubeFace = 0;
    	let _currentActiveMipmapLevel = 0;
    	let _currentRenderTarget = null;
    	let _currentMaterialId = - 1;

    	let _currentCamera = null;

    	const _currentViewport = new Vector4();
    	const _currentScissor = new Vector4();
    	let _currentScissorTest = null;

    	//

    	let _width = _canvas.width;
    	let _height = _canvas.height;

    	let _pixelRatio = 1;
    	let _opaqueSort = null;
    	let _transparentSort = null;

    	const _viewport = new Vector4( 0, 0, _width, _height );
    	const _scissor = new Vector4( 0, 0, _width, _height );
    	let _scissorTest = false;

    	// frustum

    	const _frustum = new Frustum();

    	// clipping

    	let _clippingEnabled = false;
    	let _localClippingEnabled = false;

    	// transmission

    	let _transmissionRenderTarget = null;

    	// camera matrices cache

    	const _projScreenMatrix = new Matrix4();

    	const _vector2 = new Vector2();
    	const _vector3 = new Vector3();

    	const _emptyScene = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: true };

    	function getTargetPixelRatio() {

    		return _currentRenderTarget === null ? _pixelRatio : 1;

    	}

    	// initialize

    	let _gl = _context;

    	function getContext( contextNames, contextAttributes ) {

    		for ( let i = 0; i < contextNames.length; i ++ ) {

    			const contextName = contextNames[ i ];
    			const context = _canvas.getContext( contextName, contextAttributes );
    			if ( context !== null ) return context;

    		}

    		return null;

    	}

    	try {

    		const contextAttributes = {
    			alpha: true,
    			depth: _depth,
    			stencil: _stencil,
    			antialias: _antialias,
    			premultipliedAlpha: _premultipliedAlpha,
    			preserveDrawingBuffer: _preserveDrawingBuffer,
    			powerPreference: _powerPreference,
    			failIfMajorPerformanceCaveat: _failIfMajorPerformanceCaveat
    		};

    		// OffscreenCanvas does not have setAttribute, see #22811
    		if ( 'setAttribute' in _canvas ) _canvas.setAttribute( 'data-engine', `three.js r${REVISION}` );

    		// event listeners must be registered before WebGL context is created, see #12753
    		_canvas.addEventListener( 'webglcontextlost', onContextLost, false );
    		_canvas.addEventListener( 'webglcontextrestored', onContextRestore, false );
    		_canvas.addEventListener( 'webglcontextcreationerror', onContextCreationError, false );

    		if ( _gl === null ) {

    			const contextNames = [ 'webgl2', 'webgl', 'experimental-webgl' ];

    			if ( _this.isWebGL1Renderer === true ) {

    				contextNames.shift();

    			}

    			_gl = getContext( contextNames, contextAttributes );

    			if ( _gl === null ) {

    				if ( getContext( contextNames ) ) {

    					throw new Error( 'Error creating WebGL context with your selected attributes.' );

    				} else {

    					throw new Error( 'Error creating WebGL context.' );

    				}

    			}

    		}

    		// Some experimental-webgl implementations do not have getShaderPrecisionFormat

    		if ( _gl.getShaderPrecisionFormat === undefined ) {

    			_gl.getShaderPrecisionFormat = function () {

    				return { 'rangeMin': 1, 'rangeMax': 1, 'precision': 1 };

    			};

    		}

    	} catch ( error ) {

    		console.error( 'THREE.WebGLRenderer: ' + error.message );
    		throw error;

    	}

    	let extensions, capabilities, state, info;
    	let properties, textures, cubemaps, cubeuvmaps, attributes, geometries, objects;
    	let programCache, materials, renderLists, renderStates, clipping, shadowMap;

    	let background, morphtargets, bufferRenderer, indexedBufferRenderer;

    	let utils, bindingStates, uniformsGroups;

    	function initGLContext() {

    		extensions = new WebGLExtensions( _gl );

    		capabilities = new WebGLCapabilities( _gl, extensions, parameters );

    		extensions.init( capabilities );

    		utils = new WebGLUtils( _gl, extensions, capabilities );

    		state = new WebGLState( _gl, extensions, capabilities );

    		info = new WebGLInfo();
    		properties = new WebGLProperties();
    		textures = new WebGLTextures( _gl, extensions, state, properties, capabilities, utils, info );
    		cubemaps = new WebGLCubeMaps( _this );
    		cubeuvmaps = new WebGLCubeUVMaps( _this );
    		attributes = new WebGLAttributes( _gl, capabilities );
    		bindingStates = new WebGLBindingStates( _gl, extensions, attributes, capabilities );
    		geometries = new WebGLGeometries( _gl, attributes, info, bindingStates );
    		objects = new WebGLObjects( _gl, geometries, attributes, info );
    		morphtargets = new WebGLMorphtargets( _gl, capabilities, textures );
    		clipping = new WebGLClipping( properties );
    		programCache = new WebGLPrograms( _this, cubemaps, cubeuvmaps, extensions, capabilities, bindingStates, clipping );
    		materials = new WebGLMaterials( _this, properties );
    		renderLists = new WebGLRenderLists();
    		renderStates = new WebGLRenderStates( extensions, capabilities );
    		background = new WebGLBackground( _this, cubemaps, cubeuvmaps, state, objects, _alpha, _premultipliedAlpha );
    		shadowMap = new WebGLShadowMap( _this, objects, capabilities );
    		uniformsGroups = new WebGLUniformsGroups( _gl, info, capabilities, state );

    		bufferRenderer = new WebGLBufferRenderer( _gl, extensions, info, capabilities );
    		indexedBufferRenderer = new WebGLIndexedBufferRenderer( _gl, extensions, info, capabilities );

    		info.programs = programCache.programs;

    		_this.capabilities = capabilities;
    		_this.extensions = extensions;
    		_this.properties = properties;
    		_this.renderLists = renderLists;
    		_this.shadowMap = shadowMap;
    		_this.state = state;
    		_this.info = info;

    	}

    	initGLContext();

    	// xr

    	const xr = new WebXRManager( _this, _gl );

    	this.xr = xr;

    	// API

    	this.getContext = function () {

    		return _gl;

    	};

    	this.getContextAttributes = function () {

    		return _gl.getContextAttributes();

    	};

    	this.forceContextLoss = function () {

    		const extension = extensions.get( 'WEBGL_lose_context' );
    		if ( extension ) extension.loseContext();

    	};

    	this.forceContextRestore = function () {

    		const extension = extensions.get( 'WEBGL_lose_context' );
    		if ( extension ) extension.restoreContext();

    	};

    	this.getPixelRatio = function () {

    		return _pixelRatio;

    	};

    	this.setPixelRatio = function ( value ) {

    		if ( value === undefined ) return;

    		_pixelRatio = value;

    		this.setSize( _width, _height, false );

    	};

    	this.getSize = function ( target ) {

    		return target.set( _width, _height );

    	};

    	this.setSize = function ( width, height, updateStyle ) {

    		if ( xr.isPresenting ) {

    			console.warn( 'THREE.WebGLRenderer: Can\'t change size while VR device is presenting.' );
    			return;

    		}

    		_width = width;
    		_height = height;

    		_canvas.width = Math.floor( width * _pixelRatio );
    		_canvas.height = Math.floor( height * _pixelRatio );

    		if ( updateStyle !== false ) {

    			_canvas.style.width = width + 'px';
    			_canvas.style.height = height + 'px';

    		}

    		this.setViewport( 0, 0, width, height );

    	};

    	this.getDrawingBufferSize = function ( target ) {

    		return target.set( _width * _pixelRatio, _height * _pixelRatio ).floor();

    	};

    	this.setDrawingBufferSize = function ( width, height, pixelRatio ) {

    		_width = width;
    		_height = height;

    		_pixelRatio = pixelRatio;

    		_canvas.width = Math.floor( width * pixelRatio );
    		_canvas.height = Math.floor( height * pixelRatio );

    		this.setViewport( 0, 0, width, height );

    	};

    	this.getCurrentViewport = function ( target ) {

    		return target.copy( _currentViewport );

    	};

    	this.getViewport = function ( target ) {

    		return target.copy( _viewport );

    	};

    	this.setViewport = function ( x, y, width, height ) {

    		if ( x.isVector4 ) {

    			_viewport.set( x.x, x.y, x.z, x.w );

    		} else {

    			_viewport.set( x, y, width, height );

    		}

    		state.viewport( _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ).floor() );

    	};

    	this.getScissor = function ( target ) {

    		return target.copy( _scissor );

    	};

    	this.setScissor = function ( x, y, width, height ) {

    		if ( x.isVector4 ) {

    			_scissor.set( x.x, x.y, x.z, x.w );

    		} else {

    			_scissor.set( x, y, width, height );

    		}

    		state.scissor( _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ).floor() );

    	};

    	this.getScissorTest = function () {

    		return _scissorTest;

    	};

    	this.setScissorTest = function ( boolean ) {

    		state.setScissorTest( _scissorTest = boolean );

    	};

    	this.setOpaqueSort = function ( method ) {

    		_opaqueSort = method;

    	};

    	this.setTransparentSort = function ( method ) {

    		_transparentSort = method;

    	};

    	// Clearing

    	this.getClearColor = function ( target ) {

    		return target.copy( background.getClearColor() );

    	};

    	this.setClearColor = function () {

    		background.setClearColor.apply( background, arguments );

    	};

    	this.getClearAlpha = function () {

    		return background.getClearAlpha();

    	};

    	this.setClearAlpha = function () {

    		background.setClearAlpha.apply( background, arguments );

    	};

    	this.clear = function ( color = true, depth = true, stencil = true ) {

    		let bits = 0;

    		if ( color ) bits |= 16384;
    		if ( depth ) bits |= 256;
    		if ( stencil ) bits |= 1024;

    		_gl.clear( bits );

    	};

    	this.clearColor = function () {

    		this.clear( true, false, false );

    	};

    	this.clearDepth = function () {

    		this.clear( false, true, false );

    	};

    	this.clearStencil = function () {

    		this.clear( false, false, true );

    	};

    	//

    	this.dispose = function () {

    		_canvas.removeEventListener( 'webglcontextlost', onContextLost, false );
    		_canvas.removeEventListener( 'webglcontextrestored', onContextRestore, false );
    		_canvas.removeEventListener( 'webglcontextcreationerror', onContextCreationError, false );

    		renderLists.dispose();
    		renderStates.dispose();
    		properties.dispose();
    		cubemaps.dispose();
    		cubeuvmaps.dispose();
    		objects.dispose();
    		bindingStates.dispose();
    		uniformsGroups.dispose();
    		programCache.dispose();

    		xr.dispose();

    		xr.removeEventListener( 'sessionstart', onXRSessionStart );
    		xr.removeEventListener( 'sessionend', onXRSessionEnd );

    		if ( _transmissionRenderTarget ) {

    			_transmissionRenderTarget.dispose();
    			_transmissionRenderTarget = null;

    		}

    		animation.stop();

    	};

    	// Events

    	function onContextLost( event ) {

    		event.preventDefault();

    		console.log( 'THREE.WebGLRenderer: Context Lost.' );

    		_isContextLost = true;

    	}

    	function onContextRestore( /* event */ ) {

    		console.log( 'THREE.WebGLRenderer: Context Restored.' );

    		_isContextLost = false;

    		const infoAutoReset = info.autoReset;
    		const shadowMapEnabled = shadowMap.enabled;
    		const shadowMapAutoUpdate = shadowMap.autoUpdate;
    		const shadowMapNeedsUpdate = shadowMap.needsUpdate;
    		const shadowMapType = shadowMap.type;

    		initGLContext();

    		info.autoReset = infoAutoReset;
    		shadowMap.enabled = shadowMapEnabled;
    		shadowMap.autoUpdate = shadowMapAutoUpdate;
    		shadowMap.needsUpdate = shadowMapNeedsUpdate;
    		shadowMap.type = shadowMapType;

    	}

    	function onContextCreationError( event ) {

    		console.error( 'THREE.WebGLRenderer: A WebGL context could not be created. Reason: ', event.statusMessage );

    	}

    	function onMaterialDispose( event ) {

    		const material = event.target;

    		material.removeEventListener( 'dispose', onMaterialDispose );

    		deallocateMaterial( material );

    	}

    	// Buffer deallocation

    	function deallocateMaterial( material ) {

    		releaseMaterialProgramReferences( material );

    		properties.remove( material );

    	}


    	function releaseMaterialProgramReferences( material ) {

    		const programs = properties.get( material ).programs;

    		if ( programs !== undefined ) {

    			programs.forEach( function ( program ) {

    				programCache.releaseProgram( program );

    			} );

    			if ( material.isShaderMaterial ) {

    				programCache.releaseShaderCache( material );

    			}

    		}

    	}

    	// Buffer rendering

    	this.renderBufferDirect = function ( camera, scene, geometry, material, object, group ) {

    		if ( scene === null ) scene = _emptyScene; // renderBufferDirect second parameter used to be fog (could be null)

    		const frontFaceCW = ( object.isMesh && object.matrixWorld.determinant() < 0 );

    		const program = setProgram( camera, scene, geometry, material, object );

    		state.setMaterial( material, frontFaceCW );

    		//

    		let index = geometry.index;
    		let rangeFactor = 1;

    		if ( material.wireframe === true ) {

    			index = geometries.getWireframeAttribute( geometry );
    			rangeFactor = 2;

    		}

    		//

    		const drawRange = geometry.drawRange;
    		const position = geometry.attributes.position;

    		let drawStart = drawRange.start * rangeFactor;
    		let drawEnd = ( drawRange.start + drawRange.count ) * rangeFactor;

    		if ( group !== null ) {

    			drawStart = Math.max( drawStart, group.start * rangeFactor );
    			drawEnd = Math.min( drawEnd, ( group.start + group.count ) * rangeFactor );

    		}

    		if ( index !== null ) {

    			drawStart = Math.max( drawStart, 0 );
    			drawEnd = Math.min( drawEnd, index.count );

    		} else if ( position !== undefined && position !== null ) {

    			drawStart = Math.max( drawStart, 0 );
    			drawEnd = Math.min( drawEnd, position.count );

    		}

    		const drawCount = drawEnd - drawStart;

    		if ( drawCount < 0 || drawCount === Infinity ) return;

    		//

    		bindingStates.setup( object, material, program, geometry, index );

    		let attribute;
    		let renderer = bufferRenderer;

    		if ( index !== null ) {

    			attribute = attributes.get( index );

    			renderer = indexedBufferRenderer;
    			renderer.setIndex( attribute );

    		}

    		//

    		if ( object.isMesh ) {

    			if ( material.wireframe === true ) {

    				state.setLineWidth( material.wireframeLinewidth * getTargetPixelRatio() );
    				renderer.setMode( 1 );

    			} else {

    				renderer.setMode( 4 );

    			}

    		} else if ( object.isLine ) {

    			let lineWidth = material.linewidth;

    			if ( lineWidth === undefined ) lineWidth = 1; // Not using Line*Material

    			state.setLineWidth( lineWidth * getTargetPixelRatio() );

    			if ( object.isLineSegments ) {

    				renderer.setMode( 1 );

    			} else if ( object.isLineLoop ) {

    				renderer.setMode( 2 );

    			} else {

    				renderer.setMode( 3 );

    			}

    		} else if ( object.isPoints ) {

    			renderer.setMode( 0 );

    		} else if ( object.isSprite ) {

    			renderer.setMode( 4 );

    		}

    		if ( object.isInstancedMesh ) {

    			renderer.renderInstances( drawStart, drawCount, object.count );

    		} else if ( geometry.isInstancedBufferGeometry ) {

    			const maxInstanceCount = geometry._maxInstanceCount !== undefined ? geometry._maxInstanceCount : Infinity;
    			const instanceCount = Math.min( geometry.instanceCount, maxInstanceCount );

    			renderer.renderInstances( drawStart, drawCount, instanceCount );

    		} else {

    			renderer.render( drawStart, drawCount );

    		}

    	};

    	// Compile

    	this.compile = function ( scene, camera ) {

    		function prepare( material, scene, object ) {

    			if ( material.transparent === true && material.side === DoubleSide ) {

    				material.side = BackSide;
    				material.needsUpdate = true;
    				getProgram( material, scene, object );

    				material.side = FrontSide;
    				material.needsUpdate = true;
    				getProgram( material, scene, object );

    				material.side = DoubleSide;

    			} else {

    				getProgram( material, scene, object );

    			}

    		}

    		currentRenderState = renderStates.get( scene );
    		currentRenderState.init();

    		renderStateStack.push( currentRenderState );

    		scene.traverseVisible( function ( object ) {

    			if ( object.isLight && object.layers.test( camera.layers ) ) {

    				currentRenderState.pushLight( object );

    				if ( object.castShadow ) {

    					currentRenderState.pushShadow( object );

    				}

    			}

    		} );

    		currentRenderState.setupLights( _this.physicallyCorrectLights );

    		scene.traverse( function ( object ) {

    			const material = object.material;

    			if ( material ) {

    				if ( Array.isArray( material ) ) {

    					for ( let i = 0; i < material.length; i ++ ) {

    						const material2 = material[ i ];

    						prepare( material2, scene, object );

    					}

    				} else {

    					prepare( material, scene, object );

    				}

    			}

    		} );

    		renderStateStack.pop();
    		currentRenderState = null;

    	};

    	// Animation Loop

    	let onAnimationFrameCallback = null;

    	function onAnimationFrame( time ) {

    		if ( onAnimationFrameCallback ) onAnimationFrameCallback( time );

    	}

    	function onXRSessionStart() {

    		animation.stop();

    	}

    	function onXRSessionEnd() {

    		animation.start();

    	}

    	const animation = new WebGLAnimation();
    	animation.setAnimationLoop( onAnimationFrame );

    	if ( typeof self !== 'undefined' ) animation.setContext( self );

    	this.setAnimationLoop = function ( callback ) {

    		onAnimationFrameCallback = callback;
    		xr.setAnimationLoop( callback );

    		( callback === null ) ? animation.stop() : animation.start();

    	};

    	xr.addEventListener( 'sessionstart', onXRSessionStart );
    	xr.addEventListener( 'sessionend', onXRSessionEnd );

    	// Rendering

    	this.render = function ( scene, camera ) {

    		if ( camera !== undefined && camera.isCamera !== true ) {

    			console.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );
    			return;

    		}

    		if ( _isContextLost === true ) return;

    		// update scene graph

    		if ( scene.matrixWorldAutoUpdate === true ) scene.updateMatrixWorld();

    		// update camera matrices and frustum

    		if ( camera.parent === null && camera.matrixWorldAutoUpdate === true ) camera.updateMatrixWorld();

    		if ( xr.enabled === true && xr.isPresenting === true ) {

    			if ( xr.cameraAutoUpdate === true ) xr.updateCamera( camera );

    			camera = xr.getCamera(); // use XR camera for rendering

    		}

    		//
    		if ( scene.isScene === true ) scene.onBeforeRender( _this, scene, camera, _currentRenderTarget );

    		currentRenderState = renderStates.get( scene, renderStateStack.length );
    		currentRenderState.init();

    		renderStateStack.push( currentRenderState );

    		_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
    		_frustum.setFromProjectionMatrix( _projScreenMatrix );

    		_localClippingEnabled = this.localClippingEnabled;
    		_clippingEnabled = clipping.init( this.clippingPlanes, _localClippingEnabled, camera );

    		currentRenderList = renderLists.get( scene, renderListStack.length );
    		currentRenderList.init();

    		renderListStack.push( currentRenderList );

    		projectObject( scene, camera, 0, _this.sortObjects );

    		currentRenderList.finish();

    		if ( _this.sortObjects === true ) {

    			currentRenderList.sort( _opaqueSort, _transparentSort );

    		}

    		//

    		if ( _clippingEnabled === true ) clipping.beginShadows();

    		const shadowsArray = currentRenderState.state.shadowsArray;

    		shadowMap.render( shadowsArray, scene, camera );

    		if ( _clippingEnabled === true ) clipping.endShadows();

    		//

    		if ( this.info.autoReset === true ) this.info.reset();

    		//

    		background.render( currentRenderList, scene );

    		// render scene

    		currentRenderState.setupLights( _this.physicallyCorrectLights );

    		if ( camera.isArrayCamera ) {

    			const cameras = camera.cameras;

    			for ( let i = 0, l = cameras.length; i < l; i ++ ) {

    				const camera2 = cameras[ i ];

    				renderScene( currentRenderList, scene, camera2, camera2.viewport );

    			}

    		} else {

    			renderScene( currentRenderList, scene, camera );

    		}

    		//

    		if ( _currentRenderTarget !== null ) {

    			// resolve multisample renderbuffers to a single-sample texture if necessary

    			textures.updateMultisampleRenderTarget( _currentRenderTarget );

    			// Generate mipmap if we're using any kind of mipmap filtering

    			textures.updateRenderTargetMipmap( _currentRenderTarget );

    		}

    		//

    		if ( scene.isScene === true ) scene.onAfterRender( _this, scene, camera );

    		// _gl.finish();

    		bindingStates.resetDefaultState();
    		_currentMaterialId = - 1;
    		_currentCamera = null;

    		renderStateStack.pop();

    		if ( renderStateStack.length > 0 ) {

    			currentRenderState = renderStateStack[ renderStateStack.length - 1 ];

    		} else {

    			currentRenderState = null;

    		}

    		renderListStack.pop();

    		if ( renderListStack.length > 0 ) {

    			currentRenderList = renderListStack[ renderListStack.length - 1 ];

    		} else {

    			currentRenderList = null;

    		}

    	};

    	function projectObject( object, camera, groupOrder, sortObjects ) {

    		if ( object.visible === false ) return;

    		const visible = object.layers.test( camera.layers );

    		if ( visible ) {

    			if ( object.isGroup ) {

    				groupOrder = object.renderOrder;

    			} else if ( object.isLOD ) {

    				if ( object.autoUpdate === true ) object.update( camera );

    			} else if ( object.isLight ) {

    				currentRenderState.pushLight( object );

    				if ( object.castShadow ) {

    					currentRenderState.pushShadow( object );

    				}

    			} else if ( object.isSprite ) {

    				if ( ! object.frustumCulled || _frustum.intersectsSprite( object ) ) {

    					if ( sortObjects ) {

    						_vector3.setFromMatrixPosition( object.matrixWorld )
    							.applyMatrix4( _projScreenMatrix );

    					}

    					const geometry = objects.update( object );
    					const material = object.material;

    					if ( material.visible ) {

    						currentRenderList.push( object, geometry, material, groupOrder, _vector3.z, null );

    					}

    				}

    			} else if ( object.isMesh || object.isLine || object.isPoints ) {

    				if ( object.isSkinnedMesh ) {

    					// update skeleton only once in a frame

    					if ( object.skeleton.frame !== info.render.frame ) {

    						object.skeleton.update();
    						object.skeleton.frame = info.render.frame;

    					}

    				}

    				if ( ! object.frustumCulled || _frustum.intersectsObject( object ) ) {

    					if ( sortObjects ) {

    						_vector3.setFromMatrixPosition( object.matrixWorld )
    							.applyMatrix4( _projScreenMatrix );

    					}

    					const geometry = objects.update( object );
    					const material = object.material;

    					if ( Array.isArray( material ) ) {

    						const groups = geometry.groups;

    						for ( let i = 0, l = groups.length; i < l; i ++ ) {

    							const group = groups[ i ];
    							const groupMaterial = material[ group.materialIndex ];

    							if ( groupMaterial && groupMaterial.visible ) {

    								currentRenderList.push( object, geometry, groupMaterial, groupOrder, _vector3.z, group );

    							}

    						}

    					} else if ( material.visible ) {

    						currentRenderList.push( object, geometry, material, groupOrder, _vector3.z, null );

    					}

    				}

    			}

    		}

    		const children = object.children;

    		for ( let i = 0, l = children.length; i < l; i ++ ) {

    			projectObject( children[ i ], camera, groupOrder, sortObjects );

    		}

    	}

    	function renderScene( currentRenderList, scene, camera, viewport ) {

    		const opaqueObjects = currentRenderList.opaque;
    		const transmissiveObjects = currentRenderList.transmissive;
    		const transparentObjects = currentRenderList.transparent;

    		currentRenderState.setupLightsView( camera );

    		if ( transmissiveObjects.length > 0 ) renderTransmissionPass( opaqueObjects, scene, camera );

    		if ( viewport ) state.viewport( _currentViewport.copy( viewport ) );

    		if ( opaqueObjects.length > 0 ) renderObjects( opaqueObjects, scene, camera );
    		if ( transmissiveObjects.length > 0 ) renderObjects( transmissiveObjects, scene, camera );
    		if ( transparentObjects.length > 0 ) renderObjects( transparentObjects, scene, camera );

    		// Ensure depth buffer writing is enabled so it can be cleared on next render

    		state.buffers.depth.setTest( true );
    		state.buffers.depth.setMask( true );
    		state.buffers.color.setMask( true );

    		state.setPolygonOffset( false );

    	}

    	function renderTransmissionPass( opaqueObjects, scene, camera ) {

    		const isWebGL2 = capabilities.isWebGL2;

    		if ( _transmissionRenderTarget === null ) {

    			_transmissionRenderTarget = new WebGLRenderTarget( 1, 1, {
    				generateMipmaps: true,
    				type: extensions.has( 'EXT_color_buffer_half_float' ) ? HalfFloatType : UnsignedByteType,
    				minFilter: LinearMipmapLinearFilter,
    				samples: ( isWebGL2 && _antialias === true ) ? 4 : 0
    			} );

    		}

    		_this.getDrawingBufferSize( _vector2 );

    		if ( isWebGL2 ) {

    			_transmissionRenderTarget.setSize( _vector2.x, _vector2.y );

    		} else {

    			_transmissionRenderTarget.setSize( floorPowerOfTwo( _vector2.x ), floorPowerOfTwo( _vector2.y ) );

    		}

    		//

    		const currentRenderTarget = _this.getRenderTarget();
    		_this.setRenderTarget( _transmissionRenderTarget );
    		_this.clear();

    		// Turn off the features which can affect the frag color for opaque objects pass.
    		// Otherwise they are applied twice in opaque objects pass and transmission objects pass.
    		const currentToneMapping = _this.toneMapping;
    		_this.toneMapping = NoToneMapping;

    		renderObjects( opaqueObjects, scene, camera );

    		_this.toneMapping = currentToneMapping;

    		textures.updateMultisampleRenderTarget( _transmissionRenderTarget );
    		textures.updateRenderTargetMipmap( _transmissionRenderTarget );

    		_this.setRenderTarget( currentRenderTarget );

    	}

    	function renderObjects( renderList, scene, camera ) {

    		const overrideMaterial = scene.isScene === true ? scene.overrideMaterial : null;

    		for ( let i = 0, l = renderList.length; i < l; i ++ ) {

    			const renderItem = renderList[ i ];

    			const object = renderItem.object;
    			const geometry = renderItem.geometry;
    			const material = overrideMaterial === null ? renderItem.material : overrideMaterial;
    			const group = renderItem.group;

    			if ( object.layers.test( camera.layers ) ) {

    				renderObject( object, scene, camera, geometry, material, group );

    			}

    		}

    	}

    	function renderObject( object, scene, camera, geometry, material, group ) {

    		object.onBeforeRender( _this, scene, camera, geometry, material, group );

    		object.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );
    		object.normalMatrix.getNormalMatrix( object.modelViewMatrix );

    		material.onBeforeRender( _this, scene, camera, geometry, object, group );

    		if ( material.transparent === true && material.side === DoubleSide ) {

    			material.side = BackSide;
    			material.needsUpdate = true;
    			_this.renderBufferDirect( camera, scene, geometry, material, object, group );

    			material.side = FrontSide;
    			material.needsUpdate = true;
    			_this.renderBufferDirect( camera, scene, geometry, material, object, group );

    			material.side = DoubleSide;

    		} else {

    			_this.renderBufferDirect( camera, scene, geometry, material, object, group );

    		}

    		object.onAfterRender( _this, scene, camera, geometry, material, group );

    	}

    	function getProgram( material, scene, object ) {

    		if ( scene.isScene !== true ) scene = _emptyScene; // scene could be a Mesh, Line, Points, ...

    		const materialProperties = properties.get( material );

    		const lights = currentRenderState.state.lights;
    		const shadowsArray = currentRenderState.state.shadowsArray;

    		const lightsStateVersion = lights.state.version;

    		const parameters = programCache.getParameters( material, lights.state, shadowsArray, scene, object );
    		const programCacheKey = programCache.getProgramCacheKey( parameters );

    		let programs = materialProperties.programs;

    		// always update environment and fog - changing these trigger an getProgram call, but it's possible that the program doesn't change

    		materialProperties.environment = material.isMeshStandardMaterial ? scene.environment : null;
    		materialProperties.fog = scene.fog;
    		materialProperties.envMap = ( material.isMeshStandardMaterial ? cubeuvmaps : cubemaps ).get( material.envMap || materialProperties.environment );

    		if ( programs === undefined ) {

    			// new material

    			material.addEventListener( 'dispose', onMaterialDispose );

    			programs = new Map();
    			materialProperties.programs = programs;

    		}

    		let program = programs.get( programCacheKey );

    		if ( program !== undefined ) {

    			// early out if program and light state is identical

    			if ( materialProperties.currentProgram === program && materialProperties.lightsStateVersion === lightsStateVersion ) {

    				updateCommonMaterialProperties( material, parameters );

    				return program;

    			}

    		} else {

    			parameters.uniforms = programCache.getUniforms( material );

    			material.onBuild( object, parameters, _this );

    			material.onBeforeCompile( parameters, _this );

    			program = programCache.acquireProgram( parameters, programCacheKey );
    			programs.set( programCacheKey, program );

    			materialProperties.uniforms = parameters.uniforms;

    		}

    		const uniforms = materialProperties.uniforms;

    		if ( ( ! material.isShaderMaterial && ! material.isRawShaderMaterial ) || material.clipping === true ) {

    			uniforms.clippingPlanes = clipping.uniform;

    		}

    		updateCommonMaterialProperties( material, parameters );

    		// store the light setup it was created for

    		materialProperties.needsLights = materialNeedsLights( material );
    		materialProperties.lightsStateVersion = lightsStateVersion;

    		if ( materialProperties.needsLights ) {

    			// wire up the material to this renderer's lighting state

    			uniforms.ambientLightColor.value = lights.state.ambient;
    			uniforms.lightProbe.value = lights.state.probe;
    			uniforms.directionalLights.value = lights.state.directional;
    			uniforms.directionalLightShadows.value = lights.state.directionalShadow;
    			uniforms.spotLights.value = lights.state.spot;
    			uniforms.spotLightShadows.value = lights.state.spotShadow;
    			uniforms.rectAreaLights.value = lights.state.rectArea;
    			uniforms.ltc_1.value = lights.state.rectAreaLTC1;
    			uniforms.ltc_2.value = lights.state.rectAreaLTC2;
    			uniforms.pointLights.value = lights.state.point;
    			uniforms.pointLightShadows.value = lights.state.pointShadow;
    			uniforms.hemisphereLights.value = lights.state.hemi;

    			uniforms.directionalShadowMap.value = lights.state.directionalShadowMap;
    			uniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;
    			uniforms.spotShadowMap.value = lights.state.spotShadowMap;
    			uniforms.spotLightMatrix.value = lights.state.spotLightMatrix;
    			uniforms.spotLightMap.value = lights.state.spotLightMap;
    			uniforms.pointShadowMap.value = lights.state.pointShadowMap;
    			uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix;
    			// TODO (abelnation): add area lights shadow info to uniforms

    		}

    		const progUniforms = program.getUniforms();
    		const uniformsList = WebGLUniforms.seqWithValue( progUniforms.seq, uniforms );

    		materialProperties.currentProgram = program;
    		materialProperties.uniformsList = uniformsList;

    		return program;

    	}

    	function updateCommonMaterialProperties( material, parameters ) {

    		const materialProperties = properties.get( material );

    		materialProperties.outputEncoding = parameters.outputEncoding;
    		materialProperties.instancing = parameters.instancing;
    		materialProperties.skinning = parameters.skinning;
    		materialProperties.morphTargets = parameters.morphTargets;
    		materialProperties.morphNormals = parameters.morphNormals;
    		materialProperties.morphColors = parameters.morphColors;
    		materialProperties.morphTargetsCount = parameters.morphTargetsCount;
    		materialProperties.numClippingPlanes = parameters.numClippingPlanes;
    		materialProperties.numIntersection = parameters.numClipIntersection;
    		materialProperties.vertexAlphas = parameters.vertexAlphas;
    		materialProperties.vertexTangents = parameters.vertexTangents;
    		materialProperties.toneMapping = parameters.toneMapping;

    	}

    	function setProgram( camera, scene, geometry, material, object ) {

    		if ( scene.isScene !== true ) scene = _emptyScene; // scene could be a Mesh, Line, Points, ...

    		textures.resetTextureUnits();

    		const fog = scene.fog;
    		const environment = material.isMeshStandardMaterial ? scene.environment : null;
    		const encoding = ( _currentRenderTarget === null ) ? _this.outputEncoding : ( _currentRenderTarget.isXRRenderTarget === true ? _currentRenderTarget.texture.encoding : LinearEncoding );
    		const envMap = ( material.isMeshStandardMaterial ? cubeuvmaps : cubemaps ).get( material.envMap || environment );
    		const vertexAlphas = material.vertexColors === true && !! geometry.attributes.color && geometry.attributes.color.itemSize === 4;
    		const vertexTangents = !! material.normalMap && !! geometry.attributes.tangent;
    		const morphTargets = !! geometry.morphAttributes.position;
    		const morphNormals = !! geometry.morphAttributes.normal;
    		const morphColors = !! geometry.morphAttributes.color;
    		const toneMapping = material.toneMapped ? _this.toneMapping : NoToneMapping;

    		const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
    		const morphTargetsCount = ( morphAttribute !== undefined ) ? morphAttribute.length : 0;

    		const materialProperties = properties.get( material );
    		const lights = currentRenderState.state.lights;

    		if ( _clippingEnabled === true ) {

    			if ( _localClippingEnabled === true || camera !== _currentCamera ) {

    				const useCache =
    					camera === _currentCamera &&
    					material.id === _currentMaterialId;

    				// we might want to call this function with some ClippingGroup
    				// object instead of the material, once it becomes feasible
    				// (#8465, #8379)
    				clipping.setState( material, camera, useCache );

    			}

    		}

    		//

    		let needsProgramChange = false;

    		if ( material.version === materialProperties.__version ) {

    			if ( materialProperties.needsLights && ( materialProperties.lightsStateVersion !== lights.state.version ) ) {

    				needsProgramChange = true;

    			} else if ( materialProperties.outputEncoding !== encoding ) {

    				needsProgramChange = true;

    			} else if ( object.isInstancedMesh && materialProperties.instancing === false ) {

    				needsProgramChange = true;

    			} else if ( ! object.isInstancedMesh && materialProperties.instancing === true ) {

    				needsProgramChange = true;

    			} else if ( object.isSkinnedMesh && materialProperties.skinning === false ) {

    				needsProgramChange = true;

    			} else if ( ! object.isSkinnedMesh && materialProperties.skinning === true ) {

    				needsProgramChange = true;

    			} else if ( materialProperties.envMap !== envMap ) {

    				needsProgramChange = true;

    			} else if ( material.fog === true && materialProperties.fog !== fog ) {

    				needsProgramChange = true;

    			} else if ( materialProperties.numClippingPlanes !== undefined &&
    				( materialProperties.numClippingPlanes !== clipping.numPlanes ||
    				materialProperties.numIntersection !== clipping.numIntersection ) ) {

    				needsProgramChange = true;

    			} else if ( materialProperties.vertexAlphas !== vertexAlphas ) {

    				needsProgramChange = true;

    			} else if ( materialProperties.vertexTangents !== vertexTangents ) {

    				needsProgramChange = true;

    			} else if ( materialProperties.morphTargets !== morphTargets ) {

    				needsProgramChange = true;

    			} else if ( materialProperties.morphNormals !== morphNormals ) {

    				needsProgramChange = true;

    			} else if ( materialProperties.morphColors !== morphColors ) {

    				needsProgramChange = true;

    			} else if ( materialProperties.toneMapping !== toneMapping ) {

    				needsProgramChange = true;

    			} else if ( capabilities.isWebGL2 === true && materialProperties.morphTargetsCount !== morphTargetsCount ) {

    				needsProgramChange = true;

    			}

    		} else {

    			needsProgramChange = true;
    			materialProperties.__version = material.version;

    		}

    		//

    		let program = materialProperties.currentProgram;

    		if ( needsProgramChange === true ) {

    			program = getProgram( material, scene, object );

    		}

    		let refreshProgram = false;
    		let refreshMaterial = false;
    		let refreshLights = false;

    		const p_uniforms = program.getUniforms(),
    			m_uniforms = materialProperties.uniforms;

    		if ( state.useProgram( program.program ) ) {

    			refreshProgram = true;
    			refreshMaterial = true;
    			refreshLights = true;

    		}

    		if ( material.id !== _currentMaterialId ) {

    			_currentMaterialId = material.id;

    			refreshMaterial = true;

    		}

    		if ( refreshProgram || _currentCamera !== camera ) {

    			p_uniforms.setValue( _gl, 'projectionMatrix', camera.projectionMatrix );

    			if ( capabilities.logarithmicDepthBuffer ) {

    				p_uniforms.setValue( _gl, 'logDepthBufFC',
    					2.0 / ( Math.log( camera.far + 1.0 ) / Math.LN2 ) );

    			}

    			if ( _currentCamera !== camera ) {

    				_currentCamera = camera;

    				// lighting uniforms depend on the camera so enforce an update
    				// now, in case this material supports lights - or later, when
    				// the next material that does gets activated:

    				refreshMaterial = true;		// set to true on material change
    				refreshLights = true;		// remains set until update done

    			}

    			// load material specific uniforms
    			// (shader material also gets them for the sake of genericity)

    			if ( material.isShaderMaterial ||
    				material.isMeshPhongMaterial ||
    				material.isMeshToonMaterial ||
    				material.isMeshStandardMaterial ||
    				material.envMap ) {

    				const uCamPos = p_uniforms.map.cameraPosition;

    				if ( uCamPos !== undefined ) {

    					uCamPos.setValue( _gl,
    						_vector3.setFromMatrixPosition( camera.matrixWorld ) );

    				}

    			}

    			if ( material.isMeshPhongMaterial ||
    				material.isMeshToonMaterial ||
    				material.isMeshLambertMaterial ||
    				material.isMeshBasicMaterial ||
    				material.isMeshStandardMaterial ||
    				material.isShaderMaterial ) {

    				p_uniforms.setValue( _gl, 'isOrthographic', camera.isOrthographicCamera === true );

    			}

    			if ( material.isMeshPhongMaterial ||
    				material.isMeshToonMaterial ||
    				material.isMeshLambertMaterial ||
    				material.isMeshBasicMaterial ||
    				material.isMeshStandardMaterial ||
    				material.isShaderMaterial ||
    				material.isShadowMaterial ||
    				object.isSkinnedMesh ) {

    				p_uniforms.setValue( _gl, 'viewMatrix', camera.matrixWorldInverse );

    			}

    		}

    		// skinning and morph target uniforms must be set even if material didn't change
    		// auto-setting of texture unit for bone and morph texture must go before other textures
    		// otherwise textures used for skinning and morphing can take over texture units reserved for other material textures

    		if ( object.isSkinnedMesh ) {

    			p_uniforms.setOptional( _gl, object, 'bindMatrix' );
    			p_uniforms.setOptional( _gl, object, 'bindMatrixInverse' );

    			const skeleton = object.skeleton;

    			if ( skeleton ) {

    				if ( capabilities.floatVertexTextures ) {

    					if ( skeleton.boneTexture === null ) skeleton.computeBoneTexture();

    					p_uniforms.setValue( _gl, 'boneTexture', skeleton.boneTexture, textures );
    					p_uniforms.setValue( _gl, 'boneTextureSize', skeleton.boneTextureSize );

    				} else {

    					console.warn( 'THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required.' );

    				}

    			}

    		}

    		const morphAttributes = geometry.morphAttributes;

    		if ( morphAttributes.position !== undefined || morphAttributes.normal !== undefined || ( morphAttributes.color !== undefined && capabilities.isWebGL2 === true ) ) {

    			morphtargets.update( object, geometry, material, program );

    		}

    		if ( refreshMaterial || materialProperties.receiveShadow !== object.receiveShadow ) {

    			materialProperties.receiveShadow = object.receiveShadow;
    			p_uniforms.setValue( _gl, 'receiveShadow', object.receiveShadow );

    		}

    		// https://github.com/mrdoob/three.js/pull/24467#issuecomment-1209031512

    		if ( material.isMeshGouraudMaterial && material.envMap !== null ) {

    			m_uniforms.envMap.value = envMap;

    			m_uniforms.flipEnvMap.value = ( envMap.isCubeTexture && envMap.isRenderTargetTexture === false ) ? - 1 : 1;

    		}

    		if ( refreshMaterial ) {

    			p_uniforms.setValue( _gl, 'toneMappingExposure', _this.toneMappingExposure );

    			if ( materialProperties.needsLights ) {

    				// the current material requires lighting info

    				// note: all lighting uniforms are always set correctly
    				// they simply reference the renderer's state for their
    				// values
    				//
    				// use the current material's .needsUpdate flags to set
    				// the GL state when required

    				markUniformsLightsNeedsUpdate( m_uniforms, refreshLights );

    			}

    			// refresh uniforms common to several materials

    			if ( fog && material.fog === true ) {

    				materials.refreshFogUniforms( m_uniforms, fog );

    			}

    			materials.refreshMaterialUniforms( m_uniforms, material, _pixelRatio, _height, _transmissionRenderTarget );

    			WebGLUniforms.upload( _gl, materialProperties.uniformsList, m_uniforms, textures );

    		}

    		if ( material.isShaderMaterial && material.uniformsNeedUpdate === true ) {

    			WebGLUniforms.upload( _gl, materialProperties.uniformsList, m_uniforms, textures );
    			material.uniformsNeedUpdate = false;

    		}

    		if ( material.isSpriteMaterial ) {

    			p_uniforms.setValue( _gl, 'center', object.center );

    		}

    		// common matrices

    		p_uniforms.setValue( _gl, 'modelViewMatrix', object.modelViewMatrix );
    		p_uniforms.setValue( _gl, 'normalMatrix', object.normalMatrix );
    		p_uniforms.setValue( _gl, 'modelMatrix', object.matrixWorld );

    		// UBOs

    		if ( material.isShaderMaterial || material.isRawShaderMaterial ) {

    			const groups = material.uniformsGroups;

    			for ( let i = 0, l = groups.length; i < l; i ++ ) {

    				if ( capabilities.isWebGL2 ) {

    					const group = groups[ i ];

    					uniformsGroups.update( group, program );
    					uniformsGroups.bind( group, program );

    				} else {

    					console.warn( 'THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2.' );

    				}

    			}

    		}

    		return program;

    	}

    	// If uniforms are marked as clean, they don't need to be loaded to the GPU.

    	function markUniformsLightsNeedsUpdate( uniforms, value ) {

    		uniforms.ambientLightColor.needsUpdate = value;
    		uniforms.lightProbe.needsUpdate = value;

    		uniforms.directionalLights.needsUpdate = value;
    		uniforms.directionalLightShadows.needsUpdate = value;
    		uniforms.pointLights.needsUpdate = value;
    		uniforms.pointLightShadows.needsUpdate = value;
    		uniforms.spotLights.needsUpdate = value;
    		uniforms.spotLightShadows.needsUpdate = value;
    		uniforms.rectAreaLights.needsUpdate = value;
    		uniforms.hemisphereLights.needsUpdate = value;

    	}

    	function materialNeedsLights( material ) {

    		return material.isMeshLambertMaterial || material.isMeshToonMaterial || material.isMeshPhongMaterial ||
    			material.isMeshStandardMaterial || material.isShadowMaterial ||
    			( material.isShaderMaterial && material.lights === true );

    	}

    	this.getActiveCubeFace = function () {

    		return _currentActiveCubeFace;

    	};

    	this.getActiveMipmapLevel = function () {

    		return _currentActiveMipmapLevel;

    	};

    	this.getRenderTarget = function () {

    		return _currentRenderTarget;

    	};

    	this.setRenderTargetTextures = function ( renderTarget, colorTexture, depthTexture ) {

    		properties.get( renderTarget.texture ).__webglTexture = colorTexture;
    		properties.get( renderTarget.depthTexture ).__webglTexture = depthTexture;

    		const renderTargetProperties = properties.get( renderTarget );
    		renderTargetProperties.__hasExternalTextures = true;

    		if ( renderTargetProperties.__hasExternalTextures ) {

    			renderTargetProperties.__autoAllocateDepthBuffer = depthTexture === undefined;

    			if ( ! renderTargetProperties.__autoAllocateDepthBuffer ) {

    				// The multisample_render_to_texture extension doesn't work properly if there
    				// are midframe flushes and an external depth buffer. Disable use of the extension.
    				if ( extensions.has( 'WEBGL_multisampled_render_to_texture' ) === true ) {

    					console.warn( 'THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided' );
    					renderTargetProperties.__useRenderToTexture = false;

    				}

    			}

    		}

    	};

    	this.setRenderTargetFramebuffer = function ( renderTarget, defaultFramebuffer ) {

    		const renderTargetProperties = properties.get( renderTarget );
    		renderTargetProperties.__webglFramebuffer = defaultFramebuffer;
    		renderTargetProperties.__useDefaultFramebuffer = defaultFramebuffer === undefined;

    	};

    	this.setRenderTarget = function ( renderTarget, activeCubeFace = 0, activeMipmapLevel = 0 ) {

    		_currentRenderTarget = renderTarget;
    		_currentActiveCubeFace = activeCubeFace;
    		_currentActiveMipmapLevel = activeMipmapLevel;

    		let useDefaultFramebuffer = true;
    		let framebuffer = null;
    		let isCube = false;
    		let isRenderTarget3D = false;

    		if ( renderTarget ) {

    			const renderTargetProperties = properties.get( renderTarget );

    			if ( renderTargetProperties.__useDefaultFramebuffer !== undefined ) {

    				// We need to make sure to rebind the framebuffer.
    				state.bindFramebuffer( 36160, null );
    				useDefaultFramebuffer = false;

    			} else if ( renderTargetProperties.__webglFramebuffer === undefined ) {

    				textures.setupRenderTarget( renderTarget );

    			} else if ( renderTargetProperties.__hasExternalTextures ) {

    				// Color and depth texture must be rebound in order for the swapchain to update.
    				textures.rebindTextures( renderTarget, properties.get( renderTarget.texture ).__webglTexture, properties.get( renderTarget.depthTexture ).__webglTexture );

    			}

    			const texture = renderTarget.texture;

    			if ( texture.isData3DTexture || texture.isDataArrayTexture || texture.isCompressedArrayTexture ) {

    				isRenderTarget3D = true;

    			}

    			const __webglFramebuffer = properties.get( renderTarget ).__webglFramebuffer;

    			if ( renderTarget.isWebGLCubeRenderTarget ) {

    				framebuffer = __webglFramebuffer[ activeCubeFace ];
    				isCube = true;

    			} else if ( ( capabilities.isWebGL2 && renderTarget.samples > 0 ) && textures.useMultisampledRTT( renderTarget ) === false ) {

    				framebuffer = properties.get( renderTarget ).__webglMultisampledFramebuffer;

    			} else {

    				framebuffer = __webglFramebuffer;

    			}

    			_currentViewport.copy( renderTarget.viewport );
    			_currentScissor.copy( renderTarget.scissor );
    			_currentScissorTest = renderTarget.scissorTest;

    		} else {

    			_currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ).floor();
    			_currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ).floor();
    			_currentScissorTest = _scissorTest;

    		}

    		const framebufferBound = state.bindFramebuffer( 36160, framebuffer );

    		if ( framebufferBound && capabilities.drawBuffers && useDefaultFramebuffer ) {

    			state.drawBuffers( renderTarget, framebuffer );

    		}

    		state.viewport( _currentViewport );
    		state.scissor( _currentScissor );
    		state.setScissorTest( _currentScissorTest );

    		if ( isCube ) {

    			const textureProperties = properties.get( renderTarget.texture );
    			_gl.framebufferTexture2D( 36160, 36064, 34069 + activeCubeFace, textureProperties.__webglTexture, activeMipmapLevel );

    		} else if ( isRenderTarget3D ) {

    			const textureProperties = properties.get( renderTarget.texture );
    			const layer = activeCubeFace || 0;
    			_gl.framebufferTextureLayer( 36160, 36064, textureProperties.__webglTexture, activeMipmapLevel || 0, layer );

    		}

    		_currentMaterialId = - 1; // reset current material to ensure correct uniform bindings

    	};

    	this.readRenderTargetPixels = function ( renderTarget, x, y, width, height, buffer, activeCubeFaceIndex ) {

    		if ( ! ( renderTarget && renderTarget.isWebGLRenderTarget ) ) {

    			console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.' );
    			return;

    		}

    		let framebuffer = properties.get( renderTarget ).__webglFramebuffer;

    		if ( renderTarget.isWebGLCubeRenderTarget && activeCubeFaceIndex !== undefined ) {

    			framebuffer = framebuffer[ activeCubeFaceIndex ];

    		}

    		if ( framebuffer ) {

    			state.bindFramebuffer( 36160, framebuffer );

    			try {

    				const texture = renderTarget.texture;
    				const textureFormat = texture.format;
    				const textureType = texture.type;

    				if ( textureFormat !== RGBAFormat && utils.convert( textureFormat ) !== _gl.getParameter( 35739 ) ) {

    					console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.' );
    					return;

    				}

    				const halfFloatSupportedByExt = ( textureType === HalfFloatType ) && ( extensions.has( 'EXT_color_buffer_half_float' ) || ( capabilities.isWebGL2 && extensions.has( 'EXT_color_buffer_float' ) ) );

    				if ( textureType !== UnsignedByteType && utils.convert( textureType ) !== _gl.getParameter( 35738 ) && // Edge and Chrome Mac < 52 (#9513)
    					! ( textureType === FloatType && ( capabilities.isWebGL2 || extensions.has( 'OES_texture_float' ) || extensions.has( 'WEBGL_color_buffer_float' ) ) ) && // Chrome Mac >= 52 and Firefox
    					! halfFloatSupportedByExt ) {

    					console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.' );
    					return;

    				}

    				// the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)

    				if ( ( x >= 0 && x <= ( renderTarget.width - width ) ) && ( y >= 0 && y <= ( renderTarget.height - height ) ) ) {

    					_gl.readPixels( x, y, width, height, utils.convert( textureFormat ), utils.convert( textureType ), buffer );

    				}

    			} finally {

    				// restore framebuffer of current render target if necessary

    				const framebuffer = ( _currentRenderTarget !== null ) ? properties.get( _currentRenderTarget ).__webglFramebuffer : null;
    				state.bindFramebuffer( 36160, framebuffer );

    			}

    		}

    	};

    	this.copyFramebufferToTexture = function ( position, texture, level = 0 ) {

    		const levelScale = Math.pow( 2, - level );
    		const width = Math.floor( texture.image.width * levelScale );
    		const height = Math.floor( texture.image.height * levelScale );

    		textures.setTexture2D( texture, 0 );

    		_gl.copyTexSubImage2D( 3553, level, 0, 0, position.x, position.y, width, height );

    		state.unbindTexture();

    	};

    	this.copyTextureToTexture = function ( position, srcTexture, dstTexture, level = 0 ) {

    		const width = srcTexture.image.width;
    		const height = srcTexture.image.height;
    		const glFormat = utils.convert( dstTexture.format );
    		const glType = utils.convert( dstTexture.type );

    		textures.setTexture2D( dstTexture, 0 );

    		// As another texture upload may have changed pixelStorei
    		// parameters, make sure they are correct for the dstTexture
    		_gl.pixelStorei( 37440, dstTexture.flipY );
    		_gl.pixelStorei( 37441, dstTexture.premultiplyAlpha );
    		_gl.pixelStorei( 3317, dstTexture.unpackAlignment );

    		if ( srcTexture.isDataTexture ) {

    			_gl.texSubImage2D( 3553, level, position.x, position.y, width, height, glFormat, glType, srcTexture.image.data );

    		} else {

    			if ( srcTexture.isCompressedTexture ) {

    				_gl.compressedTexSubImage2D( 3553, level, position.x, position.y, srcTexture.mipmaps[ 0 ].width, srcTexture.mipmaps[ 0 ].height, glFormat, srcTexture.mipmaps[ 0 ].data );

    			} else {

    				_gl.texSubImage2D( 3553, level, position.x, position.y, glFormat, glType, srcTexture.image );

    			}

    		}

    		// Generate mipmaps only when copying level 0
    		if ( level === 0 && dstTexture.generateMipmaps ) _gl.generateMipmap( 3553 );

    		state.unbindTexture();

    	};

    	this.copyTextureToTexture3D = function ( sourceBox, position, srcTexture, dstTexture, level = 0 ) {

    		if ( _this.isWebGL1Renderer ) {

    			console.warn( 'THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.' );
    			return;

    		}

    		const width = sourceBox.max.x - sourceBox.min.x + 1;
    		const height = sourceBox.max.y - sourceBox.min.y + 1;
    		const depth = sourceBox.max.z - sourceBox.min.z + 1;
    		const glFormat = utils.convert( dstTexture.format );
    		const glType = utils.convert( dstTexture.type );
    		let glTarget;

    		if ( dstTexture.isData3DTexture ) {

    			textures.setTexture3D( dstTexture, 0 );
    			glTarget = 32879;

    		} else if ( dstTexture.isDataArrayTexture ) {

    			textures.setTexture2DArray( dstTexture, 0 );
    			glTarget = 35866;

    		} else {

    			console.warn( 'THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.' );
    			return;

    		}

    		_gl.pixelStorei( 37440, dstTexture.flipY );
    		_gl.pixelStorei( 37441, dstTexture.premultiplyAlpha );
    		_gl.pixelStorei( 3317, dstTexture.unpackAlignment );

    		const unpackRowLen = _gl.getParameter( 3314 );
    		const unpackImageHeight = _gl.getParameter( 32878 );
    		const unpackSkipPixels = _gl.getParameter( 3316 );
    		const unpackSkipRows = _gl.getParameter( 3315 );
    		const unpackSkipImages = _gl.getParameter( 32877 );

    		const image = srcTexture.isCompressedTexture ? srcTexture.mipmaps[ 0 ] : srcTexture.image;

    		_gl.pixelStorei( 3314, image.width );
    		_gl.pixelStorei( 32878, image.height );
    		_gl.pixelStorei( 3316, sourceBox.min.x );
    		_gl.pixelStorei( 3315, sourceBox.min.y );
    		_gl.pixelStorei( 32877, sourceBox.min.z );

    		if ( srcTexture.isDataTexture || srcTexture.isData3DTexture ) {

    			_gl.texSubImage3D( glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, glType, image.data );

    		} else {

    			if ( srcTexture.isCompressedArrayTexture ) {

    				console.warn( 'THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture.' );
    				_gl.compressedTexSubImage3D( glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, image.data );

    			} else {

    				_gl.texSubImage3D( glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, glType, image );

    			}

    		}

    		_gl.pixelStorei( 3314, unpackRowLen );
    		_gl.pixelStorei( 32878, unpackImageHeight );
    		_gl.pixelStorei( 3316, unpackSkipPixels );
    		_gl.pixelStorei( 3315, unpackSkipRows );
    		_gl.pixelStorei( 32877, unpackSkipImages );

    		// Generate mipmaps only when copying level 0
    		if ( level === 0 && dstTexture.generateMipmaps ) _gl.generateMipmap( glTarget );

    		state.unbindTexture();

    	};

    	this.initTexture = function ( texture ) {

    		if ( texture.isCubeTexture ) {

    			textures.setTextureCube( texture, 0 );

    		} else if ( texture.isData3DTexture ) {

    			textures.setTexture3D( texture, 0 );

    		} else if ( texture.isDataArrayTexture || texture.isCompressedArrayTexture ) {

    			textures.setTexture2DArray( texture, 0 );

    		} else {

    			textures.setTexture2D( texture, 0 );

    		}

    		state.unbindTexture();

    	};

    	this.resetState = function () {

    		_currentActiveCubeFace = 0;
    		_currentActiveMipmapLevel = 0;
    		_currentRenderTarget = null;

    		state.reset();
    		bindingStates.reset();

    	};

    	if ( typeof __THREE_DEVTOOLS__ !== 'undefined' ) {

    		__THREE_DEVTOOLS__.dispatchEvent( new CustomEvent( 'observe', { detail: this } ) );

    	}

    }

    class WebGL1Renderer extends WebGLRenderer {}

    WebGL1Renderer.prototype.isWebGL1Renderer = true;

    class Scene extends Object3D {

    	constructor() {

    		super();

    		this.isScene = true;

    		this.type = 'Scene';

    		this.background = null;
    		this.environment = null;
    		this.fog = null;

    		this.backgroundBlurriness = 0;
    		this.backgroundIntensity = 1;

    		this.overrideMaterial = null;

    		if ( typeof __THREE_DEVTOOLS__ !== 'undefined' ) {

    			__THREE_DEVTOOLS__.dispatchEvent( new CustomEvent( 'observe', { detail: this } ) );

    		}

    	}

    	copy( source, recursive ) {

    		super.copy( source, recursive );

    		if ( source.background !== null ) this.background = source.background.clone();
    		if ( source.environment !== null ) this.environment = source.environment.clone();
    		if ( source.fog !== null ) this.fog = source.fog.clone();

    		this.backgroundBlurriness = source.backgroundBlurriness;
    		this.backgroundIntensity = source.backgroundIntensity;

    		if ( source.overrideMaterial !== null ) this.overrideMaterial = source.overrideMaterial.clone();

    		this.matrixAutoUpdate = source.matrixAutoUpdate;

    		return this;

    	}

    	toJSON( meta ) {

    		const data = super.toJSON( meta );

    		if ( this.fog !== null ) data.object.fog = this.fog.toJSON();
    		if ( this.backgroundBlurriness > 0 ) data.backgroundBlurriness = this.backgroundBlurriness;
    		if ( this.backgroundIntensity !== 1 ) data.backgroundIntensity = this.backgroundIntensity;

    		return data;

    	}

    	// @deprecated

    	get autoUpdate() {

    		console.warn( 'THREE.Scene: autoUpdate was renamed to matrixWorldAutoUpdate in r144.' );
    		return this.matrixWorldAutoUpdate;

    	}

    	set autoUpdate( value ) {

    		console.warn( 'THREE.Scene: autoUpdate was renamed to matrixWorldAutoUpdate in r144.' );
    		this.matrixWorldAutoUpdate = value;

    	}

    }

    class InterleavedBuffer {

    	constructor( array, stride ) {

    		this.isInterleavedBuffer = true;

    		this.array = array;
    		this.stride = stride;
    		this.count = array !== undefined ? array.length / stride : 0;

    		this.usage = StaticDrawUsage;
    		this.updateRange = { offset: 0, count: - 1 };

    		this.version = 0;

    		this.uuid = generateUUID();

    	}

    	onUploadCallback() {}

    	set needsUpdate( value ) {

    		if ( value === true ) this.version ++;

    	}

    	setUsage( value ) {

    		this.usage = value;

    		return this;

    	}

    	copy( source ) {

    		this.array = new source.array.constructor( source.array );
    		this.count = source.count;
    		this.stride = source.stride;
    		this.usage = source.usage;

    		return this;

    	}

    	copyAt( index1, attribute, index2 ) {

    		index1 *= this.stride;
    		index2 *= attribute.stride;

    		for ( let i = 0, l = this.stride; i < l; i ++ ) {

    			this.array[ index1 + i ] = attribute.array[ index2 + i ];

    		}

    		return this;

    	}

    	set( value, offset = 0 ) {

    		this.array.set( value, offset );

    		return this;

    	}

    	clone( data ) {

    		if ( data.arrayBuffers === undefined ) {

    			data.arrayBuffers = {};

    		}

    		if ( this.array.buffer._uuid === undefined ) {

    			this.array.buffer._uuid = generateUUID();

    		}

    		if ( data.arrayBuffers[ this.array.buffer._uuid ] === undefined ) {

    			data.arrayBuffers[ this.array.buffer._uuid ] = this.array.slice( 0 ).buffer;

    		}

    		const array = new this.array.constructor( data.arrayBuffers[ this.array.buffer._uuid ] );

    		const ib = new this.constructor( array, this.stride );
    		ib.setUsage( this.usage );

    		return ib;

    	}

    	onUpload( callback ) {

    		this.onUploadCallback = callback;

    		return this;

    	}

    	toJSON( data ) {

    		if ( data.arrayBuffers === undefined ) {

    			data.arrayBuffers = {};

    		}

    		// generate UUID for array buffer if necessary

    		if ( this.array.buffer._uuid === undefined ) {

    			this.array.buffer._uuid = generateUUID();

    		}

    		if ( data.arrayBuffers[ this.array.buffer._uuid ] === undefined ) {

    			data.arrayBuffers[ this.array.buffer._uuid ] = Array.from( new Uint32Array( this.array.buffer ) );

    		}

    		//

    		return {
    			uuid: this.uuid,
    			buffer: this.array.buffer._uuid,
    			type: this.array.constructor.name,
    			stride: this.stride
    		};

    	}

    }

    const _vector$6 = /*@__PURE__*/ new Vector3();

    class InterleavedBufferAttribute {

    	constructor( interleavedBuffer, itemSize, offset, normalized = false ) {

    		this.isInterleavedBufferAttribute = true;

    		this.name = '';

    		this.data = interleavedBuffer;
    		this.itemSize = itemSize;
    		this.offset = offset;

    		this.normalized = normalized === true;

    	}

    	get count() {

    		return this.data.count;

    	}

    	get array() {

    		return this.data.array;

    	}

    	set needsUpdate( value ) {

    		this.data.needsUpdate = value;

    	}

    	applyMatrix4( m ) {

    		for ( let i = 0, l = this.data.count; i < l; i ++ ) {

    			_vector$6.fromBufferAttribute( this, i );

    			_vector$6.applyMatrix4( m );

    			this.setXYZ( i, _vector$6.x, _vector$6.y, _vector$6.z );

    		}

    		return this;

    	}

    	applyNormalMatrix( m ) {

    		for ( let i = 0, l = this.count; i < l; i ++ ) {

    			_vector$6.fromBufferAttribute( this, i );

    			_vector$6.applyNormalMatrix( m );

    			this.setXYZ( i, _vector$6.x, _vector$6.y, _vector$6.z );

    		}

    		return this;

    	}

    	transformDirection( m ) {

    		for ( let i = 0, l = this.count; i < l; i ++ ) {

    			_vector$6.fromBufferAttribute( this, i );

    			_vector$6.transformDirection( m );

    			this.setXYZ( i, _vector$6.x, _vector$6.y, _vector$6.z );

    		}

    		return this;

    	}

    	setX( index, x ) {

    		if ( this.normalized ) x = normalize$1( x, this.array );

    		this.data.array[ index * this.data.stride + this.offset ] = x;

    		return this;

    	}

    	setY( index, y ) {

    		if ( this.normalized ) y = normalize$1( y, this.array );

    		this.data.array[ index * this.data.stride + this.offset + 1 ] = y;

    		return this;

    	}

    	setZ( index, z ) {

    		if ( this.normalized ) z = normalize$1( z, this.array );

    		this.data.array[ index * this.data.stride + this.offset + 2 ] = z;

    		return this;

    	}

    	setW( index, w ) {

    		if ( this.normalized ) w = normalize$1( w, this.array );

    		this.data.array[ index * this.data.stride + this.offset + 3 ] = w;

    		return this;

    	}

    	getX( index ) {

    		let x = this.data.array[ index * this.data.stride + this.offset ];

    		if ( this.normalized ) x = denormalize( x, this.array );

    		return x;

    	}

    	getY( index ) {

    		let y = this.data.array[ index * this.data.stride + this.offset + 1 ];

    		if ( this.normalized ) y = denormalize( y, this.array );

    		return y;

    	}

    	getZ( index ) {

    		let z = this.data.array[ index * this.data.stride + this.offset + 2 ];

    		if ( this.normalized ) z = denormalize( z, this.array );

    		return z;

    	}

    	getW( index ) {

    		let w = this.data.array[ index * this.data.stride + this.offset + 3 ];

    		if ( this.normalized ) w = denormalize( w, this.array );

    		return w;

    	}

    	setXY( index, x, y ) {

    		index = index * this.data.stride + this.offset;

    		if ( this.normalized ) {

    			x = normalize$1( x, this.array );
    			y = normalize$1( y, this.array );

    		}

    		this.data.array[ index + 0 ] = x;
    		this.data.array[ index + 1 ] = y;

    		return this;

    	}

    	setXYZ( index, x, y, z ) {

    		index = index * this.data.stride + this.offset;

    		if ( this.normalized ) {

    			x = normalize$1( x, this.array );
    			y = normalize$1( y, this.array );
    			z = normalize$1( z, this.array );

    		}

    		this.data.array[ index + 0 ] = x;
    		this.data.array[ index + 1 ] = y;
    		this.data.array[ index + 2 ] = z;

    		return this;

    	}

    	setXYZW( index, x, y, z, w ) {

    		index = index * this.data.stride + this.offset;

    		if ( this.normalized ) {

    			x = normalize$1( x, this.array );
    			y = normalize$1( y, this.array );
    			z = normalize$1( z, this.array );
    			w = normalize$1( w, this.array );

    		}

    		this.data.array[ index + 0 ] = x;
    		this.data.array[ index + 1 ] = y;
    		this.data.array[ index + 2 ] = z;
    		this.data.array[ index + 3 ] = w;

    		return this;

    	}

    	clone( data ) {

    		if ( data === undefined ) {

    			console.log( 'THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.' );

    			const array = [];

    			for ( let i = 0; i < this.count; i ++ ) {

    				const index = i * this.data.stride + this.offset;

    				for ( let j = 0; j < this.itemSize; j ++ ) {

    					array.push( this.data.array[ index + j ] );

    				}

    			}

    			return new BufferAttribute( new this.array.constructor( array ), this.itemSize, this.normalized );

    		} else {

    			if ( data.interleavedBuffers === undefined ) {

    				data.interleavedBuffers = {};

    			}

    			if ( data.interleavedBuffers[ this.data.uuid ] === undefined ) {

    				data.interleavedBuffers[ this.data.uuid ] = this.data.clone( data );

    			}

    			return new InterleavedBufferAttribute( data.interleavedBuffers[ this.data.uuid ], this.itemSize, this.offset, this.normalized );

    		}

    	}

    	toJSON( data ) {

    		if ( data === undefined ) {

    			console.log( 'THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.' );

    			const array = [];

    			for ( let i = 0; i < this.count; i ++ ) {

    				const index = i * this.data.stride + this.offset;

    				for ( let j = 0; j < this.itemSize; j ++ ) {

    					array.push( this.data.array[ index + j ] );

    				}

    			}

    			// de-interleave data and save it as an ordinary buffer attribute for now

    			return {
    				itemSize: this.itemSize,
    				type: this.array.constructor.name,
    				array: array,
    				normalized: this.normalized
    			};

    		} else {

    			// save as true interleaved attribute

    			if ( data.interleavedBuffers === undefined ) {

    				data.interleavedBuffers = {};

    			}

    			if ( data.interleavedBuffers[ this.data.uuid ] === undefined ) {

    				data.interleavedBuffers[ this.data.uuid ] = this.data.toJSON( data );

    			}

    			return {
    				isInterleavedBufferAttribute: true,
    				itemSize: this.itemSize,
    				data: this.data.uuid,
    				offset: this.offset,
    				normalized: this.normalized
    			};

    		}

    	}

    }

    class InstancedBufferAttribute extends BufferAttribute {

    	constructor( array, itemSize, normalized, meshPerAttribute = 1 ) {

    		super( array, itemSize, normalized );

    		this.isInstancedBufferAttribute = true;

    		this.meshPerAttribute = meshPerAttribute;

    	}

    	copy( source ) {

    		super.copy( source );

    		this.meshPerAttribute = source.meshPerAttribute;

    		return this;

    	}

    	toJSON() {

    		const data = super.toJSON();

    		data.meshPerAttribute = this.meshPerAttribute;

    		data.isInstancedBufferAttribute = true;

    		return data;

    	}

    }

    class LineBasicMaterial extends Material {

    	constructor( parameters ) {

    		super();

    		this.isLineBasicMaterial = true;

    		this.type = 'LineBasicMaterial';

    		this.color = new Color$1( 0xffffff );

    		this.linewidth = 1;
    		this.linecap = 'round';
    		this.linejoin = 'round';

    		this.fog = true;

    		this.setValues( parameters );

    	}


    	copy( source ) {

    		super.copy( source );

    		this.color.copy( source.color );

    		this.linewidth = source.linewidth;
    		this.linecap = source.linecap;
    		this.linejoin = source.linejoin;

    		this.fog = source.fog;

    		return this;

    	}

    }

    const _start$1 = /*@__PURE__*/ new Vector3();
    const _end$1 = /*@__PURE__*/ new Vector3();
    const _inverseMatrix$1 = /*@__PURE__*/ new Matrix4();
    const _ray$1 = /*@__PURE__*/ new Ray();
    const _sphere$1 = /*@__PURE__*/ new Sphere();

    class Line extends Object3D {

    	constructor( geometry = new BufferGeometry(), material = new LineBasicMaterial() ) {

    		super();

    		this.isLine = true;

    		this.type = 'Line';

    		this.geometry = geometry;
    		this.material = material;

    		this.updateMorphTargets();

    	}

    	copy( source, recursive ) {

    		super.copy( source, recursive );

    		this.material = source.material;
    		this.geometry = source.geometry;

    		return this;

    	}

    	computeLineDistances() {

    		const geometry = this.geometry;

    		// we assume non-indexed geometry

    		if ( geometry.index === null ) {

    			const positionAttribute = geometry.attributes.position;
    			const lineDistances = [ 0 ];

    			for ( let i = 1, l = positionAttribute.count; i < l; i ++ ) {

    				_start$1.fromBufferAttribute( positionAttribute, i - 1 );
    				_end$1.fromBufferAttribute( positionAttribute, i );

    				lineDistances[ i ] = lineDistances[ i - 1 ];
    				lineDistances[ i ] += _start$1.distanceTo( _end$1 );

    			}

    			geometry.setAttribute( 'lineDistance', new Float32BufferAttribute( lineDistances, 1 ) );

    		} else {

    			console.warn( 'THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.' );

    		}

    		return this;

    	}

    	raycast( raycaster, intersects ) {

    		const geometry = this.geometry;
    		const matrixWorld = this.matrixWorld;
    		const threshold = raycaster.params.Line.threshold;
    		const drawRange = geometry.drawRange;

    		// Checking boundingSphere distance to ray

    		if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

    		_sphere$1.copy( geometry.boundingSphere );
    		_sphere$1.applyMatrix4( matrixWorld );
    		_sphere$1.radius += threshold;

    		if ( raycaster.ray.intersectsSphere( _sphere$1 ) === false ) return;

    		//

    		_inverseMatrix$1.copy( matrixWorld ).invert();
    		_ray$1.copy( raycaster.ray ).applyMatrix4( _inverseMatrix$1 );

    		const localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );
    		const localThresholdSq = localThreshold * localThreshold;

    		const vStart = new Vector3();
    		const vEnd = new Vector3();
    		const interSegment = new Vector3();
    		const interRay = new Vector3();
    		const step = this.isLineSegments ? 2 : 1;

    		const index = geometry.index;
    		const attributes = geometry.attributes;
    		const positionAttribute = attributes.position;

    		if ( index !== null ) {

    			const start = Math.max( 0, drawRange.start );
    			const end = Math.min( index.count, ( drawRange.start + drawRange.count ) );

    			for ( let i = start, l = end - 1; i < l; i += step ) {

    				const a = index.getX( i );
    				const b = index.getX( i + 1 );

    				vStart.fromBufferAttribute( positionAttribute, a );
    				vEnd.fromBufferAttribute( positionAttribute, b );

    				const distSq = _ray$1.distanceSqToSegment( vStart, vEnd, interRay, interSegment );

    				if ( distSq > localThresholdSq ) continue;

    				interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

    				const distance = raycaster.ray.origin.distanceTo( interRay );

    				if ( distance < raycaster.near || distance > raycaster.far ) continue;

    				intersects.push( {

    					distance: distance,
    					// What do we want? intersection point on the ray or on the segment??
    					// point: raycaster.ray.at( distance ),
    					point: interSegment.clone().applyMatrix4( this.matrixWorld ),
    					index: i,
    					face: null,
    					faceIndex: null,
    					object: this

    				} );

    			}

    		} else {

    			const start = Math.max( 0, drawRange.start );
    			const end = Math.min( positionAttribute.count, ( drawRange.start + drawRange.count ) );

    			for ( let i = start, l = end - 1; i < l; i += step ) {

    				vStart.fromBufferAttribute( positionAttribute, i );
    				vEnd.fromBufferAttribute( positionAttribute, i + 1 );

    				const distSq = _ray$1.distanceSqToSegment( vStart, vEnd, interRay, interSegment );

    				if ( distSq > localThresholdSq ) continue;

    				interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

    				const distance = raycaster.ray.origin.distanceTo( interRay );

    				if ( distance < raycaster.near || distance > raycaster.far ) continue;

    				intersects.push( {

    					distance: distance,
    					// What do we want? intersection point on the ray or on the segment??
    					// point: raycaster.ray.at( distance ),
    					point: interSegment.clone().applyMatrix4( this.matrixWorld ),
    					index: i,
    					face: null,
    					faceIndex: null,
    					object: this

    				} );

    			}

    		}

    	}

    	updateMorphTargets() {

    		const geometry = this.geometry;

    		const morphAttributes = geometry.morphAttributes;
    		const keys = Object.keys( morphAttributes );

    		if ( keys.length > 0 ) {

    			const morphAttribute = morphAttributes[ keys[ 0 ] ];

    			if ( morphAttribute !== undefined ) {

    				this.morphTargetInfluences = [];
    				this.morphTargetDictionary = {};

    				for ( let m = 0, ml = morphAttribute.length; m < ml; m ++ ) {

    					const name = morphAttribute[ m ].name || String( m );

    					this.morphTargetInfluences.push( 0 );
    					this.morphTargetDictionary[ name ] = m;

    				}

    			}

    		}

    	}

    }

    const _start$2 = /*@__PURE__*/ new Vector3();
    const _end$2 = /*@__PURE__*/ new Vector3();

    class LineSegments extends Line {

    	constructor( geometry, material ) {

    		super( geometry, material );

    		this.isLineSegments = true;

    		this.type = 'LineSegments';

    	}

    	computeLineDistances() {

    		const geometry = this.geometry;

    		// we assume non-indexed geometry

    		if ( geometry.index === null ) {

    			const positionAttribute = geometry.attributes.position;
    			const lineDistances = [];

    			for ( let i = 0, l = positionAttribute.count; i < l; i += 2 ) {

    				_start$2.fromBufferAttribute( positionAttribute, i );
    				_end$2.fromBufferAttribute( positionAttribute, i + 1 );

    				lineDistances[ i ] = ( i === 0 ) ? 0 : lineDistances[ i - 1 ];
    				lineDistances[ i + 1 ] = lineDistances[ i ] + _start$2.distanceTo( _end$2 );

    			}

    			geometry.setAttribute( 'lineDistance', new Float32BufferAttribute( lineDistances, 1 ) );

    		} else {

    			console.warn( 'THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.' );

    		}

    		return this;

    	}

    }

    /**
     * Extensible curve object.
     *
     * Some common of curve methods:
     * .getPoint( t, optionalTarget ), .getTangent( t, optionalTarget )
     * .getPointAt( u, optionalTarget ), .getTangentAt( u, optionalTarget )
     * .getPoints(), .getSpacedPoints()
     * .getLength()
     * .updateArcLengths()
     *
     * This following curves inherit from THREE.Curve:
     *
     * -- 2D curves --
     * THREE.ArcCurve
     * THREE.CubicBezierCurve
     * THREE.EllipseCurve
     * THREE.LineCurve
     * THREE.QuadraticBezierCurve
     * THREE.SplineCurve
     *
     * -- 3D curves --
     * THREE.CatmullRomCurve3
     * THREE.CubicBezierCurve3
     * THREE.LineCurve3
     * THREE.QuadraticBezierCurve3
     *
     * A series of curves can be represented as a THREE.CurvePath.
     *
     **/

    class Curve {

    	constructor() {

    		this.type = 'Curve';

    		this.arcLengthDivisions = 200;

    	}

    	// Virtual base class method to overwrite and implement in subclasses
    	//	- t [0 .. 1]

    	getPoint( /* t, optionalTarget */ ) {

    		console.warn( 'THREE.Curve: .getPoint() not implemented.' );
    		return null;

    	}

    	// Get point at relative position in curve according to arc length
    	// - u [0 .. 1]

    	getPointAt( u, optionalTarget ) {

    		const t = this.getUtoTmapping( u );
    		return this.getPoint( t, optionalTarget );

    	}

    	// Get sequence of points using getPoint( t )

    	getPoints( divisions = 5 ) {

    		const points = [];

    		for ( let d = 0; d <= divisions; d ++ ) {

    			points.push( this.getPoint( d / divisions ) );

    		}

    		return points;

    	}

    	// Get sequence of points using getPointAt( u )

    	getSpacedPoints( divisions = 5 ) {

    		const points = [];

    		for ( let d = 0; d <= divisions; d ++ ) {

    			points.push( this.getPointAt( d / divisions ) );

    		}

    		return points;

    	}

    	// Get total curve arc length

    	getLength() {

    		const lengths = this.getLengths();
    		return lengths[ lengths.length - 1 ];

    	}

    	// Get list of cumulative segment lengths

    	getLengths( divisions = this.arcLengthDivisions ) {

    		if ( this.cacheArcLengths &&
    			( this.cacheArcLengths.length === divisions + 1 ) &&
    			! this.needsUpdate ) {

    			return this.cacheArcLengths;

    		}

    		this.needsUpdate = false;

    		const cache = [];
    		let current, last = this.getPoint( 0 );
    		let sum = 0;

    		cache.push( 0 );

    		for ( let p = 1; p <= divisions; p ++ ) {

    			current = this.getPoint( p / divisions );
    			sum += current.distanceTo( last );
    			cache.push( sum );
    			last = current;

    		}

    		this.cacheArcLengths = cache;

    		return cache; // { sums: cache, sum: sum }; Sum is in the last element.

    	}

    	updateArcLengths() {

    		this.needsUpdate = true;
    		this.getLengths();

    	}

    	// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant

    	getUtoTmapping( u, distance ) {

    		const arcLengths = this.getLengths();

    		let i = 0;
    		const il = arcLengths.length;

    		let targetArcLength; // The targeted u distance value to get

    		if ( distance ) {

    			targetArcLength = distance;

    		} else {

    			targetArcLength = u * arcLengths[ il - 1 ];

    		}

    		// binary search for the index with largest value smaller than target u distance

    		let low = 0, high = il - 1, comparison;

    		while ( low <= high ) {

    			i = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats

    			comparison = arcLengths[ i ] - targetArcLength;

    			if ( comparison < 0 ) {

    				low = i + 1;

    			} else if ( comparison > 0 ) {

    				high = i - 1;

    			} else {

    				high = i;
    				break;

    				// DONE

    			}

    		}

    		i = high;

    		if ( arcLengths[ i ] === targetArcLength ) {

    			return i / ( il - 1 );

    		}

    		// we could get finer grain at lengths, or use simple interpolation between two points

    		const lengthBefore = arcLengths[ i ];
    		const lengthAfter = arcLengths[ i + 1 ];

    		const segmentLength = lengthAfter - lengthBefore;

    		// determine where we are between the 'before' and 'after' points

    		const segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;

    		// add that fractional amount to t

    		const t = ( i + segmentFraction ) / ( il - 1 );

    		return t;

    	}

    	// Returns a unit vector tangent at t
    	// In case any sub curve does not implement its tangent derivation,
    	// 2 points a small delta apart will be used to find its gradient
    	// which seems to give a reasonable approximation

    	getTangent( t, optionalTarget ) {

    		const delta = 0.0001;
    		let t1 = t - delta;
    		let t2 = t + delta;

    		// Capping in case of danger

    		if ( t1 < 0 ) t1 = 0;
    		if ( t2 > 1 ) t2 = 1;

    		const pt1 = this.getPoint( t1 );
    		const pt2 = this.getPoint( t2 );

    		const tangent = optionalTarget || ( ( pt1.isVector2 ) ? new Vector2() : new Vector3() );

    		tangent.copy( pt2 ).sub( pt1 ).normalize();

    		return tangent;

    	}

    	getTangentAt( u, optionalTarget ) {

    		const t = this.getUtoTmapping( u );
    		return this.getTangent( t, optionalTarget );

    	}

    	computeFrenetFrames( segments, closed ) {

    		// see http://www.cs.indiana.edu/pub/techreports/TR425.pdf

    		const normal = new Vector3();

    		const tangents = [];
    		const normals = [];
    		const binormals = [];

    		const vec = new Vector3();
    		const mat = new Matrix4();

    		// compute the tangent vectors for each segment on the curve

    		for ( let i = 0; i <= segments; i ++ ) {

    			const u = i / segments;

    			tangents[ i ] = this.getTangentAt( u, new Vector3() );

    		}

    		// select an initial normal vector perpendicular to the first tangent vector,
    		// and in the direction of the minimum tangent xyz component

    		normals[ 0 ] = new Vector3();
    		binormals[ 0 ] = new Vector3();
    		let min = Number.MAX_VALUE;
    		const tx = Math.abs( tangents[ 0 ].x );
    		const ty = Math.abs( tangents[ 0 ].y );
    		const tz = Math.abs( tangents[ 0 ].z );

    		if ( tx <= min ) {

    			min = tx;
    			normal.set( 1, 0, 0 );

    		}

    		if ( ty <= min ) {

    			min = ty;
    			normal.set( 0, 1, 0 );

    		}

    		if ( tz <= min ) {

    			normal.set( 0, 0, 1 );

    		}

    		vec.crossVectors( tangents[ 0 ], normal ).normalize();

    		normals[ 0 ].crossVectors( tangents[ 0 ], vec );
    		binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );


    		// compute the slowly-varying normal and binormal vectors for each segment on the curve

    		for ( let i = 1; i <= segments; i ++ ) {

    			normals[ i ] = normals[ i - 1 ].clone();

    			binormals[ i ] = binormals[ i - 1 ].clone();

    			vec.crossVectors( tangents[ i - 1 ], tangents[ i ] );

    			if ( vec.length() > Number.EPSILON ) {

    				vec.normalize();

    				const theta = Math.acos( clamp$1( tangents[ i - 1 ].dot( tangents[ i ] ), - 1, 1 ) ); // clamp for floating pt errors

    				normals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );

    			}

    			binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

    		}

    		// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same

    		if ( closed === true ) {

    			let theta = Math.acos( clamp$1( normals[ 0 ].dot( normals[ segments ] ), - 1, 1 ) );
    			theta /= segments;

    			if ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ segments ] ) ) > 0 ) {

    				theta = - theta;

    			}

    			for ( let i = 1; i <= segments; i ++ ) {

    				// twist a little...
    				normals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );
    				binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

    			}

    		}

    		return {
    			tangents: tangents,
    			normals: normals,
    			binormals: binormals
    		};

    	}

    	clone() {

    		return new this.constructor().copy( this );

    	}

    	copy( source ) {

    		this.arcLengthDivisions = source.arcLengthDivisions;

    		return this;

    	}

    	toJSON() {

    		const data = {
    			metadata: {
    				version: 4.5,
    				type: 'Curve',
    				generator: 'Curve.toJSON'
    			}
    		};

    		data.arcLengthDivisions = this.arcLengthDivisions;
    		data.type = this.type;

    		return data;

    	}

    	fromJSON( json ) {

    		this.arcLengthDivisions = json.arcLengthDivisions;

    		return this;

    	}

    }

    class EllipseCurve extends Curve {

    	constructor( aX = 0, aY = 0, xRadius = 1, yRadius = 1, aStartAngle = 0, aEndAngle = Math.PI * 2, aClockwise = false, aRotation = 0 ) {

    		super();

    		this.isEllipseCurve = true;

    		this.type = 'EllipseCurve';

    		this.aX = aX;
    		this.aY = aY;

    		this.xRadius = xRadius;
    		this.yRadius = yRadius;

    		this.aStartAngle = aStartAngle;
    		this.aEndAngle = aEndAngle;

    		this.aClockwise = aClockwise;

    		this.aRotation = aRotation;

    	}

    	getPoint( t, optionalTarget ) {

    		const point = optionalTarget || new Vector2();

    		const twoPi = Math.PI * 2;
    		let deltaAngle = this.aEndAngle - this.aStartAngle;
    		const samePoints = Math.abs( deltaAngle ) < Number.EPSILON;

    		// ensures that deltaAngle is 0 .. 2 PI
    		while ( deltaAngle < 0 ) deltaAngle += twoPi;
    		while ( deltaAngle > twoPi ) deltaAngle -= twoPi;

    		if ( deltaAngle < Number.EPSILON ) {

    			if ( samePoints ) {

    				deltaAngle = 0;

    			} else {

    				deltaAngle = twoPi;

    			}

    		}

    		if ( this.aClockwise === true && ! samePoints ) {

    			if ( deltaAngle === twoPi ) {

    				deltaAngle = - twoPi;

    			} else {

    				deltaAngle = deltaAngle - twoPi;

    			}

    		}

    		const angle = this.aStartAngle + t * deltaAngle;
    		let x = this.aX + this.xRadius * Math.cos( angle );
    		let y = this.aY + this.yRadius * Math.sin( angle );

    		if ( this.aRotation !== 0 ) {

    			const cos = Math.cos( this.aRotation );
    			const sin = Math.sin( this.aRotation );

    			const tx = x - this.aX;
    			const ty = y - this.aY;

    			// Rotate the point about the center of the ellipse.
    			x = tx * cos - ty * sin + this.aX;
    			y = tx * sin + ty * cos + this.aY;

    		}

    		return point.set( x, y );

    	}

    	copy( source ) {

    		super.copy( source );

    		this.aX = source.aX;
    		this.aY = source.aY;

    		this.xRadius = source.xRadius;
    		this.yRadius = source.yRadius;

    		this.aStartAngle = source.aStartAngle;
    		this.aEndAngle = source.aEndAngle;

    		this.aClockwise = source.aClockwise;

    		this.aRotation = source.aRotation;

    		return this;

    	}

    	toJSON() {

    		const data = super.toJSON();

    		data.aX = this.aX;
    		data.aY = this.aY;

    		data.xRadius = this.xRadius;
    		data.yRadius = this.yRadius;

    		data.aStartAngle = this.aStartAngle;
    		data.aEndAngle = this.aEndAngle;

    		data.aClockwise = this.aClockwise;

    		data.aRotation = this.aRotation;

    		return data;

    	}

    	fromJSON( json ) {

    		super.fromJSON( json );

    		this.aX = json.aX;
    		this.aY = json.aY;

    		this.xRadius = json.xRadius;
    		this.yRadius = json.yRadius;

    		this.aStartAngle = json.aStartAngle;
    		this.aEndAngle = json.aEndAngle;

    		this.aClockwise = json.aClockwise;

    		this.aRotation = json.aRotation;

    		return this;

    	}

    }

    class ArcCurve extends EllipseCurve {

    	constructor( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

    		super( aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );

    		this.isArcCurve = true;

    		this.type = 'ArcCurve';

    	}

    }

    /**
     * Centripetal CatmullRom Curve - which is useful for avoiding
     * cusps and self-intersections in non-uniform catmull rom curves.
     * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf
     *
     * curve.type accepts centripetal(default), chordal and catmullrom
     * curve.tension is used for catmullrom which defaults to 0.5
     */


    /*
    Based on an optimized c++ solution in
     - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/
     - http://ideone.com/NoEbVM

    This CubicPoly class could be used for reusing some variables and calculations,
    but for three.js curve use, it could be possible inlined and flatten into a single function call
    which can be placed in CurveUtils.
    */

    function CubicPoly() {

    	let c0 = 0, c1 = 0, c2 = 0, c3 = 0;

    	/*
    	 * Compute coefficients for a cubic polynomial
    	 *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3
    	 * such that
    	 *   p(0) = x0, p(1) = x1
    	 *  and
    	 *   p'(0) = t0, p'(1) = t1.
    	 */
    	function init( x0, x1, t0, t1 ) {

    		c0 = x0;
    		c1 = t0;
    		c2 = - 3 * x0 + 3 * x1 - 2 * t0 - t1;
    		c3 = 2 * x0 - 2 * x1 + t0 + t1;

    	}

    	return {

    		initCatmullRom: function ( x0, x1, x2, x3, tension ) {

    			init( x1, x2, tension * ( x2 - x0 ), tension * ( x3 - x1 ) );

    		},

    		initNonuniformCatmullRom: function ( x0, x1, x2, x3, dt0, dt1, dt2 ) {

    			// compute tangents when parameterized in [t1,t2]
    			let t1 = ( x1 - x0 ) / dt0 - ( x2 - x0 ) / ( dt0 + dt1 ) + ( x2 - x1 ) / dt1;
    			let t2 = ( x2 - x1 ) / dt1 - ( x3 - x1 ) / ( dt1 + dt2 ) + ( x3 - x2 ) / dt2;

    			// rescale tangents for parametrization in [0,1]
    			t1 *= dt1;
    			t2 *= dt1;

    			init( x1, x2, t1, t2 );

    		},

    		calc: function ( t ) {

    			const t2 = t * t;
    			const t3 = t2 * t;
    			return c0 + c1 * t + c2 * t2 + c3 * t3;

    		}

    	};

    }

    //

    const tmp = /*@__PURE__*/ new Vector3();
    const px = /*@__PURE__*/ new CubicPoly();
    const py = /*@__PURE__*/ new CubicPoly();
    const pz = /*@__PURE__*/ new CubicPoly();

    class CatmullRomCurve3 extends Curve {

    	constructor( points = [], closed = false, curveType = 'centripetal', tension = 0.5 ) {

    		super();

    		this.isCatmullRomCurve3 = true;

    		this.type = 'CatmullRomCurve3';

    		this.points = points;
    		this.closed = closed;
    		this.curveType = curveType;
    		this.tension = tension;

    	}

    	getPoint( t, optionalTarget = new Vector3() ) {

    		const point = optionalTarget;

    		const points = this.points;
    		const l = points.length;

    		const p = ( l - ( this.closed ? 0 : 1 ) ) * t;
    		let intPoint = Math.floor( p );
    		let weight = p - intPoint;

    		if ( this.closed ) {

    			intPoint += intPoint > 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / l ) + 1 ) * l;

    		} else if ( weight === 0 && intPoint === l - 1 ) {

    			intPoint = l - 2;
    			weight = 1;

    		}

    		let p0, p3; // 4 points (p1 & p2 defined below)

    		if ( this.closed || intPoint > 0 ) {

    			p0 = points[ ( intPoint - 1 ) % l ];

    		} else {

    			// extrapolate first point
    			tmp.subVectors( points[ 0 ], points[ 1 ] ).add( points[ 0 ] );
    			p0 = tmp;

    		}

    		const p1 = points[ intPoint % l ];
    		const p2 = points[ ( intPoint + 1 ) % l ];

    		if ( this.closed || intPoint + 2 < l ) {

    			p3 = points[ ( intPoint + 2 ) % l ];

    		} else {

    			// extrapolate last point
    			tmp.subVectors( points[ l - 1 ], points[ l - 2 ] ).add( points[ l - 1 ] );
    			p3 = tmp;

    		}

    		if ( this.curveType === 'centripetal' || this.curveType === 'chordal' ) {

    			// init Centripetal / Chordal Catmull-Rom
    			const pow = this.curveType === 'chordal' ? 0.5 : 0.25;
    			let dt0 = Math.pow( p0.distanceToSquared( p1 ), pow );
    			let dt1 = Math.pow( p1.distanceToSquared( p2 ), pow );
    			let dt2 = Math.pow( p2.distanceToSquared( p3 ), pow );

    			// safety check for repeated points
    			if ( dt1 < 1e-4 ) dt1 = 1.0;
    			if ( dt0 < 1e-4 ) dt0 = dt1;
    			if ( dt2 < 1e-4 ) dt2 = dt1;

    			px.initNonuniformCatmullRom( p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2 );
    			py.initNonuniformCatmullRom( p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2 );
    			pz.initNonuniformCatmullRom( p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2 );

    		} else if ( this.curveType === 'catmullrom' ) {

    			px.initCatmullRom( p0.x, p1.x, p2.x, p3.x, this.tension );
    			py.initCatmullRom( p0.y, p1.y, p2.y, p3.y, this.tension );
    			pz.initCatmullRom( p0.z, p1.z, p2.z, p3.z, this.tension );

    		}

    		point.set(
    			px.calc( weight ),
    			py.calc( weight ),
    			pz.calc( weight )
    		);

    		return point;

    	}

    	copy( source ) {

    		super.copy( source );

    		this.points = [];

    		for ( let i = 0, l = source.points.length; i < l; i ++ ) {

    			const point = source.points[ i ];

    			this.points.push( point.clone() );

    		}

    		this.closed = source.closed;
    		this.curveType = source.curveType;
    		this.tension = source.tension;

    		return this;

    	}

    	toJSON() {

    		const data = super.toJSON();

    		data.points = [];

    		for ( let i = 0, l = this.points.length; i < l; i ++ ) {

    			const point = this.points[ i ];
    			data.points.push( point.toArray() );

    		}

    		data.closed = this.closed;
    		data.curveType = this.curveType;
    		data.tension = this.tension;

    		return data;

    	}

    	fromJSON( json ) {

    		super.fromJSON( json );

    		this.points = [];

    		for ( let i = 0, l = json.points.length; i < l; i ++ ) {

    			const point = json.points[ i ];
    			this.points.push( new Vector3().fromArray( point ) );

    		}

    		this.closed = json.closed;
    		this.curveType = json.curveType;
    		this.tension = json.tension;

    		return this;

    	}

    }

    /**
     * Bezier Curves formulas obtained from
     * https://en.wikipedia.org/wiki/B%C3%A9zier_curve
     */

    function CatmullRom( t, p0, p1, p2, p3 ) {

    	const v0 = ( p2 - p0 ) * 0.5;
    	const v1 = ( p3 - p1 ) * 0.5;
    	const t2 = t * t;
    	const t3 = t * t2;
    	return ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;

    }

    //

    function QuadraticBezierP0( t, p ) {

    	const k = 1 - t;
    	return k * k * p;

    }

    function QuadraticBezierP1( t, p ) {

    	return 2 * ( 1 - t ) * t * p;

    }

    function QuadraticBezierP2( t, p ) {

    	return t * t * p;

    }

    function QuadraticBezier( t, p0, p1, p2 ) {

    	return QuadraticBezierP0( t, p0 ) + QuadraticBezierP1( t, p1 ) +
    		QuadraticBezierP2( t, p2 );

    }

    //

    function CubicBezierP0( t, p ) {

    	const k = 1 - t;
    	return k * k * k * p;

    }

    function CubicBezierP1( t, p ) {

    	const k = 1 - t;
    	return 3 * k * k * t * p;

    }

    function CubicBezierP2( t, p ) {

    	return 3 * ( 1 - t ) * t * t * p;

    }

    function CubicBezierP3( t, p ) {

    	return t * t * t * p;

    }

    function CubicBezier( t, p0, p1, p2, p3 ) {

    	return CubicBezierP0( t, p0 ) + CubicBezierP1( t, p1 ) + CubicBezierP2( t, p2 ) +
    		CubicBezierP3( t, p3 );

    }

    class CubicBezierCurve extends Curve {

    	constructor( v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2(), v3 = new Vector2() ) {

    		super();

    		this.isCubicBezierCurve = true;

    		this.type = 'CubicBezierCurve';

    		this.v0 = v0;
    		this.v1 = v1;
    		this.v2 = v2;
    		this.v3 = v3;

    	}

    	getPoint( t, optionalTarget = new Vector2() ) {

    		const point = optionalTarget;

    		const v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;

    		point.set(
    			CubicBezier( t, v0.x, v1.x, v2.x, v3.x ),
    			CubicBezier( t, v0.y, v1.y, v2.y, v3.y )
    		);

    		return point;

    	}

    	copy( source ) {

    		super.copy( source );

    		this.v0.copy( source.v0 );
    		this.v1.copy( source.v1 );
    		this.v2.copy( source.v2 );
    		this.v3.copy( source.v3 );

    		return this;

    	}

    	toJSON() {

    		const data = super.toJSON();

    		data.v0 = this.v0.toArray();
    		data.v1 = this.v1.toArray();
    		data.v2 = this.v2.toArray();
    		data.v3 = this.v3.toArray();

    		return data;

    	}

    	fromJSON( json ) {

    		super.fromJSON( json );

    		this.v0.fromArray( json.v0 );
    		this.v1.fromArray( json.v1 );
    		this.v2.fromArray( json.v2 );
    		this.v3.fromArray( json.v3 );

    		return this;

    	}

    }

    class CubicBezierCurve3 extends Curve {

    	constructor( v0 = new Vector3(), v1 = new Vector3(), v2 = new Vector3(), v3 = new Vector3() ) {

    		super();

    		this.isCubicBezierCurve3 = true;

    		this.type = 'CubicBezierCurve3';

    		this.v0 = v0;
    		this.v1 = v1;
    		this.v2 = v2;
    		this.v3 = v3;

    	}

    	getPoint( t, optionalTarget = new Vector3() ) {

    		const point = optionalTarget;

    		const v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;

    		point.set(
    			CubicBezier( t, v0.x, v1.x, v2.x, v3.x ),
    			CubicBezier( t, v0.y, v1.y, v2.y, v3.y ),
    			CubicBezier( t, v0.z, v1.z, v2.z, v3.z )
    		);

    		return point;

    	}

    	copy( source ) {

    		super.copy( source );

    		this.v0.copy( source.v0 );
    		this.v1.copy( source.v1 );
    		this.v2.copy( source.v2 );
    		this.v3.copy( source.v3 );

    		return this;

    	}

    	toJSON() {

    		const data = super.toJSON();

    		data.v0 = this.v0.toArray();
    		data.v1 = this.v1.toArray();
    		data.v2 = this.v2.toArray();
    		data.v3 = this.v3.toArray();

    		return data;

    	}

    	fromJSON( json ) {

    		super.fromJSON( json );

    		this.v0.fromArray( json.v0 );
    		this.v1.fromArray( json.v1 );
    		this.v2.fromArray( json.v2 );
    		this.v3.fromArray( json.v3 );

    		return this;

    	}

    }

    class LineCurve extends Curve {

    	constructor( v1 = new Vector2(), v2 = new Vector2() ) {

    		super();

    		this.isLineCurve = true;

    		this.type = 'LineCurve';

    		this.v1 = v1;
    		this.v2 = v2;

    	}

    	getPoint( t, optionalTarget = new Vector2() ) {

    		const point = optionalTarget;

    		if ( t === 1 ) {

    			point.copy( this.v2 );

    		} else {

    			point.copy( this.v2 ).sub( this.v1 );
    			point.multiplyScalar( t ).add( this.v1 );

    		}

    		return point;

    	}

    	// Line curve is linear, so we can overwrite default getPointAt
    	getPointAt( u, optionalTarget ) {

    		return this.getPoint( u, optionalTarget );

    	}

    	getTangent( t, optionalTarget ) {

    		const tangent = optionalTarget || new Vector2();

    		tangent.copy( this.v2 ).sub( this.v1 ).normalize();

    		return tangent;

    	}

    	copy( source ) {

    		super.copy( source );

    		this.v1.copy( source.v1 );
    		this.v2.copy( source.v2 );

    		return this;

    	}

    	toJSON() {

    		const data = super.toJSON();

    		data.v1 = this.v1.toArray();
    		data.v2 = this.v2.toArray();

    		return data;

    	}

    	fromJSON( json ) {

    		super.fromJSON( json );

    		this.v1.fromArray( json.v1 );
    		this.v2.fromArray( json.v2 );

    		return this;

    	}

    }

    class LineCurve3 extends Curve {

    	constructor( v1 = new Vector3(), v2 = new Vector3() ) {

    		super();

    		this.isLineCurve3 = true;

    		this.type = 'LineCurve3';

    		this.v1 = v1;
    		this.v2 = v2;

    	}
    	getPoint( t, optionalTarget = new Vector3() ) {

    		const point = optionalTarget;

    		if ( t === 1 ) {

    			point.copy( this.v2 );

    		} else {

    			point.copy( this.v2 ).sub( this.v1 );
    			point.multiplyScalar( t ).add( this.v1 );

    		}

    		return point;

    	}
    	// Line curve is linear, so we can overwrite default getPointAt
    	getPointAt( u, optionalTarget ) {

    		return this.getPoint( u, optionalTarget );

    	}
    	copy( source ) {

    		super.copy( source );

    		this.v1.copy( source.v1 );
    		this.v2.copy( source.v2 );

    		return this;

    	}
    	toJSON() {

    		const data = super.toJSON();

    		data.v1 = this.v1.toArray();
    		data.v2 = this.v2.toArray();

    		return data;

    	}
    	fromJSON( json ) {

    		super.fromJSON( json );

    		this.v1.fromArray( json.v1 );
    		this.v2.fromArray( json.v2 );

    		return this;

    	}

    }

    class QuadraticBezierCurve extends Curve {

    	constructor( v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2() ) {

    		super();

    		this.isQuadraticBezierCurve = true;

    		this.type = 'QuadraticBezierCurve';

    		this.v0 = v0;
    		this.v1 = v1;
    		this.v2 = v2;

    	}

    	getPoint( t, optionalTarget = new Vector2() ) {

    		const point = optionalTarget;

    		const v0 = this.v0, v1 = this.v1, v2 = this.v2;

    		point.set(
    			QuadraticBezier( t, v0.x, v1.x, v2.x ),
    			QuadraticBezier( t, v0.y, v1.y, v2.y )
    		);

    		return point;

    	}

    	copy( source ) {

    		super.copy( source );

    		this.v0.copy( source.v0 );
    		this.v1.copy( source.v1 );
    		this.v2.copy( source.v2 );

    		return this;

    	}

    	toJSON() {

    		const data = super.toJSON();

    		data.v0 = this.v0.toArray();
    		data.v1 = this.v1.toArray();
    		data.v2 = this.v2.toArray();

    		return data;

    	}

    	fromJSON( json ) {

    		super.fromJSON( json );

    		this.v0.fromArray( json.v0 );
    		this.v1.fromArray( json.v1 );
    		this.v2.fromArray( json.v2 );

    		return this;

    	}

    }

    class QuadraticBezierCurve3 extends Curve {

    	constructor( v0 = new Vector3(), v1 = new Vector3(), v2 = new Vector3() ) {

    		super();

    		this.isQuadraticBezierCurve3 = true;

    		this.type = 'QuadraticBezierCurve3';

    		this.v0 = v0;
    		this.v1 = v1;
    		this.v2 = v2;

    	}

    	getPoint( t, optionalTarget = new Vector3() ) {

    		const point = optionalTarget;

    		const v0 = this.v0, v1 = this.v1, v2 = this.v2;

    		point.set(
    			QuadraticBezier( t, v0.x, v1.x, v2.x ),
    			QuadraticBezier( t, v0.y, v1.y, v2.y ),
    			QuadraticBezier( t, v0.z, v1.z, v2.z )
    		);

    		return point;

    	}

    	copy( source ) {

    		super.copy( source );

    		this.v0.copy( source.v0 );
    		this.v1.copy( source.v1 );
    		this.v2.copy( source.v2 );

    		return this;

    	}

    	toJSON() {

    		const data = super.toJSON();

    		data.v0 = this.v0.toArray();
    		data.v1 = this.v1.toArray();
    		data.v2 = this.v2.toArray();

    		return data;

    	}

    	fromJSON( json ) {

    		super.fromJSON( json );

    		this.v0.fromArray( json.v0 );
    		this.v1.fromArray( json.v1 );
    		this.v2.fromArray( json.v2 );

    		return this;

    	}

    }

    class SplineCurve extends Curve {

    	constructor( points = [] ) {

    		super();

    		this.isSplineCurve = true;

    		this.type = 'SplineCurve';

    		this.points = points;

    	}

    	getPoint( t, optionalTarget = new Vector2() ) {

    		const point = optionalTarget;

    		const points = this.points;
    		const p = ( points.length - 1 ) * t;

    		const intPoint = Math.floor( p );
    		const weight = p - intPoint;

    		const p0 = points[ intPoint === 0 ? intPoint : intPoint - 1 ];
    		const p1 = points[ intPoint ];
    		const p2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];
    		const p3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];

    		point.set(
    			CatmullRom( weight, p0.x, p1.x, p2.x, p3.x ),
    			CatmullRom( weight, p0.y, p1.y, p2.y, p3.y )
    		);

    		return point;

    	}

    	copy( source ) {

    		super.copy( source );

    		this.points = [];

    		for ( let i = 0, l = source.points.length; i < l; i ++ ) {

    			const point = source.points[ i ];

    			this.points.push( point.clone() );

    		}

    		return this;

    	}

    	toJSON() {

    		const data = super.toJSON();

    		data.points = [];

    		for ( let i = 0, l = this.points.length; i < l; i ++ ) {

    			const point = this.points[ i ];
    			data.points.push( point.toArray() );

    		}

    		return data;

    	}

    	fromJSON( json ) {

    		super.fromJSON( json );

    		this.points = [];

    		for ( let i = 0, l = json.points.length; i < l; i ++ ) {

    			const point = json.points[ i ];
    			this.points.push( new Vector2().fromArray( point ) );

    		}

    		return this;

    	}

    }

    var Curves = /*#__PURE__*/Object.freeze({
    	__proto__: null,
    	ArcCurve: ArcCurve,
    	CatmullRomCurve3: CatmullRomCurve3,
    	CubicBezierCurve: CubicBezierCurve,
    	CubicBezierCurve3: CubicBezierCurve3,
    	EllipseCurve: EllipseCurve,
    	LineCurve: LineCurve,
    	LineCurve3: LineCurve3,
    	QuadraticBezierCurve: QuadraticBezierCurve,
    	QuadraticBezierCurve3: QuadraticBezierCurve3,
    	SplineCurve: SplineCurve
    });

    /**************************************************************
     *	Curved Path - a curve path is simply a array of connected
     *  curves, but retains the api of a curve
     **************************************************************/

    class CurvePath extends Curve {

    	constructor() {

    		super();

    		this.type = 'CurvePath';

    		this.curves = [];
    		this.autoClose = false; // Automatically closes the path

    	}

    	add( curve ) {

    		this.curves.push( curve );

    	}

    	closePath() {

    		// Add a line curve if start and end of lines are not connected
    		const startPoint = this.curves[ 0 ].getPoint( 0 );
    		const endPoint = this.curves[ this.curves.length - 1 ].getPoint( 1 );

    		if ( ! startPoint.equals( endPoint ) ) {

    			this.curves.push( new LineCurve( endPoint, startPoint ) );

    		}

    	}

    	// To get accurate point with reference to
    	// entire path distance at time t,
    	// following has to be done:

    	// 1. Length of each sub path have to be known
    	// 2. Locate and identify type of curve
    	// 3. Get t for the curve
    	// 4. Return curve.getPointAt(t')

    	getPoint( t, optionalTarget ) {

    		const d = t * this.getLength();
    		const curveLengths = this.getCurveLengths();
    		let i = 0;

    		// To think about boundaries points.

    		while ( i < curveLengths.length ) {

    			if ( curveLengths[ i ] >= d ) {

    				const diff = curveLengths[ i ] - d;
    				const curve = this.curves[ i ];

    				const segmentLength = curve.getLength();
    				const u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;

    				return curve.getPointAt( u, optionalTarget );

    			}

    			i ++;

    		}

    		return null;

    		// loop where sum != 0, sum > d , sum+1 <d

    	}

    	// We cannot use the default THREE.Curve getPoint() with getLength() because in
    	// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
    	// getPoint() depends on getLength

    	getLength() {

    		const lens = this.getCurveLengths();
    		return lens[ lens.length - 1 ];

    	}

    	// cacheLengths must be recalculated.
    	updateArcLengths() {

    		this.needsUpdate = true;
    		this.cacheLengths = null;
    		this.getCurveLengths();

    	}

    	// Compute lengths and cache them
    	// We cannot overwrite getLengths() because UtoT mapping uses it.

    	getCurveLengths() {

    		// We use cache values if curves and cache array are same length

    		if ( this.cacheLengths && this.cacheLengths.length === this.curves.length ) {

    			return this.cacheLengths;

    		}

    		// Get length of sub-curve
    		// Push sums into cached array

    		const lengths = [];
    		let sums = 0;

    		for ( let i = 0, l = this.curves.length; i < l; i ++ ) {

    			sums += this.curves[ i ].getLength();
    			lengths.push( sums );

    		}

    		this.cacheLengths = lengths;

    		return lengths;

    	}

    	getSpacedPoints( divisions = 40 ) {

    		const points = [];

    		for ( let i = 0; i <= divisions; i ++ ) {

    			points.push( this.getPoint( i / divisions ) );

    		}

    		if ( this.autoClose ) {

    			points.push( points[ 0 ] );

    		}

    		return points;

    	}

    	getPoints( divisions = 12 ) {

    		const points = [];
    		let last;

    		for ( let i = 0, curves = this.curves; i < curves.length; i ++ ) {

    			const curve = curves[ i ];
    			const resolution = curve.isEllipseCurve ? divisions * 2
    				: ( curve.isLineCurve || curve.isLineCurve3 ) ? 1
    					: curve.isSplineCurve ? divisions * curve.points.length
    						: divisions;

    			const pts = curve.getPoints( resolution );

    			for ( let j = 0; j < pts.length; j ++ ) {

    				const point = pts[ j ];

    				if ( last && last.equals( point ) ) continue; // ensures no consecutive points are duplicates

    				points.push( point );
    				last = point;

    			}

    		}

    		if ( this.autoClose && points.length > 1 && ! points[ points.length - 1 ].equals( points[ 0 ] ) ) {

    			points.push( points[ 0 ] );

    		}

    		return points;

    	}

    	copy( source ) {

    		super.copy( source );

    		this.curves = [];

    		for ( let i = 0, l = source.curves.length; i < l; i ++ ) {

    			const curve = source.curves[ i ];

    			this.curves.push( curve.clone() );

    		}

    		this.autoClose = source.autoClose;

    		return this;

    	}

    	toJSON() {

    		const data = super.toJSON();

    		data.autoClose = this.autoClose;
    		data.curves = [];

    		for ( let i = 0, l = this.curves.length; i < l; i ++ ) {

    			const curve = this.curves[ i ];
    			data.curves.push( curve.toJSON() );

    		}

    		return data;

    	}

    	fromJSON( json ) {

    		super.fromJSON( json );

    		this.autoClose = json.autoClose;
    		this.curves = [];

    		for ( let i = 0, l = json.curves.length; i < l; i ++ ) {

    			const curve = json.curves[ i ];
    			this.curves.push( new Curves[ curve.type ]().fromJSON( curve ) );

    		}

    		return this;

    	}

    }

    class Path$1 extends CurvePath {

    	constructor( points ) {

    		super();

    		this.type = 'Path';

    		this.currentPoint = new Vector2();

    		if ( points ) {

    			this.setFromPoints( points );

    		}

    	}

    	setFromPoints( points ) {

    		this.moveTo( points[ 0 ].x, points[ 0 ].y );

    		for ( let i = 1, l = points.length; i < l; i ++ ) {

    			this.lineTo( points[ i ].x, points[ i ].y );

    		}

    		return this;

    	}

    	moveTo( x, y ) {

    		this.currentPoint.set( x, y ); // TODO consider referencing vectors instead of copying?

    		return this;

    	}

    	lineTo( x, y ) {

    		const curve = new LineCurve( this.currentPoint.clone(), new Vector2( x, y ) );
    		this.curves.push( curve );

    		this.currentPoint.set( x, y );

    		return this;

    	}

    	quadraticCurveTo( aCPx, aCPy, aX, aY ) {

    		const curve = new QuadraticBezierCurve(
    			this.currentPoint.clone(),
    			new Vector2( aCPx, aCPy ),
    			new Vector2( aX, aY )
    		);

    		this.curves.push( curve );

    		this.currentPoint.set( aX, aY );

    		return this;

    	}

    	bezierCurveTo( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {

    		const curve = new CubicBezierCurve(
    			this.currentPoint.clone(),
    			new Vector2( aCP1x, aCP1y ),
    			new Vector2( aCP2x, aCP2y ),
    			new Vector2( aX, aY )
    		);

    		this.curves.push( curve );

    		this.currentPoint.set( aX, aY );

    		return this;

    	}

    	splineThru( pts /*Array of Vector*/ ) {

    		const npts = [ this.currentPoint.clone() ].concat( pts );

    		const curve = new SplineCurve( npts );
    		this.curves.push( curve );

    		this.currentPoint.copy( pts[ pts.length - 1 ] );

    		return this;

    	}

    	arc( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

    		const x0 = this.currentPoint.x;
    		const y0 = this.currentPoint.y;

    		this.absarc( aX + x0, aY + y0, aRadius,
    			aStartAngle, aEndAngle, aClockwise );

    		return this;

    	}

    	absarc( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

    		this.absellipse( aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );

    		return this;

    	}

    	ellipse( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {

    		const x0 = this.currentPoint.x;
    		const y0 = this.currentPoint.y;

    		this.absellipse( aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );

    		return this;

    	}

    	absellipse( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {

    		const curve = new EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );

    		if ( this.curves.length > 0 ) {

    			// if a previous curve is present, attempt to join
    			const firstPoint = curve.getPoint( 0 );

    			if ( ! firstPoint.equals( this.currentPoint ) ) {

    				this.lineTo( firstPoint.x, firstPoint.y );

    			}

    		}

    		this.curves.push( curve );

    		const lastPoint = curve.getPoint( 1 );
    		this.currentPoint.copy( lastPoint );

    		return this;

    	}

    	copy( source ) {

    		super.copy( source );

    		this.currentPoint.copy( source.currentPoint );

    		return this;

    	}

    	toJSON() {

    		const data = super.toJSON();

    		data.currentPoint = this.currentPoint.toArray();

    		return data;

    	}

    	fromJSON( json ) {

    		super.fromJSON( json );

    		this.currentPoint.fromArray( json.currentPoint );

    		return this;

    	}

    }

    class CircleGeometry extends BufferGeometry {

    	constructor( radius = 1, segments = 8, thetaStart = 0, thetaLength = Math.PI * 2 ) {

    		super();

    		this.type = 'CircleGeometry';

    		this.parameters = {
    			radius: radius,
    			segments: segments,
    			thetaStart: thetaStart,
    			thetaLength: thetaLength
    		};

    		segments = Math.max( 3, segments );

    		// buffers

    		const indices = [];
    		const vertices = [];
    		const normals = [];
    		const uvs = [];

    		// helper variables

    		const vertex = new Vector3();
    		const uv = new Vector2();

    		// center point

    		vertices.push( 0, 0, 0 );
    		normals.push( 0, 0, 1 );
    		uvs.push( 0.5, 0.5 );

    		for ( let s = 0, i = 3; s <= segments; s ++, i += 3 ) {

    			const segment = thetaStart + s / segments * thetaLength;

    			// vertex

    			vertex.x = radius * Math.cos( segment );
    			vertex.y = radius * Math.sin( segment );

    			vertices.push( vertex.x, vertex.y, vertex.z );

    			// normal

    			normals.push( 0, 0, 1 );

    			// uvs

    			uv.x = ( vertices[ i ] / radius + 1 ) / 2;
    			uv.y = ( vertices[ i + 1 ] / radius + 1 ) / 2;

    			uvs.push( uv.x, uv.y );

    		}

    		// indices

    		for ( let i = 1; i <= segments; i ++ ) {

    			indices.push( i, i + 1, 0 );

    		}

    		// build geometry

    		this.setIndex( indices );
    		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
    		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
    		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

    	}

    	static fromJSON( data ) {

    		return new CircleGeometry( data.radius, data.segments, data.thetaStart, data.thetaLength );

    	}

    }

    class CylinderGeometry extends BufferGeometry {

    	constructor( radiusTop = 1, radiusBottom = 1, height = 1, radialSegments = 8, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2 ) {

    		super();

    		this.type = 'CylinderGeometry';

    		this.parameters = {
    			radiusTop: radiusTop,
    			radiusBottom: radiusBottom,
    			height: height,
    			radialSegments: radialSegments,
    			heightSegments: heightSegments,
    			openEnded: openEnded,
    			thetaStart: thetaStart,
    			thetaLength: thetaLength
    		};

    		const scope = this;

    		radialSegments = Math.floor( radialSegments );
    		heightSegments = Math.floor( heightSegments );

    		// buffers

    		const indices = [];
    		const vertices = [];
    		const normals = [];
    		const uvs = [];

    		// helper variables

    		let index = 0;
    		const indexArray = [];
    		const halfHeight = height / 2;
    		let groupStart = 0;

    		// generate geometry

    		generateTorso();

    		if ( openEnded === false ) {

    			if ( radiusTop > 0 ) generateCap( true );
    			if ( radiusBottom > 0 ) generateCap( false );

    		}

    		// build geometry

    		this.setIndex( indices );
    		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
    		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
    		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

    		function generateTorso() {

    			const normal = new Vector3();
    			const vertex = new Vector3();

    			let groupCount = 0;

    			// this will be used to calculate the normal
    			const slope = ( radiusBottom - radiusTop ) / height;

    			// generate vertices, normals and uvs

    			for ( let y = 0; y <= heightSegments; y ++ ) {

    				const indexRow = [];

    				const v = y / heightSegments;

    				// calculate the radius of the current row

    				const radius = v * ( radiusBottom - radiusTop ) + radiusTop;

    				for ( let x = 0; x <= radialSegments; x ++ ) {

    					const u = x / radialSegments;

    					const theta = u * thetaLength + thetaStart;

    					const sinTheta = Math.sin( theta );
    					const cosTheta = Math.cos( theta );

    					// vertex

    					vertex.x = radius * sinTheta;
    					vertex.y = - v * height + halfHeight;
    					vertex.z = radius * cosTheta;
    					vertices.push( vertex.x, vertex.y, vertex.z );

    					// normal

    					normal.set( sinTheta, slope, cosTheta ).normalize();
    					normals.push( normal.x, normal.y, normal.z );

    					// uv

    					uvs.push( u, 1 - v );

    					// save index of vertex in respective row

    					indexRow.push( index ++ );

    				}

    				// now save vertices of the row in our index array

    				indexArray.push( indexRow );

    			}

    			// generate indices

    			for ( let x = 0; x < radialSegments; x ++ ) {

    				for ( let y = 0; y < heightSegments; y ++ ) {

    					// we use the index array to access the correct indices

    					const a = indexArray[ y ][ x ];
    					const b = indexArray[ y + 1 ][ x ];
    					const c = indexArray[ y + 1 ][ x + 1 ];
    					const d = indexArray[ y ][ x + 1 ];

    					// faces

    					indices.push( a, b, d );
    					indices.push( b, c, d );

    					// update group counter

    					groupCount += 6;

    				}

    			}

    			// add a group to the geometry. this will ensure multi material support

    			scope.addGroup( groupStart, groupCount, 0 );

    			// calculate new start value for groups

    			groupStart += groupCount;

    		}

    		function generateCap( top ) {

    			// save the index of the first center vertex
    			const centerIndexStart = index;

    			const uv = new Vector2();
    			const vertex = new Vector3();

    			let groupCount = 0;

    			const radius = ( top === true ) ? radiusTop : radiusBottom;
    			const sign = ( top === true ) ? 1 : - 1;

    			// first we generate the center vertex data of the cap.
    			// because the geometry needs one set of uvs per face,
    			// we must generate a center vertex per face/segment

    			for ( let x = 1; x <= radialSegments; x ++ ) {

    				// vertex

    				vertices.push( 0, halfHeight * sign, 0 );

    				// normal

    				normals.push( 0, sign, 0 );

    				// uv

    				uvs.push( 0.5, 0.5 );

    				// increase index

    				index ++;

    			}

    			// save the index of the last center vertex
    			const centerIndexEnd = index;

    			// now we generate the surrounding vertices, normals and uvs

    			for ( let x = 0; x <= radialSegments; x ++ ) {

    				const u = x / radialSegments;
    				const theta = u * thetaLength + thetaStart;

    				const cosTheta = Math.cos( theta );
    				const sinTheta = Math.sin( theta );

    				// vertex

    				vertex.x = radius * sinTheta;
    				vertex.y = halfHeight * sign;
    				vertex.z = radius * cosTheta;
    				vertices.push( vertex.x, vertex.y, vertex.z );

    				// normal

    				normals.push( 0, sign, 0 );

    				// uv

    				uv.x = ( cosTheta * 0.5 ) + 0.5;
    				uv.y = ( sinTheta * 0.5 * sign ) + 0.5;
    				uvs.push( uv.x, uv.y );

    				// increase index

    				index ++;

    			}

    			// generate indices

    			for ( let x = 0; x < radialSegments; x ++ ) {

    				const c = centerIndexStart + x;
    				const i = centerIndexEnd + x;

    				if ( top === true ) {

    					// face top

    					indices.push( i, i + 1, c );

    				} else {

    					// face bottom

    					indices.push( i + 1, i, c );

    				}

    				groupCount += 3;

    			}

    			// add a group to the geometry. this will ensure multi material support

    			scope.addGroup( groupStart, groupCount, top === true ? 1 : 2 );

    			// calculate new start value for groups

    			groupStart += groupCount;

    		}

    	}

    	static fromJSON( data ) {

    		return new CylinderGeometry( data.radiusTop, data.radiusBottom, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength );

    	}

    }

    class Shape extends Path$1 {

    	constructor( points ) {

    		super( points );

    		this.uuid = generateUUID();

    		this.type = 'Shape';

    		this.holes = [];

    	}

    	getPointsHoles( divisions ) {

    		const holesPts = [];

    		for ( let i = 0, l = this.holes.length; i < l; i ++ ) {

    			holesPts[ i ] = this.holes[ i ].getPoints( divisions );

    		}

    		return holesPts;

    	}

    	// get points of shape and holes (keypoints based on segments parameter)

    	extractPoints( divisions ) {

    		return {

    			shape: this.getPoints( divisions ),
    			holes: this.getPointsHoles( divisions )

    		};

    	}

    	copy( source ) {

    		super.copy( source );

    		this.holes = [];

    		for ( let i = 0, l = source.holes.length; i < l; i ++ ) {

    			const hole = source.holes[ i ];

    			this.holes.push( hole.clone() );

    		}

    		return this;

    	}

    	toJSON() {

    		const data = super.toJSON();

    		data.uuid = this.uuid;
    		data.holes = [];

    		for ( let i = 0, l = this.holes.length; i < l; i ++ ) {

    			const hole = this.holes[ i ];
    			data.holes.push( hole.toJSON() );

    		}

    		return data;

    	}

    	fromJSON( json ) {

    		super.fromJSON( json );

    		this.uuid = json.uuid;
    		this.holes = [];

    		for ( let i = 0, l = json.holes.length; i < l; i ++ ) {

    			const hole = json.holes[ i ];
    			this.holes.push( new Path$1().fromJSON( hole ) );

    		}

    		return this;

    	}

    }

    /**
     * Port from https://github.com/mapbox/earcut (v2.2.4)
     */

    const Earcut = {

    	triangulate: function ( data, holeIndices, dim = 2 ) {

    		const hasHoles = holeIndices && holeIndices.length;
    		const outerLen = hasHoles ? holeIndices[ 0 ] * dim : data.length;
    		let outerNode = linkedList$1( data, 0, outerLen, dim, true );
    		const triangles = [];

    		if ( ! outerNode || outerNode.next === outerNode.prev ) return triangles;

    		let minX, minY, maxX, maxY, x, y, invSize;

    		if ( hasHoles ) outerNode = eliminateHoles$1( data, holeIndices, outerNode, dim );

    		// if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
    		if ( data.length > 80 * dim ) {

    			minX = maxX = data[ 0 ];
    			minY = maxY = data[ 1 ];

    			for ( let i = dim; i < outerLen; i += dim ) {

    				x = data[ i ];
    				y = data[ i + 1 ];
    				if ( x < minX ) minX = x;
    				if ( y < minY ) minY = y;
    				if ( x > maxX ) maxX = x;
    				if ( y > maxY ) maxY = y;

    			}

    			// minX, minY and invSize are later used to transform coords into integers for z-order calculation
    			invSize = Math.max( maxX - minX, maxY - minY );
    			invSize = invSize !== 0 ? 32767 / invSize : 0;

    		}

    		earcutLinked$1( outerNode, triangles, dim, minX, minY, invSize, 0 );

    		return triangles;

    	}

    };

    // create a circular doubly linked list from polygon points in the specified winding order
    function linkedList$1( data, start, end, dim, clockwise ) {

    	let i, last;

    	if ( clockwise === ( signedArea$1( data, start, end, dim ) > 0 ) ) {

    		for ( i = start; i < end; i += dim ) last = insertNode$1( i, data[ i ], data[ i + 1 ], last );

    	} else {

    		for ( i = end - dim; i >= start; i -= dim ) last = insertNode$1( i, data[ i ], data[ i + 1 ], last );

    	}

    	if ( last && equals$1( last, last.next ) ) {

    		removeNode$1( last );
    		last = last.next;

    	}

    	return last;

    }

    // eliminate colinear or duplicate points
    function filterPoints$1( start, end ) {

    	if ( ! start ) return start;
    	if ( ! end ) end = start;

    	let p = start,
    		again;
    	do {

    		again = false;

    		if ( ! p.steiner && ( equals$1( p, p.next ) || area$1( p.prev, p, p.next ) === 0 ) ) {

    			removeNode$1( p );
    			p = end = p.prev;
    			if ( p === p.next ) break;
    			again = true;

    		} else {

    			p = p.next;

    		}

    	} while ( again || p !== end );

    	return end;

    }

    // main ear slicing loop which triangulates a polygon (given as a linked list)
    function earcutLinked$1( ear, triangles, dim, minX, minY, invSize, pass ) {

    	if ( ! ear ) return;

    	// interlink polygon nodes in z-order
    	if ( ! pass && invSize ) indexCurve$1( ear, minX, minY, invSize );

    	let stop = ear,
    		prev, next;

    	// iterate through ears, slicing them one by one
    	while ( ear.prev !== ear.next ) {

    		prev = ear.prev;
    		next = ear.next;

    		if ( invSize ? isEarHashed$1( ear, minX, minY, invSize ) : isEar$1( ear ) ) {

    			// cut off the triangle
    			triangles.push( prev.i / dim | 0 );
    			triangles.push( ear.i / dim | 0 );
    			triangles.push( next.i / dim | 0 );

    			removeNode$1( ear );

    			// skipping the next vertex leads to less sliver triangles
    			ear = next.next;
    			stop = next.next;

    			continue;

    		}

    		ear = next;

    		// if we looped through the whole remaining polygon and can't find any more ears
    		if ( ear === stop ) {

    			// try filtering points and slicing again
    			if ( ! pass ) {

    				earcutLinked$1( filterPoints$1( ear ), triangles, dim, minX, minY, invSize, 1 );

    				// if this didn't work, try curing all small self-intersections locally

    			} else if ( pass === 1 ) {

    				ear = cureLocalIntersections$1( filterPoints$1( ear ), triangles, dim );
    				earcutLinked$1( ear, triangles, dim, minX, minY, invSize, 2 );

    				// as a last resort, try splitting the remaining polygon into two

    			} else if ( pass === 2 ) {

    				splitEarcut$1( ear, triangles, dim, minX, minY, invSize );

    			}

    			break;

    		}

    	}

    }

    // check whether a polygon node forms a valid ear with adjacent nodes
    function isEar$1( ear ) {

    	const a = ear.prev,
    		b = ear,
    		c = ear.next;

    	if ( area$1( a, b, c ) >= 0 ) return false; // reflex, can't be an ear

    	// now make sure we don't have other points inside the potential ear
    	const ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;

    	// triangle bbox; min & max are calculated like this for speed
    	const x0 = ax < bx ? ( ax < cx ? ax : cx ) : ( bx < cx ? bx : cx ),
    		y0 = ay < by ? ( ay < cy ? ay : cy ) : ( by < cy ? by : cy ),
    		x1 = ax > bx ? ( ax > cx ? ax : cx ) : ( bx > cx ? bx : cx ),
    		y1 = ay > by ? ( ay > cy ? ay : cy ) : ( by > cy ? by : cy );

    	let p = c.next;
    	while ( p !== a ) {

    		if ( p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 &&
    			pointInTriangle$1( ax, ay, bx, by, cx, cy, p.x, p.y ) &&
    			area$1( p.prev, p, p.next ) >= 0 ) return false;
    		p = p.next;

    	}

    	return true;

    }

    function isEarHashed$1( ear, minX, minY, invSize ) {

    	const a = ear.prev,
    		b = ear,
    		c = ear.next;

    	if ( area$1( a, b, c ) >= 0 ) return false; // reflex, can't be an ear

    	const ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;

    	// triangle bbox; min & max are calculated like this for speed
    	const x0 = ax < bx ? ( ax < cx ? ax : cx ) : ( bx < cx ? bx : cx ),
    		y0 = ay < by ? ( ay < cy ? ay : cy ) : ( by < cy ? by : cy ),
    		x1 = ax > bx ? ( ax > cx ? ax : cx ) : ( bx > cx ? bx : cx ),
    		y1 = ay > by ? ( ay > cy ? ay : cy ) : ( by > cy ? by : cy );

    	// z-order range for the current triangle bbox;
    	const minZ = zOrder$1( x0, y0, minX, minY, invSize ),
    		maxZ = zOrder$1( x1, y1, minX, minY, invSize );

    	let p = ear.prevZ,
    		n = ear.nextZ;

    	// look for points inside the triangle in both directions
    	while ( p && p.z >= minZ && n && n.z <= maxZ ) {

    		if ( p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c &&
    			pointInTriangle$1( ax, ay, bx, by, cx, cy, p.x, p.y ) && area$1( p.prev, p, p.next ) >= 0 ) return false;
    		p = p.prevZ;

    		if ( n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c &&
    			pointInTriangle$1( ax, ay, bx, by, cx, cy, n.x, n.y ) && area$1( n.prev, n, n.next ) >= 0 ) return false;
    		n = n.nextZ;

    	}

    	// look for remaining points in decreasing z-order
    	while ( p && p.z >= minZ ) {

    		if ( p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c &&
    			pointInTriangle$1( ax, ay, bx, by, cx, cy, p.x, p.y ) && area$1( p.prev, p, p.next ) >= 0 ) return false;
    		p = p.prevZ;

    	}

    	// look for remaining points in increasing z-order
    	while ( n && n.z <= maxZ ) {

    		if ( n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c &&
    			pointInTriangle$1( ax, ay, bx, by, cx, cy, n.x, n.y ) && area$1( n.prev, n, n.next ) >= 0 ) return false;
    		n = n.nextZ;

    	}

    	return true;

    }

    // go through all polygon nodes and cure small local self-intersections
    function cureLocalIntersections$1( start, triangles, dim ) {

    	let p = start;
    	do {

    		const a = p.prev,
    			b = p.next.next;

    		if ( ! equals$1( a, b ) && intersects$1( a, p, p.next, b ) && locallyInside$1( a, b ) && locallyInside$1( b, a ) ) {

    			triangles.push( a.i / dim | 0 );
    			triangles.push( p.i / dim | 0 );
    			triangles.push( b.i / dim | 0 );

    			// remove two nodes involved
    			removeNode$1( p );
    			removeNode$1( p.next );

    			p = start = b;

    		}

    		p = p.next;

    	} while ( p !== start );

    	return filterPoints$1( p );

    }

    // try splitting polygon into two and triangulate them independently
    function splitEarcut$1( start, triangles, dim, minX, minY, invSize ) {

    	// look for a valid diagonal that divides the polygon into two
    	let a = start;
    	do {

    		let b = a.next.next;
    		while ( b !== a.prev ) {

    			if ( a.i !== b.i && isValidDiagonal$1( a, b ) ) {

    				// split the polygon in two by the diagonal
    				let c = splitPolygon$1( a, b );

    				// filter colinear points around the cuts
    				a = filterPoints$1( a, a.next );
    				c = filterPoints$1( c, c.next );

    				// run earcut on each half
    				earcutLinked$1( a, triangles, dim, minX, minY, invSize, 0 );
    				earcutLinked$1( c, triangles, dim, minX, minY, invSize, 0 );
    				return;

    			}

    			b = b.next;

    		}

    		a = a.next;

    	} while ( a !== start );

    }

    // link every hole into the outer loop, producing a single-ring polygon without holes
    function eliminateHoles$1( data, holeIndices, outerNode, dim ) {

    	const queue = [];
    	let i, len, start, end, list;

    	for ( i = 0, len = holeIndices.length; i < len; i ++ ) {

    		start = holeIndices[ i ] * dim;
    		end = i < len - 1 ? holeIndices[ i + 1 ] * dim : data.length;
    		list = linkedList$1( data, start, end, dim, false );
    		if ( list === list.next ) list.steiner = true;
    		queue.push( getLeftmost$1( list ) );

    	}

    	queue.sort( compareX$1 );

    	// process holes from left to right
    	for ( i = 0; i < queue.length; i ++ ) {

    		outerNode = eliminateHole$1( queue[ i ], outerNode );

    	}

    	return outerNode;

    }

    function compareX$1( a, b ) {

    	return a.x - b.x;

    }

    // find a bridge between vertices that connects hole with an outer ring and link it
    function eliminateHole$1( hole, outerNode ) {

    	const bridge = findHoleBridge$1( hole, outerNode );
    	if ( ! bridge ) {

    		return outerNode;

    	}

    	const bridgeReverse = splitPolygon$1( bridge, hole );

    	// filter collinear points around the cuts
    	filterPoints$1( bridgeReverse, bridgeReverse.next );
    	return filterPoints$1( bridge, bridge.next );

    }

    // David Eberly's algorithm for finding a bridge between hole and outer polygon
    function findHoleBridge$1( hole, outerNode ) {

    	let p = outerNode,
    		qx = - Infinity,
    		m;

    	const hx = hole.x, hy = hole.y;

    	// find a segment intersected by a ray from the hole's leftmost point to the left;
    	// segment's endpoint with lesser x will be potential connection point
    	do {

    		if ( hy <= p.y && hy >= p.next.y && p.next.y !== p.y ) {

    			const x = p.x + ( hy - p.y ) * ( p.next.x - p.x ) / ( p.next.y - p.y );
    			if ( x <= hx && x > qx ) {

    				qx = x;
    				m = p.x < p.next.x ? p : p.next;
    				if ( x === hx ) return m; // hole touches outer segment; pick leftmost endpoint

    			}

    		}

    		p = p.next;

    	} while ( p !== outerNode );

    	if ( ! m ) return null;

    	// look for points inside the triangle of hole point, segment intersection and endpoint;
    	// if there are no points found, we have a valid connection;
    	// otherwise choose the point of the minimum angle with the ray as connection point

    	const stop = m,
    		mx = m.x,
    		my = m.y;
    	let tanMin = Infinity, tan;

    	p = m;

    	do {

    		if ( hx >= p.x && p.x >= mx && hx !== p.x &&
    				pointInTriangle$1( hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y ) ) {

    			tan = Math.abs( hy - p.y ) / ( hx - p.x ); // tangential

    			if ( locallyInside$1( p, hole ) && ( tan < tanMin || ( tan === tanMin && ( p.x > m.x || ( p.x === m.x && sectorContainsSector$1( m, p ) ) ) ) ) ) {

    				m = p;
    				tanMin = tan;

    			}

    		}

    		p = p.next;

    	} while ( p !== stop );

    	return m;

    }

    // whether sector in vertex m contains sector in vertex p in the same coordinates
    function sectorContainsSector$1( m, p ) {

    	return area$1( m.prev, m, p.prev ) < 0 && area$1( p.next, m, m.next ) < 0;

    }

    // interlink polygon nodes in z-order
    function indexCurve$1( start, minX, minY, invSize ) {

    	let p = start;
    	do {

    		if ( p.z === 0 ) p.z = zOrder$1( p.x, p.y, minX, minY, invSize );
    		p.prevZ = p.prev;
    		p.nextZ = p.next;
    		p = p.next;

    	} while ( p !== start );

    	p.prevZ.nextZ = null;
    	p.prevZ = null;

    	sortLinked$1( p );

    }

    // Simon Tatham's linked list merge sort algorithm
    // http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
    function sortLinked$1( list ) {

    	let i, p, q, e, tail, numMerges, pSize, qSize,
    		inSize = 1;

    	do {

    		p = list;
    		list = null;
    		tail = null;
    		numMerges = 0;

    		while ( p ) {

    			numMerges ++;
    			q = p;
    			pSize = 0;
    			for ( i = 0; i < inSize; i ++ ) {

    				pSize ++;
    				q = q.nextZ;
    				if ( ! q ) break;

    			}

    			qSize = inSize;

    			while ( pSize > 0 || ( qSize > 0 && q ) ) {

    				if ( pSize !== 0 && ( qSize === 0 || ! q || p.z <= q.z ) ) {

    					e = p;
    					p = p.nextZ;
    					pSize --;

    				} else {

    					e = q;
    					q = q.nextZ;
    					qSize --;

    				}

    				if ( tail ) tail.nextZ = e;
    				else list = e;

    				e.prevZ = tail;
    				tail = e;

    			}

    			p = q;

    		}

    		tail.nextZ = null;
    		inSize *= 2;

    	} while ( numMerges > 1 );

    	return list;

    }

    // z-order of a point given coords and inverse of the longer side of data bbox
    function zOrder$1( x, y, minX, minY, invSize ) {

    	// coords are transformed into non-negative 15-bit integer range
    	x = ( x - minX ) * invSize | 0;
    	y = ( y - minY ) * invSize | 0;

    	x = ( x | ( x << 8 ) ) & 0x00FF00FF;
    	x = ( x | ( x << 4 ) ) & 0x0F0F0F0F;
    	x = ( x | ( x << 2 ) ) & 0x33333333;
    	x = ( x | ( x << 1 ) ) & 0x55555555;

    	y = ( y | ( y << 8 ) ) & 0x00FF00FF;
    	y = ( y | ( y << 4 ) ) & 0x0F0F0F0F;
    	y = ( y | ( y << 2 ) ) & 0x33333333;
    	y = ( y | ( y << 1 ) ) & 0x55555555;

    	return x | ( y << 1 );

    }

    // find the leftmost node of a polygon ring
    function getLeftmost$1( start ) {

    	let p = start,
    		leftmost = start;
    	do {

    		if ( p.x < leftmost.x || ( p.x === leftmost.x && p.y < leftmost.y ) ) leftmost = p;
    		p = p.next;

    	} while ( p !== start );

    	return leftmost;

    }

    // check if a point lies within a convex triangle
    function pointInTriangle$1( ax, ay, bx, by, cx, cy, px, py ) {

    	return ( cx - px ) * ( ay - py ) >= ( ax - px ) * ( cy - py ) &&
               ( ax - px ) * ( by - py ) >= ( bx - px ) * ( ay - py ) &&
               ( bx - px ) * ( cy - py ) >= ( cx - px ) * ( by - py );

    }

    // check if a diagonal between two polygon nodes is valid (lies in polygon interior)
    function isValidDiagonal$1( a, b ) {

    	return a.next.i !== b.i && a.prev.i !== b.i && ! intersectsPolygon$1( a, b ) && // dones't intersect other edges
               ( locallyInside$1( a, b ) && locallyInside$1( b, a ) && middleInside$1( a, b ) && // locally visible
                ( area$1( a.prev, a, b.prev ) || area$1( a, b.prev, b ) ) || // does not create opposite-facing sectors
                equals$1( a, b ) && area$1( a.prev, a, a.next ) > 0 && area$1( b.prev, b, b.next ) > 0 ); // special zero-length case

    }

    // signed area of a triangle
    function area$1( p, q, r ) {

    	return ( q.y - p.y ) * ( r.x - q.x ) - ( q.x - p.x ) * ( r.y - q.y );

    }

    // check if two points are equal
    function equals$1( p1, p2 ) {

    	return p1.x === p2.x && p1.y === p2.y;

    }

    // check if two segments intersect
    function intersects$1( p1, q1, p2, q2 ) {

    	const o1 = sign$4( area$1( p1, q1, p2 ) );
    	const o2 = sign$4( area$1( p1, q1, q2 ) );
    	const o3 = sign$4( area$1( p2, q2, p1 ) );
    	const o4 = sign$4( area$1( p2, q2, q1 ) );

    	if ( o1 !== o2 && o3 !== o4 ) return true; // general case

    	if ( o1 === 0 && onSegment$1( p1, p2, q1 ) ) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1
    	if ( o2 === 0 && onSegment$1( p1, q2, q1 ) ) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1
    	if ( o3 === 0 && onSegment$1( p2, p1, q2 ) ) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2
    	if ( o4 === 0 && onSegment$1( p2, q1, q2 ) ) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2

    	return false;

    }

    // for collinear points p, q, r, check if point q lies on segment pr
    function onSegment$1( p, q, r ) {

    	return q.x <= Math.max( p.x, r.x ) && q.x >= Math.min( p.x, r.x ) && q.y <= Math.max( p.y, r.y ) && q.y >= Math.min( p.y, r.y );

    }

    function sign$4( num ) {

    	return num > 0 ? 1 : num < 0 ? - 1 : 0;

    }

    // check if a polygon diagonal intersects any polygon segments
    function intersectsPolygon$1( a, b ) {

    	let p = a;
    	do {

    		if ( p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&
    			intersects$1( p, p.next, a, b ) ) return true;
    		p = p.next;

    	} while ( p !== a );

    	return false;

    }

    // check if a polygon diagonal is locally inside the polygon
    function locallyInside$1( a, b ) {

    	return area$1( a.prev, a, a.next ) < 0 ?
    		area$1( a, b, a.next ) >= 0 && area$1( a, a.prev, b ) >= 0 :
    		area$1( a, b, a.prev ) < 0 || area$1( a, a.next, b ) < 0;

    }

    // check if the middle point of a polygon diagonal is inside the polygon
    function middleInside$1( a, b ) {

    	let p = a,
    		inside = false;
    	const px = ( a.x + b.x ) / 2,
    		py = ( a.y + b.y ) / 2;
    	do {

    		if ( ( ( p.y > py ) !== ( p.next.y > py ) ) && p.next.y !== p.y &&
    			( px < ( p.next.x - p.x ) * ( py - p.y ) / ( p.next.y - p.y ) + p.x ) )
    			inside = ! inside;
    		p = p.next;

    	} while ( p !== a );

    	return inside;

    }

    // link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
    // if one belongs to the outer ring and another to a hole, it merges it into a single ring
    function splitPolygon$1( a, b ) {

    	const a2 = new Node$1( a.i, a.x, a.y ),
    		b2 = new Node$1( b.i, b.x, b.y ),
    		an = a.next,
    		bp = b.prev;

    	a.next = b;
    	b.prev = a;

    	a2.next = an;
    	an.prev = a2;

    	b2.next = a2;
    	a2.prev = b2;

    	bp.next = b2;
    	b2.prev = bp;

    	return b2;

    }

    // create a node and optionally link it with previous one (in a circular doubly linked list)
    function insertNode$1( i, x, y, last ) {

    	const p = new Node$1( i, x, y );

    	if ( ! last ) {

    		p.prev = p;
    		p.next = p;

    	} else {

    		p.next = last.next;
    		p.prev = last;
    		last.next.prev = p;
    		last.next = p;

    	}

    	return p;

    }

    function removeNode$1( p ) {

    	p.next.prev = p.prev;
    	p.prev.next = p.next;

    	if ( p.prevZ ) p.prevZ.nextZ = p.nextZ;
    	if ( p.nextZ ) p.nextZ.prevZ = p.prevZ;

    }

    function Node$1( i, x, y ) {

    	// vertex index in coordinates array
    	this.i = i;

    	// vertex coordinates
    	this.x = x;
    	this.y = y;

    	// previous and next vertex nodes in a polygon ring
    	this.prev = null;
    	this.next = null;

    	// z-order curve value
    	this.z = 0;

    	// previous and next nodes in z-order
    	this.prevZ = null;
    	this.nextZ = null;

    	// indicates whether this is a steiner point
    	this.steiner = false;

    }

    function signedArea$1( data, start, end, dim ) {

    	let sum = 0;
    	for ( let i = start, j = end - dim; i < end; i += dim ) {

    		sum += ( data[ j ] - data[ i ] ) * ( data[ i + 1 ] + data[ j + 1 ] );
    		j = i;

    	}

    	return sum;

    }

    class ShapeUtils {

    	// calculate area of the contour polygon

    	static area( contour ) {

    		const n = contour.length;
    		let a = 0.0;

    		for ( let p = n - 1, q = 0; q < n; p = q ++ ) {

    			a += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;

    		}

    		return a * 0.5;

    	}

    	static isClockWise( pts ) {

    		return ShapeUtils.area( pts ) < 0;

    	}

    	static triangulateShape( contour, holes ) {

    		const vertices = []; // flat array of vertices like [ x0,y0, x1,y1, x2,y2, ... ]
    		const holeIndices = []; // array of hole indices
    		const faces = []; // final array of vertex indices like [ [ a,b,d ], [ b,c,d ] ]

    		removeDupEndPts( contour );
    		addContour( vertices, contour );

    		//

    		let holeIndex = contour.length;

    		holes.forEach( removeDupEndPts );

    		for ( let i = 0; i < holes.length; i ++ ) {

    			holeIndices.push( holeIndex );
    			holeIndex += holes[ i ].length;
    			addContour( vertices, holes[ i ] );

    		}

    		//

    		const triangles = Earcut.triangulate( vertices, holeIndices );

    		//

    		for ( let i = 0; i < triangles.length; i += 3 ) {

    			faces.push( triangles.slice( i, i + 3 ) );

    		}

    		return faces;

    	}

    }

    function removeDupEndPts( points ) {

    	const l = points.length;

    	if ( l > 2 && points[ l - 1 ].equals( points[ 0 ] ) ) {

    		points.pop();

    	}

    }

    function addContour( vertices, contour ) {

    	for ( let i = 0; i < contour.length; i ++ ) {

    		vertices.push( contour[ i ].x );
    		vertices.push( contour[ i ].y );

    	}

    }

    /**
     * Creates extruded geometry from a path shape.
     *
     * parameters = {
     *
     *  curveSegments: <int>, // number of points on the curves
     *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too
     *  depth: <float>, // Depth to extrude the shape
     *
     *  bevelEnabled: <bool>, // turn on bevel
     *  bevelThickness: <float>, // how deep into the original shape bevel goes
     *  bevelSize: <float>, // how far from shape outline (including bevelOffset) is bevel
     *  bevelOffset: <float>, // how far from shape outline does bevel start
     *  bevelSegments: <int>, // number of bevel layers
     *
     *  extrudePath: <THREE.Curve> // curve to extrude shape along
     *
     *  UVGenerator: <Object> // object that provides UV generator functions
     *
     * }
     */

    class ExtrudeGeometry extends BufferGeometry {

    	constructor( shapes = new Shape( [ new Vector2( 0.5, 0.5 ), new Vector2( - 0.5, 0.5 ), new Vector2( - 0.5, - 0.5 ), new Vector2( 0.5, - 0.5 ) ] ), options = {} ) {

    		super();

    		this.type = 'ExtrudeGeometry';

    		this.parameters = {
    			shapes: shapes,
    			options: options
    		};

    		shapes = Array.isArray( shapes ) ? shapes : [ shapes ];

    		const scope = this;

    		const verticesArray = [];
    		const uvArray = [];

    		for ( let i = 0, l = shapes.length; i < l; i ++ ) {

    			const shape = shapes[ i ];
    			addShape( shape );

    		}

    		// build geometry

    		this.setAttribute( 'position', new Float32BufferAttribute( verticesArray, 3 ) );
    		this.setAttribute( 'uv', new Float32BufferAttribute( uvArray, 2 ) );

    		this.computeVertexNormals();

    		// functions

    		function addShape( shape ) {

    			const placeholder = [];

    			// options

    			const curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;
    			const steps = options.steps !== undefined ? options.steps : 1;
    			const depth = options.depth !== undefined ? options.depth : 1;

    			let bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true;
    			let bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 0.2;
    			let bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 0.1;
    			let bevelOffset = options.bevelOffset !== undefined ? options.bevelOffset : 0;
    			let bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;

    			const extrudePath = options.extrudePath;

    			const uvgen = options.UVGenerator !== undefined ? options.UVGenerator : WorldUVGenerator;

    			//

    			let extrudePts, extrudeByPath = false;
    			let splineTube, binormal, normal, position2;

    			if ( extrudePath ) {

    				extrudePts = extrudePath.getSpacedPoints( steps );

    				extrudeByPath = true;
    				bevelEnabled = false; // bevels not supported for path extrusion

    				// SETUP TNB variables

    				// TODO1 - have a .isClosed in spline?

    				splineTube = extrudePath.computeFrenetFrames( steps, false );

    				// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);

    				binormal = new Vector3();
    				normal = new Vector3();
    				position2 = new Vector3();

    			}

    			// Safeguards if bevels are not enabled

    			if ( ! bevelEnabled ) {

    				bevelSegments = 0;
    				bevelThickness = 0;
    				bevelSize = 0;
    				bevelOffset = 0;

    			}

    			// Variables initialization

    			const shapePoints = shape.extractPoints( curveSegments );

    			let vertices = shapePoints.shape;
    			const holes = shapePoints.holes;

    			const reverse = ! ShapeUtils.isClockWise( vertices );

    			if ( reverse ) {

    				vertices = vertices.reverse();

    				// Maybe we should also check if holes are in the opposite direction, just to be safe ...

    				for ( let h = 0, hl = holes.length; h < hl; h ++ ) {

    					const ahole = holes[ h ];

    					if ( ShapeUtils.isClockWise( ahole ) ) {

    						holes[ h ] = ahole.reverse();

    					}

    				}

    			}


    			const faces = ShapeUtils.triangulateShape( vertices, holes );

    			/* Vertices */

    			const contour = vertices; // vertices has all points but contour has only points of circumference

    			for ( let h = 0, hl = holes.length; h < hl; h ++ ) {

    				const ahole = holes[ h ];

    				vertices = vertices.concat( ahole );

    			}


    			function scalePt2( pt, vec, size ) {

    				if ( ! vec ) console.error( 'THREE.ExtrudeGeometry: vec does not exist' );

    				return vec.clone().multiplyScalar( size ).add( pt );

    			}

    			const vlen = vertices.length, flen = faces.length;


    			// Find directions for point movement


    			function getBevelVec( inPt, inPrev, inNext ) {

    				// computes for inPt the corresponding point inPt' on a new contour
    				//   shifted by 1 unit (length of normalized vector) to the left
    				// if we walk along contour clockwise, this new contour is outside the old one
    				//
    				// inPt' is the intersection of the two lines parallel to the two
    				//  adjacent edges of inPt at a distance of 1 unit on the left side.

    				let v_trans_x, v_trans_y, shrink_by; // resulting translation vector for inPt

    				// good reading for geometry algorithms (here: line-line intersection)
    				// http://geomalgorithms.com/a05-_intersect-1.html

    				const v_prev_x = inPt.x - inPrev.x,
    					v_prev_y = inPt.y - inPrev.y;
    				const v_next_x = inNext.x - inPt.x,
    					v_next_y = inNext.y - inPt.y;

    				const v_prev_lensq = ( v_prev_x * v_prev_x + v_prev_y * v_prev_y );

    				// check for collinear edges
    				const collinear0 = ( v_prev_x * v_next_y - v_prev_y * v_next_x );

    				if ( Math.abs( collinear0 ) > Number.EPSILON ) {

    					// not collinear

    					// length of vectors for normalizing

    					const v_prev_len = Math.sqrt( v_prev_lensq );
    					const v_next_len = Math.sqrt( v_next_x * v_next_x + v_next_y * v_next_y );

    					// shift adjacent points by unit vectors to the left

    					const ptPrevShift_x = ( inPrev.x - v_prev_y / v_prev_len );
    					const ptPrevShift_y = ( inPrev.y + v_prev_x / v_prev_len );

    					const ptNextShift_x = ( inNext.x - v_next_y / v_next_len );
    					const ptNextShift_y = ( inNext.y + v_next_x / v_next_len );

    					// scaling factor for v_prev to intersection point

    					const sf = ( ( ptNextShift_x - ptPrevShift_x ) * v_next_y -
    							( ptNextShift_y - ptPrevShift_y ) * v_next_x ) /
    						( v_prev_x * v_next_y - v_prev_y * v_next_x );

    					// vector from inPt to intersection point

    					v_trans_x = ( ptPrevShift_x + v_prev_x * sf - inPt.x );
    					v_trans_y = ( ptPrevShift_y + v_prev_y * sf - inPt.y );

    					// Don't normalize!, otherwise sharp corners become ugly
    					//  but prevent crazy spikes
    					const v_trans_lensq = ( v_trans_x * v_trans_x + v_trans_y * v_trans_y );
    					if ( v_trans_lensq <= 2 ) {

    						return new Vector2( v_trans_x, v_trans_y );

    					} else {

    						shrink_by = Math.sqrt( v_trans_lensq / 2 );

    					}

    				} else {

    					// handle special case of collinear edges

    					let direction_eq = false; // assumes: opposite

    					if ( v_prev_x > Number.EPSILON ) {

    						if ( v_next_x > Number.EPSILON ) {

    							direction_eq = true;

    						}

    					} else {

    						if ( v_prev_x < - Number.EPSILON ) {

    							if ( v_next_x < - Number.EPSILON ) {

    								direction_eq = true;

    							}

    						} else {

    							if ( Math.sign( v_prev_y ) === Math.sign( v_next_y ) ) {

    								direction_eq = true;

    							}

    						}

    					}

    					if ( direction_eq ) {

    						// console.log("Warning: lines are a straight sequence");
    						v_trans_x = - v_prev_y;
    						v_trans_y = v_prev_x;
    						shrink_by = Math.sqrt( v_prev_lensq );

    					} else {

    						// console.log("Warning: lines are a straight spike");
    						v_trans_x = v_prev_x;
    						v_trans_y = v_prev_y;
    						shrink_by = Math.sqrt( v_prev_lensq / 2 );

    					}

    				}

    				return new Vector2( v_trans_x / shrink_by, v_trans_y / shrink_by );

    			}


    			const contourMovements = [];

    			for ( let i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {

    				if ( j === il ) j = 0;
    				if ( k === il ) k = 0;

    				//  (j)---(i)---(k)
    				// console.log('i,j,k', i, j , k)

    				contourMovements[ i ] = getBevelVec( contour[ i ], contour[ j ], contour[ k ] );

    			}

    			const holesMovements = [];
    			let oneHoleMovements, verticesMovements = contourMovements.concat();

    			for ( let h = 0, hl = holes.length; h < hl; h ++ ) {

    				const ahole = holes[ h ];

    				oneHoleMovements = [];

    				for ( let i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {

    					if ( j === il ) j = 0;
    					if ( k === il ) k = 0;

    					//  (j)---(i)---(k)
    					oneHoleMovements[ i ] = getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );

    				}

    				holesMovements.push( oneHoleMovements );
    				verticesMovements = verticesMovements.concat( oneHoleMovements );

    			}


    			// Loop bevelSegments, 1 for the front, 1 for the back

    			for ( let b = 0; b < bevelSegments; b ++ ) {

    				//for ( b = bevelSegments; b > 0; b -- ) {

    				const t = b / bevelSegments;
    				const z = bevelThickness * Math.cos( t * Math.PI / 2 );
    				const bs = bevelSize * Math.sin( t * Math.PI / 2 ) + bevelOffset;

    				// contract shape

    				for ( let i = 0, il = contour.length; i < il; i ++ ) {

    					const vert = scalePt2( contour[ i ], contourMovements[ i ], bs );

    					v( vert.x, vert.y, - z );

    				}

    				// expand holes

    				for ( let h = 0, hl = holes.length; h < hl; h ++ ) {

    					const ahole = holes[ h ];
    					oneHoleMovements = holesMovements[ h ];

    					for ( let i = 0, il = ahole.length; i < il; i ++ ) {

    						const vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );

    						v( vert.x, vert.y, - z );

    					}

    				}

    			}

    			const bs = bevelSize + bevelOffset;

    			// Back facing vertices

    			for ( let i = 0; i < vlen; i ++ ) {

    				const vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];

    				if ( ! extrudeByPath ) {

    					v( vert.x, vert.y, 0 );

    				} else {

    					// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );

    					normal.copy( splineTube.normals[ 0 ] ).multiplyScalar( vert.x );
    					binormal.copy( splineTube.binormals[ 0 ] ).multiplyScalar( vert.y );

    					position2.copy( extrudePts[ 0 ] ).add( normal ).add( binormal );

    					v( position2.x, position2.y, position2.z );

    				}

    			}

    			// Add stepped vertices...
    			// Including front facing vertices

    			for ( let s = 1; s <= steps; s ++ ) {

    				for ( let i = 0; i < vlen; i ++ ) {

    					const vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];

    					if ( ! extrudeByPath ) {

    						v( vert.x, vert.y, depth / steps * s );

    					} else {

    						// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );

    						normal.copy( splineTube.normals[ s ] ).multiplyScalar( vert.x );
    						binormal.copy( splineTube.binormals[ s ] ).multiplyScalar( vert.y );

    						position2.copy( extrudePts[ s ] ).add( normal ).add( binormal );

    						v( position2.x, position2.y, position2.z );

    					}

    				}

    			}


    			// Add bevel segments planes

    			//for ( b = 1; b <= bevelSegments; b ++ ) {
    			for ( let b = bevelSegments - 1; b >= 0; b -- ) {

    				const t = b / bevelSegments;
    				const z = bevelThickness * Math.cos( t * Math.PI / 2 );
    				const bs = bevelSize * Math.sin( t * Math.PI / 2 ) + bevelOffset;

    				// contract shape

    				for ( let i = 0, il = contour.length; i < il; i ++ ) {

    					const vert = scalePt2( contour[ i ], contourMovements[ i ], bs );
    					v( vert.x, vert.y, depth + z );

    				}

    				// expand holes

    				for ( let h = 0, hl = holes.length; h < hl; h ++ ) {

    					const ahole = holes[ h ];
    					oneHoleMovements = holesMovements[ h ];

    					for ( let i = 0, il = ahole.length; i < il; i ++ ) {

    						const vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );

    						if ( ! extrudeByPath ) {

    							v( vert.x, vert.y, depth + z );

    						} else {

    							v( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );

    						}

    					}

    				}

    			}

    			/* Faces */

    			// Top and bottom faces

    			buildLidFaces();

    			// Sides faces

    			buildSideFaces();


    			/////  Internal functions

    			function buildLidFaces() {

    				const start = verticesArray.length / 3;

    				if ( bevelEnabled ) {

    					let layer = 0; // steps + 1
    					let offset = vlen * layer;

    					// Bottom faces

    					for ( let i = 0; i < flen; i ++ ) {

    						const face = faces[ i ];
    						f3( face[ 2 ] + offset, face[ 1 ] + offset, face[ 0 ] + offset );

    					}

    					layer = steps + bevelSegments * 2;
    					offset = vlen * layer;

    					// Top faces

    					for ( let i = 0; i < flen; i ++ ) {

    						const face = faces[ i ];
    						f3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset );

    					}

    				} else {

    					// Bottom faces

    					for ( let i = 0; i < flen; i ++ ) {

    						const face = faces[ i ];
    						f3( face[ 2 ], face[ 1 ], face[ 0 ] );

    					}

    					// Top faces

    					for ( let i = 0; i < flen; i ++ ) {

    						const face = faces[ i ];
    						f3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps );

    					}

    				}

    				scope.addGroup( start, verticesArray.length / 3 - start, 0 );

    			}

    			// Create faces for the z-sides of the shape

    			function buildSideFaces() {

    				const start = verticesArray.length / 3;
    				let layeroffset = 0;
    				sidewalls( contour, layeroffset );
    				layeroffset += contour.length;

    				for ( let h = 0, hl = holes.length; h < hl; h ++ ) {

    					const ahole = holes[ h ];
    					sidewalls( ahole, layeroffset );

    					//, true
    					layeroffset += ahole.length;

    				}


    				scope.addGroup( start, verticesArray.length / 3 - start, 1 );


    			}

    			function sidewalls( contour, layeroffset ) {

    				let i = contour.length;

    				while ( -- i >= 0 ) {

    					const j = i;
    					let k = i - 1;
    					if ( k < 0 ) k = contour.length - 1;

    					//console.log('b', i,j, i-1, k,vertices.length);

    					for ( let s = 0, sl = ( steps + bevelSegments * 2 ); s < sl; s ++ ) {

    						const slen1 = vlen * s;
    						const slen2 = vlen * ( s + 1 );

    						const a = layeroffset + j + slen1,
    							b = layeroffset + k + slen1,
    							c = layeroffset + k + slen2,
    							d = layeroffset + j + slen2;

    						f4( a, b, c, d );

    					}

    				}

    			}

    			function v( x, y, z ) {

    				placeholder.push( x );
    				placeholder.push( y );
    				placeholder.push( z );

    			}


    			function f3( a, b, c ) {

    				addVertex( a );
    				addVertex( b );
    				addVertex( c );

    				const nextIndex = verticesArray.length / 3;
    				const uvs = uvgen.generateTopUV( scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1 );

    				addUV( uvs[ 0 ] );
    				addUV( uvs[ 1 ] );
    				addUV( uvs[ 2 ] );

    			}

    			function f4( a, b, c, d ) {

    				addVertex( a );
    				addVertex( b );
    				addVertex( d );

    				addVertex( b );
    				addVertex( c );
    				addVertex( d );


    				const nextIndex = verticesArray.length / 3;
    				const uvs = uvgen.generateSideWallUV( scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1 );

    				addUV( uvs[ 0 ] );
    				addUV( uvs[ 1 ] );
    				addUV( uvs[ 3 ] );

    				addUV( uvs[ 1 ] );
    				addUV( uvs[ 2 ] );
    				addUV( uvs[ 3 ] );

    			}

    			function addVertex( index ) {

    				verticesArray.push( placeholder[ index * 3 + 0 ] );
    				verticesArray.push( placeholder[ index * 3 + 1 ] );
    				verticesArray.push( placeholder[ index * 3 + 2 ] );

    			}


    			function addUV( vector2 ) {

    				uvArray.push( vector2.x );
    				uvArray.push( vector2.y );

    			}

    		}

    	}

    	toJSON() {

    		const data = super.toJSON();

    		const shapes = this.parameters.shapes;
    		const options = this.parameters.options;

    		return toJSON$1( shapes, options, data );

    	}

    	static fromJSON( data, shapes ) {

    		const geometryShapes = [];

    		for ( let j = 0, jl = data.shapes.length; j < jl; j ++ ) {

    			const shape = shapes[ data.shapes[ j ] ];

    			geometryShapes.push( shape );

    		}

    		const extrudePath = data.options.extrudePath;

    		if ( extrudePath !== undefined ) {

    			data.options.extrudePath = new Curves[ extrudePath.type ]().fromJSON( extrudePath );

    		}

    		return new ExtrudeGeometry( geometryShapes, data.options );

    	}

    }

    const WorldUVGenerator = {

    	generateTopUV: function ( geometry, vertices, indexA, indexB, indexC ) {

    		const a_x = vertices[ indexA * 3 ];
    		const a_y = vertices[ indexA * 3 + 1 ];
    		const b_x = vertices[ indexB * 3 ];
    		const b_y = vertices[ indexB * 3 + 1 ];
    		const c_x = vertices[ indexC * 3 ];
    		const c_y = vertices[ indexC * 3 + 1 ];

    		return [
    			new Vector2( a_x, a_y ),
    			new Vector2( b_x, b_y ),
    			new Vector2( c_x, c_y )
    		];

    	},

    	generateSideWallUV: function ( geometry, vertices, indexA, indexB, indexC, indexD ) {

    		const a_x = vertices[ indexA * 3 ];
    		const a_y = vertices[ indexA * 3 + 1 ];
    		const a_z = vertices[ indexA * 3 + 2 ];
    		const b_x = vertices[ indexB * 3 ];
    		const b_y = vertices[ indexB * 3 + 1 ];
    		const b_z = vertices[ indexB * 3 + 2 ];
    		const c_x = vertices[ indexC * 3 ];
    		const c_y = vertices[ indexC * 3 + 1 ];
    		const c_z = vertices[ indexC * 3 + 2 ];
    		const d_x = vertices[ indexD * 3 ];
    		const d_y = vertices[ indexD * 3 + 1 ];
    		const d_z = vertices[ indexD * 3 + 2 ];

    		if ( Math.abs( a_y - b_y ) < Math.abs( a_x - b_x ) ) {

    			return [
    				new Vector2( a_x, 1 - a_z ),
    				new Vector2( b_x, 1 - b_z ),
    				new Vector2( c_x, 1 - c_z ),
    				new Vector2( d_x, 1 - d_z )
    			];

    		} else {

    			return [
    				new Vector2( a_y, 1 - a_z ),
    				new Vector2( b_y, 1 - b_z ),
    				new Vector2( c_y, 1 - c_z ),
    				new Vector2( d_y, 1 - d_z )
    			];

    		}

    	}

    };

    function toJSON$1( shapes, options, data ) {

    	data.shapes = [];

    	if ( Array.isArray( shapes ) ) {

    		for ( let i = 0, l = shapes.length; i < l; i ++ ) {

    			const shape = shapes[ i ];

    			data.shapes.push( shape.uuid );

    		}

    	} else {

    		data.shapes.push( shapes.uuid );

    	}

    	data.options = Object.assign( {}, options );

    	if ( options.extrudePath !== undefined ) data.options.extrudePath = options.extrudePath.toJSON();

    	return data;

    }

    class SphereGeometry extends BufferGeometry {

    	constructor( radius = 1, widthSegments = 32, heightSegments = 16, phiStart = 0, phiLength = Math.PI * 2, thetaStart = 0, thetaLength = Math.PI ) {

    		super();

    		this.type = 'SphereGeometry';

    		this.parameters = {
    			radius: radius,
    			widthSegments: widthSegments,
    			heightSegments: heightSegments,
    			phiStart: phiStart,
    			phiLength: phiLength,
    			thetaStart: thetaStart,
    			thetaLength: thetaLength
    		};

    		widthSegments = Math.max( 3, Math.floor( widthSegments ) );
    		heightSegments = Math.max( 2, Math.floor( heightSegments ) );

    		const thetaEnd = Math.min( thetaStart + thetaLength, Math.PI );

    		let index = 0;
    		const grid = [];

    		const vertex = new Vector3();
    		const normal = new Vector3();

    		// buffers

    		const indices = [];
    		const vertices = [];
    		const normals = [];
    		const uvs = [];

    		// generate vertices, normals and uvs

    		for ( let iy = 0; iy <= heightSegments; iy ++ ) {

    			const verticesRow = [];

    			const v = iy / heightSegments;

    			// special case for the poles

    			let uOffset = 0;

    			if ( iy == 0 && thetaStart == 0 ) {

    				uOffset = 0.5 / widthSegments;

    			} else if ( iy == heightSegments && thetaEnd == Math.PI ) {

    				uOffset = - 0.5 / widthSegments;

    			}

    			for ( let ix = 0; ix <= widthSegments; ix ++ ) {

    				const u = ix / widthSegments;

    				// vertex

    				vertex.x = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );
    				vertex.y = radius * Math.cos( thetaStart + v * thetaLength );
    				vertex.z = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );

    				vertices.push( vertex.x, vertex.y, vertex.z );

    				// normal

    				normal.copy( vertex ).normalize();
    				normals.push( normal.x, normal.y, normal.z );

    				// uv

    				uvs.push( u + uOffset, 1 - v );

    				verticesRow.push( index ++ );

    			}

    			grid.push( verticesRow );

    		}

    		// indices

    		for ( let iy = 0; iy < heightSegments; iy ++ ) {

    			for ( let ix = 0; ix < widthSegments; ix ++ ) {

    				const a = grid[ iy ][ ix + 1 ];
    				const b = grid[ iy ][ ix ];
    				const c = grid[ iy + 1 ][ ix ];
    				const d = grid[ iy + 1 ][ ix + 1 ];

    				if ( iy !== 0 || thetaStart > 0 ) indices.push( a, b, d );
    				if ( iy !== heightSegments - 1 || thetaEnd < Math.PI ) indices.push( b, c, d );

    			}

    		}

    		// build geometry

    		this.setIndex( indices );
    		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
    		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
    		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

    	}

    	static fromJSON( data ) {

    		return new SphereGeometry( data.radius, data.widthSegments, data.heightSegments, data.phiStart, data.phiLength, data.thetaStart, data.thetaLength );

    	}

    }

    class TubeGeometry extends BufferGeometry {

    	constructor( path = new QuadraticBezierCurve3( new Vector3( - 1, - 1, 0 ), new Vector3( - 1, 1, 0 ), new Vector3( 1, 1, 0 ) ), tubularSegments = 64, radius = 1, radialSegments = 8, closed = false ) {

    		super();

    		this.type = 'TubeGeometry';

    		this.parameters = {
    			path: path,
    			tubularSegments: tubularSegments,
    			radius: radius,
    			radialSegments: radialSegments,
    			closed: closed
    		};

    		const frames = path.computeFrenetFrames( tubularSegments, closed );

    		// expose internals

    		this.tangents = frames.tangents;
    		this.normals = frames.normals;
    		this.binormals = frames.binormals;

    		// helper variables

    		const vertex = new Vector3();
    		const normal = new Vector3();
    		const uv = new Vector2();
    		let P = new Vector3();

    		// buffer

    		const vertices = [];
    		const normals = [];
    		const uvs = [];
    		const indices = [];

    		// create buffer data

    		generateBufferData();

    		// build geometry

    		this.setIndex( indices );
    		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
    		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
    		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

    		// functions

    		function generateBufferData() {

    			for ( let i = 0; i < tubularSegments; i ++ ) {

    				generateSegment( i );

    			}

    			// if the geometry is not closed, generate the last row of vertices and normals
    			// at the regular position on the given path
    			//
    			// if the geometry is closed, duplicate the first row of vertices and normals (uvs will differ)

    			generateSegment( ( closed === false ) ? tubularSegments : 0 );

    			// uvs are generated in a separate function.
    			// this makes it easy compute correct values for closed geometries

    			generateUVs();

    			// finally create faces

    			generateIndices();

    		}

    		function generateSegment( i ) {

    			// we use getPointAt to sample evenly distributed points from the given path

    			P = path.getPointAt( i / tubularSegments, P );

    			// retrieve corresponding normal and binormal

    			const N = frames.normals[ i ];
    			const B = frames.binormals[ i ];

    			// generate normals and vertices for the current segment

    			for ( let j = 0; j <= radialSegments; j ++ ) {

    				const v = j / radialSegments * Math.PI * 2;

    				const sin = Math.sin( v );
    				const cos = - Math.cos( v );

    				// normal

    				normal.x = ( cos * N.x + sin * B.x );
    				normal.y = ( cos * N.y + sin * B.y );
    				normal.z = ( cos * N.z + sin * B.z );
    				normal.normalize();

    				normals.push( normal.x, normal.y, normal.z );

    				// vertex

    				vertex.x = P.x + radius * normal.x;
    				vertex.y = P.y + radius * normal.y;
    				vertex.z = P.z + radius * normal.z;

    				vertices.push( vertex.x, vertex.y, vertex.z );

    			}

    		}

    		function generateIndices() {

    			for ( let j = 1; j <= tubularSegments; j ++ ) {

    				for ( let i = 1; i <= radialSegments; i ++ ) {

    					const a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );
    					const b = ( radialSegments + 1 ) * j + ( i - 1 );
    					const c = ( radialSegments + 1 ) * j + i;
    					const d = ( radialSegments + 1 ) * ( j - 1 ) + i;

    					// faces

    					indices.push( a, b, d );
    					indices.push( b, c, d );

    				}

    			}

    		}

    		function generateUVs() {

    			for ( let i = 0; i <= tubularSegments; i ++ ) {

    				for ( let j = 0; j <= radialSegments; j ++ ) {

    					uv.x = i / tubularSegments;
    					uv.y = j / radialSegments;

    					uvs.push( uv.x, uv.y );

    				}

    			}

    		}

    	}

    	toJSON() {

    		const data = super.toJSON();

    		data.path = this.parameters.path.toJSON();

    		return data;

    	}

    	static fromJSON( data ) {

    		// This only works for built-in curves (e.g. CatmullRomCurve3).
    		// User defined curves or instances of CurvePath will not be deserialized.
    		return new TubeGeometry(
    			new Curves[ data.path.type ]().fromJSON( data.path ),
    			data.tubularSegments,
    			data.radius,
    			data.radialSegments,
    			data.closed
    		);

    	}

    }

    class WireframeGeometry extends BufferGeometry {

    	constructor( geometry = null ) {

    		super();

    		this.type = 'WireframeGeometry';

    		this.parameters = {
    			geometry: geometry
    		};

    		if ( geometry !== null ) {

    			// buffer

    			const vertices = [];
    			const edges = new Set();

    			// helper variables

    			const start = new Vector3();
    			const end = new Vector3();

    			if ( geometry.index !== null ) {

    				// indexed BufferGeometry

    				const position = geometry.attributes.position;
    				const indices = geometry.index;
    				let groups = geometry.groups;

    				if ( groups.length === 0 ) {

    					groups = [ { start: 0, count: indices.count, materialIndex: 0 } ];

    				}

    				// create a data structure that contains all edges without duplicates

    				for ( let o = 0, ol = groups.length; o < ol; ++ o ) {

    					const group = groups[ o ];

    					const groupStart = group.start;
    					const groupCount = group.count;

    					for ( let i = groupStart, l = ( groupStart + groupCount ); i < l; i += 3 ) {

    						for ( let j = 0; j < 3; j ++ ) {

    							const index1 = indices.getX( i + j );
    							const index2 = indices.getX( i + ( j + 1 ) % 3 );

    							start.fromBufferAttribute( position, index1 );
    							end.fromBufferAttribute( position, index2 );

    							if ( isUniqueEdge( start, end, edges ) === true ) {

    								vertices.push( start.x, start.y, start.z );
    								vertices.push( end.x, end.y, end.z );

    							}

    						}

    					}

    				}

    			} else {

    				// non-indexed BufferGeometry

    				const position = geometry.attributes.position;

    				for ( let i = 0, l = ( position.count / 3 ); i < l; i ++ ) {

    					for ( let j = 0; j < 3; j ++ ) {

    						// three edges per triangle, an edge is represented as (index1, index2)
    						// e.g. the first triangle has the following edges: (0,1),(1,2),(2,0)

    						const index1 = 3 * i + j;
    						const index2 = 3 * i + ( ( j + 1 ) % 3 );

    						start.fromBufferAttribute( position, index1 );
    						end.fromBufferAttribute( position, index2 );

    						if ( isUniqueEdge( start, end, edges ) === true ) {

    							vertices.push( start.x, start.y, start.z );
    							vertices.push( end.x, end.y, end.z );

    						}

    					}

    				}

    			}

    			// build geometry

    			this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );

    		}

    	}

    }

    function isUniqueEdge( start, end, edges ) {

    	const hash1 = `${start.x},${start.y},${start.z}-${end.x},${end.y},${end.z}`;
    	const hash2 = `${end.x},${end.y},${end.z}-${start.x},${start.y},${start.z}`; // coincident edge

    	if ( edges.has( hash1 ) === true || edges.has( hash2 ) === true ) {

    		return false;

    	} else {

    		edges.add( hash1 );
    		edges.add( hash2 );
    		return true;

    	}

    }

    class MeshPhongMaterial extends Material {

    	constructor( parameters ) {

    		super();

    		this.isMeshPhongMaterial = true;

    		this.type = 'MeshPhongMaterial';

    		this.color = new Color$1( 0xffffff ); // diffuse
    		this.specular = new Color$1( 0x111111 );
    		this.shininess = 30;

    		this.map = null;

    		this.lightMap = null;
    		this.lightMapIntensity = 1.0;

    		this.aoMap = null;
    		this.aoMapIntensity = 1.0;

    		this.emissive = new Color$1( 0x000000 );
    		this.emissiveIntensity = 1.0;
    		this.emissiveMap = null;

    		this.bumpMap = null;
    		this.bumpScale = 1;

    		this.normalMap = null;
    		this.normalMapType = TangentSpaceNormalMap;
    		this.normalScale = new Vector2( 1, 1 );

    		this.displacementMap = null;
    		this.displacementScale = 1;
    		this.displacementBias = 0;

    		this.specularMap = null;

    		this.alphaMap = null;

    		this.envMap = null;
    		this.combine = MultiplyOperation;
    		this.reflectivity = 1;
    		this.refractionRatio = 0.98;

    		this.wireframe = false;
    		this.wireframeLinewidth = 1;
    		this.wireframeLinecap = 'round';
    		this.wireframeLinejoin = 'round';

    		this.flatShading = false;

    		this.fog = true;

    		this.setValues( parameters );

    	}

    	copy( source ) {

    		super.copy( source );

    		this.color.copy( source.color );
    		this.specular.copy( source.specular );
    		this.shininess = source.shininess;

    		this.map = source.map;

    		this.lightMap = source.lightMap;
    		this.lightMapIntensity = source.lightMapIntensity;

    		this.aoMap = source.aoMap;
    		this.aoMapIntensity = source.aoMapIntensity;

    		this.emissive.copy( source.emissive );
    		this.emissiveMap = source.emissiveMap;
    		this.emissiveIntensity = source.emissiveIntensity;

    		this.bumpMap = source.bumpMap;
    		this.bumpScale = source.bumpScale;

    		this.normalMap = source.normalMap;
    		this.normalMapType = source.normalMapType;
    		this.normalScale.copy( source.normalScale );

    		this.displacementMap = source.displacementMap;
    		this.displacementScale = source.displacementScale;
    		this.displacementBias = source.displacementBias;

    		this.specularMap = source.specularMap;

    		this.alphaMap = source.alphaMap;

    		this.envMap = source.envMap;
    		this.combine = source.combine;
    		this.reflectivity = source.reflectivity;
    		this.refractionRatio = source.refractionRatio;

    		this.wireframe = source.wireframe;
    		this.wireframeLinewidth = source.wireframeLinewidth;
    		this.wireframeLinecap = source.wireframeLinecap;
    		this.wireframeLinejoin = source.wireframeLinejoin;

    		this.flatShading = source.flatShading;

    		this.fog = source.fog;

    		return this;

    	}

    }

    class MeshLambertMaterial extends Material {

    	constructor( parameters ) {

    		super();

    		this.isMeshLambertMaterial = true;

    		this.type = 'MeshLambertMaterial';

    		this.color = new Color$1( 0xffffff ); // diffuse

    		this.map = null;

    		this.lightMap = null;
    		this.lightMapIntensity = 1.0;

    		this.aoMap = null;
    		this.aoMapIntensity = 1.0;

    		this.emissive = new Color$1( 0x000000 );
    		this.emissiveIntensity = 1.0;
    		this.emissiveMap = null;

    		this.bumpMap = null;
    		this.bumpScale = 1;

    		this.normalMap = null;
    		this.normalMapType = TangentSpaceNormalMap;
    		this.normalScale = new Vector2( 1, 1 );

    		this.displacementMap = null;
    		this.displacementScale = 1;
    		this.displacementBias = 0;

    		this.specularMap = null;

    		this.alphaMap = null;

    		this.envMap = null;
    		this.combine = MultiplyOperation;
    		this.reflectivity = 1;
    		this.refractionRatio = 0.98;

    		this.wireframe = false;
    		this.wireframeLinewidth = 1;
    		this.wireframeLinecap = 'round';
    		this.wireframeLinejoin = 'round';

    		this.flatShading = false;

    		this.fog = true;

    		this.setValues( parameters );

    	}

    	copy( source ) {

    		super.copy( source );

    		this.color.copy( source.color );

    		this.map = source.map;

    		this.lightMap = source.lightMap;
    		this.lightMapIntensity = source.lightMapIntensity;

    		this.aoMap = source.aoMap;
    		this.aoMapIntensity = source.aoMapIntensity;

    		this.emissive.copy( source.emissive );
    		this.emissiveMap = source.emissiveMap;
    		this.emissiveIntensity = source.emissiveIntensity;

    		this.bumpMap = source.bumpMap;
    		this.bumpScale = source.bumpScale;

    		this.normalMap = source.normalMap;
    		this.normalMapType = source.normalMapType;
    		this.normalScale.copy( source.normalScale );

    		this.displacementMap = source.displacementMap;
    		this.displacementScale = source.displacementScale;
    		this.displacementBias = source.displacementBias;

    		this.specularMap = source.specularMap;

    		this.alphaMap = source.alphaMap;

    		this.envMap = source.envMap;
    		this.combine = source.combine;
    		this.reflectivity = source.reflectivity;
    		this.refractionRatio = source.refractionRatio;

    		this.wireframe = source.wireframe;
    		this.wireframeLinewidth = source.wireframeLinewidth;
    		this.wireframeLinecap = source.wireframeLinecap;
    		this.wireframeLinejoin = source.wireframeLinejoin;

    		this.flatShading = source.flatShading;

    		this.fog = source.fog;

    		return this;

    	}

    }

    const Cache = {

    	enabled: false,

    	files: {},

    	add: function ( key, file ) {

    		if ( this.enabled === false ) return;

    		// console.log( 'THREE.Cache', 'Adding key:', key );

    		this.files[ key ] = file;

    	},

    	get: function ( key ) {

    		if ( this.enabled === false ) return;

    		// console.log( 'THREE.Cache', 'Checking key:', key );

    		return this.files[ key ];

    	},

    	remove: function ( key ) {

    		delete this.files[ key ];

    	},

    	clear: function () {

    		this.files = {};

    	}

    };

    class LoadingManager {

    	constructor( onLoad, onProgress, onError ) {

    		const scope = this;

    		let isLoading = false;
    		let itemsLoaded = 0;
    		let itemsTotal = 0;
    		let urlModifier = undefined;
    		const handlers = [];

    		// Refer to #5689 for the reason why we don't set .onStart
    		// in the constructor

    		this.onStart = undefined;
    		this.onLoad = onLoad;
    		this.onProgress = onProgress;
    		this.onError = onError;

    		this.itemStart = function ( url ) {

    			itemsTotal ++;

    			if ( isLoading === false ) {

    				if ( scope.onStart !== undefined ) {

    					scope.onStart( url, itemsLoaded, itemsTotal );

    				}

    			}

    			isLoading = true;

    		};

    		this.itemEnd = function ( url ) {

    			itemsLoaded ++;

    			if ( scope.onProgress !== undefined ) {

    				scope.onProgress( url, itemsLoaded, itemsTotal );

    			}

    			if ( itemsLoaded === itemsTotal ) {

    				isLoading = false;

    				if ( scope.onLoad !== undefined ) {

    					scope.onLoad();

    				}

    			}

    		};

    		this.itemError = function ( url ) {

    			if ( scope.onError !== undefined ) {

    				scope.onError( url );

    			}

    		};

    		this.resolveURL = function ( url ) {

    			if ( urlModifier ) {

    				return urlModifier( url );

    			}

    			return url;

    		};

    		this.setURLModifier = function ( transform ) {

    			urlModifier = transform;

    			return this;

    		};

    		this.addHandler = function ( regex, loader ) {

    			handlers.push( regex, loader );

    			return this;

    		};

    		this.removeHandler = function ( regex ) {

    			const index = handlers.indexOf( regex );

    			if ( index !== - 1 ) {

    				handlers.splice( index, 2 );

    			}

    			return this;

    		};

    		this.getHandler = function ( file ) {

    			for ( let i = 0, l = handlers.length; i < l; i += 2 ) {

    				const regex = handlers[ i ];
    				const loader = handlers[ i + 1 ];

    				if ( regex.global ) regex.lastIndex = 0; // see #17920

    				if ( regex.test( file ) ) {

    					return loader;

    				}

    			}

    			return null;

    		};

    	}

    }

    const DefaultLoadingManager = /*@__PURE__*/ new LoadingManager();

    class Loader {

    	constructor( manager ) {

    		this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

    		this.crossOrigin = 'anonymous';
    		this.withCredentials = false;
    		this.path = '';
    		this.resourcePath = '';
    		this.requestHeader = {};

    	}

    	load( /* url, onLoad, onProgress, onError */ ) {}

    	loadAsync( url, onProgress ) {

    		const scope = this;

    		return new Promise( function ( resolve, reject ) {

    			scope.load( url, resolve, onProgress, reject );

    		} );

    	}

    	parse( /* data */ ) {}

    	setCrossOrigin( crossOrigin ) {

    		this.crossOrigin = crossOrigin;
    		return this;

    	}

    	setWithCredentials( value ) {

    		this.withCredentials = value;
    		return this;

    	}

    	setPath( path ) {

    		this.path = path;
    		return this;

    	}

    	setResourcePath( resourcePath ) {

    		this.resourcePath = resourcePath;
    		return this;

    	}

    	setRequestHeader( requestHeader ) {

    		this.requestHeader = requestHeader;
    		return this;

    	}

    }

    class ImageLoader extends Loader {

    	constructor( manager ) {

    		super( manager );

    	}

    	load( url, onLoad, onProgress, onError ) {

    		if ( this.path !== undefined ) url = this.path + url;

    		url = this.manager.resolveURL( url );

    		const scope = this;

    		const cached = Cache.get( url );

    		if ( cached !== undefined ) {

    			scope.manager.itemStart( url );

    			setTimeout( function () {

    				if ( onLoad ) onLoad( cached );

    				scope.manager.itemEnd( url );

    			}, 0 );

    			return cached;

    		}

    		const image = createElementNS( 'img' );

    		function onImageLoad() {

    			removeEventListeners();

    			Cache.add( url, this );

    			if ( onLoad ) onLoad( this );

    			scope.manager.itemEnd( url );

    		}

    		function onImageError( event ) {

    			removeEventListeners();

    			if ( onError ) onError( event );

    			scope.manager.itemError( url );
    			scope.manager.itemEnd( url );

    		}

    		function removeEventListeners() {

    			image.removeEventListener( 'load', onImageLoad, false );
    			image.removeEventListener( 'error', onImageError, false );

    		}

    		image.addEventListener( 'load', onImageLoad, false );
    		image.addEventListener( 'error', onImageError, false );

    		if ( url.slice( 0, 5 ) !== 'data:' ) {

    			if ( this.crossOrigin !== undefined ) image.crossOrigin = this.crossOrigin;

    		}

    		scope.manager.itemStart( url );

    		image.src = url;

    		return image;

    	}

    }

    class TextureLoader extends Loader {

    	constructor( manager ) {

    		super( manager );

    	}

    	load( url, onLoad, onProgress, onError ) {

    		const texture = new Texture();

    		const loader = new ImageLoader( this.manager );
    		loader.setCrossOrigin( this.crossOrigin );
    		loader.setPath( this.path );

    		loader.load( url, function ( image ) {

    			texture.image = image;
    			texture.needsUpdate = true;

    			if ( onLoad !== undefined ) {

    				onLoad( texture );

    			}

    		}, onProgress, onError );

    		return texture;

    	}

    }

    class Light extends Object3D {

    	constructor( color, intensity = 1 ) {

    		super();

    		this.isLight = true;

    		this.type = 'Light';

    		this.color = new Color$1( color );
    		this.intensity = intensity;

    	}

    	dispose() {

    		// Empty here in base class; some subclasses override.

    	}

    	copy( source, recursive ) {

    		super.copy( source, recursive );

    		this.color.copy( source.color );
    		this.intensity = source.intensity;

    		return this;

    	}

    	toJSON( meta ) {

    		const data = super.toJSON( meta );

    		data.object.color = this.color.getHex();
    		data.object.intensity = this.intensity;

    		if ( this.groundColor !== undefined ) data.object.groundColor = this.groundColor.getHex();

    		if ( this.distance !== undefined ) data.object.distance = this.distance;
    		if ( this.angle !== undefined ) data.object.angle = this.angle;
    		if ( this.decay !== undefined ) data.object.decay = this.decay;
    		if ( this.penumbra !== undefined ) data.object.penumbra = this.penumbra;

    		if ( this.shadow !== undefined ) data.object.shadow = this.shadow.toJSON();

    		return data;

    	}

    }

    const _projScreenMatrix$1 = /*@__PURE__*/ new Matrix4();
    const _lightPositionWorld$1 = /*@__PURE__*/ new Vector3();
    const _lookTarget$1 = /*@__PURE__*/ new Vector3();

    class LightShadow {

    	constructor( camera ) {

    		this.camera = camera;

    		this.bias = 0;
    		this.normalBias = 0;
    		this.radius = 1;
    		this.blurSamples = 8;

    		this.mapSize = new Vector2( 512, 512 );

    		this.map = null;
    		this.mapPass = null;
    		this.matrix = new Matrix4();

    		this.autoUpdate = true;
    		this.needsUpdate = false;

    		this._frustum = new Frustum();
    		this._frameExtents = new Vector2( 1, 1 );

    		this._viewportCount = 1;

    		this._viewports = [

    			new Vector4( 0, 0, 1, 1 )

    		];

    	}

    	getViewportCount() {

    		return this._viewportCount;

    	}

    	getFrustum() {

    		return this._frustum;

    	}

    	updateMatrices( light ) {

    		const shadowCamera = this.camera;
    		const shadowMatrix = this.matrix;

    		_lightPositionWorld$1.setFromMatrixPosition( light.matrixWorld );
    		shadowCamera.position.copy( _lightPositionWorld$1 );

    		_lookTarget$1.setFromMatrixPosition( light.target.matrixWorld );
    		shadowCamera.lookAt( _lookTarget$1 );
    		shadowCamera.updateMatrixWorld();

    		_projScreenMatrix$1.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );
    		this._frustum.setFromProjectionMatrix( _projScreenMatrix$1 );

    		shadowMatrix.set(
    			0.5, 0.0, 0.0, 0.5,
    			0.0, 0.5, 0.0, 0.5,
    			0.0, 0.0, 0.5, 0.5,
    			0.0, 0.0, 0.0, 1.0
    		);

    		shadowMatrix.multiply( _projScreenMatrix$1 );

    	}

    	getViewport( viewportIndex ) {

    		return this._viewports[ viewportIndex ];

    	}

    	getFrameExtents() {

    		return this._frameExtents;

    	}

    	dispose() {

    		if ( this.map ) {

    			this.map.dispose();

    		}

    		if ( this.mapPass ) {

    			this.mapPass.dispose();

    		}

    	}

    	copy( source ) {

    		this.camera = source.camera.clone();

    		this.bias = source.bias;
    		this.radius = source.radius;

    		this.mapSize.copy( source.mapSize );

    		return this;

    	}

    	clone() {

    		return new this.constructor().copy( this );

    	}

    	toJSON() {

    		const object = {};

    		if ( this.bias !== 0 ) object.bias = this.bias;
    		if ( this.normalBias !== 0 ) object.normalBias = this.normalBias;
    		if ( this.radius !== 1 ) object.radius = this.radius;
    		if ( this.mapSize.x !== 512 || this.mapSize.y !== 512 ) object.mapSize = this.mapSize.toArray();

    		object.camera = this.camera.toJSON( false ).object;
    		delete object.camera.matrix;

    		return object;

    	}

    }

    class DirectionalLightShadow extends LightShadow {

    	constructor() {

    		super( new OrthographicCamera( - 5, 5, 5, - 5, 0.5, 500 ) );

    		this.isDirectionalLightShadow = true;

    	}

    }

    class DirectionalLight extends Light {

    	constructor( color, intensity ) {

    		super( color, intensity );

    		this.isDirectionalLight = true;

    		this.type = 'DirectionalLight';

    		this.position.copy( Object3D.DefaultUp );
    		this.updateMatrix();

    		this.target = new Object3D();

    		this.shadow = new DirectionalLightShadow();

    	}

    	dispose() {

    		this.shadow.dispose();

    	}

    	copy( source ) {

    		super.copy( source );

    		this.target = source.target.clone();
    		this.shadow = source.shadow.clone();

    		return this;

    	}

    }

    class AmbientLight extends Light {

    	constructor( color, intensity ) {

    		super( color, intensity );

    		this.isAmbientLight = true;

    		this.type = 'AmbientLight';

    	}

    }

    class InstancedBufferGeometry extends BufferGeometry {

    	constructor() {

    		super();

    		this.isInstancedBufferGeometry = true;

    		this.type = 'InstancedBufferGeometry';
    		this.instanceCount = Infinity;

    	}

    	copy( source ) {

    		super.copy( source );

    		this.instanceCount = source.instanceCount;

    		return this;

    	}

    	toJSON() {

    		const data = super.toJSON();

    		data.instanceCount = this.instanceCount;

    		data.isInstancedBufferGeometry = true;

    		return data;

    	}

    }

    class Clock {

    	constructor( autoStart = true ) {

    		this.autoStart = autoStart;

    		this.startTime = 0;
    		this.oldTime = 0;
    		this.elapsedTime = 0;

    		this.running = false;

    	}

    	start() {

    		this.startTime = now$2();

    		this.oldTime = this.startTime;
    		this.elapsedTime = 0;
    		this.running = true;

    	}

    	stop() {

    		this.getElapsedTime();
    		this.running = false;
    		this.autoStart = false;

    	}

    	getElapsedTime() {

    		this.getDelta();
    		return this.elapsedTime;

    	}

    	getDelta() {

    		let diff = 0;

    		if ( this.autoStart && ! this.running ) {

    			this.start();
    			return 0;

    		}

    		if ( this.running ) {

    			const newTime = now$2();

    			diff = ( newTime - this.oldTime ) / 1000;
    			this.oldTime = newTime;

    			this.elapsedTime += diff;

    		}

    		return diff;

    	}

    }

    function now$2() {

    	return ( typeof performance === 'undefined' ? Date : performance ).now(); // see #10732

    }

    class InstancedInterleavedBuffer extends InterleavedBuffer {

    	constructor( array, stride, meshPerAttribute = 1 ) {

    		super( array, stride );

    		this.isInstancedInterleavedBuffer = true;

    		this.meshPerAttribute = meshPerAttribute;

    	}

    	copy( source ) {

    		super.copy( source );

    		this.meshPerAttribute = source.meshPerAttribute;

    		return this;

    	}

    	clone( data ) {

    		const ib = super.clone( data );

    		ib.meshPerAttribute = this.meshPerAttribute;

    		return ib;

    	}

    	toJSON( data ) {

    		const json = super.toJSON( data );

    		json.isInstancedInterleavedBuffer = true;
    		json.meshPerAttribute = this.meshPerAttribute;

    		return json;

    	}

    }

    class Raycaster {

    	constructor( origin, direction, near = 0, far = Infinity ) {

    		this.ray = new Ray( origin, direction );
    		// direction is assumed to be normalized (for accurate distance calculations)

    		this.near = near;
    		this.far = far;
    		this.camera = null;
    		this.layers = new Layers();

    		this.params = {
    			Mesh: {},
    			Line: { threshold: 1 },
    			LOD: {},
    			Points: { threshold: 1 },
    			Sprite: {}
    		};

    	}

    	set( origin, direction ) {

    		// direction is assumed to be normalized (for accurate distance calculations)

    		this.ray.set( origin, direction );

    	}

    	setFromCamera( coords, camera ) {

    		if ( camera.isPerspectiveCamera ) {

    			this.ray.origin.setFromMatrixPosition( camera.matrixWorld );
    			this.ray.direction.set( coords.x, coords.y, 0.5 ).unproject( camera ).sub( this.ray.origin ).normalize();
    			this.camera = camera;

    		} else if ( camera.isOrthographicCamera ) {

    			this.ray.origin.set( coords.x, coords.y, ( camera.near + camera.far ) / ( camera.near - camera.far ) ).unproject( camera ); // set origin in plane of camera
    			this.ray.direction.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );
    			this.camera = camera;

    		} else {

    			console.error( 'THREE.Raycaster: Unsupported camera type: ' + camera.type );

    		}

    	}

    	intersectObject( object, recursive = true, intersects = [] ) {

    		intersectObject( object, this, intersects, recursive );

    		intersects.sort( ascSort );

    		return intersects;

    	}

    	intersectObjects( objects, recursive = true, intersects = [] ) {

    		for ( let i = 0, l = objects.length; i < l; i ++ ) {

    			intersectObject( objects[ i ], this, intersects, recursive );

    		}

    		intersects.sort( ascSort );

    		return intersects;

    	}

    }

    function ascSort( a, b ) {

    	return a.distance - b.distance;

    }

    function intersectObject( object, raycaster, intersects, recursive ) {

    	if ( object.layers.test( raycaster.layers ) ) {

    		object.raycast( raycaster, intersects );

    	}

    	if ( recursive === true ) {

    		const children = object.children;

    		for ( let i = 0, l = children.length; i < l; i ++ ) {

    			intersectObject( children[ i ], raycaster, intersects, true );

    		}

    	}

    }

    /**
     * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system
     *
     * The polar angle (phi) is measured from the positive y-axis. The positive y-axis is up.
     * The azimuthal angle (theta) is measured from the positive z-axis.
     */

    class Spherical {

    	constructor( radius = 1, phi = 0, theta = 0 ) {

    		this.radius = radius;
    		this.phi = phi; // polar angle
    		this.theta = theta; // azimuthal angle

    		return this;

    	}

    	set( radius, phi, theta ) {

    		this.radius = radius;
    		this.phi = phi;
    		this.theta = theta;

    		return this;

    	}

    	copy( other ) {

    		this.radius = other.radius;
    		this.phi = other.phi;
    		this.theta = other.theta;

    		return this;

    	}

    	// restrict phi to be between EPS and PI-EPS
    	makeSafe() {

    		const EPS = 0.000001;
    		this.phi = Math.max( EPS, Math.min( Math.PI - EPS, this.phi ) );

    		return this;

    	}

    	setFromVector3( v ) {

    		return this.setFromCartesianCoords( v.x, v.y, v.z );

    	}

    	setFromCartesianCoords( x, y, z ) {

    		this.radius = Math.sqrt( x * x + y * y + z * z );

    		if ( this.radius === 0 ) {

    			this.theta = 0;
    			this.phi = 0;

    		} else {

    			this.theta = Math.atan2( x, z );
    			this.phi = Math.acos( clamp$1( y / this.radius, - 1, 1 ) );

    		}

    		return this;

    	}

    	clone() {

    		return new this.constructor().copy( this );

    	}

    }

    const _startP = /*@__PURE__*/ new Vector3();
    const _startEnd = /*@__PURE__*/ new Vector3();

    class Line3 {

    	constructor( start = new Vector3(), end = new Vector3() ) {

    		this.start = start;
    		this.end = end;

    	}

    	set( start, end ) {

    		this.start.copy( start );
    		this.end.copy( end );

    		return this;

    	}

    	copy( line ) {

    		this.start.copy( line.start );
    		this.end.copy( line.end );

    		return this;

    	}

    	getCenter( target ) {

    		return target.addVectors( this.start, this.end ).multiplyScalar( 0.5 );

    	}

    	delta( target ) {

    		return target.subVectors( this.end, this.start );

    	}

    	distanceSq() {

    		return this.start.distanceToSquared( this.end );

    	}

    	distance() {

    		return this.start.distanceTo( this.end );

    	}

    	at( t, target ) {

    		return this.delta( target ).multiplyScalar( t ).add( this.start );

    	}

    	closestPointToPointParameter( point, clampToLine ) {

    		_startP.subVectors( point, this.start );
    		_startEnd.subVectors( this.end, this.start );

    		const startEnd2 = _startEnd.dot( _startEnd );
    		const startEnd_startP = _startEnd.dot( _startP );

    		let t = startEnd_startP / startEnd2;

    		if ( clampToLine ) {

    			t = clamp$1( t, 0, 1 );

    		}

    		return t;

    	}

    	closestPointToPoint( point, clampToLine, target ) {

    		const t = this.closestPointToPointParameter( point, clampToLine );

    		return this.delta( target ).multiplyScalar( t ).add( this.start );

    	}

    	applyMatrix4( matrix ) {

    		this.start.applyMatrix4( matrix );
    		this.end.applyMatrix4( matrix );

    		return this;

    	}

    	equals( line ) {

    		return line.start.equals( this.start ) && line.end.equals( this.end );

    	}

    	clone() {

    		return new this.constructor().copy( this );

    	}

    }

    class ShapePath {

    	constructor() {

    		this.type = 'ShapePath';

    		this.color = new Color$1();

    		this.subPaths = [];
    		this.currentPath = null;

    	}

    	moveTo( x, y ) {

    		this.currentPath = new Path$1();
    		this.subPaths.push( this.currentPath );
    		this.currentPath.moveTo( x, y );

    		return this;

    	}

    	lineTo( x, y ) {

    		this.currentPath.lineTo( x, y );

    		return this;

    	}

    	quadraticCurveTo( aCPx, aCPy, aX, aY ) {

    		this.currentPath.quadraticCurveTo( aCPx, aCPy, aX, aY );

    		return this;

    	}

    	bezierCurveTo( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {

    		this.currentPath.bezierCurveTo( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY );

    		return this;

    	}

    	splineThru( pts ) {

    		this.currentPath.splineThru( pts );

    		return this;

    	}

    	toShapes( isCCW ) {

    		function toShapesNoHoles( inSubpaths ) {

    			const shapes = [];

    			for ( let i = 0, l = inSubpaths.length; i < l; i ++ ) {

    				const tmpPath = inSubpaths[ i ];

    				const tmpShape = new Shape();
    				tmpShape.curves = tmpPath.curves;

    				shapes.push( tmpShape );

    			}

    			return shapes;

    		}

    		function isPointInsidePolygon( inPt, inPolygon ) {

    			const polyLen = inPolygon.length;

    			// inPt on polygon contour => immediate success    or
    			// toggling of inside/outside at every single! intersection point of an edge
    			//  with the horizontal line through inPt, left of inPt
    			//  not counting lowerY endpoints of edges and whole edges on that line
    			let inside = false;
    			for ( let p = polyLen - 1, q = 0; q < polyLen; p = q ++ ) {

    				let edgeLowPt = inPolygon[ p ];
    				let edgeHighPt = inPolygon[ q ];

    				let edgeDx = edgeHighPt.x - edgeLowPt.x;
    				let edgeDy = edgeHighPt.y - edgeLowPt.y;

    				if ( Math.abs( edgeDy ) > Number.EPSILON ) {

    					// not parallel
    					if ( edgeDy < 0 ) {

    						edgeLowPt = inPolygon[ q ]; edgeDx = - edgeDx;
    						edgeHighPt = inPolygon[ p ]; edgeDy = - edgeDy;

    					}

    					if ( ( inPt.y < edgeLowPt.y ) || ( inPt.y > edgeHighPt.y ) ) 		continue;

    					if ( inPt.y === edgeLowPt.y ) {

    						if ( inPt.x === edgeLowPt.x )		return	true;		// inPt is on contour ?
    						// continue;				// no intersection or edgeLowPt => doesn't count !!!

    					} else {

    						const perpEdge = edgeDy * ( inPt.x - edgeLowPt.x ) - edgeDx * ( inPt.y - edgeLowPt.y );
    						if ( perpEdge === 0 )				return	true;		// inPt is on contour ?
    						if ( perpEdge < 0 ) 				continue;
    						inside = ! inside;		// true intersection left of inPt

    					}

    				} else {

    					// parallel or collinear
    					if ( inPt.y !== edgeLowPt.y ) 		continue;			// parallel
    					// edge lies on the same horizontal line as inPt
    					if ( ( ( edgeHighPt.x <= inPt.x ) && ( inPt.x <= edgeLowPt.x ) ) ||
    						 ( ( edgeLowPt.x <= inPt.x ) && ( inPt.x <= edgeHighPt.x ) ) )		return	true;	// inPt: Point on contour !
    					// continue;

    				}

    			}

    			return	inside;

    		}

    		const isClockWise = ShapeUtils.isClockWise;

    		const subPaths = this.subPaths;
    		if ( subPaths.length === 0 ) return [];

    		let solid, tmpPath, tmpShape;
    		const shapes = [];

    		if ( subPaths.length === 1 ) {

    			tmpPath = subPaths[ 0 ];
    			tmpShape = new Shape();
    			tmpShape.curves = tmpPath.curves;
    			shapes.push( tmpShape );
    			return shapes;

    		}

    		let holesFirst = ! isClockWise( subPaths[ 0 ].getPoints() );
    		holesFirst = isCCW ? ! holesFirst : holesFirst;

    		// console.log("Holes first", holesFirst);

    		const betterShapeHoles = [];
    		const newShapes = [];
    		let newShapeHoles = [];
    		let mainIdx = 0;
    		let tmpPoints;

    		newShapes[ mainIdx ] = undefined;
    		newShapeHoles[ mainIdx ] = [];

    		for ( let i = 0, l = subPaths.length; i < l; i ++ ) {

    			tmpPath = subPaths[ i ];
    			tmpPoints = tmpPath.getPoints();
    			solid = isClockWise( tmpPoints );
    			solid = isCCW ? ! solid : solid;

    			if ( solid ) {

    				if ( ( ! holesFirst ) && ( newShapes[ mainIdx ] ) )	mainIdx ++;

    				newShapes[ mainIdx ] = { s: new Shape(), p: tmpPoints };
    				newShapes[ mainIdx ].s.curves = tmpPath.curves;

    				if ( holesFirst )	mainIdx ++;
    				newShapeHoles[ mainIdx ] = [];

    				//console.log('cw', i);

    			} else {

    				newShapeHoles[ mainIdx ].push( { h: tmpPath, p: tmpPoints[ 0 ] } );

    				//console.log('ccw', i);

    			}

    		}

    		// only Holes? -> probably all Shapes with wrong orientation
    		if ( ! newShapes[ 0 ] )	return	toShapesNoHoles( subPaths );


    		if ( newShapes.length > 1 ) {

    			let ambiguous = false;
    			let toChange = 0;

    			for ( let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {

    				betterShapeHoles[ sIdx ] = [];

    			}

    			for ( let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {

    				const sho = newShapeHoles[ sIdx ];

    				for ( let hIdx = 0; hIdx < sho.length; hIdx ++ ) {

    					const ho = sho[ hIdx ];
    					let hole_unassigned = true;

    					for ( let s2Idx = 0; s2Idx < newShapes.length; s2Idx ++ ) {

    						if ( isPointInsidePolygon( ho.p, newShapes[ s2Idx ].p ) ) {

    							if ( sIdx !== s2Idx )	toChange ++;

    							if ( hole_unassigned ) {

    								hole_unassigned = false;
    								betterShapeHoles[ s2Idx ].push( ho );

    							} else {

    								ambiguous = true;

    							}

    						}

    					}

    					if ( hole_unassigned ) {

    						betterShapeHoles[ sIdx ].push( ho );

    					}

    				}

    			}

    			if ( toChange > 0 && ambiguous === false ) {

    				newShapeHoles = betterShapeHoles;

    			}

    		}

    		let tmpHoles;

    		for ( let i = 0, il = newShapes.length; i < il; i ++ ) {

    			tmpShape = newShapes[ i ].s;
    			shapes.push( tmpShape );
    			tmpHoles = newShapeHoles[ i ];

    			for ( let j = 0, jl = tmpHoles.length; j < jl; j ++ ) {

    				tmpShape.holes.push( tmpHoles[ j ].h );

    			}

    		}

    		//console.log("shape", shapes);

    		return shapes;

    	}

    }

    if ( typeof __THREE_DEVTOOLS__ !== 'undefined' ) {

    	__THREE_DEVTOOLS__.dispatchEvent( new CustomEvent( 'register', { detail: {
    		revision: REVISION,
    	} } ) );

    }

    if ( typeof window !== 'undefined' ) {

    	if ( window.__THREE__ ) {

    		console.warn( 'WARNING: Multiple instances of Three.js being imported.' );

    	} else {

    		window.__THREE__ = REVISION;

    	}

    }

    class CSS2DObject extends Object3D {

    	constructor( element = document.createElement( 'div' ) ) {

    		super();

    		this.isCSS2DObject = true;

    		this.element = element;

    		this.element.style.position = 'absolute';
    		this.element.style.userSelect = 'none';

    		this.element.setAttribute( 'draggable', false );

    		this.addEventListener( 'removed', function () {

    			this.traverse( function ( object ) {

    				if ( object.element instanceof Element && object.element.parentNode !== null ) {

    					object.element.parentNode.removeChild( object.element );

    				}

    			} );

    		} );

    	}

    	copy( source, recursive ) {

    		super.copy( source, recursive );

    		this.element = source.element.cloneNode( true );

    		return this;

    	}

    }

    //

    const _vector$1 = new Vector3();
    const _viewMatrix = new Matrix4();
    const _viewProjectionMatrix = new Matrix4();
    const _a = new Vector3();
    const _b = new Vector3();

    class CSS2DRenderer {

    	constructor( parameters = {} ) {

    		const _this = this;

    		let _width, _height;
    		let _widthHalf, _heightHalf;

    		const cache = {
    			objects: new WeakMap()
    		};

    		const domElement = parameters.element !== undefined ? parameters.element : document.createElement( 'div' );

    		domElement.style.overflow = 'hidden';

    		this.domElement = domElement;

    		this.getSize = function () {

    			return {
    				width: _width,
    				height: _height
    			};

    		};

    		this.render = function ( scene, camera ) {

    			if ( scene.matrixWorldAutoUpdate === true ) scene.updateMatrixWorld();
    			if ( camera.parent === null && camera.matrixWorldAutoUpdate === true ) camera.updateMatrixWorld();

    			_viewMatrix.copy( camera.matrixWorldInverse );
    			_viewProjectionMatrix.multiplyMatrices( camera.projectionMatrix, _viewMatrix );

    			renderObject( scene, scene, camera );
    			zOrder( scene );

    		};

    		this.setSize = function ( width, height ) {

    			_width = width;
    			_height = height;

    			_widthHalf = _width / 2;
    			_heightHalf = _height / 2;

    			domElement.style.width = width + 'px';
    			domElement.style.height = height + 'px';

    		};

    		function renderObject( object, scene, camera ) {

    			if ( object.isCSS2DObject ) {

    				_vector$1.setFromMatrixPosition( object.matrixWorld );
    				_vector$1.applyMatrix4( _viewProjectionMatrix );

    				const visible = ( object.visible === true ) && ( _vector$1.z >= - 1 && _vector$1.z <= 1 ) && ( object.layers.test( camera.layers ) === true );
    				object.element.style.display = ( visible === true ) ? '' : 'none';

    				if ( visible === true ) {

    					object.onBeforeRender( _this, scene, camera );

    					const element = object.element;

    					element.style.transform = 'translate(-50%,-50%) translate(' + ( _vector$1.x * _widthHalf + _widthHalf ) + 'px,' + ( - _vector$1.y * _heightHalf + _heightHalf ) + 'px)';

    					if ( element.parentNode !== domElement ) {

    						domElement.appendChild( element );

    					}

    					object.onAfterRender( _this, scene, camera );

    				}

    				const objectData = {
    					distanceToCameraSquared: getDistanceToSquared( camera, object )
    				};

    				cache.objects.set( object, objectData );

    			}

    			for ( let i = 0, l = object.children.length; i < l; i ++ ) {

    				renderObject( object.children[ i ], scene, camera );

    			}

    		}

    		function getDistanceToSquared( object1, object2 ) {

    			_a.setFromMatrixPosition( object1.matrixWorld );
    			_b.setFromMatrixPosition( object2.matrixWorld );

    			return _a.distanceToSquared( _b );

    		}

    		function filterAndFlatten( scene ) {

    			const result = [];

    			scene.traverse( function ( object ) {

    				if ( object.isCSS2DObject ) result.push( object );

    			} );

    			return result;

    		}

    		function zOrder( scene ) {

    			const sorted = filterAndFlatten( scene ).sort( function ( a, b ) {

    				if ( a.renderOrder !== b.renderOrder ) {

    					return b.renderOrder - a.renderOrder;

    				}

    				const distanceA = cache.objects.get( a ).distanceToCameraSquared;
    				const distanceB = cache.objects.get( b ).distanceToCameraSquared;

    				return distanceA - distanceB;

    			} );

    			const zMax = sorted.length;

    			for ( let i = 0, l = sorted.length; i < l; i ++ ) {

    				sorted[ i ].element.style.zIndex = zMax - i;

    			}

    		}

    	}

    }

    /**
     * Returns a function, that, as long as it continues to be invoked, will not
     * be triggered. The function will be called after it stops being called for
     * N milliseconds. If `immediate` is passed, trigger the function on the
     * leading edge, instead of the trailing. The function also has a property 'clear' 
     * that is a function which will clear the timer to prevent previously scheduled executions. 
     *
     * @source underscore.js
     * @see http://unscriptable.com/2009/03/20/debouncing-javascript-methods/
     * @param {Function} function to wrap
     * @param {Number} timeout in ms (`100`)
     * @param {Boolean} whether to execute at the beginning (`false`)
     * @api public
     */
    function debounce$2(func, wait, immediate){
      var timeout, args, context, timestamp, result;
      if (null == wait) wait = 100;

      function later() {
        var last = Date.now() - timestamp;

        if (last < wait && last >= 0) {
          timeout = setTimeout(later, wait - last);
        } else {
          timeout = null;
          if (!immediate) {
            result = func.apply(context, args);
            context = args = null;
          }
        }
      }
      var debounced = function(){
        context = this;
        args = arguments;
        timestamp = Date.now();
        var callNow = immediate && !timeout;
        if (!timeout) timeout = setTimeout(later, wait);
        if (callNow) {
          result = func.apply(context, args);
          context = args = null;
        }

        return result;
      };

      debounced.clear = function() {
        if (timeout) {
          clearTimeout(timeout);
          timeout = null;
        }
      };
      
      debounced.flush = function() {
        if (timeout) {
          result = func.apply(context, args);
          context = args = null;
          
          clearTimeout(timeout);
          timeout = null;
        }
      };

      return debounced;
    }
    // Adds compatibility for ES modules
    debounce$2.debounce = debounce$2;

    var debounce_1 = debounce$2;

    function _classCallCheck$3(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }

    function _defineProperties$4(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    function _createClass$4(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties$4(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties$4(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", {
        writable: false
      });
      return Constructor;
    }

    function _slicedToArray$6(arr, i) {
      return _arrayWithHoles$6(arr) || _iterableToArrayLimit$6(arr, i) || _unsupportedIterableToArray$7(arr, i) || _nonIterableRest$6();
    }

    function _arrayWithHoles$6(arr) {
      if (Array.isArray(arr)) return arr;
    }

    function _iterableToArrayLimit$6(arr, i) {
      var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

      if (_i == null) return;
      var _arr = [];
      var _n = true;
      var _d = false;

      var _s, _e;

      try {
        for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);

          if (i && _arr.length === i) break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"] != null) _i["return"]();
        } finally {
          if (_d) throw _e;
        }
      }

      return _arr;
    }

    function _unsupportedIterableToArray$7(o, minLen) {
      if (!o) return;
      if (typeof o === "string") return _arrayLikeToArray$7(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor) n = o.constructor.name;
      if (n === "Map" || n === "Set") return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$7(o, minLen);
    }

    function _arrayLikeToArray$7(arr, len) {
      if (len == null || len > arr.length) len = arr.length;

      for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

      return arr2;
    }

    function _nonIterableRest$6() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }

    var Prop = /*#__PURE__*/_createClass$4(function Prop(name, _ref) {
      var _ref$default = _ref["default"],
          defaultVal = _ref$default === void 0 ? null : _ref$default,
          _ref$triggerUpdate = _ref.triggerUpdate,
          triggerUpdate = _ref$triggerUpdate === void 0 ? true : _ref$triggerUpdate,
          _ref$onChange = _ref.onChange,
          onChange = _ref$onChange === void 0 ? function (newVal, state) {} : _ref$onChange;

      _classCallCheck$3(this, Prop);

      this.name = name;
      this.defaultVal = defaultVal;
      this.triggerUpdate = triggerUpdate;
      this.onChange = onChange;
    });

    function index$2 (_ref2) {
      var _ref2$stateInit = _ref2.stateInit,
          stateInit = _ref2$stateInit === void 0 ? function () {
        return {};
      } : _ref2$stateInit,
          _ref2$props = _ref2.props,
          rawProps = _ref2$props === void 0 ? {} : _ref2$props,
          _ref2$methods = _ref2.methods,
          methods = _ref2$methods === void 0 ? {} : _ref2$methods,
          _ref2$aliases = _ref2.aliases,
          aliases = _ref2$aliases === void 0 ? {} : _ref2$aliases,
          _ref2$init = _ref2.init,
          initFn = _ref2$init === void 0 ? function () {} : _ref2$init,
          _ref2$update = _ref2.update,
          updateFn = _ref2$update === void 0 ? function () {} : _ref2$update;
      // Parse props into Prop instances
      var props = Object.keys(rawProps).map(function (propName) {
        return new Prop(propName, rawProps[propName]);
      });
      return function () {
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        // Holds component state
        var state = Object.assign({}, stateInit instanceof Function ? stateInit(options) : stateInit, // Support plain objects for backwards compatibility
        {
          initialised: false
        }); // keeps track of which props triggered an update

        var changedProps = {}; // Component constructor

        function comp(nodeElement) {
          initStatic(nodeElement, options);
          digest();
          return comp;
        }

        var initStatic = function initStatic(nodeElement, options) {
          initFn.call(comp, nodeElement, state, options);
          state.initialised = true;
        };

        var digest = debounce_1(function () {
          if (!state.initialised) {
            return;
          }

          updateFn.call(comp, state, changedProps);
          changedProps = {};
        }, 1); // Getter/setter methods

        props.forEach(function (prop) {
          comp[prop.name] = getSetProp(prop);

          function getSetProp(_ref3) {
            var prop = _ref3.name,
                _ref3$triggerUpdate = _ref3.triggerUpdate,
                redigest = _ref3$triggerUpdate === void 0 ? false : _ref3$triggerUpdate,
                _ref3$onChange = _ref3.onChange,
                onChange = _ref3$onChange === void 0 ? function (newVal, state) {} : _ref3$onChange,
                _ref3$defaultVal = _ref3.defaultVal,
                defaultVal = _ref3$defaultVal === void 0 ? null : _ref3$defaultVal;
            return function (_) {
              var curVal = state[prop];

              if (!arguments.length) {
                return curVal;
              } // Getter mode


              var val = _ === undefined ? defaultVal : _; // pick default if value passed is undefined

              state[prop] = val;
              onChange.call(comp, val, state, curVal); // track changed props

              !changedProps.hasOwnProperty(prop) && (changedProps[prop] = curVal);

              if (redigest) {
                digest();
              }

              return comp;
            };
          }
        }); // Other methods

        Object.keys(methods).forEach(function (methodName) {
          comp[methodName] = function () {
            var _methods$methodName;

            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }

            return (_methods$methodName = methods[methodName]).call.apply(_methods$methodName, [comp, state].concat(args));
          };
        }); // Link aliases

        Object.entries(aliases).forEach(function (_ref4) {
          var _ref5 = _slicedToArray$6(_ref4, 2),
              alias = _ref5[0],
              target = _ref5[1];

          return comp[alias] = comp[target];
        }); // Reset all component props to their default value

        comp.resetProps = function () {
          props.forEach(function (prop) {
            comp[prop.name](prop.defaultVal);
          });
          return comp;
        }; //


        comp.resetProps(); // Apply all prop defaults

        state._rerender = digest; // Expose digest method

        return comp;
      };
    }

    /**
     * The Ease class provides a collection of easing functions for use with tween.js.
     */
    var Easing = {
        Linear: {
            None: function (amount) {
                return amount;
            },
        },
        Quadratic: {
            In: function (amount) {
                return amount * amount;
            },
            Out: function (amount) {
                return amount * (2 - amount);
            },
            InOut: function (amount) {
                if ((amount *= 2) < 1) {
                    return 0.5 * amount * amount;
                }
                return -0.5 * (--amount * (amount - 2) - 1);
            },
        },
        Cubic: {
            In: function (amount) {
                return amount * amount * amount;
            },
            Out: function (amount) {
                return --amount * amount * amount + 1;
            },
            InOut: function (amount) {
                if ((amount *= 2) < 1) {
                    return 0.5 * amount * amount * amount;
                }
                return 0.5 * ((amount -= 2) * amount * amount + 2);
            },
        },
        Quartic: {
            In: function (amount) {
                return amount * amount * amount * amount;
            },
            Out: function (amount) {
                return 1 - --amount * amount * amount * amount;
            },
            InOut: function (amount) {
                if ((amount *= 2) < 1) {
                    return 0.5 * amount * amount * amount * amount;
                }
                return -0.5 * ((amount -= 2) * amount * amount * amount - 2);
            },
        },
        Quintic: {
            In: function (amount) {
                return amount * amount * amount * amount * amount;
            },
            Out: function (amount) {
                return --amount * amount * amount * amount * amount + 1;
            },
            InOut: function (amount) {
                if ((amount *= 2) < 1) {
                    return 0.5 * amount * amount * amount * amount * amount;
                }
                return 0.5 * ((amount -= 2) * amount * amount * amount * amount + 2);
            },
        },
        Sinusoidal: {
            In: function (amount) {
                return 1 - Math.cos((amount * Math.PI) / 2);
            },
            Out: function (amount) {
                return Math.sin((amount * Math.PI) / 2);
            },
            InOut: function (amount) {
                return 0.5 * (1 - Math.cos(Math.PI * amount));
            },
        },
        Exponential: {
            In: function (amount) {
                return amount === 0 ? 0 : Math.pow(1024, amount - 1);
            },
            Out: function (amount) {
                return amount === 1 ? 1 : 1 - Math.pow(2, -10 * amount);
            },
            InOut: function (amount) {
                if (amount === 0) {
                    return 0;
                }
                if (amount === 1) {
                    return 1;
                }
                if ((amount *= 2) < 1) {
                    return 0.5 * Math.pow(1024, amount - 1);
                }
                return 0.5 * (-Math.pow(2, -10 * (amount - 1)) + 2);
            },
        },
        Circular: {
            In: function (amount) {
                return 1 - Math.sqrt(1 - amount * amount);
            },
            Out: function (amount) {
                return Math.sqrt(1 - --amount * amount);
            },
            InOut: function (amount) {
                if ((amount *= 2) < 1) {
                    return -0.5 * (Math.sqrt(1 - amount * amount) - 1);
                }
                return 0.5 * (Math.sqrt(1 - (amount -= 2) * amount) + 1);
            },
        },
        Elastic: {
            In: function (amount) {
                if (amount === 0) {
                    return 0;
                }
                if (amount === 1) {
                    return 1;
                }
                return -Math.pow(2, 10 * (amount - 1)) * Math.sin((amount - 1.1) * 5 * Math.PI);
            },
            Out: function (amount) {
                if (amount === 0) {
                    return 0;
                }
                if (amount === 1) {
                    return 1;
                }
                return Math.pow(2, -10 * amount) * Math.sin((amount - 0.1) * 5 * Math.PI) + 1;
            },
            InOut: function (amount) {
                if (amount === 0) {
                    return 0;
                }
                if (amount === 1) {
                    return 1;
                }
                amount *= 2;
                if (amount < 1) {
                    return -0.5 * Math.pow(2, 10 * (amount - 1)) * Math.sin((amount - 1.1) * 5 * Math.PI);
                }
                return 0.5 * Math.pow(2, -10 * (amount - 1)) * Math.sin((amount - 1.1) * 5 * Math.PI) + 1;
            },
        },
        Back: {
            In: function (amount) {
                var s = 1.70158;
                return amount * amount * ((s + 1) * amount - s);
            },
            Out: function (amount) {
                var s = 1.70158;
                return --amount * amount * ((s + 1) * amount + s) + 1;
            },
            InOut: function (amount) {
                var s = 1.70158 * 1.525;
                if ((amount *= 2) < 1) {
                    return 0.5 * (amount * amount * ((s + 1) * amount - s));
                }
                return 0.5 * ((amount -= 2) * amount * ((s + 1) * amount + s) + 2);
            },
        },
        Bounce: {
            In: function (amount) {
                return 1 - Easing.Bounce.Out(1 - amount);
            },
            Out: function (amount) {
                if (amount < 1 / 2.75) {
                    return 7.5625 * amount * amount;
                }
                else if (amount < 2 / 2.75) {
                    return 7.5625 * (amount -= 1.5 / 2.75) * amount + 0.75;
                }
                else if (amount < 2.5 / 2.75) {
                    return 7.5625 * (amount -= 2.25 / 2.75) * amount + 0.9375;
                }
                else {
                    return 7.5625 * (amount -= 2.625 / 2.75) * amount + 0.984375;
                }
            },
            InOut: function (amount) {
                if (amount < 0.5) {
                    return Easing.Bounce.In(amount * 2) * 0.5;
                }
                return Easing.Bounce.Out(amount * 2 - 1) * 0.5 + 0.5;
            },
        },
    };

    var now;
    // Include a performance.now polyfill.
    // In node.js, use process.hrtime.
    // eslint-disable-next-line
    // @ts-ignore
    if (typeof self === 'undefined' && typeof process !== 'undefined' && process.hrtime) {
        now = function () {
            // eslint-disable-next-line
            // @ts-ignore
            var time = process.hrtime();
            // Convert [seconds, nanoseconds] to milliseconds.
            return time[0] * 1000 + time[1] / 1000000;
        };
    }
    // In a browser, use self.performance.now if it is available.
    else if (typeof self !== 'undefined' && self.performance !== undefined && self.performance.now !== undefined) {
        // This must be bound, because directly assigning this function
        // leads to an invocation exception in Chrome.
        now = self.performance.now.bind(self.performance);
    }
    // Use Date.now if it is available.
    else if (Date.now !== undefined) {
        now = Date.now;
    }
    // Otherwise, use 'new Date().getTime()'.
    else {
        now = function () {
            return new Date().getTime();
        };
    }
    var now$1 = now;

    /**
     * Controlling groups of tweens
     *
     * Using the TWEEN singleton to manage your tweens can cause issues in large apps with many components.
     * In these cases, you may want to create your own smaller groups of tween
     */
    var Group = /** @class */ (function () {
        function Group() {
            this._tweens = {};
            this._tweensAddedDuringUpdate = {};
        }
        Group.prototype.getAll = function () {
            var _this = this;
            return Object.keys(this._tweens).map(function (tweenId) {
                return _this._tweens[tweenId];
            });
        };
        Group.prototype.removeAll = function () {
            this._tweens = {};
        };
        Group.prototype.add = function (tween) {
            this._tweens[tween.getId()] = tween;
            this._tweensAddedDuringUpdate[tween.getId()] = tween;
        };
        Group.prototype.remove = function (tween) {
            delete this._tweens[tween.getId()];
            delete this._tweensAddedDuringUpdate[tween.getId()];
        };
        Group.prototype.update = function (time, preserve) {
            if (time === void 0) { time = now$1(); }
            if (preserve === void 0) { preserve = false; }
            var tweenIds = Object.keys(this._tweens);
            if (tweenIds.length === 0) {
                return false;
            }
            // Tweens are updated in "batches". If you add a new tween during an
            // update, then the new tween will be updated in the next batch.
            // If you remove a tween during an update, it may or may not be updated.
            // However, if the removed tween was added during the current batch,
            // then it will not be updated.
            while (tweenIds.length > 0) {
                this._tweensAddedDuringUpdate = {};
                for (var i = 0; i < tweenIds.length; i++) {
                    var tween = this._tweens[tweenIds[i]];
                    var autoStart = !preserve;
                    if (tween && tween.update(time, autoStart) === false && !preserve) {
                        delete this._tweens[tweenIds[i]];
                    }
                }
                tweenIds = Object.keys(this._tweensAddedDuringUpdate);
            }
            return true;
        };
        return Group;
    }());

    /**
     *
     */
    var Interpolation = {
        Linear: function (v, k) {
            var m = v.length - 1;
            var f = m * k;
            var i = Math.floor(f);
            var fn = Interpolation.Utils.Linear;
            if (k < 0) {
                return fn(v[0], v[1], f);
            }
            if (k > 1) {
                return fn(v[m], v[m - 1], m - f);
            }
            return fn(v[i], v[i + 1 > m ? m : i + 1], f - i);
        },
        Bezier: function (v, k) {
            var b = 0;
            var n = v.length - 1;
            var pw = Math.pow;
            var bn = Interpolation.Utils.Bernstein;
            for (var i = 0; i <= n; i++) {
                b += pw(1 - k, n - i) * pw(k, i) * v[i] * bn(n, i);
            }
            return b;
        },
        CatmullRom: function (v, k) {
            var m = v.length - 1;
            var f = m * k;
            var i = Math.floor(f);
            var fn = Interpolation.Utils.CatmullRom;
            if (v[0] === v[m]) {
                if (k < 0) {
                    i = Math.floor((f = m * (1 + k)));
                }
                return fn(v[(i - 1 + m) % m], v[i], v[(i + 1) % m], v[(i + 2) % m], f - i);
            }
            else {
                if (k < 0) {
                    return v[0] - (fn(v[0], v[0], v[1], v[1], -f) - v[0]);
                }
                if (k > 1) {
                    return v[m] - (fn(v[m], v[m], v[m - 1], v[m - 1], f - m) - v[m]);
                }
                return fn(v[i ? i - 1 : 0], v[i], v[m < i + 1 ? m : i + 1], v[m < i + 2 ? m : i + 2], f - i);
            }
        },
        Utils: {
            Linear: function (p0, p1, t) {
                return (p1 - p0) * t + p0;
            },
            Bernstein: function (n, i) {
                var fc = Interpolation.Utils.Factorial;
                return fc(n) / fc(i) / fc(n - i);
            },
            Factorial: (function () {
                var a = [1];
                return function (n) {
                    var s = 1;
                    if (a[n]) {
                        return a[n];
                    }
                    for (var i = n; i > 1; i--) {
                        s *= i;
                    }
                    a[n] = s;
                    return s;
                };
            })(),
            CatmullRom: function (p0, p1, p2, p3, t) {
                var v0 = (p2 - p0) * 0.5;
                var v1 = (p3 - p1) * 0.5;
                var t2 = t * t;
                var t3 = t * t2;
                return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;
            },
        },
    };

    /**
     * Utils
     */
    var Sequence = /** @class */ (function () {
        function Sequence() {
        }
        Sequence.nextId = function () {
            return Sequence._nextId++;
        };
        Sequence._nextId = 0;
        return Sequence;
    }());

    var mainGroup = new Group();

    /**
     * Tween.js - Licensed under the MIT license
     * https://github.com/tweenjs/tween.js
     * ----------------------------------------------
     *
     * See https://github.com/tweenjs/tween.js/graphs/contributors for the full list of contributors.
     * Thank you all, you're awesome!
     */
    var Tween = /** @class */ (function () {
        function Tween(_object, _group) {
            if (_group === void 0) { _group = mainGroup; }
            this._object = _object;
            this._group = _group;
            this._isPaused = false;
            this._pauseStart = 0;
            this._valuesStart = {};
            this._valuesEnd = {};
            this._valuesStartRepeat = {};
            this._duration = 1000;
            this._initialRepeat = 0;
            this._repeat = 0;
            this._yoyo = false;
            this._isPlaying = false;
            this._reversed = false;
            this._delayTime = 0;
            this._startTime = 0;
            this._easingFunction = Easing.Linear.None;
            this._interpolationFunction = Interpolation.Linear;
            this._chainedTweens = [];
            this._onStartCallbackFired = false;
            this._id = Sequence.nextId();
            this._isChainStopped = false;
            this._goToEnd = false;
        }
        Tween.prototype.getId = function () {
            return this._id;
        };
        Tween.prototype.isPlaying = function () {
            return this._isPlaying;
        };
        Tween.prototype.isPaused = function () {
            return this._isPaused;
        };
        Tween.prototype.to = function (properties, duration) {
            // TODO? restore this, then update the 07_dynamic_to example to set fox
            // tween's to on each update. That way the behavior is opt-in (there's
            // currently no opt-out).
            // for (const prop in properties) this._valuesEnd[prop] = properties[prop]
            this._valuesEnd = Object.create(properties);
            if (duration !== undefined) {
                this._duration = duration;
            }
            return this;
        };
        Tween.prototype.duration = function (d) {
            this._duration = d;
            return this;
        };
        Tween.prototype.start = function (time) {
            if (this._isPlaying) {
                return this;
            }
            // eslint-disable-next-line
            this._group && this._group.add(this);
            this._repeat = this._initialRepeat;
            if (this._reversed) {
                // If we were reversed (f.e. using the yoyo feature) then we need to
                // flip the tween direction back to forward.
                this._reversed = false;
                for (var property in this._valuesStartRepeat) {
                    this._swapEndStartRepeatValues(property);
                    this._valuesStart[property] = this._valuesStartRepeat[property];
                }
            }
            this._isPlaying = true;
            this._isPaused = false;
            this._onStartCallbackFired = false;
            this._isChainStopped = false;
            this._startTime = time !== undefined ? (typeof time === 'string' ? now$1() + parseFloat(time) : time) : now$1();
            this._startTime += this._delayTime;
            this._setupProperties(this._object, this._valuesStart, this._valuesEnd, this._valuesStartRepeat);
            return this;
        };
        Tween.prototype._setupProperties = function (_object, _valuesStart, _valuesEnd, _valuesStartRepeat) {
            for (var property in _valuesEnd) {
                var startValue = _object[property];
                var startValueIsArray = Array.isArray(startValue);
                var propType = startValueIsArray ? 'array' : typeof startValue;
                var isInterpolationList = !startValueIsArray && Array.isArray(_valuesEnd[property]);
                // If `to()` specifies a property that doesn't exist in the source object,
                // we should not set that property in the object
                if (propType === 'undefined' || propType === 'function') {
                    continue;
                }
                // Check if an Array was provided as property value
                if (isInterpolationList) {
                    var endValues = _valuesEnd[property];
                    if (endValues.length === 0) {
                        continue;
                    }
                    // handle an array of relative values
                    endValues = endValues.map(this._handleRelativeValue.bind(this, startValue));
                    // Create a local copy of the Array with the start value at the front
                    _valuesEnd[property] = [startValue].concat(endValues);
                }
                // handle the deepness of the values
                if ((propType === 'object' || startValueIsArray) && startValue && !isInterpolationList) {
                    _valuesStart[property] = startValueIsArray ? [] : {};
                    // eslint-disable-next-line
                    for (var prop in startValue) {
                        // eslint-disable-next-line
                        // @ts-ignore FIXME?
                        _valuesStart[property][prop] = startValue[prop];
                    }
                    _valuesStartRepeat[property] = startValueIsArray ? [] : {}; // TODO? repeat nested values? And yoyo? And array values?
                    // eslint-disable-next-line
                    // @ts-ignore FIXME?
                    this._setupProperties(startValue, _valuesStart[property], _valuesEnd[property], _valuesStartRepeat[property]);
                }
                else {
                    // Save the starting value, but only once.
                    if (typeof _valuesStart[property] === 'undefined') {
                        _valuesStart[property] = startValue;
                    }
                    if (!startValueIsArray) {
                        // eslint-disable-next-line
                        // @ts-ignore FIXME?
                        _valuesStart[property] *= 1.0; // Ensures we're using numbers, not strings
                    }
                    if (isInterpolationList) {
                        // eslint-disable-next-line
                        // @ts-ignore FIXME?
                        _valuesStartRepeat[property] = _valuesEnd[property].slice().reverse();
                    }
                    else {
                        _valuesStartRepeat[property] = _valuesStart[property] || 0;
                    }
                }
            }
        };
        Tween.prototype.stop = function () {
            if (!this._isChainStopped) {
                this._isChainStopped = true;
                this.stopChainedTweens();
            }
            if (!this._isPlaying) {
                return this;
            }
            // eslint-disable-next-line
            this._group && this._group.remove(this);
            this._isPlaying = false;
            this._isPaused = false;
            if (this._onStopCallback) {
                this._onStopCallback(this._object);
            }
            return this;
        };
        Tween.prototype.end = function () {
            this._goToEnd = true;
            this.update(Infinity);
            return this;
        };
        Tween.prototype.pause = function (time) {
            if (time === void 0) { time = now$1(); }
            if (this._isPaused || !this._isPlaying) {
                return this;
            }
            this._isPaused = true;
            this._pauseStart = time;
            // eslint-disable-next-line
            this._group && this._group.remove(this);
            return this;
        };
        Tween.prototype.resume = function (time) {
            if (time === void 0) { time = now$1(); }
            if (!this._isPaused || !this._isPlaying) {
                return this;
            }
            this._isPaused = false;
            this._startTime += time - this._pauseStart;
            this._pauseStart = 0;
            // eslint-disable-next-line
            this._group && this._group.add(this);
            return this;
        };
        Tween.prototype.stopChainedTweens = function () {
            for (var i = 0, numChainedTweens = this._chainedTweens.length; i < numChainedTweens; i++) {
                this._chainedTweens[i].stop();
            }
            return this;
        };
        Tween.prototype.group = function (group) {
            this._group = group;
            return this;
        };
        Tween.prototype.delay = function (amount) {
            this._delayTime = amount;
            return this;
        };
        Tween.prototype.repeat = function (times) {
            this._initialRepeat = times;
            this._repeat = times;
            return this;
        };
        Tween.prototype.repeatDelay = function (amount) {
            this._repeatDelayTime = amount;
            return this;
        };
        Tween.prototype.yoyo = function (yoyo) {
            this._yoyo = yoyo;
            return this;
        };
        Tween.prototype.easing = function (easingFunction) {
            this._easingFunction = easingFunction;
            return this;
        };
        Tween.prototype.interpolation = function (interpolationFunction) {
            this._interpolationFunction = interpolationFunction;
            return this;
        };
        Tween.prototype.chain = function () {
            var tweens = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                tweens[_i] = arguments[_i];
            }
            this._chainedTweens = tweens;
            return this;
        };
        Tween.prototype.onStart = function (callback) {
            this._onStartCallback = callback;
            return this;
        };
        Tween.prototype.onUpdate = function (callback) {
            this._onUpdateCallback = callback;
            return this;
        };
        Tween.prototype.onRepeat = function (callback) {
            this._onRepeatCallback = callback;
            return this;
        };
        Tween.prototype.onComplete = function (callback) {
            this._onCompleteCallback = callback;
            return this;
        };
        Tween.prototype.onStop = function (callback) {
            this._onStopCallback = callback;
            return this;
        };
        /**
         * @returns true if the tween is still playing after the update, false
         * otherwise (calling update on a paused tween still returns true because
         * it is still playing, just paused).
         */
        Tween.prototype.update = function (time, autoStart) {
            if (time === void 0) { time = now$1(); }
            if (autoStart === void 0) { autoStart = true; }
            if (this._isPaused)
                return true;
            var property;
            var elapsed;
            var endTime = this._startTime + this._duration;
            if (!this._goToEnd && !this._isPlaying) {
                if (time > endTime)
                    return false;
                if (autoStart)
                    this.start(time);
            }
            this._goToEnd = false;
            if (time < this._startTime) {
                return true;
            }
            if (this._onStartCallbackFired === false) {
                if (this._onStartCallback) {
                    this._onStartCallback(this._object);
                }
                this._onStartCallbackFired = true;
            }
            elapsed = (time - this._startTime) / this._duration;
            elapsed = this._duration === 0 || elapsed > 1 ? 1 : elapsed;
            var value = this._easingFunction(elapsed);
            // properties transformations
            this._updateProperties(this._object, this._valuesStart, this._valuesEnd, value);
            if (this._onUpdateCallback) {
                this._onUpdateCallback(this._object, elapsed);
            }
            if (elapsed === 1) {
                if (this._repeat > 0) {
                    if (isFinite(this._repeat)) {
                        this._repeat--;
                    }
                    // Reassign starting values, restart by making startTime = now
                    for (property in this._valuesStartRepeat) {
                        if (!this._yoyo && typeof this._valuesEnd[property] === 'string') {
                            this._valuesStartRepeat[property] =
                                // eslint-disable-next-line
                                // @ts-ignore FIXME?
                                this._valuesStartRepeat[property] + parseFloat(this._valuesEnd[property]);
                        }
                        if (this._yoyo) {
                            this._swapEndStartRepeatValues(property);
                        }
                        this._valuesStart[property] = this._valuesStartRepeat[property];
                    }
                    if (this._yoyo) {
                        this._reversed = !this._reversed;
                    }
                    if (this._repeatDelayTime !== undefined) {
                        this._startTime = time + this._repeatDelayTime;
                    }
                    else {
                        this._startTime = time + this._delayTime;
                    }
                    if (this._onRepeatCallback) {
                        this._onRepeatCallback(this._object);
                    }
                    return true;
                }
                else {
                    if (this._onCompleteCallback) {
                        this._onCompleteCallback(this._object);
                    }
                    for (var i = 0, numChainedTweens = this._chainedTweens.length; i < numChainedTweens; i++) {
                        // Make the chained tweens start exactly at the time they should,
                        // even if the `update()` method was called way past the duration of the tween
                        this._chainedTweens[i].start(this._startTime + this._duration);
                    }
                    this._isPlaying = false;
                    return false;
                }
            }
            return true;
        };
        Tween.prototype._updateProperties = function (_object, _valuesStart, _valuesEnd, value) {
            for (var property in _valuesEnd) {
                // Don't update properties that do not exist in the source object
                if (_valuesStart[property] === undefined) {
                    continue;
                }
                var start = _valuesStart[property] || 0;
                var end = _valuesEnd[property];
                var startIsArray = Array.isArray(_object[property]);
                var endIsArray = Array.isArray(end);
                var isInterpolationList = !startIsArray && endIsArray;
                if (isInterpolationList) {
                    _object[property] = this._interpolationFunction(end, value);
                }
                else if (typeof end === 'object' && end) {
                    // eslint-disable-next-line
                    // @ts-ignore FIXME?
                    this._updateProperties(_object[property], start, end, value);
                }
                else {
                    // Parses relative end values with start as base (e.g.: +10, -3)
                    end = this._handleRelativeValue(start, end);
                    // Protect against non numeric properties.
                    if (typeof end === 'number') {
                        // eslint-disable-next-line
                        // @ts-ignore FIXME?
                        _object[property] = start + (end - start) * value;
                    }
                }
            }
        };
        Tween.prototype._handleRelativeValue = function (start, end) {
            if (typeof end !== 'string') {
                return end;
            }
            if (end.charAt(0) === '+' || end.charAt(0) === '-') {
                return start + parseFloat(end);
            }
            else {
                return parseFloat(end);
            }
        };
        Tween.prototype._swapEndStartRepeatValues = function (property) {
            var tmp = this._valuesStartRepeat[property];
            var endValue = this._valuesEnd[property];
            if (typeof endValue === 'string') {
                this._valuesStartRepeat[property] = this._valuesStartRepeat[property] + parseFloat(endValue);
            }
            else {
                this._valuesStartRepeat[property] = this._valuesEnd[property];
            }
            this._valuesEnd[property] = tmp;
        };
        return Tween;
    }());

    var VERSION = '18.6.4';

    /**
     * Tween.js - Licensed under the MIT license
     * https://github.com/tweenjs/tween.js
     * ----------------------------------------------
     *
     * See https://github.com/tweenjs/tween.js/graphs/contributors for the full list of contributors.
     * Thank you all, you're awesome!
     */
    var nextId = Sequence.nextId;
    /**
     * Controlling groups of tweens
     *
     * Using the TWEEN singleton to manage your tweens can cause issues in large apps with many components.
     * In these cases, you may want to create your own smaller groups of tweens.
     */
    var TWEEN = mainGroup;
    // This is the best way to export things in a way that's compatible with both ES
    // Modules and CommonJS, without build hacks, and so as not to break the
    // existing API.
    // https://github.com/rollup/rollup/issues/1961#issuecomment-423037881
    var getAll = TWEEN.getAll.bind(TWEEN);
    var removeAll = TWEEN.removeAll.bind(TWEEN);
    var add = TWEEN.add.bind(TWEEN);
    var remove$1 = TWEEN.remove.bind(TWEEN);
    var update = TWEEN.update.bind(TWEEN);
    var exports$1 = {
        Easing: Easing,
        Group: Group,
        Interpolation: Interpolation,
        now: now$1,
        Sequence: Sequence,
        nextId: nextId,
        Tween: Tween,
        VERSION: VERSION,
        getAll: getAll,
        removeAll: removeAll,
        add: add,
        remove: remove$1,
        update: update,
    };

    var earcut_1 = earcut;
    var _default = earcut;

    function earcut(data, holeIndices, dim) {

        dim = dim || 2;

        var hasHoles = holeIndices && holeIndices.length,
            outerLen = hasHoles ? holeIndices[0] * dim : data.length,
            outerNode = linkedList(data, 0, outerLen, dim, true),
            triangles = [];

        if (!outerNode || outerNode.next === outerNode.prev) return triangles;

        var minX, minY, maxX, maxY, x, y, invSize;

        if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);

        // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
        if (data.length > 80 * dim) {
            minX = maxX = data[0];
            minY = maxY = data[1];

            for (var i = dim; i < outerLen; i += dim) {
                x = data[i];
                y = data[i + 1];
                if (x < minX) minX = x;
                if (y < minY) minY = y;
                if (x > maxX) maxX = x;
                if (y > maxY) maxY = y;
            }

            // minX, minY and invSize are later used to transform coords into integers for z-order calculation
            invSize = Math.max(maxX - minX, maxY - minY);
            invSize = invSize !== 0 ? 32767 / invSize : 0;
        }

        earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);

        return triangles;
    }

    // create a circular doubly linked list from polygon points in the specified winding order
    function linkedList(data, start, end, dim, clockwise) {
        var i, last;

        if (clockwise === (signedArea(data, start, end, dim) > 0)) {
            for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);
        } else {
            for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);
        }

        if (last && equals(last, last.next)) {
            removeNode(last);
            last = last.next;
        }

        return last;
    }

    // eliminate colinear or duplicate points
    function filterPoints(start, end) {
        if (!start) return start;
        if (!end) end = start;

        var p = start,
            again;
        do {
            again = false;

            if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
                removeNode(p);
                p = end = p.prev;
                if (p === p.next) break;
                again = true;

            } else {
                p = p.next;
            }
        } while (again || p !== end);

        return end;
    }

    // main ear slicing loop which triangulates a polygon (given as a linked list)
    function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
        if (!ear) return;

        // interlink polygon nodes in z-order
        if (!pass && invSize) indexCurve(ear, minX, minY, invSize);

        var stop = ear,
            prev, next;

        // iterate through ears, slicing them one by one
        while (ear.prev !== ear.next) {
            prev = ear.prev;
            next = ear.next;

            if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
                // cut off the triangle
                triangles.push(prev.i / dim | 0);
                triangles.push(ear.i / dim | 0);
                triangles.push(next.i / dim | 0);

                removeNode(ear);

                // skipping the next vertex leads to less sliver triangles
                ear = next.next;
                stop = next.next;

                continue;
            }

            ear = next;

            // if we looped through the whole remaining polygon and can't find any more ears
            if (ear === stop) {
                // try filtering points and slicing again
                if (!pass) {
                    earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);

                // if this didn't work, try curing all small self-intersections locally
                } else if (pass === 1) {
                    ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
                    earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);

                // as a last resort, try splitting the remaining polygon into two
                } else if (pass === 2) {
                    splitEarcut(ear, triangles, dim, minX, minY, invSize);
                }

                break;
            }
        }
    }

    // check whether a polygon node forms a valid ear with adjacent nodes
    function isEar(ear) {
        var a = ear.prev,
            b = ear,
            c = ear.next;

        if (area(a, b, c) >= 0) return false; // reflex, can't be an ear

        // now make sure we don't have other points inside the potential ear
        var ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;

        // triangle bbox; min & max are calculated like this for speed
        var x0 = ax < bx ? (ax < cx ? ax : cx) : (bx < cx ? bx : cx),
            y0 = ay < by ? (ay < cy ? ay : cy) : (by < cy ? by : cy),
            x1 = ax > bx ? (ax > cx ? ax : cx) : (bx > cx ? bx : cx),
            y1 = ay > by ? (ay > cy ? ay : cy) : (by > cy ? by : cy);

        var p = c.next;
        while (p !== a) {
            if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 &&
                pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) &&
                area(p.prev, p, p.next) >= 0) return false;
            p = p.next;
        }

        return true;
    }

    function isEarHashed(ear, minX, minY, invSize) {
        var a = ear.prev,
            b = ear,
            c = ear.next;

        if (area(a, b, c) >= 0) return false; // reflex, can't be an ear

        var ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;

        // triangle bbox; min & max are calculated like this for speed
        var x0 = ax < bx ? (ax < cx ? ax : cx) : (bx < cx ? bx : cx),
            y0 = ay < by ? (ay < cy ? ay : cy) : (by < cy ? by : cy),
            x1 = ax > bx ? (ax > cx ? ax : cx) : (bx > cx ? bx : cx),
            y1 = ay > by ? (ay > cy ? ay : cy) : (by > cy ? by : cy);

        // z-order range for the current triangle bbox;
        var minZ = zOrder(x0, y0, minX, minY, invSize),
            maxZ = zOrder(x1, y1, minX, minY, invSize);

        var p = ear.prevZ,
            n = ear.nextZ;

        // look for points inside the triangle in both directions
        while (p && p.z >= minZ && n && n.z <= maxZ) {
            if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c &&
                pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
            p = p.prevZ;

            if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c &&
                pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
            n = n.nextZ;
        }

        // look for remaining points in decreasing z-order
        while (p && p.z >= minZ) {
            if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c &&
                pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
            p = p.prevZ;
        }

        // look for remaining points in increasing z-order
        while (n && n.z <= maxZ) {
            if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c &&
                pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
            n = n.nextZ;
        }

        return true;
    }

    // go through all polygon nodes and cure small local self-intersections
    function cureLocalIntersections(start, triangles, dim) {
        var p = start;
        do {
            var a = p.prev,
                b = p.next.next;

            if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {

                triangles.push(a.i / dim | 0);
                triangles.push(p.i / dim | 0);
                triangles.push(b.i / dim | 0);

                // remove two nodes involved
                removeNode(p);
                removeNode(p.next);

                p = start = b;
            }
            p = p.next;
        } while (p !== start);

        return filterPoints(p);
    }

    // try splitting polygon into two and triangulate them independently
    function splitEarcut(start, triangles, dim, minX, minY, invSize) {
        // look for a valid diagonal that divides the polygon into two
        var a = start;
        do {
            var b = a.next.next;
            while (b !== a.prev) {
                if (a.i !== b.i && isValidDiagonal(a, b)) {
                    // split the polygon in two by the diagonal
                    var c = splitPolygon(a, b);

                    // filter colinear points around the cuts
                    a = filterPoints(a, a.next);
                    c = filterPoints(c, c.next);

                    // run earcut on each half
                    earcutLinked(a, triangles, dim, minX, minY, invSize, 0);
                    earcutLinked(c, triangles, dim, minX, minY, invSize, 0);
                    return;
                }
                b = b.next;
            }
            a = a.next;
        } while (a !== start);
    }

    // link every hole into the outer loop, producing a single-ring polygon without holes
    function eliminateHoles(data, holeIndices, outerNode, dim) {
        var queue = [],
            i, len, start, end, list;

        for (i = 0, len = holeIndices.length; i < len; i++) {
            start = holeIndices[i] * dim;
            end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
            list = linkedList(data, start, end, dim, false);
            if (list === list.next) list.steiner = true;
            queue.push(getLeftmost(list));
        }

        queue.sort(compareX);

        // process holes from left to right
        for (i = 0; i < queue.length; i++) {
            outerNode = eliminateHole(queue[i], outerNode);
        }

        return outerNode;
    }

    function compareX(a, b) {
        return a.x - b.x;
    }

    // find a bridge between vertices that connects hole with an outer ring and and link it
    function eliminateHole(hole, outerNode) {
        var bridge = findHoleBridge(hole, outerNode);
        if (!bridge) {
            return outerNode;
        }

        var bridgeReverse = splitPolygon(bridge, hole);

        // filter collinear points around the cuts
        filterPoints(bridgeReverse, bridgeReverse.next);
        return filterPoints(bridge, bridge.next);
    }

    // David Eberly's algorithm for finding a bridge between hole and outer polygon
    function findHoleBridge(hole, outerNode) {
        var p = outerNode,
            hx = hole.x,
            hy = hole.y,
            qx = -Infinity,
            m;

        // find a segment intersected by a ray from the hole's leftmost point to the left;
        // segment's endpoint with lesser x will be potential connection point
        do {
            if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
                var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
                if (x <= hx && x > qx) {
                    qx = x;
                    m = p.x < p.next.x ? p : p.next;
                    if (x === hx) return m; // hole touches outer segment; pick leftmost endpoint
                }
            }
            p = p.next;
        } while (p !== outerNode);

        if (!m) return null;

        // look for points inside the triangle of hole point, segment intersection and endpoint;
        // if there are no points found, we have a valid connection;
        // otherwise choose the point of the minimum angle with the ray as connection point

        var stop = m,
            mx = m.x,
            my = m.y,
            tanMin = Infinity,
            tan;

        p = m;

        do {
            if (hx >= p.x && p.x >= mx && hx !== p.x &&
                    pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {

                tan = Math.abs(hy - p.y) / (hx - p.x); // tangential

                if (locallyInside(p, hole) &&
                    (tan < tanMin || (tan === tanMin && (p.x > m.x || (p.x === m.x && sectorContainsSector(m, p)))))) {
                    m = p;
                    tanMin = tan;
                }
            }

            p = p.next;
        } while (p !== stop);

        return m;
    }

    // whether sector in vertex m contains sector in vertex p in the same coordinates
    function sectorContainsSector(m, p) {
        return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;
    }

    // interlink polygon nodes in z-order
    function indexCurve(start, minX, minY, invSize) {
        var p = start;
        do {
            if (p.z === 0) p.z = zOrder(p.x, p.y, minX, minY, invSize);
            p.prevZ = p.prev;
            p.nextZ = p.next;
            p = p.next;
        } while (p !== start);

        p.prevZ.nextZ = null;
        p.prevZ = null;

        sortLinked(p);
    }

    // Simon Tatham's linked list merge sort algorithm
    // http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
    function sortLinked(list) {
        var i, p, q, e, tail, numMerges, pSize, qSize,
            inSize = 1;

        do {
            p = list;
            list = null;
            tail = null;
            numMerges = 0;

            while (p) {
                numMerges++;
                q = p;
                pSize = 0;
                for (i = 0; i < inSize; i++) {
                    pSize++;
                    q = q.nextZ;
                    if (!q) break;
                }
                qSize = inSize;

                while (pSize > 0 || (qSize > 0 && q)) {

                    if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
                        e = p;
                        p = p.nextZ;
                        pSize--;
                    } else {
                        e = q;
                        q = q.nextZ;
                        qSize--;
                    }

                    if (tail) tail.nextZ = e;
                    else list = e;

                    e.prevZ = tail;
                    tail = e;
                }

                p = q;
            }

            tail.nextZ = null;
            inSize *= 2;

        } while (numMerges > 1);

        return list;
    }

    // z-order of a point given coords and inverse of the longer side of data bbox
    function zOrder(x, y, minX, minY, invSize) {
        // coords are transformed into non-negative 15-bit integer range
        x = (x - minX) * invSize | 0;
        y = (y - minY) * invSize | 0;

        x = (x | (x << 8)) & 0x00FF00FF;
        x = (x | (x << 4)) & 0x0F0F0F0F;
        x = (x | (x << 2)) & 0x33333333;
        x = (x | (x << 1)) & 0x55555555;

        y = (y | (y << 8)) & 0x00FF00FF;
        y = (y | (y << 4)) & 0x0F0F0F0F;
        y = (y | (y << 2)) & 0x33333333;
        y = (y | (y << 1)) & 0x55555555;

        return x | (y << 1);
    }

    // find the leftmost node of a polygon ring
    function getLeftmost(start) {
        var p = start,
            leftmost = start;
        do {
            if (p.x < leftmost.x || (p.x === leftmost.x && p.y < leftmost.y)) leftmost = p;
            p = p.next;
        } while (p !== start);

        return leftmost;
    }

    // check if a point lies within a convex triangle
    function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
        return (cx - px) * (ay - py) >= (ax - px) * (cy - py) &&
               (ax - px) * (by - py) >= (bx - px) * (ay - py) &&
               (bx - px) * (cy - py) >= (cx - px) * (by - py);
    }

    // check if a diagonal between two polygon nodes is valid (lies in polygon interior)
    function isValidDiagonal(a, b) {
        return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && // dones't intersect other edges
               (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && // locally visible
                (area(a.prev, a, b.prev) || area(a, b.prev, b)) || // does not create opposite-facing sectors
                equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0); // special zero-length case
    }

    // signed area of a triangle
    function area(p, q, r) {
        return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
    }

    // check if two points are equal
    function equals(p1, p2) {
        return p1.x === p2.x && p1.y === p2.y;
    }

    // check if two segments intersect
    function intersects(p1, q1, p2, q2) {
        var o1 = sign$3(area(p1, q1, p2));
        var o2 = sign$3(area(p1, q1, q2));
        var o3 = sign$3(area(p2, q2, p1));
        var o4 = sign$3(area(p2, q2, q1));

        if (o1 !== o2 && o3 !== o4) return true; // general case

        if (o1 === 0 && onSegment(p1, p2, q1)) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1
        if (o2 === 0 && onSegment(p1, q2, q1)) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1
        if (o3 === 0 && onSegment(p2, p1, q2)) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2
        if (o4 === 0 && onSegment(p2, q1, q2)) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2

        return false;
    }

    // for collinear points p, q, r, check if point q lies on segment pr
    function onSegment(p, q, r) {
        return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
    }

    function sign$3(num) {
        return num > 0 ? 1 : num < 0 ? -1 : 0;
    }

    // check if a polygon diagonal intersects any polygon segments
    function intersectsPolygon(a, b) {
        var p = a;
        do {
            if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&
                    intersects(p, p.next, a, b)) return true;
            p = p.next;
        } while (p !== a);

        return false;
    }

    // check if a polygon diagonal is locally inside the polygon
    function locallyInside(a, b) {
        return area(a.prev, a, a.next) < 0 ?
            area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 :
            area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
    }

    // check if the middle point of a polygon diagonal is inside the polygon
    function middleInside(a, b) {
        var p = a,
            inside = false,
            px = (a.x + b.x) / 2,
            py = (a.y + b.y) / 2;
        do {
            if (((p.y > py) !== (p.next.y > py)) && p.next.y !== p.y &&
                    (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x))
                inside = !inside;
            p = p.next;
        } while (p !== a);

        return inside;
    }

    // link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
    // if one belongs to the outer ring and another to a hole, it merges it into a single ring
    function splitPolygon(a, b) {
        var a2 = new Node(a.i, a.x, a.y),
            b2 = new Node(b.i, b.x, b.y),
            an = a.next,
            bp = b.prev;

        a.next = b;
        b.prev = a;

        a2.next = an;
        an.prev = a2;

        b2.next = a2;
        a2.prev = b2;

        bp.next = b2;
        b2.prev = bp;

        return b2;
    }

    // create a node and optionally link it with previous one (in a circular doubly linked list)
    function insertNode(i, x, y, last) {
        var p = new Node(i, x, y);

        if (!last) {
            p.prev = p;
            p.next = p;

        } else {
            p.next = last.next;
            p.prev = last;
            last.next.prev = p;
            last.next = p;
        }
        return p;
    }

    function removeNode(p) {
        p.next.prev = p.prev;
        p.prev.next = p.next;

        if (p.prevZ) p.prevZ.nextZ = p.nextZ;
        if (p.nextZ) p.nextZ.prevZ = p.prevZ;
    }

    function Node(i, x, y) {
        // vertex index in coordinates array
        this.i = i;

        // vertex coordinates
        this.x = x;
        this.y = y;

        // previous and next vertex nodes in a polygon ring
        this.prev = null;
        this.next = null;

        // z-order curve value
        this.z = 0;

        // previous and next nodes in z-order
        this.prevZ = null;
        this.nextZ = null;

        // indicates whether this is a steiner point
        this.steiner = false;
    }

    // return a percentage difference between the polygon area and its triangulation area;
    // used to verify correctness of triangulation
    earcut.deviation = function (data, holeIndices, dim, triangles) {
        var hasHoles = holeIndices && holeIndices.length;
        var outerLen = hasHoles ? holeIndices[0] * dim : data.length;

        var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));
        if (hasHoles) {
            for (var i = 0, len = holeIndices.length; i < len; i++) {
                var start = holeIndices[i] * dim;
                var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
                polygonArea -= Math.abs(signedArea(data, start, end, dim));
            }
        }

        var trianglesArea = 0;
        for (i = 0; i < triangles.length; i += 3) {
            var a = triangles[i] * dim;
            var b = triangles[i + 1] * dim;
            var c = triangles[i + 2] * dim;
            trianglesArea += Math.abs(
                (data[a] - data[c]) * (data[b + 1] - data[a + 1]) -
                (data[a] - data[b]) * (data[c + 1] - data[a + 1]));
        }

        return polygonArea === 0 && trianglesArea === 0 ? 0 :
            Math.abs((trianglesArea - polygonArea) / polygonArea);
    };

    function signedArea(data, start, end, dim) {
        var sum = 0;
        for (var i = start, j = end - dim; i < end; i += dim) {
            sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
            j = i;
        }
        return sum;
    }

    // turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form Earcut accepts
    earcut.flatten = function (data) {
        var dim = data[0][0].length,
            result = {vertices: [], holes: [], dimensions: dim},
            holeIndex = 0;

        for (var i = 0; i < data.length; i++) {
            for (var j = 0; j < data[i].length; j++) {
                for (var d = 0; d < dim; d++) result.vertices.push(data[i][j][d]);
            }
            if (i > 0) {
                holeIndex += data[i - 1].length;
                result.holes.push(holeIndex);
            }
        }
        return result;
    };
    earcut_1.default = _default;

    function ascending(a, b) {
      return a == null || b == null ? NaN : a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
    }

    function descending(a, b) {
      return a == null || b == null ? NaN
        : b < a ? -1
        : b > a ? 1
        : b >= a ? 0
        : NaN;
    }

    function bisector(f) {
      let compare1, compare2, delta;

      // If an accessor is specified, promote it to a comparator. In this case we
      // can test whether the search value is (self-) comparable. We can’t do this
      // for a comparator (except for specific, known comparators) because we can’t
      // tell if the comparator is symmetric, and an asymmetric comparator can’t be
      // used to test whether a single value is comparable.
      if (f.length !== 2) {
        compare1 = ascending;
        compare2 = (d, x) => ascending(f(d), x);
        delta = (d, x) => f(d) - x;
      } else {
        compare1 = f === ascending || f === descending ? f : zero$1;
        compare2 = f;
        delta = f;
      }

      function left(a, x, lo = 0, hi = a.length) {
        if (lo < hi) {
          if (compare1(x, x) !== 0) return hi;
          do {
            const mid = (lo + hi) >>> 1;
            if (compare2(a[mid], x) < 0) lo = mid + 1;
            else hi = mid;
          } while (lo < hi);
        }
        return lo;
      }

      function right(a, x, lo = 0, hi = a.length) {
        if (lo < hi) {
          if (compare1(x, x) !== 0) return hi;
          do {
            const mid = (lo + hi) >>> 1;
            if (compare2(a[mid], x) <= 0) lo = mid + 1;
            else hi = mid;
          } while (lo < hi);
        }
        return lo;
      }

      function center(a, x, lo = 0, hi = a.length) {
        const i = left(a, x, lo, hi - 1);
        return i > lo && delta(a[i - 1], x) > -delta(a[i], x) ? i - 1 : i;
      }

      return {left, center, right};
    }

    function zero$1() {
      return 0;
    }

    function number$1(x) {
      return x === null ? NaN : +x;
    }

    const ascendingBisect = bisector(ascending);
    const bisectRight = ascendingBisect.right;
    bisector(number$1).center;
    var bisect = bisectRight;

    function extent(values, valueof) {
      let min;
      let max;
      if (valueof === undefined) {
        for (const value of values) {
          if (value != null) {
            if (min === undefined) {
              if (value >= value) min = max = value;
            } else {
              if (min > value) min = value;
              if (max < value) max = value;
            }
          }
        }
      } else {
        let index = -1;
        for (let value of values) {
          if ((value = valueof(value, ++index, values)) != null) {
            if (min === undefined) {
              if (value >= value) min = max = value;
            } else {
              if (min > value) min = value;
              if (max < value) max = value;
            }
          }
        }
      }
      return [min, max];
    }

    // https://github.com/python/cpython/blob/a74eea238f5baba15797e2e8b570d153bc8690a7/Modules/mathmodule.c#L1423
    class Adder {
      constructor() {
        this._partials = new Float64Array(32);
        this._n = 0;
      }
      add(x) {
        const p = this._partials;
        let i = 0;
        for (let j = 0; j < this._n && j < 32; j++) {
          const y = p[j],
            hi = x + y,
            lo = Math.abs(x) < Math.abs(y) ? x - (hi - y) : y - (hi - x);
          if (lo) p[i++] = lo;
          x = hi;
        }
        p[i] = x;
        this._n = i + 1;
        return this;
      }
      valueOf() {
        const p = this._partials;
        let n = this._n, x, y, lo, hi = 0;
        if (n > 0) {
          hi = p[--n];
          while (n > 0) {
            x = hi;
            y = p[--n];
            hi = x + y;
            lo = y - (hi - x);
            if (lo) break;
          }
          if (n > 0 && ((lo < 0 && p[n - 1] < 0) || (lo > 0 && p[n - 1] > 0))) {
            y = lo * 2;
            x = hi + y;
            if (y == x - hi) hi = x;
          }
        }
        return hi;
      }
    }

    var e10 = Math.sqrt(50),
        e5 = Math.sqrt(10),
        e2 = Math.sqrt(2);

    function ticks(start, stop, count) {
      var reverse,
          i = -1,
          n,
          ticks,
          step;

      stop = +stop, start = +start, count = +count;
      if (start === stop && count > 0) return [start];
      if (reverse = stop < start) n = start, start = stop, stop = n;
      if ((step = tickIncrement(start, stop, count)) === 0 || !isFinite(step)) return [];

      if (step > 0) {
        let r0 = Math.round(start / step), r1 = Math.round(stop / step);
        if (r0 * step < start) ++r0;
        if (r1 * step > stop) --r1;
        ticks = new Array(n = r1 - r0 + 1);
        while (++i < n) ticks[i] = (r0 + i) * step;
      } else {
        step = -step;
        let r0 = Math.round(start * step), r1 = Math.round(stop * step);
        if (r0 / step < start) ++r0;
        if (r1 / step > stop) --r1;
        ticks = new Array(n = r1 - r0 + 1);
        while (++i < n) ticks[i] = (r0 + i) / step;
      }

      if (reverse) ticks.reverse();

      return ticks;
    }

    function tickIncrement(start, stop, count) {
      var step = (stop - start) / Math.max(0, count),
          power = Math.floor(Math.log(step) / Math.LN10),
          error = step / Math.pow(10, power);
      return power >= 0
          ? (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1) * Math.pow(10, power)
          : -Math.pow(10, -power) / (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1);
    }

    function tickStep(start, stop, count) {
      var step0 = Math.abs(stop - start) / Math.max(0, count),
          step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)),
          error = step0 / step1;
      if (error >= e10) step1 *= 10;
      else if (error >= e5) step1 *= 5;
      else if (error >= e2) step1 *= 2;
      return stop < start ? -step1 : step1;
    }

    function mean(values, valueof) {
      let count = 0;
      let sum = 0;
      if (valueof === undefined) {
        for (let value of values) {
          if (value != null && (value = +value) >= value) {
            ++count, sum += value;
          }
        }
      } else {
        let index = -1;
        for (let value of values) {
          if ((value = valueof(value, ++index, values)) != null && (value = +value) >= value) {
            ++count, sum += value;
          }
        }
      }
      if (count) return sum / count;
    }

    function* flatten(arrays) {
      for (const array of arrays) {
        yield* array;
      }
    }

    function merge$2(arrays) {
      return Array.from(flatten(arrays));
    }

    function range$1(start, stop, step) {
      start = +start, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step;

      var i = -1,
          n = Math.max(0, Math.ceil((stop - start) / step)) | 0,
          range = new Array(n);

      while (++i < n) {
        range[i] = start + i * step;
      }

      return range;
    }

    var epsilon$2 = 1e-6;
    var epsilon2 = 1e-12;
    var pi$1 = Math.PI;
    var halfPi$1 = pi$1 / 2;
    var quarterPi = pi$1 / 4;
    var tau$1 = pi$1 * 2;

    var degrees$1 = 180 / pi$1;
    var radians$1 = pi$1 / 180;

    var abs$1 = Math.abs;
    var atan = Math.atan;
    var atan2$1 = Math.atan2;
    var cos$1 = Math.cos;
    var ceil$1 = Math.ceil;
    var hypot = Math.hypot;
    var sin$1 = Math.sin;
    var sign$2 = Math.sign || function(x) { return x > 0 ? 1 : x < 0 ? -1 : 0; };
    var sqrt$1 = Math.sqrt;

    function acos(x) {
      return x > 1 ? 0 : x < -1 ? pi$1 : Math.acos(x);
    }

    function asin$1(x) {
      return x > 1 ? halfPi$1 : x < -1 ? -halfPi$1 : Math.asin(x);
    }

    function haversin(x) {
      return (x = sin$1(x / 2)) * x;
    }

    function noop$1() {}

    function streamGeometry(geometry, stream) {
      if (geometry && streamGeometryType.hasOwnProperty(geometry.type)) {
        streamGeometryType[geometry.type](geometry, stream);
      }
    }

    var streamObjectType = {
      Feature: function(object, stream) {
        streamGeometry(object.geometry, stream);
      },
      FeatureCollection: function(object, stream) {
        var features = object.features, i = -1, n = features.length;
        while (++i < n) streamGeometry(features[i].geometry, stream);
      }
    };

    var streamGeometryType = {
      Sphere: function(object, stream) {
        stream.sphere();
      },
      Point: function(object, stream) {
        object = object.coordinates;
        stream.point(object[0], object[1], object[2]);
      },
      MultiPoint: function(object, stream) {
        var coordinates = object.coordinates, i = -1, n = coordinates.length;
        while (++i < n) object = coordinates[i], stream.point(object[0], object[1], object[2]);
      },
      LineString: function(object, stream) {
        streamLine(object.coordinates, stream, 0);
      },
      MultiLineString: function(object, stream) {
        var coordinates = object.coordinates, i = -1, n = coordinates.length;
        while (++i < n) streamLine(coordinates[i], stream, 0);
      },
      Polygon: function(object, stream) {
        streamPolygon(object.coordinates, stream);
      },
      MultiPolygon: function(object, stream) {
        var coordinates = object.coordinates, i = -1, n = coordinates.length;
        while (++i < n) streamPolygon(coordinates[i], stream);
      },
      GeometryCollection: function(object, stream) {
        var geometries = object.geometries, i = -1, n = geometries.length;
        while (++i < n) streamGeometry(geometries[i], stream);
      }
    };

    function streamLine(coordinates, stream, closed) {
      var i = -1, n = coordinates.length - closed, coordinate;
      stream.lineStart();
      while (++i < n) coordinate = coordinates[i], stream.point(coordinate[0], coordinate[1], coordinate[2]);
      stream.lineEnd();
    }

    function streamPolygon(coordinates, stream) {
      var i = -1, n = coordinates.length;
      stream.polygonStart();
      while (++i < n) streamLine(coordinates[i], stream, 1);
      stream.polygonEnd();
    }

    function geoStream(object, stream) {
      if (object && streamObjectType.hasOwnProperty(object.type)) {
        streamObjectType[object.type](object, stream);
      } else {
        streamGeometry(object, stream);
      }
    }

    var areaRingSum = new Adder();

    // hello?

    var areaSum = new Adder(),
        lambda00$2,
        phi00$2,
        lambda0$2,
        cosPhi0$1,
        sinPhi0$1;

    var areaStream = {
      point: noop$1,
      lineStart: noop$1,
      lineEnd: noop$1,
      polygonStart: function() {
        areaRingSum = new Adder();
        areaStream.lineStart = areaRingStart;
        areaStream.lineEnd = areaRingEnd;
      },
      polygonEnd: function() {
        var areaRing = +areaRingSum;
        areaSum.add(areaRing < 0 ? tau$1 + areaRing : areaRing);
        this.lineStart = this.lineEnd = this.point = noop$1;
      },
      sphere: function() {
        areaSum.add(tau$1);
      }
    };

    function areaRingStart() {
      areaStream.point = areaPointFirst;
    }

    function areaRingEnd() {
      areaPoint(lambda00$2, phi00$2);
    }

    function areaPointFirst(lambda, phi) {
      areaStream.point = areaPoint;
      lambda00$2 = lambda, phi00$2 = phi;
      lambda *= radians$1, phi *= radians$1;
      lambda0$2 = lambda, cosPhi0$1 = cos$1(phi = phi / 2 + quarterPi), sinPhi0$1 = sin$1(phi);
    }

    function areaPoint(lambda, phi) {
      lambda *= radians$1, phi *= radians$1;
      phi = phi / 2 + quarterPi; // half the angular distance from south pole

      // Spherical excess E for a spherical triangle with vertices: south pole,
      // previous point, current point.  Uses a formula derived from Cagnoli’s
      // theorem.  See Todhunter, Spherical Trig. (1871), Sec. 103, Eq. (2).
      var dLambda = lambda - lambda0$2,
          sdLambda = dLambda >= 0 ? 1 : -1,
          adLambda = sdLambda * dLambda,
          cosPhi = cos$1(phi),
          sinPhi = sin$1(phi),
          k = sinPhi0$1 * sinPhi,
          u = cosPhi0$1 * cosPhi + k * cos$1(adLambda),
          v = k * sdLambda * sin$1(adLambda);
      areaRingSum.add(atan2$1(v, u));

      // Advance the previous points.
      lambda0$2 = lambda, cosPhi0$1 = cosPhi, sinPhi0$1 = sinPhi;
    }

    function spherical$1(cartesian) {
      return [atan2$1(cartesian[1], cartesian[0]), asin$1(cartesian[2])];
    }

    function cartesian$1(spherical) {
      var lambda = spherical[0], phi = spherical[1], cosPhi = cos$1(phi);
      return [cosPhi * cos$1(lambda), cosPhi * sin$1(lambda), sin$1(phi)];
    }

    function cartesianDot$1(a, b) {
      return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
    }

    function cartesianCross$1(a, b) {
      return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]];
    }

    // TODO return a
    function cartesianAddInPlace(a, b) {
      a[0] += b[0], a[1] += b[1], a[2] += b[2];
    }

    function cartesianScale(vector, k) {
      return [vector[0] * k, vector[1] * k, vector[2] * k];
    }

    // TODO return d
    function cartesianNormalizeInPlace(d) {
      var l = sqrt$1(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);
      d[0] /= l, d[1] /= l, d[2] /= l;
    }

    var lambda0$1, phi0, lambda1, phi1, // bounds
        lambda2, // previous lambda-coordinate
        lambda00$1, phi00$1, // first point
        p0, // previous 3D point
        deltaSum,
        ranges,
        range;

    var boundsStream$2 = {
      point: boundsPoint$1,
      lineStart: boundsLineStart,
      lineEnd: boundsLineEnd,
      polygonStart: function() {
        boundsStream$2.point = boundsRingPoint;
        boundsStream$2.lineStart = boundsRingStart;
        boundsStream$2.lineEnd = boundsRingEnd;
        deltaSum = new Adder();
        areaStream.polygonStart();
      },
      polygonEnd: function() {
        areaStream.polygonEnd();
        boundsStream$2.point = boundsPoint$1;
        boundsStream$2.lineStart = boundsLineStart;
        boundsStream$2.lineEnd = boundsLineEnd;
        if (areaRingSum < 0) lambda0$1 = -(lambda1 = 180), phi0 = -(phi1 = 90);
        else if (deltaSum > epsilon$2) phi1 = 90;
        else if (deltaSum < -epsilon$2) phi0 = -90;
        range[0] = lambda0$1, range[1] = lambda1;
      },
      sphere: function() {
        lambda0$1 = -(lambda1 = 180), phi0 = -(phi1 = 90);
      }
    };

    function boundsPoint$1(lambda, phi) {
      ranges.push(range = [lambda0$1 = lambda, lambda1 = lambda]);
      if (phi < phi0) phi0 = phi;
      if (phi > phi1) phi1 = phi;
    }

    function linePoint(lambda, phi) {
      var p = cartesian$1([lambda * radians$1, phi * radians$1]);
      if (p0) {
        var normal = cartesianCross$1(p0, p),
            equatorial = [normal[1], -normal[0], 0],
            inflection = cartesianCross$1(equatorial, normal);
        cartesianNormalizeInPlace(inflection);
        inflection = spherical$1(inflection);
        var delta = lambda - lambda2,
            sign = delta > 0 ? 1 : -1,
            lambdai = inflection[0] * degrees$1 * sign,
            phii,
            antimeridian = abs$1(delta) > 180;
        if (antimeridian ^ (sign * lambda2 < lambdai && lambdai < sign * lambda)) {
          phii = inflection[1] * degrees$1;
          if (phii > phi1) phi1 = phii;
        } else if (lambdai = (lambdai + 360) % 360 - 180, antimeridian ^ (sign * lambda2 < lambdai && lambdai < sign * lambda)) {
          phii = -inflection[1] * degrees$1;
          if (phii < phi0) phi0 = phii;
        } else {
          if (phi < phi0) phi0 = phi;
          if (phi > phi1) phi1 = phi;
        }
        if (antimeridian) {
          if (lambda < lambda2) {
            if (angle(lambda0$1, lambda) > angle(lambda0$1, lambda1)) lambda1 = lambda;
          } else {
            if (angle(lambda, lambda1) > angle(lambda0$1, lambda1)) lambda0$1 = lambda;
          }
        } else {
          if (lambda1 >= lambda0$1) {
            if (lambda < lambda0$1) lambda0$1 = lambda;
            if (lambda > lambda1) lambda1 = lambda;
          } else {
            if (lambda > lambda2) {
              if (angle(lambda0$1, lambda) > angle(lambda0$1, lambda1)) lambda1 = lambda;
            } else {
              if (angle(lambda, lambda1) > angle(lambda0$1, lambda1)) lambda0$1 = lambda;
            }
          }
        }
      } else {
        ranges.push(range = [lambda0$1 = lambda, lambda1 = lambda]);
      }
      if (phi < phi0) phi0 = phi;
      if (phi > phi1) phi1 = phi;
      p0 = p, lambda2 = lambda;
    }

    function boundsLineStart() {
      boundsStream$2.point = linePoint;
    }

    function boundsLineEnd() {
      range[0] = lambda0$1, range[1] = lambda1;
      boundsStream$2.point = boundsPoint$1;
      p0 = null;
    }

    function boundsRingPoint(lambda, phi) {
      if (p0) {
        var delta = lambda - lambda2;
        deltaSum.add(abs$1(delta) > 180 ? delta + (delta > 0 ? 360 : -360) : delta);
      } else {
        lambda00$1 = lambda, phi00$1 = phi;
      }
      areaStream.point(lambda, phi);
      linePoint(lambda, phi);
    }

    function boundsRingStart() {
      areaStream.lineStart();
    }

    function boundsRingEnd() {
      boundsRingPoint(lambda00$1, phi00$1);
      areaStream.lineEnd();
      if (abs$1(deltaSum) > epsilon$2) lambda0$1 = -(lambda1 = 180);
      range[0] = lambda0$1, range[1] = lambda1;
      p0 = null;
    }

    // Finds the left-right distance between two longitudes.
    // This is almost the same as (lambda1 - lambda0 + 360°) % 360°, except that we want
    // the distance between ±180° to be 360°.
    function angle(lambda0, lambda1) {
      return (lambda1 -= lambda0) < 0 ? lambda1 + 360 : lambda1;
    }

    function rangeCompare(a, b) {
      return a[0] - b[0];
    }

    function rangeContains(range, x) {
      return range[0] <= range[1] ? range[0] <= x && x <= range[1] : x < range[0] || range[1] < x;
    }

    function geoBounds(feature) {
      var i, n, a, b, merged, deltaMax, delta;

      phi1 = lambda1 = -(lambda0$1 = phi0 = Infinity);
      ranges = [];
      geoStream(feature, boundsStream$2);

      // First, sort ranges by their minimum longitudes.
      if (n = ranges.length) {
        ranges.sort(rangeCompare);

        // Then, merge any ranges that overlap.
        for (i = 1, a = ranges[0], merged = [a]; i < n; ++i) {
          b = ranges[i];
          if (rangeContains(a, b[0]) || rangeContains(a, b[1])) {
            if (angle(a[0], b[1]) > angle(a[0], a[1])) a[1] = b[1];
            if (angle(b[0], a[1]) > angle(a[0], a[1])) a[0] = b[0];
          } else {
            merged.push(a = b);
          }
        }

        // Finally, find the largest gap between the merged ranges.
        // The final bounding box will be the inverse of this gap.
        for (deltaMax = -Infinity, n = merged.length - 1, i = 0, a = merged[n]; i <= n; a = b, ++i) {
          b = merged[i];
          if ((delta = angle(a[1], b[0])) > deltaMax) deltaMax = delta, lambda0$1 = b[0], lambda1 = a[1];
        }
      }

      ranges = range = null;

      return lambda0$1 === Infinity || phi0 === Infinity
          ? [[NaN, NaN], [NaN, NaN]]
          : [[lambda0$1, phi0], [lambda1, phi1]];
    }

    var W0, W1,
        X0, Y0, Z0,
        X1, Y1, Z1,
        X2, Y2, Z2,
        lambda00, phi00, // first point
        x0$1, y0$1, z0; // previous point

    var centroidStream = {
      sphere: noop$1,
      point: centroidPoint,
      lineStart: centroidLineStart,
      lineEnd: centroidLineEnd,
      polygonStart: function() {
        centroidStream.lineStart = centroidRingStart;
        centroidStream.lineEnd = centroidRingEnd;
      },
      polygonEnd: function() {
        centroidStream.lineStart = centroidLineStart;
        centroidStream.lineEnd = centroidLineEnd;
      }
    };

    // Arithmetic mean of Cartesian vectors.
    function centroidPoint(lambda, phi) {
      lambda *= radians$1, phi *= radians$1;
      var cosPhi = cos$1(phi);
      centroidPointCartesian(cosPhi * cos$1(lambda), cosPhi * sin$1(lambda), sin$1(phi));
    }

    function centroidPointCartesian(x, y, z) {
      ++W0;
      X0 += (x - X0) / W0;
      Y0 += (y - Y0) / W0;
      Z0 += (z - Z0) / W0;
    }

    function centroidLineStart() {
      centroidStream.point = centroidLinePointFirst;
    }

    function centroidLinePointFirst(lambda, phi) {
      lambda *= radians$1, phi *= radians$1;
      var cosPhi = cos$1(phi);
      x0$1 = cosPhi * cos$1(lambda);
      y0$1 = cosPhi * sin$1(lambda);
      z0 = sin$1(phi);
      centroidStream.point = centroidLinePoint;
      centroidPointCartesian(x0$1, y0$1, z0);
    }

    function centroidLinePoint(lambda, phi) {
      lambda *= radians$1, phi *= radians$1;
      var cosPhi = cos$1(phi),
          x = cosPhi * cos$1(lambda),
          y = cosPhi * sin$1(lambda),
          z = sin$1(phi),
          w = atan2$1(sqrt$1((w = y0$1 * z - z0 * y) * w + (w = z0 * x - x0$1 * z) * w + (w = x0$1 * y - y0$1 * x) * w), x0$1 * x + y0$1 * y + z0 * z);
      W1 += w;
      X1 += w * (x0$1 + (x0$1 = x));
      Y1 += w * (y0$1 + (y0$1 = y));
      Z1 += w * (z0 + (z0 = z));
      centroidPointCartesian(x0$1, y0$1, z0);
    }

    function centroidLineEnd() {
      centroidStream.point = centroidPoint;
    }

    // See J. E. Brock, The Inertia Tensor for a Spherical Triangle,
    // J. Applied Mechanics 42, 239 (1975).
    function centroidRingStart() {
      centroidStream.point = centroidRingPointFirst;
    }

    function centroidRingEnd() {
      centroidRingPoint(lambda00, phi00);
      centroidStream.point = centroidPoint;
    }

    function centroidRingPointFirst(lambda, phi) {
      lambda00 = lambda, phi00 = phi;
      lambda *= radians$1, phi *= radians$1;
      centroidStream.point = centroidRingPoint;
      var cosPhi = cos$1(phi);
      x0$1 = cosPhi * cos$1(lambda);
      y0$1 = cosPhi * sin$1(lambda);
      z0 = sin$1(phi);
      centroidPointCartesian(x0$1, y0$1, z0);
    }

    function centroidRingPoint(lambda, phi) {
      lambda *= radians$1, phi *= radians$1;
      var cosPhi = cos$1(phi),
          x = cosPhi * cos$1(lambda),
          y = cosPhi * sin$1(lambda),
          z = sin$1(phi),
          cx = y0$1 * z - z0 * y,
          cy = z0 * x - x0$1 * z,
          cz = x0$1 * y - y0$1 * x,
          m = hypot(cx, cy, cz),
          w = asin$1(m), // line weight = angle
          v = m && -w / m; // area weight multiplier
      X2.add(v * cx);
      Y2.add(v * cy);
      Z2.add(v * cz);
      W1 += w;
      X1 += w * (x0$1 + (x0$1 = x));
      Y1 += w * (y0$1 + (y0$1 = y));
      Z1 += w * (z0 + (z0 = z));
      centroidPointCartesian(x0$1, y0$1, z0);
    }

    function geoCentroid(object) {
      W0 = W1 =
      X0 = Y0 = Z0 =
      X1 = Y1 = Z1 = 0;
      X2 = new Adder();
      Y2 = new Adder();
      Z2 = new Adder();
      geoStream(object, centroidStream);

      var x = +X2,
          y = +Y2,
          z = +Z2,
          m = hypot(x, y, z);

      // If the area-weighted ccentroid is undefined, fall back to length-weighted ccentroid.
      if (m < epsilon2) {
        x = X1, y = Y1, z = Z1;
        // If the feature has zero length, fall back to arithmetic mean of point vectors.
        if (W1 < epsilon$2) x = X0, y = Y0, z = Z0;
        m = hypot(x, y, z);
        // If the feature still has an undefined ccentroid, then return.
        if (m < epsilon2) return [NaN, NaN];
      }

      return [atan2$1(y, x) * degrees$1, asin$1(z / m) * degrees$1];
    }

    function compose(a, b) {

      function compose(x, y) {
        return x = a(x, y), b(x[0], x[1]);
      }

      if (a.invert && b.invert) compose.invert = function(x, y) {
        return x = b.invert(x, y), x && a.invert(x[0], x[1]);
      };

      return compose;
    }

    function rotationIdentity(lambda, phi) {
      return [abs$1(lambda) > pi$1 ? lambda + Math.round(-lambda / tau$1) * tau$1 : lambda, phi];
    }

    rotationIdentity.invert = rotationIdentity;

    function rotateRadians(deltaLambda, deltaPhi, deltaGamma) {
      return (deltaLambda %= tau$1) ? (deltaPhi || deltaGamma ? compose(rotationLambda(deltaLambda), rotationPhiGamma(deltaPhi, deltaGamma))
        : rotationLambda(deltaLambda))
        : (deltaPhi || deltaGamma ? rotationPhiGamma(deltaPhi, deltaGamma)
        : rotationIdentity);
    }

    function forwardRotationLambda(deltaLambda) {
      return function(lambda, phi) {
        return lambda += deltaLambda, [lambda > pi$1 ? lambda - tau$1 : lambda < -pi$1 ? lambda + tau$1 : lambda, phi];
      };
    }

    function rotationLambda(deltaLambda) {
      var rotation = forwardRotationLambda(deltaLambda);
      rotation.invert = forwardRotationLambda(-deltaLambda);
      return rotation;
    }

    function rotationPhiGamma(deltaPhi, deltaGamma) {
      var cosDeltaPhi = cos$1(deltaPhi),
          sinDeltaPhi = sin$1(deltaPhi),
          cosDeltaGamma = cos$1(deltaGamma),
          sinDeltaGamma = sin$1(deltaGamma);

      function rotation(lambda, phi) {
        var cosPhi = cos$1(phi),
            x = cos$1(lambda) * cosPhi,
            y = sin$1(lambda) * cosPhi,
            z = sin$1(phi),
            k = z * cosDeltaPhi + x * sinDeltaPhi;
        return [
          atan2$1(y * cosDeltaGamma - k * sinDeltaGamma, x * cosDeltaPhi - z * sinDeltaPhi),
          asin$1(k * cosDeltaGamma + y * sinDeltaGamma)
        ];
      }

      rotation.invert = function(lambda, phi) {
        var cosPhi = cos$1(phi),
            x = cos$1(lambda) * cosPhi,
            y = sin$1(lambda) * cosPhi,
            z = sin$1(phi),
            k = z * cosDeltaGamma - y * sinDeltaGamma;
        return [
          atan2$1(y * cosDeltaGamma + z * sinDeltaGamma, x * cosDeltaPhi + k * sinDeltaPhi),
          asin$1(k * cosDeltaPhi - x * sinDeltaPhi)
        ];
      };

      return rotation;
    }

    function geoRotation(rotate) {
      rotate = rotateRadians(rotate[0] * radians$1, rotate[1] * radians$1, rotate.length > 2 ? rotate[2] * radians$1 : 0);

      function forward(coordinates) {
        coordinates = rotate(coordinates[0] * radians$1, coordinates[1] * radians$1);
        return coordinates[0] *= degrees$1, coordinates[1] *= degrees$1, coordinates;
      }

      forward.invert = function(coordinates) {
        coordinates = rotate.invert(coordinates[0] * radians$1, coordinates[1] * radians$1);
        return coordinates[0] *= degrees$1, coordinates[1] *= degrees$1, coordinates;
      };

      return forward;
    }

    // Generates a circle centered at [0°, 0°], with a given radius and precision.
    function circleStream(stream, radius, delta, direction, t0, t1) {
      if (!delta) return;
      var cosRadius = cos$1(radius),
          sinRadius = sin$1(radius),
          step = direction * delta;
      if (t0 == null) {
        t0 = radius + direction * tau$1;
        t1 = radius - step / 2;
      } else {
        t0 = circleRadius(cosRadius, t0);
        t1 = circleRadius(cosRadius, t1);
        if (direction > 0 ? t0 < t1 : t0 > t1) t0 += direction * tau$1;
      }
      for (var point, t = t0; direction > 0 ? t > t1 : t < t1; t -= step) {
        point = spherical$1([cosRadius, -sinRadius * cos$1(t), -sinRadius * sin$1(t)]);
        stream.point(point[0], point[1]);
      }
    }

    // Returns the signed angle of a cartesian point relative to [cosRadius, 0, 0].
    function circleRadius(cosRadius, point) {
      point = cartesian$1(point), point[0] -= cosRadius;
      cartesianNormalizeInPlace(point);
      var radius = acos(-point[1]);
      return ((-point[2] < 0 ? -radius : radius) + tau$1 - epsilon$2) % tau$1;
    }

    function clipBuffer() {
      var lines = [],
          line;
      return {
        point: function(x, y, m) {
          line.push([x, y, m]);
        },
        lineStart: function() {
          lines.push(line = []);
        },
        lineEnd: noop$1,
        rejoin: function() {
          if (lines.length > 1) lines.push(lines.pop().concat(lines.shift()));
        },
        result: function() {
          var result = lines;
          lines = [];
          line = null;
          return result;
        }
      };
    }

    function pointEqual(a, b) {
      return abs$1(a[0] - b[0]) < epsilon$2 && abs$1(a[1] - b[1]) < epsilon$2;
    }

    function Intersection(point, points, other, entry) {
      this.x = point;
      this.z = points;
      this.o = other; // another intersection
      this.e = entry; // is an entry?
      this.v = false; // visited
      this.n = this.p = null; // next & previous
    }

    // A generalized polygon clipping algorithm: given a polygon that has been cut
    // into its visible line segments, and rejoins the segments by interpolating
    // along the clip edge.
    function clipRejoin(segments, compareIntersection, startInside, interpolate, stream) {
      var subject = [],
          clip = [],
          i,
          n;

      segments.forEach(function(segment) {
        if ((n = segment.length - 1) <= 0) return;
        var n, p0 = segment[0], p1 = segment[n], x;

        if (pointEqual(p0, p1)) {
          if (!p0[2] && !p1[2]) {
            stream.lineStart();
            for (i = 0; i < n; ++i) stream.point((p0 = segment[i])[0], p0[1]);
            stream.lineEnd();
            return;
          }
          // handle degenerate cases by moving the point
          p1[0] += 2 * epsilon$2;
        }

        subject.push(x = new Intersection(p0, segment, null, true));
        clip.push(x.o = new Intersection(p0, null, x, false));
        subject.push(x = new Intersection(p1, segment, null, false));
        clip.push(x.o = new Intersection(p1, null, x, true));
      });

      if (!subject.length) return;

      clip.sort(compareIntersection);
      link(subject);
      link(clip);

      for (i = 0, n = clip.length; i < n; ++i) {
        clip[i].e = startInside = !startInside;
      }

      var start = subject[0],
          points,
          point;

      while (1) {
        // Find first unvisited intersection.
        var current = start,
            isSubject = true;
        while (current.v) if ((current = current.n) === start) return;
        points = current.z;
        stream.lineStart();
        do {
          current.v = current.o.v = true;
          if (current.e) {
            if (isSubject) {
              for (i = 0, n = points.length; i < n; ++i) stream.point((point = points[i])[0], point[1]);
            } else {
              interpolate(current.x, current.n.x, 1, stream);
            }
            current = current.n;
          } else {
            if (isSubject) {
              points = current.p.z;
              for (i = points.length - 1; i >= 0; --i) stream.point((point = points[i])[0], point[1]);
            } else {
              interpolate(current.x, current.p.x, -1, stream);
            }
            current = current.p;
          }
          current = current.o;
          points = current.z;
          isSubject = !isSubject;
        } while (!current.v);
        stream.lineEnd();
      }
    }

    function link(array) {
      if (!(n = array.length)) return;
      var n,
          i = 0,
          a = array[0],
          b;
      while (++i < n) {
        a.n = b = array[i];
        b.p = a;
        a = b;
      }
      a.n = b = array[0];
      b.p = a;
    }

    function longitude(point) {
      return abs$1(point[0]) <= pi$1 ? point[0] : sign$2(point[0]) * ((abs$1(point[0]) + pi$1) % tau$1 - pi$1);
    }

    function polygonContains(polygon, point) {
      var lambda = longitude(point),
          phi = point[1],
          sinPhi = sin$1(phi),
          normal = [sin$1(lambda), -cos$1(lambda), 0],
          angle = 0,
          winding = 0;

      var sum = new Adder();

      if (sinPhi === 1) phi = halfPi$1 + epsilon$2;
      else if (sinPhi === -1) phi = -halfPi$1 - epsilon$2;

      for (var i = 0, n = polygon.length; i < n; ++i) {
        if (!(m = (ring = polygon[i]).length)) continue;
        var ring,
            m,
            point0 = ring[m - 1],
            lambda0 = longitude(point0),
            phi0 = point0[1] / 2 + quarterPi,
            sinPhi0 = sin$1(phi0),
            cosPhi0 = cos$1(phi0);

        for (var j = 0; j < m; ++j, lambda0 = lambda1, sinPhi0 = sinPhi1, cosPhi0 = cosPhi1, point0 = point1) {
          var point1 = ring[j],
              lambda1 = longitude(point1),
              phi1 = point1[1] / 2 + quarterPi,
              sinPhi1 = sin$1(phi1),
              cosPhi1 = cos$1(phi1),
              delta = lambda1 - lambda0,
              sign = delta >= 0 ? 1 : -1,
              absDelta = sign * delta,
              antimeridian = absDelta > pi$1,
              k = sinPhi0 * sinPhi1;

          sum.add(atan2$1(k * sign * sin$1(absDelta), cosPhi0 * cosPhi1 + k * cos$1(absDelta)));
          angle += antimeridian ? delta + sign * tau$1 : delta;

          // Are the longitudes either side of the point’s meridian (lambda),
          // and are the latitudes smaller than the parallel (phi)?
          if (antimeridian ^ lambda0 >= lambda ^ lambda1 >= lambda) {
            var arc = cartesianCross$1(cartesian$1(point0), cartesian$1(point1));
            cartesianNormalizeInPlace(arc);
            var intersection = cartesianCross$1(normal, arc);
            cartesianNormalizeInPlace(intersection);
            var phiArc = (antimeridian ^ delta >= 0 ? -1 : 1) * asin$1(intersection[2]);
            if (phi > phiArc || phi === phiArc && (arc[0] || arc[1])) {
              winding += antimeridian ^ delta >= 0 ? 1 : -1;
            }
          }
        }
      }

      // First, determine whether the South pole is inside or outside:
      //
      // It is inside if:
      // * the polygon winds around it in a clockwise direction.
      // * the polygon does not (cumulatively) wind around it, but has a negative
      //   (counter-clockwise) area.
      //
      // Second, count the (signed) number of times a segment crosses a lambda
      // from the point to the South pole.  If it is zero, then the point is the
      // same side as the South pole.

      return (angle < -epsilon$2 || angle < epsilon$2 && sum < -epsilon2) ^ (winding & 1);
    }

    function clip(pointVisible, clipLine, interpolate, start) {
      return function(sink) {
        var line = clipLine(sink),
            ringBuffer = clipBuffer(),
            ringSink = clipLine(ringBuffer),
            polygonStarted = false,
            polygon,
            segments,
            ring;

        var clip = {
          point: point,
          lineStart: lineStart,
          lineEnd: lineEnd,
          polygonStart: function() {
            clip.point = pointRing;
            clip.lineStart = ringStart;
            clip.lineEnd = ringEnd;
            segments = [];
            polygon = [];
          },
          polygonEnd: function() {
            clip.point = point;
            clip.lineStart = lineStart;
            clip.lineEnd = lineEnd;
            segments = merge$2(segments);
            var startInside = polygonContains(polygon, start);
            if (segments.length) {
              if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
              clipRejoin(segments, compareIntersection, startInside, interpolate, sink);
            } else if (startInside) {
              if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
              sink.lineStart();
              interpolate(null, null, 1, sink);
              sink.lineEnd();
            }
            if (polygonStarted) sink.polygonEnd(), polygonStarted = false;
            segments = polygon = null;
          },
          sphere: function() {
            sink.polygonStart();
            sink.lineStart();
            interpolate(null, null, 1, sink);
            sink.lineEnd();
            sink.polygonEnd();
          }
        };

        function point(lambda, phi) {
          if (pointVisible(lambda, phi)) sink.point(lambda, phi);
        }

        function pointLine(lambda, phi) {
          line.point(lambda, phi);
        }

        function lineStart() {
          clip.point = pointLine;
          line.lineStart();
        }

        function lineEnd() {
          clip.point = point;
          line.lineEnd();
        }

        function pointRing(lambda, phi) {
          ring.push([lambda, phi]);
          ringSink.point(lambda, phi);
        }

        function ringStart() {
          ringSink.lineStart();
          ring = [];
        }

        function ringEnd() {
          pointRing(ring[0][0], ring[0][1]);
          ringSink.lineEnd();

          var clean = ringSink.clean(),
              ringSegments = ringBuffer.result(),
              i, n = ringSegments.length, m,
              segment,
              point;

          ring.pop();
          polygon.push(ring);
          ring = null;

          if (!n) return;

          // No intersections.
          if (clean & 1) {
            segment = ringSegments[0];
            if ((m = segment.length - 1) > 0) {
              if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
              sink.lineStart();
              for (i = 0; i < m; ++i) sink.point((point = segment[i])[0], point[1]);
              sink.lineEnd();
            }
            return;
          }

          // Rejoin connected segments.
          // TODO reuse ringBuffer.rejoin()?
          if (n > 1 && clean & 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));

          segments.push(ringSegments.filter(validSegment));
        }

        return clip;
      };
    }

    function validSegment(segment) {
      return segment.length > 1;
    }

    // Intersections are sorted along the clip edge. For both antimeridian cutting
    // and circle clipping, the same comparison is used.
    function compareIntersection(a, b) {
      return ((a = a.x)[0] < 0 ? a[1] - halfPi$1 - epsilon$2 : halfPi$1 - a[1])
           - ((b = b.x)[0] < 0 ? b[1] - halfPi$1 - epsilon$2 : halfPi$1 - b[1]);
    }

    var clipAntimeridian = clip(
      function() { return true; },
      clipAntimeridianLine,
      clipAntimeridianInterpolate,
      [-pi$1, -halfPi$1]
    );

    // Takes a line and cuts into visible segments. Return values: 0 - there were
    // intersections or the line was empty; 1 - no intersections; 2 - there were
    // intersections, and the first and last segments should be rejoined.
    function clipAntimeridianLine(stream) {
      var lambda0 = NaN,
          phi0 = NaN,
          sign0 = NaN,
          clean; // no intersections

      return {
        lineStart: function() {
          stream.lineStart();
          clean = 1;
        },
        point: function(lambda1, phi1) {
          var sign1 = lambda1 > 0 ? pi$1 : -pi$1,
              delta = abs$1(lambda1 - lambda0);
          if (abs$1(delta - pi$1) < epsilon$2) { // line crosses a pole
            stream.point(lambda0, phi0 = (phi0 + phi1) / 2 > 0 ? halfPi$1 : -halfPi$1);
            stream.point(sign0, phi0);
            stream.lineEnd();
            stream.lineStart();
            stream.point(sign1, phi0);
            stream.point(lambda1, phi0);
            clean = 0;
          } else if (sign0 !== sign1 && delta >= pi$1) { // line crosses antimeridian
            if (abs$1(lambda0 - sign0) < epsilon$2) lambda0 -= sign0 * epsilon$2; // handle degeneracies
            if (abs$1(lambda1 - sign1) < epsilon$2) lambda1 -= sign1 * epsilon$2;
            phi0 = clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1);
            stream.point(sign0, phi0);
            stream.lineEnd();
            stream.lineStart();
            stream.point(sign1, phi0);
            clean = 0;
          }
          stream.point(lambda0 = lambda1, phi0 = phi1);
          sign0 = sign1;
        },
        lineEnd: function() {
          stream.lineEnd();
          lambda0 = phi0 = NaN;
        },
        clean: function() {
          return 2 - clean; // if intersections, rejoin first and last segments
        }
      };
    }

    function clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1) {
      var cosPhi0,
          cosPhi1,
          sinLambda0Lambda1 = sin$1(lambda0 - lambda1);
      return abs$1(sinLambda0Lambda1) > epsilon$2
          ? atan((sin$1(phi0) * (cosPhi1 = cos$1(phi1)) * sin$1(lambda1)
              - sin$1(phi1) * (cosPhi0 = cos$1(phi0)) * sin$1(lambda0))
              / (cosPhi0 * cosPhi1 * sinLambda0Lambda1))
          : (phi0 + phi1) / 2;
    }

    function clipAntimeridianInterpolate(from, to, direction, stream) {
      var phi;
      if (from == null) {
        phi = direction * halfPi$1;
        stream.point(-pi$1, phi);
        stream.point(0, phi);
        stream.point(pi$1, phi);
        stream.point(pi$1, 0);
        stream.point(pi$1, -phi);
        stream.point(0, -phi);
        stream.point(-pi$1, -phi);
        stream.point(-pi$1, 0);
        stream.point(-pi$1, phi);
      } else if (abs$1(from[0] - to[0]) > epsilon$2) {
        var lambda = from[0] < to[0] ? pi$1 : -pi$1;
        phi = direction * lambda / 2;
        stream.point(-lambda, phi);
        stream.point(0, phi);
        stream.point(lambda, phi);
      } else {
        stream.point(to[0], to[1]);
      }
    }

    function clipCircle(radius) {
      var cr = cos$1(radius),
          delta = 6 * radians$1,
          smallRadius = cr > 0,
          notHemisphere = abs$1(cr) > epsilon$2; // TODO optimise for this common case

      function interpolate(from, to, direction, stream) {
        circleStream(stream, radius, delta, direction, from, to);
      }

      function visible(lambda, phi) {
        return cos$1(lambda) * cos$1(phi) > cr;
      }

      // Takes a line and cuts into visible segments. Return values used for polygon
      // clipping: 0 - there were intersections or the line was empty; 1 - no
      // intersections 2 - there were intersections, and the first and last segments
      // should be rejoined.
      function clipLine(stream) {
        var point0, // previous point
            c0, // code for previous point
            v0, // visibility of previous point
            v00, // visibility of first point
            clean; // no intersections
        return {
          lineStart: function() {
            v00 = v0 = false;
            clean = 1;
          },
          point: function(lambda, phi) {
            var point1 = [lambda, phi],
                point2,
                v = visible(lambda, phi),
                c = smallRadius
                  ? v ? 0 : code(lambda, phi)
                  : v ? code(lambda + (lambda < 0 ? pi$1 : -pi$1), phi) : 0;
            if (!point0 && (v00 = v0 = v)) stream.lineStart();
            if (v !== v0) {
              point2 = intersect(point0, point1);
              if (!point2 || pointEqual(point0, point2) || pointEqual(point1, point2))
                point1[2] = 1;
            }
            if (v !== v0) {
              clean = 0;
              if (v) {
                // outside going in
                stream.lineStart();
                point2 = intersect(point1, point0);
                stream.point(point2[0], point2[1]);
              } else {
                // inside going out
                point2 = intersect(point0, point1);
                stream.point(point2[0], point2[1], 2);
                stream.lineEnd();
              }
              point0 = point2;
            } else if (notHemisphere && point0 && smallRadius ^ v) {
              var t;
              // If the codes for two points are different, or are both zero,
              // and there this segment intersects with the small circle.
              if (!(c & c0) && (t = intersect(point1, point0, true))) {
                clean = 0;
                if (smallRadius) {
                  stream.lineStart();
                  stream.point(t[0][0], t[0][1]);
                  stream.point(t[1][0], t[1][1]);
                  stream.lineEnd();
                } else {
                  stream.point(t[1][0], t[1][1]);
                  stream.lineEnd();
                  stream.lineStart();
                  stream.point(t[0][0], t[0][1], 3);
                }
              }
            }
            if (v && (!point0 || !pointEqual(point0, point1))) {
              stream.point(point1[0], point1[1]);
            }
            point0 = point1, v0 = v, c0 = c;
          },
          lineEnd: function() {
            if (v0) stream.lineEnd();
            point0 = null;
          },
          // Rejoin first and last segments if there were intersections and the first
          // and last points were visible.
          clean: function() {
            return clean | ((v00 && v0) << 1);
          }
        };
      }

      // Intersects the great circle between a and b with the clip circle.
      function intersect(a, b, two) {
        var pa = cartesian$1(a),
            pb = cartesian$1(b);

        // We have two planes, n1.p = d1 and n2.p = d2.
        // Find intersection line p(t) = c1 n1 + c2 n2 + t (n1 ⨯ n2).
        var n1 = [1, 0, 0], // normal
            n2 = cartesianCross$1(pa, pb),
            n2n2 = cartesianDot$1(n2, n2),
            n1n2 = n2[0], // cartesianDot(n1, n2),
            determinant = n2n2 - n1n2 * n1n2;

        // Two polar points.
        if (!determinant) return !two && a;

        var c1 =  cr * n2n2 / determinant,
            c2 = -cr * n1n2 / determinant,
            n1xn2 = cartesianCross$1(n1, n2),
            A = cartesianScale(n1, c1),
            B = cartesianScale(n2, c2);
        cartesianAddInPlace(A, B);

        // Solve |p(t)|^2 = 1.
        var u = n1xn2,
            w = cartesianDot$1(A, u),
            uu = cartesianDot$1(u, u),
            t2 = w * w - uu * (cartesianDot$1(A, A) - 1);

        if (t2 < 0) return;

        var t = sqrt$1(t2),
            q = cartesianScale(u, (-w - t) / uu);
        cartesianAddInPlace(q, A);
        q = spherical$1(q);

        if (!two) return q;

        // Two intersection points.
        var lambda0 = a[0],
            lambda1 = b[0],
            phi0 = a[1],
            phi1 = b[1],
            z;

        if (lambda1 < lambda0) z = lambda0, lambda0 = lambda1, lambda1 = z;

        var delta = lambda1 - lambda0,
            polar = abs$1(delta - pi$1) < epsilon$2,
            meridian = polar || delta < epsilon$2;

        if (!polar && phi1 < phi0) z = phi0, phi0 = phi1, phi1 = z;

        // Check that the first point is between a and b.
        if (meridian
            ? polar
              ? phi0 + phi1 > 0 ^ q[1] < (abs$1(q[0] - lambda0) < epsilon$2 ? phi0 : phi1)
              : phi0 <= q[1] && q[1] <= phi1
            : delta > pi$1 ^ (lambda0 <= q[0] && q[0] <= lambda1)) {
          var q1 = cartesianScale(u, (-w + t) / uu);
          cartesianAddInPlace(q1, A);
          return [q, spherical$1(q1)];
        }
      }

      // Generates a 4-bit vector representing the location of a point relative to
      // the small circle's bounding box.
      function code(lambda, phi) {
        var r = smallRadius ? radius : pi$1 - radius,
            code = 0;
        if (lambda < -r) code |= 1; // left
        else if (lambda > r) code |= 2; // right
        if (phi < -r) code |= 4; // below
        else if (phi > r) code |= 8; // above
        return code;
      }

      return clip(visible, clipLine, interpolate, smallRadius ? [0, -radius] : [-pi$1, radius - pi$1]);
    }

    function clipLine(a, b, x0, y0, x1, y1) {
      var ax = a[0],
          ay = a[1],
          bx = b[0],
          by = b[1],
          t0 = 0,
          t1 = 1,
          dx = bx - ax,
          dy = by - ay,
          r;

      r = x0 - ax;
      if (!dx && r > 0) return;
      r /= dx;
      if (dx < 0) {
        if (r < t0) return;
        if (r < t1) t1 = r;
      } else if (dx > 0) {
        if (r > t1) return;
        if (r > t0) t0 = r;
      }

      r = x1 - ax;
      if (!dx && r < 0) return;
      r /= dx;
      if (dx < 0) {
        if (r > t1) return;
        if (r > t0) t0 = r;
      } else if (dx > 0) {
        if (r < t0) return;
        if (r < t1) t1 = r;
      }

      r = y0 - ay;
      if (!dy && r > 0) return;
      r /= dy;
      if (dy < 0) {
        if (r < t0) return;
        if (r < t1) t1 = r;
      } else if (dy > 0) {
        if (r > t1) return;
        if (r > t0) t0 = r;
      }

      r = y1 - ay;
      if (!dy && r < 0) return;
      r /= dy;
      if (dy < 0) {
        if (r > t1) return;
        if (r > t0) t0 = r;
      } else if (dy > 0) {
        if (r < t0) return;
        if (r < t1) t1 = r;
      }

      if (t0 > 0) a[0] = ax + t0 * dx, a[1] = ay + t0 * dy;
      if (t1 < 1) b[0] = ax + t1 * dx, b[1] = ay + t1 * dy;
      return true;
    }

    var clipMax = 1e9, clipMin = -clipMax;

    // TODO Use d3-polygon’s polygonContains here for the ring check?
    // TODO Eliminate duplicate buffering in clipBuffer and polygon.push?

    function clipRectangle(x0, y0, x1, y1) {

      function visible(x, y) {
        return x0 <= x && x <= x1 && y0 <= y && y <= y1;
      }

      function interpolate(from, to, direction, stream) {
        var a = 0, a1 = 0;
        if (from == null
            || (a = corner(from, direction)) !== (a1 = corner(to, direction))
            || comparePoint(from, to) < 0 ^ direction > 0) {
          do stream.point(a === 0 || a === 3 ? x0 : x1, a > 1 ? y1 : y0);
          while ((a = (a + direction + 4) % 4) !== a1);
        } else {
          stream.point(to[0], to[1]);
        }
      }

      function corner(p, direction) {
        return abs$1(p[0] - x0) < epsilon$2 ? direction > 0 ? 0 : 3
            : abs$1(p[0] - x1) < epsilon$2 ? direction > 0 ? 2 : 1
            : abs$1(p[1] - y0) < epsilon$2 ? direction > 0 ? 1 : 0
            : direction > 0 ? 3 : 2; // abs(p[1] - y1) < epsilon
      }

      function compareIntersection(a, b) {
        return comparePoint(a.x, b.x);
      }

      function comparePoint(a, b) {
        var ca = corner(a, 1),
            cb = corner(b, 1);
        return ca !== cb ? ca - cb
            : ca === 0 ? b[1] - a[1]
            : ca === 1 ? a[0] - b[0]
            : ca === 2 ? a[1] - b[1]
            : b[0] - a[0];
      }

      return function(stream) {
        var activeStream = stream,
            bufferStream = clipBuffer(),
            segments,
            polygon,
            ring,
            x__, y__, v__, // first point
            x_, y_, v_, // previous point
            first,
            clean;

        var clipStream = {
          point: point,
          lineStart: lineStart,
          lineEnd: lineEnd,
          polygonStart: polygonStart,
          polygonEnd: polygonEnd
        };

        function point(x, y) {
          if (visible(x, y)) activeStream.point(x, y);
        }

        function polygonInside() {
          var winding = 0;

          for (var i = 0, n = polygon.length; i < n; ++i) {
            for (var ring = polygon[i], j = 1, m = ring.length, point = ring[0], a0, a1, b0 = point[0], b1 = point[1]; j < m; ++j) {
              a0 = b0, a1 = b1, point = ring[j], b0 = point[0], b1 = point[1];
              if (a1 <= y1) { if (b1 > y1 && (b0 - a0) * (y1 - a1) > (b1 - a1) * (x0 - a0)) ++winding; }
              else { if (b1 <= y1 && (b0 - a0) * (y1 - a1) < (b1 - a1) * (x0 - a0)) --winding; }
            }
          }

          return winding;
        }

        // Buffer geometry within a polygon and then clip it en masse.
        function polygonStart() {
          activeStream = bufferStream, segments = [], polygon = [], clean = true;
        }

        function polygonEnd() {
          var startInside = polygonInside(),
              cleanInside = clean && startInside,
              visible = (segments = merge$2(segments)).length;
          if (cleanInside || visible) {
            stream.polygonStart();
            if (cleanInside) {
              stream.lineStart();
              interpolate(null, null, 1, stream);
              stream.lineEnd();
            }
            if (visible) {
              clipRejoin(segments, compareIntersection, startInside, interpolate, stream);
            }
            stream.polygonEnd();
          }
          activeStream = stream, segments = polygon = ring = null;
        }

        function lineStart() {
          clipStream.point = linePoint;
          if (polygon) polygon.push(ring = []);
          first = true;
          v_ = false;
          x_ = y_ = NaN;
        }

        // TODO rather than special-case polygons, simply handle them separately.
        // Ideally, coincident intersection points should be jittered to avoid
        // clipping issues.
        function lineEnd() {
          if (segments) {
            linePoint(x__, y__);
            if (v__ && v_) bufferStream.rejoin();
            segments.push(bufferStream.result());
          }
          clipStream.point = point;
          if (v_) activeStream.lineEnd();
        }

        function linePoint(x, y) {
          var v = visible(x, y);
          if (polygon) ring.push([x, y]);
          if (first) {
            x__ = x, y__ = y, v__ = v;
            first = false;
            if (v) {
              activeStream.lineStart();
              activeStream.point(x, y);
            }
          } else {
            if (v && v_) activeStream.point(x, y);
            else {
              var a = [x_ = Math.max(clipMin, Math.min(clipMax, x_)), y_ = Math.max(clipMin, Math.min(clipMax, y_))],
                  b = [x = Math.max(clipMin, Math.min(clipMax, x)), y = Math.max(clipMin, Math.min(clipMax, y))];
              if (clipLine(a, b, x0, y0, x1, y1)) {
                if (!v_) {
                  activeStream.lineStart();
                  activeStream.point(a[0], a[1]);
                }
                activeStream.point(b[0], b[1]);
                if (!v) activeStream.lineEnd();
                clean = false;
              } else if (v) {
                activeStream.lineStart();
                activeStream.point(x, y);
                clean = false;
              }
            }
          }
          x_ = x, y_ = y, v_ = v;
        }

        return clipStream;
      };
    }

    var lengthSum,
        lambda0,
        sinPhi0,
        cosPhi0;

    var lengthStream = {
      sphere: noop$1,
      point: noop$1,
      lineStart: lengthLineStart,
      lineEnd: noop$1,
      polygonStart: noop$1,
      polygonEnd: noop$1
    };

    function lengthLineStart() {
      lengthStream.point = lengthPointFirst;
      lengthStream.lineEnd = lengthLineEnd;
    }

    function lengthLineEnd() {
      lengthStream.point = lengthStream.lineEnd = noop$1;
    }

    function lengthPointFirst(lambda, phi) {
      lambda *= radians$1, phi *= radians$1;
      lambda0 = lambda, sinPhi0 = sin$1(phi), cosPhi0 = cos$1(phi);
      lengthStream.point = lengthPoint;
    }

    function lengthPoint(lambda, phi) {
      lambda *= radians$1, phi *= radians$1;
      var sinPhi = sin$1(phi),
          cosPhi = cos$1(phi),
          delta = abs$1(lambda - lambda0),
          cosDelta = cos$1(delta),
          sinDelta = sin$1(delta),
          x = cosPhi * sinDelta,
          y = cosPhi0 * sinPhi - sinPhi0 * cosPhi * cosDelta,
          z = sinPhi0 * sinPhi + cosPhi0 * cosPhi * cosDelta;
      lengthSum.add(atan2$1(sqrt$1(x * x + y * y), z));
      lambda0 = lambda, sinPhi0 = sinPhi, cosPhi0 = cosPhi;
    }

    function length(object) {
      lengthSum = new Adder();
      geoStream(object, lengthStream);
      return +lengthSum;
    }

    var coordinates = [null, null],
        object$1 = {type: "LineString", coordinates: coordinates};

    function geoDistance(a, b) {
      coordinates[0] = a;
      coordinates[1] = b;
      return length(object$1);
    }

    var containsObjectType = {
      Feature: function(object, point) {
        return containsGeometry(object.geometry, point);
      },
      FeatureCollection: function(object, point) {
        var features = object.features, i = -1, n = features.length;
        while (++i < n) if (containsGeometry(features[i].geometry, point)) return true;
        return false;
      }
    };

    var containsGeometryType = {
      Sphere: function() {
        return true;
      },
      Point: function(object, point) {
        return containsPoint(object.coordinates, point);
      },
      MultiPoint: function(object, point) {
        var coordinates = object.coordinates, i = -1, n = coordinates.length;
        while (++i < n) if (containsPoint(coordinates[i], point)) return true;
        return false;
      },
      LineString: function(object, point) {
        return containsLine(object.coordinates, point);
      },
      MultiLineString: function(object, point) {
        var coordinates = object.coordinates, i = -1, n = coordinates.length;
        while (++i < n) if (containsLine(coordinates[i], point)) return true;
        return false;
      },
      Polygon: function(object, point) {
        return containsPolygon(object.coordinates, point);
      },
      MultiPolygon: function(object, point) {
        var coordinates = object.coordinates, i = -1, n = coordinates.length;
        while (++i < n) if (containsPolygon(coordinates[i], point)) return true;
        return false;
      },
      GeometryCollection: function(object, point) {
        var geometries = object.geometries, i = -1, n = geometries.length;
        while (++i < n) if (containsGeometry(geometries[i], point)) return true;
        return false;
      }
    };

    function containsGeometry(geometry, point) {
      return geometry && containsGeometryType.hasOwnProperty(geometry.type)
          ? containsGeometryType[geometry.type](geometry, point)
          : false;
    }

    function containsPoint(coordinates, point) {
      return geoDistance(coordinates, point) === 0;
    }

    function containsLine(coordinates, point) {
      var ao, bo, ab;
      for (var i = 0, n = coordinates.length; i < n; i++) {
        bo = geoDistance(coordinates[i], point);
        if (bo === 0) return true;
        if (i > 0) {
          ab = geoDistance(coordinates[i], coordinates[i - 1]);
          if (
            ab > 0 &&
            ao <= ab &&
            bo <= ab &&
            (ao + bo - ab) * (1 - Math.pow((ao - bo) / ab, 2)) < epsilon2 * ab
          )
            return true;
        }
        ao = bo;
      }
      return false;
    }

    function containsPolygon(coordinates, point) {
      return !!polygonContains(coordinates.map(ringRadians), pointRadians(point));
    }

    function ringRadians(ring) {
      return ring = ring.map(pointRadians), ring.pop(), ring;
    }

    function pointRadians(point) {
      return [point[0] * radians$1, point[1] * radians$1];
    }

    function geoContains(object, point) {
      return (object && containsObjectType.hasOwnProperty(object.type)
          ? containsObjectType[object.type]
          : containsGeometry)(object, point);
    }

    function graticuleX(y0, y1, dy) {
      var y = range$1(y0, y1 - epsilon$2, dy).concat(y1);
      return function(x) { return y.map(function(y) { return [x, y]; }); };
    }

    function graticuleY(x0, x1, dx) {
      var x = range$1(x0, x1 - epsilon$2, dx).concat(x1);
      return function(y) { return x.map(function(x) { return [x, y]; }); };
    }

    function graticule() {
      var x1, x0, X1, X0,
          y1, y0, Y1, Y0,
          dx = 10, dy = dx, DX = 90, DY = 360,
          x, y, X, Y,
          precision = 2.5;

      function graticule() {
        return {type: "MultiLineString", coordinates: lines()};
      }

      function lines() {
        return range$1(ceil$1(X0 / DX) * DX, X1, DX).map(X)
            .concat(range$1(ceil$1(Y0 / DY) * DY, Y1, DY).map(Y))
            .concat(range$1(ceil$1(x0 / dx) * dx, x1, dx).filter(function(x) { return abs$1(x % DX) > epsilon$2; }).map(x))
            .concat(range$1(ceil$1(y0 / dy) * dy, y1, dy).filter(function(y) { return abs$1(y % DY) > epsilon$2; }).map(y));
      }

      graticule.lines = function() {
        return lines().map(function(coordinates) { return {type: "LineString", coordinates: coordinates}; });
      };

      graticule.outline = function() {
        return {
          type: "Polygon",
          coordinates: [
            X(X0).concat(
            Y(Y1).slice(1),
            X(X1).reverse().slice(1),
            Y(Y0).reverse().slice(1))
          ]
        };
      };

      graticule.extent = function(_) {
        if (!arguments.length) return graticule.extentMinor();
        return graticule.extentMajor(_).extentMinor(_);
      };

      graticule.extentMajor = function(_) {
        if (!arguments.length) return [[X0, Y0], [X1, Y1]];
        X0 = +_[0][0], X1 = +_[1][0];
        Y0 = +_[0][1], Y1 = +_[1][1];
        if (X0 > X1) _ = X0, X0 = X1, X1 = _;
        if (Y0 > Y1) _ = Y0, Y0 = Y1, Y1 = _;
        return graticule.precision(precision);
      };

      graticule.extentMinor = function(_) {
        if (!arguments.length) return [[x0, y0], [x1, y1]];
        x0 = +_[0][0], x1 = +_[1][0];
        y0 = +_[0][1], y1 = +_[1][1];
        if (x0 > x1) _ = x0, x0 = x1, x1 = _;
        if (y0 > y1) _ = y0, y0 = y1, y1 = _;
        return graticule.precision(precision);
      };

      graticule.step = function(_) {
        if (!arguments.length) return graticule.stepMinor();
        return graticule.stepMajor(_).stepMinor(_);
      };

      graticule.stepMajor = function(_) {
        if (!arguments.length) return [DX, DY];
        DX = +_[0], DY = +_[1];
        return graticule;
      };

      graticule.stepMinor = function(_) {
        if (!arguments.length) return [dx, dy];
        dx = +_[0], dy = +_[1];
        return graticule;
      };

      graticule.precision = function(_) {
        if (!arguments.length) return precision;
        precision = +_;
        x = graticuleX(y0, y1, 90);
        y = graticuleY(x0, x1, precision);
        X = graticuleX(Y0, Y1, 90);
        Y = graticuleY(X0, X1, precision);
        return graticule;
      };

      return graticule
          .extentMajor([[-180, -90 + epsilon$2], [180, 90 - epsilon$2]])
          .extentMinor([[-180, -80 - epsilon$2], [180, 80 + epsilon$2]]);
    }

    function graticule10() {
      return graticule()();
    }

    function geoInterpolate(a, b) {
      var x0 = a[0] * radians$1,
          y0 = a[1] * radians$1,
          x1 = b[0] * radians$1,
          y1 = b[1] * radians$1,
          cy0 = cos$1(y0),
          sy0 = sin$1(y0),
          cy1 = cos$1(y1),
          sy1 = sin$1(y1),
          kx0 = cy0 * cos$1(x0),
          ky0 = cy0 * sin$1(x0),
          kx1 = cy1 * cos$1(x1),
          ky1 = cy1 * sin$1(x1),
          d = 2 * asin$1(sqrt$1(haversin(y1 - y0) + cy0 * cy1 * haversin(x1 - x0))),
          k = sin$1(d);

      var interpolate = d ? function(t) {
        var B = sin$1(t *= d) / k,
            A = sin$1(d - t) / k,
            x = A * kx0 + B * kx1,
            y = A * ky0 + B * ky1,
            z = A * sy0 + B * sy1;
        return [
          atan2$1(y, x) * degrees$1,
          atan2$1(z, sqrt$1(x * x + y * y)) * degrees$1
        ];
      } : function() {
        return [x0 * degrees$1, y0 * degrees$1];
      };

      interpolate.distance = d;

      return interpolate;
    }

    var identity$2 = x => x;

    var x0 = Infinity,
        y0 = x0,
        x1 = -x0,
        y1 = x1;

    var boundsStream = {
      point: boundsPoint,
      lineStart: noop$1,
      lineEnd: noop$1,
      polygonStart: noop$1,
      polygonEnd: noop$1,
      result: function() {
        var bounds = [[x0, y0], [x1, y1]];
        x1 = y1 = -(y0 = x0 = Infinity);
        return bounds;
      }
    };

    function boundsPoint(x, y) {
      if (x < x0) x0 = x;
      if (x > x1) x1 = x;
      if (y < y0) y0 = y;
      if (y > y1) y1 = y;
    }

    var boundsStream$1 = boundsStream;

    function transformer$1(methods) {
      return function(stream) {
        var s = new TransformStream;
        for (var key in methods) s[key] = methods[key];
        s.stream = stream;
        return s;
      };
    }

    function TransformStream() {}

    TransformStream.prototype = {
      constructor: TransformStream,
      point: function(x, y) { this.stream.point(x, y); },
      sphere: function() { this.stream.sphere(); },
      lineStart: function() { this.stream.lineStart(); },
      lineEnd: function() { this.stream.lineEnd(); },
      polygonStart: function() { this.stream.polygonStart(); },
      polygonEnd: function() { this.stream.polygonEnd(); }
    };

    function fit(projection, fitBounds, object) {
      var clip = projection.clipExtent && projection.clipExtent();
      projection.scale(150).translate([0, 0]);
      if (clip != null) projection.clipExtent(null);
      geoStream(object, projection.stream(boundsStream$1));
      fitBounds(boundsStream$1.result());
      if (clip != null) projection.clipExtent(clip);
      return projection;
    }

    function fitExtent(projection, extent, object) {
      return fit(projection, function(b) {
        var w = extent[1][0] - extent[0][0],
            h = extent[1][1] - extent[0][1],
            k = Math.min(w / (b[1][0] - b[0][0]), h / (b[1][1] - b[0][1])),
            x = +extent[0][0] + (w - k * (b[1][0] + b[0][0])) / 2,
            y = +extent[0][1] + (h - k * (b[1][1] + b[0][1])) / 2;
        projection.scale(150 * k).translate([x, y]);
      }, object);
    }

    function fitSize(projection, size, object) {
      return fitExtent(projection, [[0, 0], size], object);
    }

    function fitWidth(projection, width, object) {
      return fit(projection, function(b) {
        var w = +width,
            k = w / (b[1][0] - b[0][0]),
            x = (w - k * (b[1][0] + b[0][0])) / 2,
            y = -k * b[0][1];
        projection.scale(150 * k).translate([x, y]);
      }, object);
    }

    function fitHeight(projection, height, object) {
      return fit(projection, function(b) {
        var h = +height,
            k = h / (b[1][1] - b[0][1]),
            x = -k * b[0][0],
            y = (h - k * (b[1][1] + b[0][1])) / 2;
        projection.scale(150 * k).translate([x, y]);
      }, object);
    }

    var maxDepth = 16, // maximum depth of subdivision
        cosMinDistance = cos$1(30 * radians$1); // cos(minimum angular distance)

    function resample(project, delta2) {
      return +delta2 ? resample$1(project, delta2) : resampleNone(project);
    }

    function resampleNone(project) {
      return transformer$1({
        point: function(x, y) {
          x = project(x, y);
          this.stream.point(x[0], x[1]);
        }
      });
    }

    function resample$1(project, delta2) {

      function resampleLineTo(x0, y0, lambda0, a0, b0, c0, x1, y1, lambda1, a1, b1, c1, depth, stream) {
        var dx = x1 - x0,
            dy = y1 - y0,
            d2 = dx * dx + dy * dy;
        if (d2 > 4 * delta2 && depth--) {
          var a = a0 + a1,
              b = b0 + b1,
              c = c0 + c1,
              m = sqrt$1(a * a + b * b + c * c),
              phi2 = asin$1(c /= m),
              lambda2 = abs$1(abs$1(c) - 1) < epsilon$2 || abs$1(lambda0 - lambda1) < epsilon$2 ? (lambda0 + lambda1) / 2 : atan2$1(b, a),
              p = project(lambda2, phi2),
              x2 = p[0],
              y2 = p[1],
              dx2 = x2 - x0,
              dy2 = y2 - y0,
              dz = dy * dx2 - dx * dy2;
          if (dz * dz / d2 > delta2 // perpendicular projected distance
              || abs$1((dx * dx2 + dy * dy2) / d2 - 0.5) > 0.3 // midpoint close to an end
              || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) { // angular distance
            resampleLineTo(x0, y0, lambda0, a0, b0, c0, x2, y2, lambda2, a /= m, b /= m, c, depth, stream);
            stream.point(x2, y2);
            resampleLineTo(x2, y2, lambda2, a, b, c, x1, y1, lambda1, a1, b1, c1, depth, stream);
          }
        }
      }
      return function(stream) {
        var lambda00, x00, y00, a00, b00, c00, // first point
            lambda0, x0, y0, a0, b0, c0; // previous point

        var resampleStream = {
          point: point,
          lineStart: lineStart,
          lineEnd: lineEnd,
          polygonStart: function() { stream.polygonStart(); resampleStream.lineStart = ringStart; },
          polygonEnd: function() { stream.polygonEnd(); resampleStream.lineStart = lineStart; }
        };

        function point(x, y) {
          x = project(x, y);
          stream.point(x[0], x[1]);
        }

        function lineStart() {
          x0 = NaN;
          resampleStream.point = linePoint;
          stream.lineStart();
        }

        function linePoint(lambda, phi) {
          var c = cartesian$1([lambda, phi]), p = project(lambda, phi);
          resampleLineTo(x0, y0, lambda0, a0, b0, c0, x0 = p[0], y0 = p[1], lambda0 = lambda, a0 = c[0], b0 = c[1], c0 = c[2], maxDepth, stream);
          stream.point(x0, y0);
        }

        function lineEnd() {
          resampleStream.point = point;
          stream.lineEnd();
        }

        function ringStart() {
          lineStart();
          resampleStream.point = ringPoint;
          resampleStream.lineEnd = ringEnd;
        }

        function ringPoint(lambda, phi) {
          linePoint(lambda00 = lambda, phi), x00 = x0, y00 = y0, a00 = a0, b00 = b0, c00 = c0;
          resampleStream.point = linePoint;
        }

        function ringEnd() {
          resampleLineTo(x0, y0, lambda0, a0, b0, c0, x00, y00, lambda00, a00, b00, c00, maxDepth, stream);
          resampleStream.lineEnd = lineEnd;
          lineEnd();
        }

        return resampleStream;
      };
    }

    var transformRadians = transformer$1({
      point: function(x, y) {
        this.stream.point(x * radians$1, y * radians$1);
      }
    });

    function transformRotate(rotate) {
      return transformer$1({
        point: function(x, y) {
          var r = rotate(x, y);
          return this.stream.point(r[0], r[1]);
        }
      });
    }

    function scaleTranslate(k, dx, dy, sx, sy) {
      function transform(x, y) {
        x *= sx; y *= sy;
        return [dx + k * x, dy - k * y];
      }
      transform.invert = function(x, y) {
        return [(x - dx) / k * sx, (dy - y) / k * sy];
      };
      return transform;
    }

    function scaleTranslateRotate(k, dx, dy, sx, sy, alpha) {
      if (!alpha) return scaleTranslate(k, dx, dy, sx, sy);
      var cosAlpha = cos$1(alpha),
          sinAlpha = sin$1(alpha),
          a = cosAlpha * k,
          b = sinAlpha * k,
          ai = cosAlpha / k,
          bi = sinAlpha / k,
          ci = (sinAlpha * dy - cosAlpha * dx) / k,
          fi = (sinAlpha * dx + cosAlpha * dy) / k;
      function transform(x, y) {
        x *= sx; y *= sy;
        return [a * x - b * y + dx, dy - b * x - a * y];
      }
      transform.invert = function(x, y) {
        return [sx * (ai * x - bi * y + ci), sy * (fi - bi * x - ai * y)];
      };
      return transform;
    }

    function projection(project) {
      return projectionMutator(function() { return project; })();
    }

    function projectionMutator(projectAt) {
      var project,
          k = 150, // scale
          x = 480, y = 250, // translate
          lambda = 0, phi = 0, // center
          deltaLambda = 0, deltaPhi = 0, deltaGamma = 0, rotate, // pre-rotate
          alpha = 0, // post-rotate angle
          sx = 1, // reflectX
          sy = 1, // reflectX
          theta = null, preclip = clipAntimeridian, // pre-clip angle
          x0 = null, y0, x1, y1, postclip = identity$2, // post-clip extent
          delta2 = 0.5, // precision
          projectResample,
          projectTransform,
          projectRotateTransform,
          cache,
          cacheStream;

      function projection(point) {
        return projectRotateTransform(point[0] * radians$1, point[1] * radians$1);
      }

      function invert(point) {
        point = projectRotateTransform.invert(point[0], point[1]);
        return point && [point[0] * degrees$1, point[1] * degrees$1];
      }

      projection.stream = function(stream) {
        return cache && cacheStream === stream ? cache : cache = transformRadians(transformRotate(rotate)(preclip(projectResample(postclip(cacheStream = stream)))));
      };

      projection.preclip = function(_) {
        return arguments.length ? (preclip = _, theta = undefined, reset()) : preclip;
      };

      projection.postclip = function(_) {
        return arguments.length ? (postclip = _, x0 = y0 = x1 = y1 = null, reset()) : postclip;
      };

      projection.clipAngle = function(_) {
        return arguments.length ? (preclip = +_ ? clipCircle(theta = _ * radians$1) : (theta = null, clipAntimeridian), reset()) : theta * degrees$1;
      };

      projection.clipExtent = function(_) {
        return arguments.length ? (postclip = _ == null ? (x0 = y0 = x1 = y1 = null, identity$2) : clipRectangle(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reset()) : x0 == null ? null : [[x0, y0], [x1, y1]];
      };

      projection.scale = function(_) {
        return arguments.length ? (k = +_, recenter()) : k;
      };

      projection.translate = function(_) {
        return arguments.length ? (x = +_[0], y = +_[1], recenter()) : [x, y];
      };

      projection.center = function(_) {
        return arguments.length ? (lambda = _[0] % 360 * radians$1, phi = _[1] % 360 * radians$1, recenter()) : [lambda * degrees$1, phi * degrees$1];
      };

      projection.rotate = function(_) {
        return arguments.length ? (deltaLambda = _[0] % 360 * radians$1, deltaPhi = _[1] % 360 * radians$1, deltaGamma = _.length > 2 ? _[2] % 360 * radians$1 : 0, recenter()) : [deltaLambda * degrees$1, deltaPhi * degrees$1, deltaGamma * degrees$1];
      };

      projection.angle = function(_) {
        return arguments.length ? (alpha = _ % 360 * radians$1, recenter()) : alpha * degrees$1;
      };

      projection.reflectX = function(_) {
        return arguments.length ? (sx = _ ? -1 : 1, recenter()) : sx < 0;
      };

      projection.reflectY = function(_) {
        return arguments.length ? (sy = _ ? -1 : 1, recenter()) : sy < 0;
      };

      projection.precision = function(_) {
        return arguments.length ? (projectResample = resample(projectTransform, delta2 = _ * _), reset()) : sqrt$1(delta2);
      };

      projection.fitExtent = function(extent, object) {
        return fitExtent(projection, extent, object);
      };

      projection.fitSize = function(size, object) {
        return fitSize(projection, size, object);
      };

      projection.fitWidth = function(width, object) {
        return fitWidth(projection, width, object);
      };

      projection.fitHeight = function(height, object) {
        return fitHeight(projection, height, object);
      };

      function recenter() {
        var center = scaleTranslateRotate(k, 0, 0, sx, sy, alpha).apply(null, project(lambda, phi)),
            transform = scaleTranslateRotate(k, x - center[0], y - center[1], sx, sy, alpha);
        rotate = rotateRadians(deltaLambda, deltaPhi, deltaGamma);
        projectTransform = compose(project, transform);
        projectRotateTransform = compose(rotate, projectTransform);
        projectResample = resample(projectTransform, delta2);
        return reset();
      }

      function reset() {
        cache = cacheStream = null;
        return projection;
      }

      return function() {
        project = projectAt.apply(this, arguments);
        projection.invert = project.invert && invert;
        return recenter();
      };
    }

    function azimuthalInvert(angle) {
      return function(x, y) {
        var z = sqrt$1(x * x + y * y),
            c = angle(z),
            sc = sin$1(c),
            cc = cos$1(c);
        return [
          atan2$1(x * sc, z * cc),
          asin$1(z && y * sc / z)
        ];
      }
    }

    function stereographicRaw(x, y) {
      var cy = cos$1(y), k = 1 + cos$1(x) * cy;
      return [cy * sin$1(x) / k, sin$1(y) / k];
    }

    stereographicRaw.invert = azimuthalInvert(function(z) {
      return 2 * atan(z);
    });

    function geoStereographic() {
      return projection(stereographicRaw)
          .scale(250)
          .clipAngle(142);
    }

    function _classCallCheck$2(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }

    function _defineProperties$3(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    function _createClass$3(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties$3(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties$3(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", {
        writable: false
      });
      return Constructor;
    }

    function _inherits$2(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }

      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      Object.defineProperty(subClass, "prototype", {
        writable: false
      });
      if (superClass) _setPrototypeOf$3(subClass, superClass);
    }

    function _getPrototypeOf$3(o) {
      _getPrototypeOf$3 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
      };
      return _getPrototypeOf$3(o);
    }

    function _setPrototypeOf$3(o, p) {
      _setPrototypeOf$3 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };
      return _setPrototypeOf$3(o, p);
    }

    function _isNativeReflectConstruct$3() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;

      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
        return true;
      } catch (e) {
        return false;
      }
    }

    function _assertThisInitialized$3(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }

      return self;
    }

    function _possibleConstructorReturn$2(self, call) {
      if (call && (typeof call === "object" || typeof call === "function")) {
        return call;
      } else if (call !== void 0) {
        throw new TypeError("Derived constructors may only return object or undefined");
      }

      return _assertThisInitialized$3(self);
    }

    function _createSuper$2(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct$3();

      return function _createSuperInternal() {
        var Super = _getPrototypeOf$3(Derived),
            result;

        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf$3(this).constructor;

          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }

        return _possibleConstructorReturn$2(this, result);
      };
    }

    function _slicedToArray$5(arr, i) {
      return _arrayWithHoles$5(arr) || _iterableToArrayLimit$5(arr, i) || _unsupportedIterableToArray$6(arr, i) || _nonIterableRest$5();
    }

    function _arrayWithHoles$5(arr) {
      if (Array.isArray(arr)) return arr;
    }

    function _iterableToArrayLimit$5(arr, i) {
      var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

      if (_i == null) return;
      var _arr = [];
      var _n = true;
      var _d = false;

      var _s, _e;

      try {
        for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);

          if (i && _arr.length === i) break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"] != null) _i["return"]();
        } finally {
          if (_d) throw _e;
        }
      }

      return _arr;
    }

    function _unsupportedIterableToArray$6(o, minLen) {
      if (!o) return;
      if (typeof o === "string") return _arrayLikeToArray$6(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor) n = o.constructor.name;
      if (n === "Map" || n === "Set") return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$6(o, minLen);
    }

    function _arrayLikeToArray$6(arr, len) {
      if (len == null || len > arr.length) len = arr.length;

      for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

      return arr2;
    }

    function _nonIterableRest$5() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }

    function _createForOfIteratorHelper(o, allowArrayLike) {
      var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];

      if (!it) {
        if (Array.isArray(o) || (it = _unsupportedIterableToArray$6(o)) || allowArrayLike && o && typeof o.length === "number") {
          if (it) o = it;
          var i = 0;

          var F = function () {};

          return {
            s: F,
            n: function () {
              if (i >= o.length) return {
                done: true
              };
              return {
                done: false,
                value: o[i++]
              };
            },
            e: function (e) {
              throw e;
            },
            f: F
          };
        }

        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }

      var normalCompletion = true,
          didErr = false,
          err;
      return {
        s: function () {
          it = it.call(o);
        },
        n: function () {
          var step = it.next();
          normalCompletion = step.done;
          return step;
        },
        e: function (e) {
          didErr = true;
          err = e;
        },
        f: function () {
          try {
            if (!normalCompletion && it.return != null) it.return();
          } finally {
            if (didErr) throw err;
          }
        }
      };
    }

    var interpolateLine = function interpolateLine() {
      var lineCoords = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var maxDegDistance = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      var result = [];
      var prevPnt = null;
      lineCoords.forEach(function (pnt) {
        if (prevPnt) {
          var dist = geoDistance(pnt, prevPnt) * 180 / Math.PI;

          if (dist > maxDegDistance) {
            var interpol = geoInterpolate(prevPnt, pnt);
            var tStep = 1 / Math.ceil(dist / maxDegDistance);
            var t = tStep;

            while (t < 1) {
              result.push(interpol(t));
              t += tStep;
            }
          }
        }

        result.push(prevPnt = pnt);
      });
      return result;
    };

    var THREE$j = typeof window !== 'undefined' && window.THREE ? window.THREE // Prefer consumption from global THREE, if exists
    : {
      BufferGeometry: BufferGeometry,
      Float32BufferAttribute: Float32BufferAttribute
    };

    var setAttributeFn$4 = new THREE$j.BufferGeometry().setAttribute ? 'setAttribute' : 'addAttribute';

    var GeoJsonGeometry = /*#__PURE__*/function (_THREE$BufferGeometry) {
      _inherits$2(GeoJsonGeometry, _THREE$BufferGeometry);

      var _super = _createSuper$2(GeoJsonGeometry);

      function GeoJsonGeometry(geoJson) {
        var _this;

        var radius = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
        var resolution = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 5;

        _classCallCheck$2(this, GeoJsonGeometry);

        _this = _super.call(this);
        _this.type = 'GeoJsonGeometry';
        _this.parameters = {
          geoJson: geoJson,
          radius: radius,
          resolution: resolution
        }; // process various geometry types

        var groups = ({
          Point: genPoint,
          MultiPoint: genMultiPoint,
          LineString: genLineString,
          MultiLineString: genMultiLineString,
          Polygon: genPolygon,
          MultiPolygon: genMultiPolygon
        }[geoJson.type] || function () {
          return [];
        })(geoJson.coordinates, radius); // concat groups


        var indices = [],
            vertices = [];
        var groupCnt = 0;
        groups.forEach(function (newG) {
          var prevIndCnt = indices.length;
          concatGroup({
            indices: indices,
            vertices: vertices
          }, newG);

          _this.addGroup(prevIndCnt, indices.length - prevIndCnt, groupCnt++);
        }); // build geometry

        indices.length && _this.setIndex(indices);
        vertices.length && _this[setAttributeFn$4]('position', new THREE$j.Float32BufferAttribute(vertices, 3)); //

        function genPoint(coords, r) {
          var vertices = polar2Cartesian$2(coords[1], coords[0], r);
          var indices = [];
          return [{
            vertices: vertices,
            indices: indices
          }];
        }

        function genMultiPoint(coords, r) {
          var result = {
            vertices: [],
            indices: []
          };
          coords.map(function (c) {
            return genPoint(c, r);
          }).forEach(function (_ref) {
            var _ref2 = _slicedToArray$5(_ref, 1),
                newPnt = _ref2[0];

            concatGroup(result, newPnt);
          });
          return [result];
        }

        function genLineString(coords, r) {
          var coords3d = interpolateLine(coords, resolution).map(function (_ref3) {
            var _ref4 = _slicedToArray$5(_ref3, 2),
                lng = _ref4[0],
                lat = _ref4[1];

            return polar2Cartesian$2(lat, lng, r);
          });

          var _earcut$flatten = earcut_1.flatten([coords3d]),
              vertices = _earcut$flatten.vertices;

          var numPoints = Math.round(vertices.length / 3);
          var indices = [];

          for (var vIdx = 1; vIdx < numPoints; vIdx++) {
            indices.push(vIdx - 1, vIdx);
          }

          return [{
            vertices: vertices,
            indices: indices
          }];
        }

        function genMultiLineString(coords, r) {
          var result = {
            vertices: [],
            indices: []
          };
          coords.map(function (c) {
            return genLineString(c, r);
          }).forEach(function (_ref5) {
            var _ref6 = _slicedToArray$5(_ref5, 1),
                newLine = _ref6[0];

            concatGroup(result, newLine);
          });
          return [result];
        }

        function genPolygon(coords, r) {
          var coords3d = coords.map(function (coordsSegment) {
            return interpolateLine(coordsSegment, resolution).map(function (_ref7) {
              var _ref8 = _slicedToArray$5(_ref7, 2),
                  lng = _ref8[0],
                  lat = _ref8[1];

              return polar2Cartesian$2(lat, lng, r);
            });
          }); // Each point generates 3 vertice items (x,y,z).

          var _earcut$flatten2 = earcut_1.flatten(coords3d),
              vertices = _earcut$flatten2.vertices,
              holes = _earcut$flatten2.holes;

          var firstHoleIdx = holes[0] || Infinity;
          var outerVertices = vertices.slice(0, firstHoleIdx * 3);
          var holeVertices = vertices.slice(firstHoleIdx * 3);
          var holesIdx = new Set(holes);
          var numPoints = Math.round(vertices.length / 3);
          var outerIndices = [],
              holeIndices = [];

          for (var vIdx = 1; vIdx < numPoints; vIdx++) {
            if (!holesIdx.has(vIdx)) {
              if (vIdx < firstHoleIdx) {
                outerIndices.push(vIdx - 1, vIdx);
              } else {
                holeIndices.push(vIdx - 1 - firstHoleIdx, vIdx - firstHoleIdx);
              }
            }
          }

          var groups = [{
            indices: outerIndices,
            vertices: outerVertices
          }];

          if (holes.length) {
            groups.push({
              indices: holeIndices,
              vertices: holeVertices
            });
          }

          return groups;
        }

        function genMultiPolygon(coords, r) {
          var outer = {
            vertices: [],
            indices: []
          };
          var holes = {
            vertices: [],
            indices: []
          };
          coords.map(function (c) {
            return genPolygon(c, r);
          }).forEach(function (_ref9) {
            var _ref10 = _slicedToArray$5(_ref9, 2),
                newOuter = _ref10[0],
                newHoles = _ref10[1];

            concatGroup(outer, newOuter);
            newHoles && concatGroup(holes, newHoles);
          });
          var groups = [outer];
          holes.vertices.length && groups.push(holes);
          return groups;
        }

        return _this;
      }

      return _createClass$3(GeoJsonGeometry);
    }(THREE$j.BufferGeometry); //


    function concatGroup(main, extra) {
      var prevVertCnt = Math.round(main.vertices.length / 3);
      concatArr(main.vertices, extra.vertices);
      concatArr(main.indices, extra.indices.map(function (ind) {
        return ind + prevVertCnt;
      }));
    }

    function concatArr(target, src) {
      var _iterator = _createForOfIteratorHelper(src),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var e = _step.value;
          target.push(e);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }

    function polar2Cartesian$2(lat, lng) {
      var r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var phi = (90 - lat) * Math.PI / 180;
      var theta = (90 - lng) * Math.PI / 180;
      return [r * Math.sin(phi) * Math.cos(theta), // x
      r * Math.cos(phi), // y
      r * Math.sin(phi) * Math.sin(theta) // z
      ];
    }

    function computeTangents() {

    	throw new Error( 'BufferGeometryUtils: computeTangents renamed to computeMikkTSpaceTangents.' );

    }

    function computeMikkTSpaceTangents( geometry, MikkTSpace, negateSign = true ) {

    	if ( ! MikkTSpace || ! MikkTSpace.isReady ) {

    		throw new Error( 'BufferGeometryUtils: Initialized MikkTSpace library required.' );

    	}

    	if ( ! geometry.hasAttribute( 'position' ) || ! geometry.hasAttribute( 'normal' ) || ! geometry.hasAttribute( 'uv' ) ) {

    		throw new Error( 'BufferGeometryUtils: Tangents require "position", "normal", and "uv" attributes.' );

    	}

    	function getAttributeArray( attribute ) {

    		if ( attribute.normalized || attribute.isInterleavedBufferAttribute ) {

    			const dstArray = new Float32Array( attribute.getCount() * attribute.itemSize );

    			for ( let i = 0, j = 0; i < attribute.getCount(); i ++ ) {

    				dstArray[ j ++ ] = attribute.getX( i );
    				dstArray[ j ++ ] = attribute.getY( i );

    				if ( attribute.itemSize > 2 ) {

    					dstArray[ j ++ ] = attribute.getZ( i );

    				}

    			}

    			return dstArray;

    		}

    		if ( attribute.array instanceof Float32Array ) {

    			return attribute.array;

    		}

    		return new Float32Array( attribute.array );

    	}

    	// MikkTSpace algorithm requires non-indexed input.

    	const _geometry = geometry.index ? geometry.toNonIndexed() : geometry;

    	// Compute vertex tangents.

    	const tangents = MikkTSpace.generateTangents(

    		getAttributeArray( _geometry.attributes.position ),
    		getAttributeArray( _geometry.attributes.normal ),
    		getAttributeArray( _geometry.attributes.uv )

    	);

    	// Texture coordinate convention of glTF differs from the apparent
    	// default of the MikkTSpace library; .w component must be flipped.

    	if ( negateSign ) {

    		for ( let i = 3; i < tangents.length; i += 4 ) {

    			tangents[ i ] *= - 1;

    		}

    	}

    	//

    	_geometry.setAttribute( 'tangent', new BufferAttribute( tangents, 4 ) );

    	if ( geometry !== _geometry ) {

    		geometry.copy( _geometry );

    	}

    	return geometry;

    }

    /**
     * @param  {Array<BufferGeometry>} geometries
     * @param  {Boolean} useGroups
     * @return {BufferGeometry}
     */
    function mergeBufferGeometries( geometries, useGroups = false ) {

    	const isIndexed = geometries[ 0 ].index !== null;

    	const attributesUsed = new Set( Object.keys( geometries[ 0 ].attributes ) );
    	const morphAttributesUsed = new Set( Object.keys( geometries[ 0 ].morphAttributes ) );

    	const attributes = {};
    	const morphAttributes = {};

    	const morphTargetsRelative = geometries[ 0 ].morphTargetsRelative;

    	const mergedGeometry = new BufferGeometry();

    	let offset = 0;

    	for ( let i = 0; i < geometries.length; ++ i ) {

    		const geometry = geometries[ i ];
    		let attributesCount = 0;

    		// ensure that all geometries are indexed, or none

    		if ( isIndexed !== ( geometry.index !== null ) ) {

    			console.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.' );
    			return null;

    		}

    		// gather attributes, exit early if they're different

    		for ( const name in geometry.attributes ) {

    			if ( ! attributesUsed.has( name ) ) {

    				console.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. All geometries must have compatible attributes; make sure "' + name + '" attribute exists among all geometries, or in none of them.' );
    				return null;

    			}

    			if ( attributes[ name ] === undefined ) attributes[ name ] = [];

    			attributes[ name ].push( geometry.attributes[ name ] );

    			attributesCount ++;

    		}

    		// ensure geometries have the same number of attributes

    		if ( attributesCount !== attributesUsed.size ) {

    			console.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. Make sure all geometries have the same number of attributes.' );
    			return null;

    		}

    		// gather morph attributes, exit early if they're different

    		if ( morphTargetsRelative !== geometry.morphTargetsRelative ) {

    			console.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. .morphTargetsRelative must be consistent throughout all geometries.' );
    			return null;

    		}

    		for ( const name in geometry.morphAttributes ) {

    			if ( ! morphAttributesUsed.has( name ) ) {

    				console.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '.  .morphAttributes must be consistent throughout all geometries.' );
    				return null;

    			}

    			if ( morphAttributes[ name ] === undefined ) morphAttributes[ name ] = [];

    			morphAttributes[ name ].push( geometry.morphAttributes[ name ] );

    		}

    		if ( useGroups ) {

    			let count;

    			if ( isIndexed ) {

    				count = geometry.index.count;

    			} else if ( geometry.attributes.position !== undefined ) {

    				count = geometry.attributes.position.count;

    			} else {

    				console.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. The geometry must have either an index or a position attribute' );
    				return null;

    			}

    			mergedGeometry.addGroup( offset, count, i );

    			offset += count;

    		}

    	}

    	// merge indices

    	if ( isIndexed ) {

    		let indexOffset = 0;
    		const mergedIndex = [];

    		for ( let i = 0; i < geometries.length; ++ i ) {

    			const index = geometries[ i ].index;

    			for ( let j = 0; j < index.count; ++ j ) {

    				mergedIndex.push( index.getX( j ) + indexOffset );

    			}

    			indexOffset += geometries[ i ].attributes.position.count;

    		}

    		mergedGeometry.setIndex( mergedIndex );

    	}

    	// merge attributes

    	for ( const name in attributes ) {

    		const mergedAttribute = mergeBufferAttributes( attributes[ name ] );

    		if ( ! mergedAttribute ) {

    			console.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the ' + name + ' attribute.' );
    			return null;

    		}

    		mergedGeometry.setAttribute( name, mergedAttribute );

    	}

    	// merge morph attributes

    	for ( const name in morphAttributes ) {

    		const numMorphTargets = morphAttributes[ name ][ 0 ].length;

    		if ( numMorphTargets === 0 ) break;

    		mergedGeometry.morphAttributes = mergedGeometry.morphAttributes || {};
    		mergedGeometry.morphAttributes[ name ] = [];

    		for ( let i = 0; i < numMorphTargets; ++ i ) {

    			const morphAttributesToMerge = [];

    			for ( let j = 0; j < morphAttributes[ name ].length; ++ j ) {

    				morphAttributesToMerge.push( morphAttributes[ name ][ j ][ i ] );

    			}

    			const mergedMorphAttribute = mergeBufferAttributes( morphAttributesToMerge );

    			if ( ! mergedMorphAttribute ) {

    				console.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the ' + name + ' morphAttribute.' );
    				return null;

    			}

    			mergedGeometry.morphAttributes[ name ].push( mergedMorphAttribute );

    		}

    	}

    	return mergedGeometry;

    }

    /**
     * @param {Array<BufferAttribute>} attributes
     * @return {BufferAttribute}
     */
    function mergeBufferAttributes( attributes ) {

    	let TypedArray;
    	let itemSize;
    	let normalized;
    	let arrayLength = 0;

    	for ( let i = 0; i < attributes.length; ++ i ) {

    		const attribute = attributes[ i ];

    		if ( attribute.isInterleavedBufferAttribute ) {

    			console.error( 'THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. InterleavedBufferAttributes are not supported.' );
    			return null;

    		}

    		if ( TypedArray === undefined ) TypedArray = attribute.array.constructor;
    		if ( TypedArray !== attribute.array.constructor ) {

    			console.error( 'THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes.' );
    			return null;

    		}

    		if ( itemSize === undefined ) itemSize = attribute.itemSize;
    		if ( itemSize !== attribute.itemSize ) {

    			console.error( 'THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes.' );
    			return null;

    		}

    		if ( normalized === undefined ) normalized = attribute.normalized;
    		if ( normalized !== attribute.normalized ) {

    			console.error( 'THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes.' );
    			return null;

    		}

    		arrayLength += attribute.array.length;

    	}

    	const array = new TypedArray( arrayLength );
    	let offset = 0;

    	for ( let i = 0; i < attributes.length; ++ i ) {

    		array.set( attributes[ i ].array, offset );

    		offset += attributes[ i ].array.length;

    	}

    	return new BufferAttribute( array, itemSize, normalized );

    }

    /**
     * @param {BufferAttribute}
     * @return {BufferAttribute}
     */
    function deepCloneAttribute( attribute ) {

    	if ( attribute.isInstancedInterleavedBufferAttribute || attribute.isInterleavedBufferAttribute ) {

    		return deinterleaveAttribute( attribute );

    	}

    	if ( attribute.isInstancedBufferAttribute ) {

    		return new InstancedBufferAttribute().copy( attribute );

    	}

    	return new BufferAttribute().copy( attribute );

    }

    /**
     * @param {Array<BufferAttribute>} attributes
     * @return {Array<InterleavedBufferAttribute>}
     */
    function interleaveAttributes( attributes ) {

    	// Interleaves the provided attributes into an InterleavedBuffer and returns
    	// a set of InterleavedBufferAttributes for each attribute
    	let TypedArray;
    	let arrayLength = 0;
    	let stride = 0;

    	// calculate the length and type of the interleavedBuffer
    	for ( let i = 0, l = attributes.length; i < l; ++ i ) {

    		const attribute = attributes[ i ];

    		if ( TypedArray === undefined ) TypedArray = attribute.array.constructor;
    		if ( TypedArray !== attribute.array.constructor ) {

    			console.error( 'AttributeBuffers of different types cannot be interleaved' );
    			return null;

    		}

    		arrayLength += attribute.array.length;
    		stride += attribute.itemSize;

    	}

    	// Create the set of buffer attributes
    	const interleavedBuffer = new InterleavedBuffer( new TypedArray( arrayLength ), stride );
    	let offset = 0;
    	const res = [];
    	const getters = [ 'getX', 'getY', 'getZ', 'getW' ];
    	const setters = [ 'setX', 'setY', 'setZ', 'setW' ];

    	for ( let j = 0, l = attributes.length; j < l; j ++ ) {

    		const attribute = attributes[ j ];
    		const itemSize = attribute.itemSize;
    		const count = attribute.count;
    		const iba = new InterleavedBufferAttribute( interleavedBuffer, itemSize, offset, attribute.normalized );
    		res.push( iba );

    		offset += itemSize;

    		// Move the data for each attribute into the new interleavedBuffer
    		// at the appropriate offset
    		for ( let c = 0; c < count; c ++ ) {

    			for ( let k = 0; k < itemSize; k ++ ) {

    				iba[ setters[ k ] ]( c, attribute[ getters[ k ] ]( c ) );

    			}

    		}

    	}

    	return res;

    }

    // returns a new, non-interleaved version of the provided attribute
    function deinterleaveAttribute( attribute ) {

    	const cons = attribute.data.array.constructor;
    	const count = attribute.count;
    	const itemSize = attribute.itemSize;
    	const normalized = attribute.normalized;

    	const array = new cons( count * itemSize );
    	let newAttribute;
    	if ( attribute.isInstancedInterleavedBufferAttribute ) {

    		newAttribute = new InstancedBufferAttribute( array, itemSize, normalized, attribute.meshPerAttribute );

    	} else {

    		newAttribute = new BufferAttribute( array, itemSize, normalized );

    	}

    	for ( let i = 0; i < count; i ++ ) {

    		newAttribute.setX( i, attribute.getX( i ) );

    		if ( itemSize >= 2 ) {

    			newAttribute.setY( i, attribute.getY( i ) );

    		}

    		if ( itemSize >= 3 ) {

    			newAttribute.setZ( i, attribute.getZ( i ) );

    		}

    		if ( itemSize >= 4 ) {

    			newAttribute.setW( i, attribute.getW( i ) );

    		}

    	}

    	return newAttribute;

    }

    // deinterleaves all attributes on the geometry
    function deinterleaveGeometry( geometry ) {

    	const attributes = geometry.attributes;
    	const morphTargets = geometry.morphTargets;
    	const attrMap = new Map();

    	for ( const key in attributes ) {

    		const attr = attributes[ key ];
    		if ( attr.isInterleavedBufferAttribute ) {

    			if ( ! attrMap.has( attr ) ) {

    				attrMap.set( attr, deinterleaveAttribute( attr ) );

    			}

    			attributes[ key ] = attrMap.get( attr );

    		}

    	}

    	for ( const key in morphTargets ) {

    		const attr = morphTargets[ key ];
    		if ( attr.isInterleavedBufferAttribute ) {

    			if ( ! attrMap.has( attr ) ) {

    				attrMap.set( attr, deinterleaveAttribute( attr ) );

    			}

    			morphTargets[ key ] = attrMap.get( attr );

    		}

    	}

    }

    /**
     * @param {Array<BufferGeometry>} geometry
     * @return {number}
     */
    function estimateBytesUsed( geometry ) {

    	// Return the estimated memory used by this geometry in bytes
    	// Calculate using itemSize, count, and BYTES_PER_ELEMENT to account
    	// for InterleavedBufferAttributes.
    	let mem = 0;
    	for ( const name in geometry.attributes ) {

    		const attr = geometry.getAttribute( name );
    		mem += attr.count * attr.itemSize * attr.array.BYTES_PER_ELEMENT;

    	}

    	const indices = geometry.getIndex();
    	mem += indices ? indices.count * indices.itemSize * indices.array.BYTES_PER_ELEMENT : 0;
    	return mem;

    }

    /**
     * @param {BufferGeometry} geometry
     * @param {number} tolerance
     * @return {BufferGeometry}
     */
    function mergeVertices( geometry, tolerance = 1e-4 ) {

    	tolerance = Math.max( tolerance, Number.EPSILON );

    	// Generate an index buffer if the geometry doesn't have one, or optimize it
    	// if it's already available.
    	const hashToIndex = {};
    	const indices = geometry.getIndex();
    	const positions = geometry.getAttribute( 'position' );
    	const vertexCount = indices ? indices.count : positions.count;

    	// next value for triangle indices
    	let nextIndex = 0;

    	// attributes and new attribute arrays
    	const attributeNames = Object.keys( geometry.attributes );
    	const tmpAttributes = {};
    	const tmpMorphAttributes = {};
    	const newIndices = [];
    	const getters = [ 'getX', 'getY', 'getZ', 'getW' ];
    	const setters = [ 'setX', 'setY', 'setZ', 'setW' ];

    	// Initialize the arrays, allocating space conservatively. Extra
    	// space will be trimmed in the last step.
    	for ( let i = 0, l = attributeNames.length; i < l; i ++ ) {

    		const name = attributeNames[ i ];
    		const attr = geometry.attributes[ name ];

    		tmpAttributes[ name ] = new BufferAttribute(
    			new attr.array.constructor( attr.count * attr.itemSize ),
    			attr.itemSize,
    			attr.normalized
    		);

    		const morphAttr = geometry.morphAttributes[ name ];
    		if ( morphAttr ) {

    			tmpMorphAttributes[ name ] = new BufferAttribute(
    				new morphAttr.array.constructor( morphAttr.count * morphAttr.itemSize ),
    				morphAttr.itemSize,
    				morphAttr.normalized
    			);

    		}

    	}

    	// convert the error tolerance to an amount of decimal places to truncate to
    	const decimalShift = Math.log10( 1 / tolerance );
    	const shiftMultiplier = Math.pow( 10, decimalShift );
    	for ( let i = 0; i < vertexCount; i ++ ) {

    		const index = indices ? indices.getX( i ) : i;

    		// Generate a hash for the vertex attributes at the current index 'i'
    		let hash = '';
    		for ( let j = 0, l = attributeNames.length; j < l; j ++ ) {

    			const name = attributeNames[ j ];
    			const attribute = geometry.getAttribute( name );
    			const itemSize = attribute.itemSize;

    			for ( let k = 0; k < itemSize; k ++ ) {

    				// double tilde truncates the decimal value
    				hash += `${ ~ ~ ( attribute[ getters[ k ] ]( index ) * shiftMultiplier ) },`;

    			}

    		}

    		// Add another reference to the vertex if it's already
    		// used by another index
    		if ( hash in hashToIndex ) {

    			newIndices.push( hashToIndex[ hash ] );

    		} else {

    			// copy data to the new index in the temporary attributes
    			for ( let j = 0, l = attributeNames.length; j < l; j ++ ) {

    				const name = attributeNames[ j ];
    				const attribute = geometry.getAttribute( name );
    				const morphAttr = geometry.morphAttributes[ name ];
    				const itemSize = attribute.itemSize;
    				const newarray = tmpAttributes[ name ];
    				const newMorphArrays = tmpMorphAttributes[ name ];

    				for ( let k = 0; k < itemSize; k ++ ) {

    					const getterFunc = getters[ k ];
    					const setterFunc = setters[ k ];
    					newarray[ setterFunc ]( nextIndex, attribute[ getterFunc ]( index ) );

    					if ( morphAttr ) {

    						for ( let m = 0, ml = morphAttr.length; m < ml; m ++ ) {

    							newMorphArrays[ m ][ setterFunc ]( nextIndex, morphAttr[ m ][ getterFunc ]( index ) );

    						}

    					}

    				}

    			}

    			hashToIndex[ hash ] = nextIndex;
    			newIndices.push( nextIndex );
    			nextIndex ++;

    		}

    	}

    	// generate result BufferGeometry
    	const result = geometry.clone();
    	for ( const name in geometry.attributes ) {

    		const tmpAttribute = tmpAttributes[ name ];

    		result.setAttribute( name, new BufferAttribute(
    			tmpAttribute.array.slice( 0, nextIndex * tmpAttribute.itemSize ),
    			tmpAttribute.itemSize,
    			tmpAttribute.normalized,
    		) );

    		if ( ! ( name in tmpMorphAttributes ) ) continue;

    		for ( let j = 0; j < tmpMorphAttributes[ name ].length; j ++ ) {

    			const tmpMorphAttribute = tmpMorphAttributes[ name ][ j ];

    			result.morphAttributes[ name ][ j ] = new BufferAttribute(
    				tmpMorphAttribute.array.slice( 0, nextIndex * tmpMorphAttribute.itemSize ),
    				tmpMorphAttribute.itemSize,
    				tmpMorphAttribute.normalized,
    			);

    		}

    	}

    	// indices

    	result.setIndex( newIndices );

    	return result;

    }

    /**
     * @param {BufferGeometry} geometry
     * @param {number} drawMode
     * @return {BufferGeometry}
     */
    function toTrianglesDrawMode( geometry, drawMode ) {

    	if ( drawMode === TrianglesDrawMode ) {

    		console.warn( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.' );
    		return geometry;

    	}

    	if ( drawMode === TriangleFanDrawMode || drawMode === TriangleStripDrawMode ) {

    		let index = geometry.getIndex();

    		// generate index if not present

    		if ( index === null ) {

    			const indices = [];

    			const position = geometry.getAttribute( 'position' );

    			if ( position !== undefined ) {

    				for ( let i = 0; i < position.count; i ++ ) {

    					indices.push( i );

    				}

    				geometry.setIndex( indices );
    				index = geometry.getIndex();

    			} else {

    				console.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.' );
    				return geometry;

    			}

    		}

    		//

    		const numberOfTriangles = index.count - 2;
    		const newIndices = [];

    		if ( drawMode === TriangleFanDrawMode ) {

    			// gl.TRIANGLE_FAN

    			for ( let i = 1; i <= numberOfTriangles; i ++ ) {

    				newIndices.push( index.getX( 0 ) );
    				newIndices.push( index.getX( i ) );
    				newIndices.push( index.getX( i + 1 ) );

    			}

    		} else {

    			// gl.TRIANGLE_STRIP

    			for ( let i = 0; i < numberOfTriangles; i ++ ) {

    				if ( i % 2 === 0 ) {

    					newIndices.push( index.getX( i ) );
    					newIndices.push( index.getX( i + 1 ) );
    					newIndices.push( index.getX( i + 2 ) );

    				} else {

    					newIndices.push( index.getX( i + 2 ) );
    					newIndices.push( index.getX( i + 1 ) );
    					newIndices.push( index.getX( i ) );

    				}

    			}

    		}

    		if ( ( newIndices.length / 3 ) !== numberOfTriangles ) {

    			console.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.' );

    		}

    		// build final geometry

    		const newGeometry = geometry.clone();
    		newGeometry.setIndex( newIndices );
    		newGeometry.clearGroups();

    		return newGeometry;

    	} else {

    		console.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:', drawMode );
    		return geometry;

    	}

    }

    /**
     * Calculates the morphed attributes of a morphed/skinned BufferGeometry.
     * Helpful for Raytracing or Decals.
     * @param {Mesh | Line | Points} object An instance of Mesh, Line or Points.
     * @return {Object} An Object with original position/normal attributes and morphed ones.
     */
    function computeMorphedAttributes( object ) {

    	if ( object.geometry.isBufferGeometry !== true ) {

    		console.error( 'THREE.BufferGeometryUtils: Geometry is not of type BufferGeometry.' );
    		return null;

    	}

    	const _vA = new Vector3();
    	const _vB = new Vector3();
    	const _vC = new Vector3();

    	const _tempA = new Vector3();
    	const _tempB = new Vector3();
    	const _tempC = new Vector3();

    	const _morphA = new Vector3();
    	const _morphB = new Vector3();
    	const _morphC = new Vector3();

    	function _calculateMorphedAttributeData(
    		object,
    		attribute,
    		morphAttribute,
    		morphTargetsRelative,
    		a,
    		b,
    		c,
    		modifiedAttributeArray
    	) {

    		_vA.fromBufferAttribute( attribute, a );
    		_vB.fromBufferAttribute( attribute, b );
    		_vC.fromBufferAttribute( attribute, c );

    		const morphInfluences = object.morphTargetInfluences;

    		if ( morphAttribute && morphInfluences ) {

    			_morphA.set( 0, 0, 0 );
    			_morphB.set( 0, 0, 0 );
    			_morphC.set( 0, 0, 0 );

    			for ( let i = 0, il = morphAttribute.length; i < il; i ++ ) {

    				const influence = morphInfluences[ i ];
    				const morph = morphAttribute[ i ];

    				if ( influence === 0 ) continue;

    				_tempA.fromBufferAttribute( morph, a );
    				_tempB.fromBufferAttribute( morph, b );
    				_tempC.fromBufferAttribute( morph, c );

    				if ( morphTargetsRelative ) {

    					_morphA.addScaledVector( _tempA, influence );
    					_morphB.addScaledVector( _tempB, influence );
    					_morphC.addScaledVector( _tempC, influence );

    				} else {

    					_morphA.addScaledVector( _tempA.sub( _vA ), influence );
    					_morphB.addScaledVector( _tempB.sub( _vB ), influence );
    					_morphC.addScaledVector( _tempC.sub( _vC ), influence );

    				}

    			}

    			_vA.add( _morphA );
    			_vB.add( _morphB );
    			_vC.add( _morphC );

    		}

    		if ( object.isSkinnedMesh ) {

    			object.boneTransform( a, _vA );
    			object.boneTransform( b, _vB );
    			object.boneTransform( c, _vC );

    		}

    		modifiedAttributeArray[ a * 3 + 0 ] = _vA.x;
    		modifiedAttributeArray[ a * 3 + 1 ] = _vA.y;
    		modifiedAttributeArray[ a * 3 + 2 ] = _vA.z;
    		modifiedAttributeArray[ b * 3 + 0 ] = _vB.x;
    		modifiedAttributeArray[ b * 3 + 1 ] = _vB.y;
    		modifiedAttributeArray[ b * 3 + 2 ] = _vB.z;
    		modifiedAttributeArray[ c * 3 + 0 ] = _vC.x;
    		modifiedAttributeArray[ c * 3 + 1 ] = _vC.y;
    		modifiedAttributeArray[ c * 3 + 2 ] = _vC.z;

    	}

    	const geometry = object.geometry;
    	const material = object.material;

    	let a, b, c;
    	const index = geometry.index;
    	const positionAttribute = geometry.attributes.position;
    	const morphPosition = geometry.morphAttributes.position;
    	const morphTargetsRelative = geometry.morphTargetsRelative;
    	const normalAttribute = geometry.attributes.normal;
    	const morphNormal = geometry.morphAttributes.position;

    	const groups = geometry.groups;
    	const drawRange = geometry.drawRange;
    	let i, j, il, jl;
    	let group;
    	let start, end;

    	const modifiedPosition = new Float32Array( positionAttribute.count * positionAttribute.itemSize );
    	const modifiedNormal = new Float32Array( normalAttribute.count * normalAttribute.itemSize );

    	if ( index !== null ) {

    		// indexed buffer geometry

    		if ( Array.isArray( material ) ) {

    			for ( i = 0, il = groups.length; i < il; i ++ ) {

    				group = groups[ i ];

    				start = Math.max( group.start, drawRange.start );
    				end = Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) );

    				for ( j = start, jl = end; j < jl; j += 3 ) {

    					a = index.getX( j );
    					b = index.getX( j + 1 );
    					c = index.getX( j + 2 );

    					_calculateMorphedAttributeData(
    						object,
    						positionAttribute,
    						morphPosition,
    						morphTargetsRelative,
    						a, b, c,
    						modifiedPosition
    					);

    					_calculateMorphedAttributeData(
    						object,
    						normalAttribute,
    						morphNormal,
    						morphTargetsRelative,
    						a, b, c,
    						modifiedNormal
    					);

    				}

    			}

    		} else {

    			start = Math.max( 0, drawRange.start );
    			end = Math.min( index.count, ( drawRange.start + drawRange.count ) );

    			for ( i = start, il = end; i < il; i += 3 ) {

    				a = index.getX( i );
    				b = index.getX( i + 1 );
    				c = index.getX( i + 2 );

    				_calculateMorphedAttributeData(
    					object,
    					positionAttribute,
    					morphPosition,
    					morphTargetsRelative,
    					a, b, c,
    					modifiedPosition
    				);

    				_calculateMorphedAttributeData(
    					object,
    					normalAttribute,
    					morphNormal,
    					morphTargetsRelative,
    					a, b, c,
    					modifiedNormal
    				);

    			}

    		}

    	} else {

    		// non-indexed buffer geometry

    		if ( Array.isArray( material ) ) {

    			for ( i = 0, il = groups.length; i < il; i ++ ) {

    				group = groups[ i ];

    				start = Math.max( group.start, drawRange.start );
    				end = Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) );

    				for ( j = start, jl = end; j < jl; j += 3 ) {

    					a = j;
    					b = j + 1;
    					c = j + 2;

    					_calculateMorphedAttributeData(
    						object,
    						positionAttribute,
    						morphPosition,
    						morphTargetsRelative,
    						a, b, c,
    						modifiedPosition
    					);

    					_calculateMorphedAttributeData(
    						object,
    						normalAttribute,
    						morphNormal,
    						morphTargetsRelative,
    						a, b, c,
    						modifiedNormal
    					);

    				}

    			}

    		} else {

    			start = Math.max( 0, drawRange.start );
    			end = Math.min( positionAttribute.count, ( drawRange.start + drawRange.count ) );

    			for ( i = start, il = end; i < il; i += 3 ) {

    				a = i;
    				b = i + 1;
    				c = i + 2;

    				_calculateMorphedAttributeData(
    					object,
    					positionAttribute,
    					morphPosition,
    					morphTargetsRelative,
    					a, b, c,
    					modifiedPosition
    				);

    				_calculateMorphedAttributeData(
    					object,
    					normalAttribute,
    					morphNormal,
    					morphTargetsRelative,
    					a, b, c,
    					modifiedNormal
    				);

    			}

    		}

    	}

    	const morphedPositionAttribute = new Float32BufferAttribute( modifiedPosition, 3 );
    	const morphedNormalAttribute = new Float32BufferAttribute( modifiedNormal, 3 );

    	return {

    		positionAttribute: positionAttribute,
    		normalAttribute: normalAttribute,
    		morphedPositionAttribute: morphedPositionAttribute,
    		morphedNormalAttribute: morphedNormalAttribute

    	};

    }

    function mergeGroups( geometry ) {

    	if ( geometry.groups.length === 0 ) {

    		console.warn( 'THREE.BufferGeometryUtils.mergeGroups(): No groups are defined. Nothing to merge.' );
    		return geometry;

    	}

    	let groups = geometry.groups;

    	// sort groups by material index

    	groups = groups.sort( ( a, b ) => {

    		if ( a.materialIndex !== b.materialIndex ) return a.materialIndex - b.materialIndex;

    		return a.start - b.start;

    	} );

    	// create index for non-indexed geometries

    	if ( geometry.getIndex() === null ) {

    		const positionAttribute = geometry.getAttribute( 'position' );
    		const indices = [];

    		for ( let i = 0; i < positionAttribute.count; i += 3 ) {

    			indices.push( i, i + 1, i + 2 );

    		}

    		geometry.setIndex( indices );

    	}

    	// sort index

    	const index = geometry.getIndex();

    	const newIndices = [];

    	for ( let i = 0; i < groups.length; i ++ ) {

    		const group = groups[ i ];

    		const groupStart = group.start;
    		const groupLength = groupStart + group.count;

    		for ( let j = groupStart; j < groupLength; j ++ ) {

    			newIndices.push( index.getX( j ) );

    		}

    	}

    	geometry.dispose(); // Required to force buffer recreation
    	geometry.setIndex( newIndices );

    	// update groups indices

    	let start = 0;

    	for ( let i = 0; i < groups.length; i ++ ) {

    		const group = groups[ i ];

    		group.start = start;
    		start += group.count;

    	}

    	// merge groups

    	let currentGroup = groups[ 0 ];

    	geometry.groups = [ currentGroup ];

    	for ( let i = 1; i < groups.length; i ++ ) {

    		const group = groups[ i ];

    		if ( currentGroup.materialIndex === group.materialIndex ) {

    			currentGroup.count += group.count;

    		} else {

    			currentGroup = group;
    			geometry.groups.push( currentGroup );

    		}

    	}

    	return geometry;

    }


    // Creates a new, non-indexed geometry with smooth normals everywhere except faces that meet at
    // an angle greater than the crease angle.
    function toCreasedNormals( geometry, creaseAngle = Math.PI / 3 /* 60 degrees */ ) {

    	const creaseDot = Math.cos( creaseAngle );
    	const hashMultiplier = ( 1 + 1e-10 ) * 1e2;

    	// reusable vertors
    	const verts = [ new Vector3(), new Vector3(), new Vector3() ];
    	const tempVec1 = new Vector3();
    	const tempVec2 = new Vector3();
    	const tempNorm = new Vector3();
    	const tempNorm2 = new Vector3();

    	// hashes a vector
    	function hashVertex( v ) {

    		const x = ~ ~ ( v.x * hashMultiplier );
    		const y = ~ ~ ( v.y * hashMultiplier );
    		const z = ~ ~ ( v.z * hashMultiplier );
    		return `${x},${y},${z}`;

    	}

    	const resultGeometry = geometry.toNonIndexed();
    	const posAttr = resultGeometry.attributes.position;
    	const vertexMap = {};

    	// find all the normals shared by commonly located vertices
    	for ( let i = 0, l = posAttr.count / 3; i < l; i ++ ) {

    		const i3 = 3 * i;
    		const a = verts[ 0 ].fromBufferAttribute( posAttr, i3 + 0 );
    		const b = verts[ 1 ].fromBufferAttribute( posAttr, i3 + 1 );
    		const c = verts[ 2 ].fromBufferAttribute( posAttr, i3 + 2 );

    		tempVec1.subVectors( c, b );
    		tempVec2.subVectors( a, b );

    		// add the normal to the map for all vertices
    		const normal = new Vector3().crossVectors( tempVec1, tempVec2 ).normalize();
    		for ( let n = 0; n < 3; n ++ ) {

    			const vert = verts[ n ];
    			const hash = hashVertex( vert );
    			if ( ! ( hash in vertexMap ) ) {

    				vertexMap[ hash ] = [];

    			}

    			vertexMap[ hash ].push( normal );

    		}

    	}

    	// average normals from all vertices that share a common location if they are within the
    	// provided crease threshold
    	const normalArray = new Float32Array( posAttr.count * 3 );
    	const normAttr = new BufferAttribute( normalArray, 3, false );
    	for ( let i = 0, l = posAttr.count / 3; i < l; i ++ ) {

    		// get the face normal for this vertex
    		const i3 = 3 * i;
    		const a = verts[ 0 ].fromBufferAttribute( posAttr, i3 + 0 );
    		const b = verts[ 1 ].fromBufferAttribute( posAttr, i3 + 1 );
    		const c = verts[ 2 ].fromBufferAttribute( posAttr, i3 + 2 );

    		tempVec1.subVectors( c, b );
    		tempVec2.subVectors( a, b );

    		tempNorm.crossVectors( tempVec1, tempVec2 ).normalize();

    		// average all normals that meet the threshold and set the normal value
    		for ( let n = 0; n < 3; n ++ ) {

    			const vert = verts[ n ];
    			const hash = hashVertex( vert );
    			const otherNormals = vertexMap[ hash ];
    			tempNorm2.set( 0, 0, 0 );

    			for ( let k = 0, lk = otherNormals.length; k < lk; k ++ ) {

    				const otherNorm = otherNormals[ k ];
    				if ( tempNorm.dot( otherNorm ) > creaseDot ) {

    					tempNorm2.add( otherNorm );

    				}

    			}

    			tempNorm2.normalize();
    			normAttr.setXYZ( i3 + n, tempNorm2.x, tempNorm2.y, tempNorm2.z );

    		}

    	}

    	resultGeometry.setAttribute( 'normal', normAttr );
    	return resultGeometry;

    }

    var _bfg = /*#__PURE__*/Object.freeze({
        __proto__: null,
        deepCloneAttribute: deepCloneAttribute,
        deinterleaveAttribute: deinterleaveAttribute,
        deinterleaveGeometry: deinterleaveGeometry,
        computeTangents: computeTangents,
        computeMikkTSpaceTangents: computeMikkTSpaceTangents,
        mergeBufferGeometries: mergeBufferGeometries,
        mergeBufferAttributes: mergeBufferAttributes,
        interleaveAttributes: interleaveAttributes,
        estimateBytesUsed: estimateBytesUsed,
        mergeVertices: mergeVertices,
        toTrianglesDrawMode: toTrianglesDrawMode,
        computeMorphedAttributes: computeMorphedAttributes,
        mergeGroups: mergeGroups,
        toCreasedNormals: toCreasedNormals
    });

    var index$1 = (function (p) {
      return p instanceof Function ? p // fn
      : typeof p === 'string' ? function (obj) {
        return obj[p];
      } // property name
      : function (obj) {
        return p;
      };
    }); // constant

    var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

    function getDefaultExportFromCjs (x) {
    	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
    }

    function createCommonjsModule(fn) {
      var module = { exports: {} };
    	return fn(module, module.exports), module.exports;
    }

    var tinycolor = createCommonjsModule(function (module) {
    // TinyColor v1.4.2
    // https://github.com/bgrins/TinyColor
    // Brian Grinstead, MIT License

    (function(Math) {

    var trimLeft = /^\s+/,
        trimRight = /\s+$/,
        tinyCounter = 0,
        mathRound = Math.round,
        mathMin = Math.min,
        mathMax = Math.max,
        mathRandom = Math.random;

    function tinycolor (color, opts) {

        color = (color) ? color : '';
        opts = opts || { };

        // If input is already a tinycolor, return itself
        if (color instanceof tinycolor) {
           return color;
        }
        // If we are called as a function, call using new instead
        if (!(this instanceof tinycolor)) {
            return new tinycolor(color, opts);
        }

        var rgb = inputToRGB(color);
        this._originalInput = color,
        this._r = rgb.r,
        this._g = rgb.g,
        this._b = rgb.b,
        this._a = rgb.a,
        this._roundA = mathRound(100*this._a) / 100,
        this._format = opts.format || rgb.format;
        this._gradientType = opts.gradientType;

        // Don't let the range of [0,255] come back in [0,1].
        // Potentially lose a little bit of precision here, but will fix issues where
        // .5 gets interpreted as half of the total, instead of half of 1
        // If it was supposed to be 128, this was already taken care of by `inputToRgb`
        if (this._r < 1) { this._r = mathRound(this._r); }
        if (this._g < 1) { this._g = mathRound(this._g); }
        if (this._b < 1) { this._b = mathRound(this._b); }

        this._ok = rgb.ok;
        this._tc_id = tinyCounter++;
    }

    tinycolor.prototype = {
        isDark: function() {
            return this.getBrightness() < 128;
        },
        isLight: function() {
            return !this.isDark();
        },
        isValid: function() {
            return this._ok;
        },
        getOriginalInput: function() {
          return this._originalInput;
        },
        getFormat: function() {
            return this._format;
        },
        getAlpha: function() {
            return this._a;
        },
        getBrightness: function() {
            //http://www.w3.org/TR/AERT#color-contrast
            var rgb = this.toRgb();
            return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1000;
        },
        getLuminance: function() {
            //http://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef
            var rgb = this.toRgb();
            var RsRGB, GsRGB, BsRGB, R, G, B;
            RsRGB = rgb.r/255;
            GsRGB = rgb.g/255;
            BsRGB = rgb.b/255;

            if (RsRGB <= 0.03928) {R = RsRGB / 12.92;} else {R = Math.pow(((RsRGB + 0.055) / 1.055), 2.4);}
            if (GsRGB <= 0.03928) {G = GsRGB / 12.92;} else {G = Math.pow(((GsRGB + 0.055) / 1.055), 2.4);}
            if (BsRGB <= 0.03928) {B = BsRGB / 12.92;} else {B = Math.pow(((BsRGB + 0.055) / 1.055), 2.4);}
            return (0.2126 * R) + (0.7152 * G) + (0.0722 * B);
        },
        setAlpha: function(value) {
            this._a = boundAlpha(value);
            this._roundA = mathRound(100*this._a) / 100;
            return this;
        },
        toHsv: function() {
            var hsv = rgbToHsv(this._r, this._g, this._b);
            return { h: hsv.h * 360, s: hsv.s, v: hsv.v, a: this._a };
        },
        toHsvString: function() {
            var hsv = rgbToHsv(this._r, this._g, this._b);
            var h = mathRound(hsv.h * 360), s = mathRound(hsv.s * 100), v = mathRound(hsv.v * 100);
            return (this._a == 1) ?
              "hsv("  + h + ", " + s + "%, " + v + "%)" :
              "hsva(" + h + ", " + s + "%, " + v + "%, "+ this._roundA + ")";
        },
        toHsl: function() {
            var hsl = rgbToHsl(this._r, this._g, this._b);
            return { h: hsl.h * 360, s: hsl.s, l: hsl.l, a: this._a };
        },
        toHslString: function() {
            var hsl = rgbToHsl(this._r, this._g, this._b);
            var h = mathRound(hsl.h * 360), s = mathRound(hsl.s * 100), l = mathRound(hsl.l * 100);
            return (this._a == 1) ?
              "hsl("  + h + ", " + s + "%, " + l + "%)" :
              "hsla(" + h + ", " + s + "%, " + l + "%, "+ this._roundA + ")";
        },
        toHex: function(allow3Char) {
            return rgbToHex(this._r, this._g, this._b, allow3Char);
        },
        toHexString: function(allow3Char) {
            return '#' + this.toHex(allow3Char);
        },
        toHex8: function(allow4Char) {
            return rgbaToHex(this._r, this._g, this._b, this._a, allow4Char);
        },
        toHex8String: function(allow4Char) {
            return '#' + this.toHex8(allow4Char);
        },
        toRgb: function() {
            return { r: mathRound(this._r), g: mathRound(this._g), b: mathRound(this._b), a: this._a };
        },
        toRgbString: function() {
            return (this._a == 1) ?
              "rgb("  + mathRound(this._r) + ", " + mathRound(this._g) + ", " + mathRound(this._b) + ")" :
              "rgba(" + mathRound(this._r) + ", " + mathRound(this._g) + ", " + mathRound(this._b) + ", " + this._roundA + ")";
        },
        toPercentageRgb: function() {
            return { r: mathRound(bound01(this._r, 255) * 100) + "%", g: mathRound(bound01(this._g, 255) * 100) + "%", b: mathRound(bound01(this._b, 255) * 100) + "%", a: this._a };
        },
        toPercentageRgbString: function() {
            return (this._a == 1) ?
              "rgb("  + mathRound(bound01(this._r, 255) * 100) + "%, " + mathRound(bound01(this._g, 255) * 100) + "%, " + mathRound(bound01(this._b, 255) * 100) + "%)" :
              "rgba(" + mathRound(bound01(this._r, 255) * 100) + "%, " + mathRound(bound01(this._g, 255) * 100) + "%, " + mathRound(bound01(this._b, 255) * 100) + "%, " + this._roundA + ")";
        },
        toName: function() {
            if (this._a === 0) {
                return "transparent";
            }

            if (this._a < 1) {
                return false;
            }

            return hexNames[rgbToHex(this._r, this._g, this._b, true)] || false;
        },
        toFilter: function(secondColor) {
            var hex8String = '#' + rgbaToArgbHex(this._r, this._g, this._b, this._a);
            var secondHex8String = hex8String;
            var gradientType = this._gradientType ? "GradientType = 1, " : "";

            if (secondColor) {
                var s = tinycolor(secondColor);
                secondHex8String = '#' + rgbaToArgbHex(s._r, s._g, s._b, s._a);
            }

            return "progid:DXImageTransform.Microsoft.gradient("+gradientType+"startColorstr="+hex8String+",endColorstr="+secondHex8String+")";
        },
        toString: function(format) {
            var formatSet = !!format;
            format = format || this._format;

            var formattedString = false;
            var hasAlpha = this._a < 1 && this._a >= 0;
            var needsAlphaFormat = !formatSet && hasAlpha && (format === "hex" || format === "hex6" || format === "hex3" || format === "hex4" || format === "hex8" || format === "name");

            if (needsAlphaFormat) {
                // Special case for "transparent", all other non-alpha formats
                // will return rgba when there is transparency.
                if (format === "name" && this._a === 0) {
                    return this.toName();
                }
                return this.toRgbString();
            }
            if (format === "rgb") {
                formattedString = this.toRgbString();
            }
            if (format === "prgb") {
                formattedString = this.toPercentageRgbString();
            }
            if (format === "hex" || format === "hex6") {
                formattedString = this.toHexString();
            }
            if (format === "hex3") {
                formattedString = this.toHexString(true);
            }
            if (format === "hex4") {
                formattedString = this.toHex8String(true);
            }
            if (format === "hex8") {
                formattedString = this.toHex8String();
            }
            if (format === "name") {
                formattedString = this.toName();
            }
            if (format === "hsl") {
                formattedString = this.toHslString();
            }
            if (format === "hsv") {
                formattedString = this.toHsvString();
            }

            return formattedString || this.toHexString();
        },
        clone: function() {
            return tinycolor(this.toString());
        },

        _applyModification: function(fn, args) {
            var color = fn.apply(null, [this].concat([].slice.call(args)));
            this._r = color._r;
            this._g = color._g;
            this._b = color._b;
            this.setAlpha(color._a);
            return this;
        },
        lighten: function() {
            return this._applyModification(lighten, arguments);
        },
        brighten: function() {
            return this._applyModification(brighten, arguments);
        },
        darken: function() {
            return this._applyModification(darken, arguments);
        },
        desaturate: function() {
            return this._applyModification(desaturate, arguments);
        },
        saturate: function() {
            return this._applyModification(saturate, arguments);
        },
        greyscale: function() {
            return this._applyModification(greyscale, arguments);
        },
        spin: function() {
            return this._applyModification(spin, arguments);
        },

        _applyCombination: function(fn, args) {
            return fn.apply(null, [this].concat([].slice.call(args)));
        },
        analogous: function() {
            return this._applyCombination(analogous, arguments);
        },
        complement: function() {
            return this._applyCombination(complement, arguments);
        },
        monochromatic: function() {
            return this._applyCombination(monochromatic, arguments);
        },
        splitcomplement: function() {
            return this._applyCombination(splitcomplement, arguments);
        },
        triad: function() {
            return this._applyCombination(triad, arguments);
        },
        tetrad: function() {
            return this._applyCombination(tetrad, arguments);
        }
    };

    // If input is an object, force 1 into "1.0" to handle ratios properly
    // String input requires "1.0" as input, so 1 will be treated as 1
    tinycolor.fromRatio = function(color, opts) {
        if (typeof color == "object") {
            var newColor = {};
            for (var i in color) {
                if (color.hasOwnProperty(i)) {
                    if (i === "a") {
                        newColor[i] = color[i];
                    }
                    else {
                        newColor[i] = convertToPercentage(color[i]);
                    }
                }
            }
            color = newColor;
        }

        return tinycolor(color, opts);
    };

    // Given a string or object, convert that input to RGB
    // Possible string inputs:
    //
    //     "red"
    //     "#f00" or "f00"
    //     "#ff0000" or "ff0000"
    //     "#ff000000" or "ff000000"
    //     "rgb 255 0 0" or "rgb (255, 0, 0)"
    //     "rgb 1.0 0 0" or "rgb (1, 0, 0)"
    //     "rgba (255, 0, 0, 1)" or "rgba 255, 0, 0, 1"
    //     "rgba (1.0, 0, 0, 1)" or "rgba 1.0, 0, 0, 1"
    //     "hsl(0, 100%, 50%)" or "hsl 0 100% 50%"
    //     "hsla(0, 100%, 50%, 1)" or "hsla 0 100% 50%, 1"
    //     "hsv(0, 100%, 100%)" or "hsv 0 100% 100%"
    //
    function inputToRGB(color) {

        var rgb = { r: 0, g: 0, b: 0 };
        var a = 1;
        var s = null;
        var v = null;
        var l = null;
        var ok = false;
        var format = false;

        if (typeof color == "string") {
            color = stringInputToObject(color);
        }

        if (typeof color == "object") {
            if (isValidCSSUnit(color.r) && isValidCSSUnit(color.g) && isValidCSSUnit(color.b)) {
                rgb = rgbToRgb(color.r, color.g, color.b);
                ok = true;
                format = String(color.r).substr(-1) === "%" ? "prgb" : "rgb";
            }
            else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.v)) {
                s = convertToPercentage(color.s);
                v = convertToPercentage(color.v);
                rgb = hsvToRgb(color.h, s, v);
                ok = true;
                format = "hsv";
            }
            else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.l)) {
                s = convertToPercentage(color.s);
                l = convertToPercentage(color.l);
                rgb = hslToRgb(color.h, s, l);
                ok = true;
                format = "hsl";
            }

            if (color.hasOwnProperty("a")) {
                a = color.a;
            }
        }

        a = boundAlpha(a);

        return {
            ok: ok,
            format: color.format || format,
            r: mathMin(255, mathMax(rgb.r, 0)),
            g: mathMin(255, mathMax(rgb.g, 0)),
            b: mathMin(255, mathMax(rgb.b, 0)),
            a: a
        };
    }


    // Conversion Functions
    // --------------------

    // `rgbToHsl`, `rgbToHsv`, `hslToRgb`, `hsvToRgb` modified from:
    // <http://mjijackson.com/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript>

    // `rgbToRgb`
    // Handle bounds / percentage checking to conform to CSS color spec
    // <http://www.w3.org/TR/css3-color/>
    // *Assumes:* r, g, b in [0, 255] or [0, 1]
    // *Returns:* { r, g, b } in [0, 255]
    function rgbToRgb(r, g, b){
        return {
            r: bound01(r, 255) * 255,
            g: bound01(g, 255) * 255,
            b: bound01(b, 255) * 255
        };
    }

    // `rgbToHsl`
    // Converts an RGB color value to HSL.
    // *Assumes:* r, g, and b are contained in [0, 255] or [0, 1]
    // *Returns:* { h, s, l } in [0,1]
    function rgbToHsl(r, g, b) {

        r = bound01(r, 255);
        g = bound01(g, 255);
        b = bound01(b, 255);

        var max = mathMax(r, g, b), min = mathMin(r, g, b);
        var h, s, l = (max + min) / 2;

        if(max == min) {
            h = s = 0; // achromatic
        }
        else {
            var d = max - min;
            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
            switch(max) {
                case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                case g: h = (b - r) / d + 2; break;
                case b: h = (r - g) / d + 4; break;
            }

            h /= 6;
        }

        return { h: h, s: s, l: l };
    }

    // `hslToRgb`
    // Converts an HSL color value to RGB.
    // *Assumes:* h is contained in [0, 1] or [0, 360] and s and l are contained [0, 1] or [0, 100]
    // *Returns:* { r, g, b } in the set [0, 255]
    function hslToRgb(h, s, l) {
        var r, g, b;

        h = bound01(h, 360);
        s = bound01(s, 100);
        l = bound01(l, 100);

        function hue2rgb(p, q, t) {
            if(t < 0) t += 1;
            if(t > 1) t -= 1;
            if(t < 1/6) return p + (q - p) * 6 * t;
            if(t < 1/2) return q;
            if(t < 2/3) return p + (q - p) * (2/3 - t) * 6;
            return p;
        }

        if(s === 0) {
            r = g = b = l; // achromatic
        }
        else {
            var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
            var p = 2 * l - q;
            r = hue2rgb(p, q, h + 1/3);
            g = hue2rgb(p, q, h);
            b = hue2rgb(p, q, h - 1/3);
        }

        return { r: r * 255, g: g * 255, b: b * 255 };
    }

    // `rgbToHsv`
    // Converts an RGB color value to HSV
    // *Assumes:* r, g, and b are contained in the set [0, 255] or [0, 1]
    // *Returns:* { h, s, v } in [0,1]
    function rgbToHsv(r, g, b) {

        r = bound01(r, 255);
        g = bound01(g, 255);
        b = bound01(b, 255);

        var max = mathMax(r, g, b), min = mathMin(r, g, b);
        var h, s, v = max;

        var d = max - min;
        s = max === 0 ? 0 : d / max;

        if(max == min) {
            h = 0; // achromatic
        }
        else {
            switch(max) {
                case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                case g: h = (b - r) / d + 2; break;
                case b: h = (r - g) / d + 4; break;
            }
            h /= 6;
        }
        return { h: h, s: s, v: v };
    }

    // `hsvToRgb`
    // Converts an HSV color value to RGB.
    // *Assumes:* h is contained in [0, 1] or [0, 360] and s and v are contained in [0, 1] or [0, 100]
    // *Returns:* { r, g, b } in the set [0, 255]
     function hsvToRgb(h, s, v) {

        h = bound01(h, 360) * 6;
        s = bound01(s, 100);
        v = bound01(v, 100);

        var i = Math.floor(h),
            f = h - i,
            p = v * (1 - s),
            q = v * (1 - f * s),
            t = v * (1 - (1 - f) * s),
            mod = i % 6,
            r = [v, q, p, p, t, v][mod],
            g = [t, v, v, q, p, p][mod],
            b = [p, p, t, v, v, q][mod];

        return { r: r * 255, g: g * 255, b: b * 255 };
    }

    // `rgbToHex`
    // Converts an RGB color to hex
    // Assumes r, g, and b are contained in the set [0, 255]
    // Returns a 3 or 6 character hex
    function rgbToHex(r, g, b, allow3Char) {

        var hex = [
            pad2(mathRound(r).toString(16)),
            pad2(mathRound(g).toString(16)),
            pad2(mathRound(b).toString(16))
        ];

        // Return a 3 character hex if possible
        if (allow3Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1)) {
            return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0);
        }

        return hex.join("");
    }

    // `rgbaToHex`
    // Converts an RGBA color plus alpha transparency to hex
    // Assumes r, g, b are contained in the set [0, 255] and
    // a in [0, 1]. Returns a 4 or 8 character rgba hex
    function rgbaToHex(r, g, b, a, allow4Char) {

        var hex = [
            pad2(mathRound(r).toString(16)),
            pad2(mathRound(g).toString(16)),
            pad2(mathRound(b).toString(16)),
            pad2(convertDecimalToHex(a))
        ];

        // Return a 4 character hex if possible
        if (allow4Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1) && hex[3].charAt(0) == hex[3].charAt(1)) {
            return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0) + hex[3].charAt(0);
        }

        return hex.join("");
    }

    // `rgbaToArgbHex`
    // Converts an RGBA color to an ARGB Hex8 string
    // Rarely used, but required for "toFilter()"
    function rgbaToArgbHex(r, g, b, a) {

        var hex = [
            pad2(convertDecimalToHex(a)),
            pad2(mathRound(r).toString(16)),
            pad2(mathRound(g).toString(16)),
            pad2(mathRound(b).toString(16))
        ];

        return hex.join("");
    }

    // `equals`
    // Can be called with any tinycolor input
    tinycolor.equals = function (color1, color2) {
        if (!color1 || !color2) { return false; }
        return tinycolor(color1).toRgbString() == tinycolor(color2).toRgbString();
    };

    tinycolor.random = function() {
        return tinycolor.fromRatio({
            r: mathRandom(),
            g: mathRandom(),
            b: mathRandom()
        });
    };


    // Modification Functions
    // ----------------------
    // Thanks to less.js for some of the basics here
    // <https://github.com/cloudhead/less.js/blob/master/lib/less/functions.js>

    function desaturate(color, amount) {
        amount = (amount === 0) ? 0 : (amount || 10);
        var hsl = tinycolor(color).toHsl();
        hsl.s -= amount / 100;
        hsl.s = clamp01(hsl.s);
        return tinycolor(hsl);
    }

    function saturate(color, amount) {
        amount = (amount === 0) ? 0 : (amount || 10);
        var hsl = tinycolor(color).toHsl();
        hsl.s += amount / 100;
        hsl.s = clamp01(hsl.s);
        return tinycolor(hsl);
    }

    function greyscale(color) {
        return tinycolor(color).desaturate(100);
    }

    function lighten (color, amount) {
        amount = (amount === 0) ? 0 : (amount || 10);
        var hsl = tinycolor(color).toHsl();
        hsl.l += amount / 100;
        hsl.l = clamp01(hsl.l);
        return tinycolor(hsl);
    }

    function brighten(color, amount) {
        amount = (amount === 0) ? 0 : (amount || 10);
        var rgb = tinycolor(color).toRgb();
        rgb.r = mathMax(0, mathMin(255, rgb.r - mathRound(255 * - (amount / 100))));
        rgb.g = mathMax(0, mathMin(255, rgb.g - mathRound(255 * - (amount / 100))));
        rgb.b = mathMax(0, mathMin(255, rgb.b - mathRound(255 * - (amount / 100))));
        return tinycolor(rgb);
    }

    function darken (color, amount) {
        amount = (amount === 0) ? 0 : (amount || 10);
        var hsl = tinycolor(color).toHsl();
        hsl.l -= amount / 100;
        hsl.l = clamp01(hsl.l);
        return tinycolor(hsl);
    }

    // Spin takes a positive or negative amount within [-360, 360] indicating the change of hue.
    // Values outside of this range will be wrapped into this range.
    function spin(color, amount) {
        var hsl = tinycolor(color).toHsl();
        var hue = (hsl.h + amount) % 360;
        hsl.h = hue < 0 ? 360 + hue : hue;
        return tinycolor(hsl);
    }

    // Combination Functions
    // ---------------------
    // Thanks to jQuery xColor for some of the ideas behind these
    // <https://github.com/infusion/jQuery-xcolor/blob/master/jquery.xcolor.js>

    function complement(color) {
        var hsl = tinycolor(color).toHsl();
        hsl.h = (hsl.h + 180) % 360;
        return tinycolor(hsl);
    }

    function triad(color) {
        var hsl = tinycolor(color).toHsl();
        var h = hsl.h;
        return [
            tinycolor(color),
            tinycolor({ h: (h + 120) % 360, s: hsl.s, l: hsl.l }),
            tinycolor({ h: (h + 240) % 360, s: hsl.s, l: hsl.l })
        ];
    }

    function tetrad(color) {
        var hsl = tinycolor(color).toHsl();
        var h = hsl.h;
        return [
            tinycolor(color),
            tinycolor({ h: (h + 90) % 360, s: hsl.s, l: hsl.l }),
            tinycolor({ h: (h + 180) % 360, s: hsl.s, l: hsl.l }),
            tinycolor({ h: (h + 270) % 360, s: hsl.s, l: hsl.l })
        ];
    }

    function splitcomplement(color) {
        var hsl = tinycolor(color).toHsl();
        var h = hsl.h;
        return [
            tinycolor(color),
            tinycolor({ h: (h + 72) % 360, s: hsl.s, l: hsl.l}),
            tinycolor({ h: (h + 216) % 360, s: hsl.s, l: hsl.l})
        ];
    }

    function analogous(color, results, slices) {
        results = results || 6;
        slices = slices || 30;

        var hsl = tinycolor(color).toHsl();
        var part = 360 / slices;
        var ret = [tinycolor(color)];

        for (hsl.h = ((hsl.h - (part * results >> 1)) + 720) % 360; --results; ) {
            hsl.h = (hsl.h + part) % 360;
            ret.push(tinycolor(hsl));
        }
        return ret;
    }

    function monochromatic(color, results) {
        results = results || 6;
        var hsv = tinycolor(color).toHsv();
        var h = hsv.h, s = hsv.s, v = hsv.v;
        var ret = [];
        var modification = 1 / results;

        while (results--) {
            ret.push(tinycolor({ h: h, s: s, v: v}));
            v = (v + modification) % 1;
        }

        return ret;
    }

    // Utility Functions
    // ---------------------

    tinycolor.mix = function(color1, color2, amount) {
        amount = (amount === 0) ? 0 : (amount || 50);

        var rgb1 = tinycolor(color1).toRgb();
        var rgb2 = tinycolor(color2).toRgb();

        var p = amount / 100;

        var rgba = {
            r: ((rgb2.r - rgb1.r) * p) + rgb1.r,
            g: ((rgb2.g - rgb1.g) * p) + rgb1.g,
            b: ((rgb2.b - rgb1.b) * p) + rgb1.b,
            a: ((rgb2.a - rgb1.a) * p) + rgb1.a
        };

        return tinycolor(rgba);
    };


    // Readability Functions
    // ---------------------
    // <http://www.w3.org/TR/2008/REC-WCAG20-20081211/#contrast-ratiodef (WCAG Version 2)

    // `contrast`
    // Analyze the 2 colors and returns the color contrast defined by (WCAG Version 2)
    tinycolor.readability = function(color1, color2) {
        var c1 = tinycolor(color1);
        var c2 = tinycolor(color2);
        return (Math.max(c1.getLuminance(),c2.getLuminance())+0.05) / (Math.min(c1.getLuminance(),c2.getLuminance())+0.05);
    };

    // `isReadable`
    // Ensure that foreground and background color combinations meet WCAG2 guidelines.
    // The third argument is an optional Object.
    //      the 'level' property states 'AA' or 'AAA' - if missing or invalid, it defaults to 'AA';
    //      the 'size' property states 'large' or 'small' - if missing or invalid, it defaults to 'small'.
    // If the entire object is absent, isReadable defaults to {level:"AA",size:"small"}.

    // *Example*
    //    tinycolor.isReadable("#000", "#111") => false
    //    tinycolor.isReadable("#000", "#111",{level:"AA",size:"large"}) => false
    tinycolor.isReadable = function(color1, color2, wcag2) {
        var readability = tinycolor.readability(color1, color2);
        var wcag2Parms, out;

        out = false;

        wcag2Parms = validateWCAG2Parms(wcag2);
        switch (wcag2Parms.level + wcag2Parms.size) {
            case "AAsmall":
            case "AAAlarge":
                out = readability >= 4.5;
                break;
            case "AAlarge":
                out = readability >= 3;
                break;
            case "AAAsmall":
                out = readability >= 7;
                break;
        }
        return out;

    };

    // `mostReadable`
    // Given a base color and a list of possible foreground or background
    // colors for that base, returns the most readable color.
    // Optionally returns Black or White if the most readable color is unreadable.
    // *Example*
    //    tinycolor.mostReadable(tinycolor.mostReadable("#123", ["#124", "#125"],{includeFallbackColors:false}).toHexString(); // "#112255"
    //    tinycolor.mostReadable(tinycolor.mostReadable("#123", ["#124", "#125"],{includeFallbackColors:true}).toHexString();  // "#ffffff"
    //    tinycolor.mostReadable("#a8015a", ["#faf3f3"],{includeFallbackColors:true,level:"AAA",size:"large"}).toHexString(); // "#faf3f3"
    //    tinycolor.mostReadable("#a8015a", ["#faf3f3"],{includeFallbackColors:true,level:"AAA",size:"small"}).toHexString(); // "#ffffff"
    tinycolor.mostReadable = function(baseColor, colorList, args) {
        var bestColor = null;
        var bestScore = 0;
        var readability;
        var includeFallbackColors, level, size ;
        args = args || {};
        includeFallbackColors = args.includeFallbackColors ;
        level = args.level;
        size = args.size;

        for (var i= 0; i < colorList.length ; i++) {
            readability = tinycolor.readability(baseColor, colorList[i]);
            if (readability > bestScore) {
                bestScore = readability;
                bestColor = tinycolor(colorList[i]);
            }
        }

        if (tinycolor.isReadable(baseColor, bestColor, {"level":level,"size":size}) || !includeFallbackColors) {
            return bestColor;
        }
        else {
            args.includeFallbackColors=false;
            return tinycolor.mostReadable(baseColor,["#fff", "#000"],args);
        }
    };


    // Big List of Colors
    // ------------------
    // <http://www.w3.org/TR/css3-color/#svg-color>
    var names = tinycolor.names = {
        aliceblue: "f0f8ff",
        antiquewhite: "faebd7",
        aqua: "0ff",
        aquamarine: "7fffd4",
        azure: "f0ffff",
        beige: "f5f5dc",
        bisque: "ffe4c4",
        black: "000",
        blanchedalmond: "ffebcd",
        blue: "00f",
        blueviolet: "8a2be2",
        brown: "a52a2a",
        burlywood: "deb887",
        burntsienna: "ea7e5d",
        cadetblue: "5f9ea0",
        chartreuse: "7fff00",
        chocolate: "d2691e",
        coral: "ff7f50",
        cornflowerblue: "6495ed",
        cornsilk: "fff8dc",
        crimson: "dc143c",
        cyan: "0ff",
        darkblue: "00008b",
        darkcyan: "008b8b",
        darkgoldenrod: "b8860b",
        darkgray: "a9a9a9",
        darkgreen: "006400",
        darkgrey: "a9a9a9",
        darkkhaki: "bdb76b",
        darkmagenta: "8b008b",
        darkolivegreen: "556b2f",
        darkorange: "ff8c00",
        darkorchid: "9932cc",
        darkred: "8b0000",
        darksalmon: "e9967a",
        darkseagreen: "8fbc8f",
        darkslateblue: "483d8b",
        darkslategray: "2f4f4f",
        darkslategrey: "2f4f4f",
        darkturquoise: "00ced1",
        darkviolet: "9400d3",
        deeppink: "ff1493",
        deepskyblue: "00bfff",
        dimgray: "696969",
        dimgrey: "696969",
        dodgerblue: "1e90ff",
        firebrick: "b22222",
        floralwhite: "fffaf0",
        forestgreen: "228b22",
        fuchsia: "f0f",
        gainsboro: "dcdcdc",
        ghostwhite: "f8f8ff",
        gold: "ffd700",
        goldenrod: "daa520",
        gray: "808080",
        green: "008000",
        greenyellow: "adff2f",
        grey: "808080",
        honeydew: "f0fff0",
        hotpink: "ff69b4",
        indianred: "cd5c5c",
        indigo: "4b0082",
        ivory: "fffff0",
        khaki: "f0e68c",
        lavender: "e6e6fa",
        lavenderblush: "fff0f5",
        lawngreen: "7cfc00",
        lemonchiffon: "fffacd",
        lightblue: "add8e6",
        lightcoral: "f08080",
        lightcyan: "e0ffff",
        lightgoldenrodyellow: "fafad2",
        lightgray: "d3d3d3",
        lightgreen: "90ee90",
        lightgrey: "d3d3d3",
        lightpink: "ffb6c1",
        lightsalmon: "ffa07a",
        lightseagreen: "20b2aa",
        lightskyblue: "87cefa",
        lightslategray: "789",
        lightslategrey: "789",
        lightsteelblue: "b0c4de",
        lightyellow: "ffffe0",
        lime: "0f0",
        limegreen: "32cd32",
        linen: "faf0e6",
        magenta: "f0f",
        maroon: "800000",
        mediumaquamarine: "66cdaa",
        mediumblue: "0000cd",
        mediumorchid: "ba55d3",
        mediumpurple: "9370db",
        mediumseagreen: "3cb371",
        mediumslateblue: "7b68ee",
        mediumspringgreen: "00fa9a",
        mediumturquoise: "48d1cc",
        mediumvioletred: "c71585",
        midnightblue: "191970",
        mintcream: "f5fffa",
        mistyrose: "ffe4e1",
        moccasin: "ffe4b5",
        navajowhite: "ffdead",
        navy: "000080",
        oldlace: "fdf5e6",
        olive: "808000",
        olivedrab: "6b8e23",
        orange: "ffa500",
        orangered: "ff4500",
        orchid: "da70d6",
        palegoldenrod: "eee8aa",
        palegreen: "98fb98",
        paleturquoise: "afeeee",
        palevioletred: "db7093",
        papayawhip: "ffefd5",
        peachpuff: "ffdab9",
        peru: "cd853f",
        pink: "ffc0cb",
        plum: "dda0dd",
        powderblue: "b0e0e6",
        purple: "800080",
        rebeccapurple: "663399",
        red: "f00",
        rosybrown: "bc8f8f",
        royalblue: "4169e1",
        saddlebrown: "8b4513",
        salmon: "fa8072",
        sandybrown: "f4a460",
        seagreen: "2e8b57",
        seashell: "fff5ee",
        sienna: "a0522d",
        silver: "c0c0c0",
        skyblue: "87ceeb",
        slateblue: "6a5acd",
        slategray: "708090",
        slategrey: "708090",
        snow: "fffafa",
        springgreen: "00ff7f",
        steelblue: "4682b4",
        tan: "d2b48c",
        teal: "008080",
        thistle: "d8bfd8",
        tomato: "ff6347",
        turquoise: "40e0d0",
        violet: "ee82ee",
        wheat: "f5deb3",
        white: "fff",
        whitesmoke: "f5f5f5",
        yellow: "ff0",
        yellowgreen: "9acd32"
    };

    // Make it easy to access colors via `hexNames[hex]`
    var hexNames = tinycolor.hexNames = flip(names);


    // Utilities
    // ---------

    // `{ 'name1': 'val1' }` becomes `{ 'val1': 'name1' }`
    function flip(o) {
        var flipped = { };
        for (var i in o) {
            if (o.hasOwnProperty(i)) {
                flipped[o[i]] = i;
            }
        }
        return flipped;
    }

    // Return a valid alpha value [0,1] with all invalid values being set to 1
    function boundAlpha(a) {
        a = parseFloat(a);

        if (isNaN(a) || a < 0 || a > 1) {
            a = 1;
        }

        return a;
    }

    // Take input from [0, n] and return it as [0, 1]
    function bound01(n, max) {
        if (isOnePointZero(n)) { n = "100%"; }

        var processPercent = isPercentage(n);
        n = mathMin(max, mathMax(0, parseFloat(n)));

        // Automatically convert percentage into number
        if (processPercent) {
            n = parseInt(n * max, 10) / 100;
        }

        // Handle floating point rounding errors
        if ((Math.abs(n - max) < 0.000001)) {
            return 1;
        }

        // Convert into [0, 1] range if it isn't already
        return (n % max) / parseFloat(max);
    }

    // Force a number between 0 and 1
    function clamp01(val) {
        return mathMin(1, mathMax(0, val));
    }

    // Parse a base-16 hex value into a base-10 integer
    function parseIntFromHex(val) {
        return parseInt(val, 16);
    }

    // Need to handle 1.0 as 100%, since once it is a number, there is no difference between it and 1
    // <http://stackoverflow.com/questions/7422072/javascript-how-to-detect-number-as-a-decimal-including-1-0>
    function isOnePointZero(n) {
        return typeof n == "string" && n.indexOf('.') != -1 && parseFloat(n) === 1;
    }

    // Check to see if string passed in is a percentage
    function isPercentage(n) {
        return typeof n === "string" && n.indexOf('%') != -1;
    }

    // Force a hex value to have 2 characters
    function pad2(c) {
        return c.length == 1 ? '0' + c : '' + c;
    }

    // Replace a decimal with it's percentage value
    function convertToPercentage(n) {
        if (n <= 1) {
            n = (n * 100) + "%";
        }

        return n;
    }

    // Converts a decimal to a hex value
    function convertDecimalToHex(d) {
        return Math.round(parseFloat(d) * 255).toString(16);
    }
    // Converts a hex value to a decimal
    function convertHexToDecimal(h) {
        return (parseIntFromHex(h) / 255);
    }

    var matchers = (function() {

        // <http://www.w3.org/TR/css3-values/#integers>
        var CSS_INTEGER = "[-\\+]?\\d+%?";

        // <http://www.w3.org/TR/css3-values/#number-value>
        var CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?";

        // Allow positive/negative integer/number.  Don't capture the either/or, just the entire outcome.
        var CSS_UNIT = "(?:" + CSS_NUMBER + ")|(?:" + CSS_INTEGER + ")";

        // Actual matching.
        // Parentheses and commas are optional, but not required.
        // Whitespace can take the place of commas or opening paren
        var PERMISSIVE_MATCH3 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
        var PERMISSIVE_MATCH4 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";

        return {
            CSS_UNIT: new RegExp(CSS_UNIT),
            rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
            rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
            hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
            hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
            hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
            hsva: new RegExp("hsva" + PERMISSIVE_MATCH4),
            hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
            hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
            hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
            hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
        };
    })();

    // `isValidCSSUnit`
    // Take in a single string / number and check to see if it looks like a CSS unit
    // (see `matchers` above for definition).
    function isValidCSSUnit(color) {
        return !!matchers.CSS_UNIT.exec(color);
    }

    // `stringInputToObject`
    // Permissive string parsing.  Take in a number of formats, and output an object
    // based on detected format.  Returns `{ r, g, b }` or `{ h, s, l }` or `{ h, s, v}`
    function stringInputToObject(color) {

        color = color.replace(trimLeft,'').replace(trimRight, '').toLowerCase();
        var named = false;
        if (names[color]) {
            color = names[color];
            named = true;
        }
        else if (color == 'transparent') {
            return { r: 0, g: 0, b: 0, a: 0, format: "name" };
        }

        // Try to match string input using regular expressions.
        // Keep most of the number bounding out of this function - don't worry about [0,1] or [0,100] or [0,360]
        // Just return an object and let the conversion functions handle that.
        // This way the result will be the same whether the tinycolor is initialized with string or object.
        var match;
        if ((match = matchers.rgb.exec(color))) {
            return { r: match[1], g: match[2], b: match[3] };
        }
        if ((match = matchers.rgba.exec(color))) {
            return { r: match[1], g: match[2], b: match[3], a: match[4] };
        }
        if ((match = matchers.hsl.exec(color))) {
            return { h: match[1], s: match[2], l: match[3] };
        }
        if ((match = matchers.hsla.exec(color))) {
            return { h: match[1], s: match[2], l: match[3], a: match[4] };
        }
        if ((match = matchers.hsv.exec(color))) {
            return { h: match[1], s: match[2], v: match[3] };
        }
        if ((match = matchers.hsva.exec(color))) {
            return { h: match[1], s: match[2], v: match[3], a: match[4] };
        }
        if ((match = matchers.hex8.exec(color))) {
            return {
                r: parseIntFromHex(match[1]),
                g: parseIntFromHex(match[2]),
                b: parseIntFromHex(match[3]),
                a: convertHexToDecimal(match[4]),
                format: named ? "name" : "hex8"
            };
        }
        if ((match = matchers.hex6.exec(color))) {
            return {
                r: parseIntFromHex(match[1]),
                g: parseIntFromHex(match[2]),
                b: parseIntFromHex(match[3]),
                format: named ? "name" : "hex"
            };
        }
        if ((match = matchers.hex4.exec(color))) {
            return {
                r: parseIntFromHex(match[1] + '' + match[1]),
                g: parseIntFromHex(match[2] + '' + match[2]),
                b: parseIntFromHex(match[3] + '' + match[3]),
                a: convertHexToDecimal(match[4] + '' + match[4]),
                format: named ? "name" : "hex8"
            };
        }
        if ((match = matchers.hex3.exec(color))) {
            return {
                r: parseIntFromHex(match[1] + '' + match[1]),
                g: parseIntFromHex(match[2] + '' + match[2]),
                b: parseIntFromHex(match[3] + '' + match[3]),
                format: named ? "name" : "hex"
            };
        }

        return false;
    }

    function validateWCAG2Parms(parms) {
        // return valid WCAG2 parms for isReadable.
        // If input parms are invalid, return {"level":"AA", "size":"small"}
        var level, size;
        parms = parms || {"level":"AA", "size":"small"};
        level = (parms.level || "AA").toUpperCase();
        size = (parms.size || "small").toLowerCase();
        if (level !== "AA" && level !== "AAA") {
            level = "AA";
        }
        if (size !== "small" && size !== "large") {
            size = "small";
        }
        return {"level":level, "size":size};
    }

    // Node: Export function
    if (module.exports) {
        module.exports = tinycolor;
    }
    // AMD/requirejs: Define the module
    else {
        window.tinycolor = tinycolor;
    }

    })(Math);
    });

    function _objectWithoutPropertiesLoose$3(source, excluded) {
      if (source == null) return {};
      var target = {};
      var sourceKeys = Object.keys(source);
      var key, i;

      for (i = 0; i < sourceKeys.length; i++) {
        key = sourceKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        target[key] = source[key];
      }

      return target;
    }

    function _objectWithoutProperties$3(source, excluded) {
      if (source == null) return {};

      var target = _objectWithoutPropertiesLoose$3(source, excluded);

      var key, i;

      if (Object.getOwnPropertySymbols) {
        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

        for (i = 0; i < sourceSymbolKeys.length; i++) {
          key = sourceSymbolKeys[i];
          if (excluded.indexOf(key) >= 0) continue;
          if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
          target[key] = source[key];
        }
      }

      return target;
    }

    function _slicedToArray$4(arr, i) {
      return _arrayWithHoles$4(arr) || _iterableToArrayLimit$4(arr, i) || _unsupportedIterableToArray$5(arr, i) || _nonIterableRest$4();
    }

    function _toConsumableArray$5(arr) {
      return _arrayWithoutHoles$5(arr) || _iterableToArray$5(arr) || _unsupportedIterableToArray$5(arr) || _nonIterableSpread$5();
    }

    function _arrayWithoutHoles$5(arr) {
      if (Array.isArray(arr)) return _arrayLikeToArray$5(arr);
    }

    function _arrayWithHoles$4(arr) {
      if (Array.isArray(arr)) return arr;
    }

    function _iterableToArray$5(iter) {
      if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
    }

    function _iterableToArrayLimit$4(arr, i) {
      var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

      if (_i == null) return;
      var _arr = [];
      var _n = true;
      var _d = false;

      var _s, _e;

      try {
        for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);

          if (i && _arr.length === i) break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"] != null) _i["return"]();
        } finally {
          if (_d) throw _e;
        }
      }

      return _arr;
    }

    function _unsupportedIterableToArray$5(o, minLen) {
      if (!o) return;
      if (typeof o === "string") return _arrayLikeToArray$5(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor) n = o.constructor.name;
      if (n === "Map" || n === "Set") return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$5(o, minLen);
    }

    function _arrayLikeToArray$5(arr, len) {
      if (len == null || len > arr.length) len = arr.length;

      for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

      return arr2;
    }

    function _nonIterableSpread$5() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }

    function _nonIterableRest$4() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }

    function _toPrimitive(input, hint) {
      if (typeof input !== "object" || input === null) return input;
      var prim = input[Symbol.toPrimitive];

      if (prim !== undefined) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object") return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }

      return (hint === "string" ? String : Number)(input);
    }

    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");

      return typeof key === "symbol" ? key : String(key);
    }

    var index = (function () {
      var list = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var keyAccessors = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
      var multiItem = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
      var flattenKeys = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
      var keys = (keyAccessors instanceof Array ? keyAccessors.length ? keyAccessors : [undefined] : [keyAccessors]).map(function (key) {
        return {
          keyAccessor: key,
          isProp: !(key instanceof Function)
        };
      });
      var indexedResult = list.reduce(function (res, item) {
        var iterObj = res;
        var itemVal = item;
        keys.forEach(function (_ref, idx) {
          var keyAccessor = _ref.keyAccessor,
              isProp = _ref.isProp;
          var key;

          if (isProp) {
            var _itemVal = itemVal,
                propVal = _itemVal[keyAccessor],
                rest = _objectWithoutProperties$3(_itemVal, [keyAccessor].map(_toPropertyKey));

            key = propVal;
            itemVal = rest;
          } else {
            key = keyAccessor(itemVal, idx);
          }

          if (idx + 1 < keys.length) {
            if (!iterObj.hasOwnProperty(key)) {
              iterObj[key] = {};
            }

            iterObj = iterObj[key];
          } else {
            // Leaf key
            if (multiItem) {
              if (!iterObj.hasOwnProperty(key)) {
                iterObj[key] = [];
              }

              iterObj[key].push(itemVal);
            } else {
              iterObj[key] = itemVal;
            }
          }
        });
        return res;
      }, {});

      if (multiItem instanceof Function) {
        // Reduce leaf multiple values
        (function reduce(node) {
          var level = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;

          if (level === keys.length) {
            Object.keys(node).forEach(function (k) {
              return node[k] = multiItem(node[k]);
            });
          } else {
            Object.values(node).forEach(function (child) {
              return reduce(child, level + 1);
            });
          }
        })(indexedResult); // IIFE

      }

      var result = indexedResult;

      if (flattenKeys) {
        // flatten into array
        result = [];

        (function flatten(node) {
          var accKeys = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

          if (accKeys.length === keys.length) {
            result.push({
              keys: accKeys,
              vals: node
            });
          } else {
            Object.entries(node).forEach(function (_ref2) {
              var _ref3 = _slicedToArray$4(_ref2, 2),
                  key = _ref3[0],
                  val = _ref3[1];

              return flatten(val, [].concat(_toConsumableArray$5(accKeys), [key]));
            });
          }
        })(indexedResult); //IIFE


        if (keyAccessors instanceof Array && keyAccessors.length === 0 && result.length === 1) {
          // clear keys if there's no key accessors (single result)
          result[0].keys = [];
        }
      }

      return result;
    });

    function ownKeys$3(object, enumerableOnly) {
      var keys = Object.keys(object);

      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function (sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }

      return keys;
    }

    function _objectSpread2$2(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys$3(Object(source), !0).forEach(function (key) {
          _defineProperty$3(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$3(Object(source)).forEach(function (key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }

      return target;
    }

    function _defineProperty$3(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }

      return obj;
    }

    function _objectWithoutPropertiesLoose$2(source, excluded) {
      if (source == null) return {};
      var target = {};
      var sourceKeys = Object.keys(source);
      var key, i;

      for (i = 0; i < sourceKeys.length; i++) {
        key = sourceKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        target[key] = source[key];
      }

      return target;
    }

    function _objectWithoutProperties$2(source, excluded) {
      if (source == null) return {};

      var target = _objectWithoutPropertiesLoose$2(source, excluded);

      var key, i;

      if (Object.getOwnPropertySymbols) {
        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

        for (i = 0; i < sourceSymbolKeys.length; i++) {
          key = sourceSymbolKeys[i];
          if (excluded.indexOf(key) >= 0) continue;
          if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
          target[key] = source[key];
        }
      }

      return target;
    }

    function _slicedToArray$3(arr, i) {
      return _arrayWithHoles$3(arr) || _iterableToArrayLimit$3(arr, i) || _unsupportedIterableToArray$4(arr, i) || _nonIterableRest$3();
    }

    function _toConsumableArray$4(arr) {
      return _arrayWithoutHoles$4(arr) || _iterableToArray$4(arr) || _unsupportedIterableToArray$4(arr) || _nonIterableSpread$4();
    }

    function _arrayWithoutHoles$4(arr) {
      if (Array.isArray(arr)) return _arrayLikeToArray$4(arr);
    }

    function _arrayWithHoles$3(arr) {
      if (Array.isArray(arr)) return arr;
    }

    function _iterableToArray$4(iter) {
      if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
    }

    function _iterableToArrayLimit$3(arr, i) {
      var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

      if (_i == null) return;
      var _arr = [];
      var _n = true;
      var _d = false;

      var _s, _e;

      try {
        for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);

          if (i && _arr.length === i) break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"] != null) _i["return"]();
        } finally {
          if (_d) throw _e;
        }
      }

      return _arr;
    }

    function _unsupportedIterableToArray$4(o, minLen) {
      if (!o) return;
      if (typeof o === "string") return _arrayLikeToArray$4(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor) n = o.constructor.name;
      if (n === "Map" || n === "Set") return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$4(o, minLen);
    }

    function _arrayLikeToArray$4(arr, len) {
      if (len == null || len > arr.length) len = arr.length;

      for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

      return arr2;
    }

    function _nonIterableSpread$4() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }

    function _nonIterableRest$3() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }

    var _excluded$2 = ["createObj", "updateObj", "exitObj", "objBindAttr", "dataBindAttr"];

    function diffArrays(prev, next, idAccessor) {
      var result = {
        enter: [],
        update: [],
        exit: []
      };

      if (!idAccessor) {
        // use object references for comparison
        var prevSet = new Set(prev);
        var nextSet = new Set(next);
        new Set([].concat(_toConsumableArray$4(prevSet), _toConsumableArray$4(nextSet))).forEach(function (item) {
          var type = !prevSet.has(item) ? 'enter' : !nextSet.has(item) ? 'exit' : 'update';
          result[type].push(type === 'update' ? [item, item] : item);
        });
      } else {
        // compare by id (duplicate keys are ignored)
        var prevById = index(prev, idAccessor, false);
        var nextById = index(next, idAccessor, false);
        var byId = Object.assign({}, prevById, nextById);
        Object.entries(byId).forEach(function (_ref) {
          var _ref2 = _slicedToArray$3(_ref, 2),
              id = _ref2[0],
              item = _ref2[1];

          var type = !prevById.hasOwnProperty(id) ? 'enter' : !nextById.hasOwnProperty(id) ? 'exit' : 'update';
          result[type].push(type === 'update' ? [prevById[id], nextById[id]] : item);
        });
      }

      return result;
    }

    function dataBindDiff(data, existingObjs, _ref3) {
      var _ref3$objBindAttr = _ref3.objBindAttr,
          objBindAttr = _ref3$objBindAttr === void 0 ? '__obj' : _ref3$objBindAttr,
          _ref3$dataBindAttr = _ref3.dataBindAttr,
          dataBindAttr = _ref3$dataBindAttr === void 0 ? '__data' : _ref3$dataBindAttr,
          idAccessor = _ref3.idAccessor,
          _ref3$purge = _ref3.purge,
          purge = _ref3$purge === void 0 ? false : _ref3$purge;

      var isObjValid = function isObjValid(obj) {
        return obj.hasOwnProperty(dataBindAttr);
      };

      var removeObjs = existingObjs.filter(function (obj) {
        return !isObjValid(obj);
      });
      var prevD = existingObjs.filter(isObjValid).map(function (obj) {
        return obj[dataBindAttr];
      });
      var nextD = data;
      var diff = purge ? {
        enter: nextD,
        exit: prevD,
        update: []
      } // don't diff data in purge mode
      : diffArrays(prevD, nextD, idAccessor);
      diff.update = diff.update.map(function (_ref4) {
        var _ref5 = _slicedToArray$3(_ref4, 2),
            prevD = _ref5[0],
            nextD = _ref5[1];

        if (prevD !== nextD) {
          // transfer obj to new data point (if different)
          nextD[objBindAttr] = prevD[objBindAttr];
          nextD[objBindAttr][dataBindAttr] = nextD;
        }

        return nextD;
      });
      diff.exit = diff.exit.concat(removeObjs.map(function (obj) {
        return _defineProperty$3({}, objBindAttr, obj);
      }));
      return diff;
    }

    function viewDigest(data, existingObjs, // list
    appendObj, // item => {...} function
    removeObj, // item => {...} function
    _ref7) {
      var _ref7$createObj = _ref7.createObj,
          createObj = _ref7$createObj === void 0 ? function (d) {
        return {};
      } : _ref7$createObj,
          _ref7$updateObj = _ref7.updateObj,
          updateObj = _ref7$updateObj === void 0 ? function (obj, d) {} : _ref7$updateObj,
          _ref7$exitObj = _ref7.exitObj,
          exitObj = _ref7$exitObj === void 0 ? function (obj) {} : _ref7$exitObj,
          _ref7$objBindAttr = _ref7.objBindAttr,
          objBindAttr = _ref7$objBindAttr === void 0 ? '__obj' : _ref7$objBindAttr,
          _ref7$dataBindAttr = _ref7.dataBindAttr,
          dataBindAttr = _ref7$dataBindAttr === void 0 ? '__data' : _ref7$dataBindAttr,
          dataDiffOptions = _objectWithoutProperties$2(_ref7, _excluded$2);

      var _dataBindDiff = dataBindDiff(data, existingObjs, _objectSpread2$2({
        objBindAttr: objBindAttr,
        dataBindAttr: dataBindAttr
      }, dataDiffOptions)),
          enter = _dataBindDiff.enter,
          update = _dataBindDiff.update,
          exit = _dataBindDiff.exit; // Remove exiting points


      exit.forEach(function (d) {
        var obj = d[objBindAttr];
        delete d[objBindAttr]; // unbind obj

        exitObj(obj);
        removeObj(obj);
      });
      var newObjs = createObjs(enter);
      var pointsData = [].concat(_toConsumableArray$4(enter), _toConsumableArray$4(update));
      updateObjs(pointsData); // Add new points

      newObjs.forEach(appendObj); //

      function createObjs(data) {
        var newObjs = [];
        data.forEach(function (d) {
          var obj = createObj(d);

          if (obj) {
            obj[dataBindAttr] = d;
            d[objBindAttr] = obj;
            newObjs.push(obj);
          }
        });
        return newObjs;
      }

      function updateObjs(data) {
        data.forEach(function (d) {
          var obj = d[objBindAttr];

          if (obj) {
            obj[dataBindAttr] = d;
            updateObj(obj, d);
          }
        });
      }
    }

    var FrameTicker$3 = createCommonjsModule(function (module, exports) {
    !function(e,t){module.exports=t();}(commonjsGlobal,function(){return function(e){function t(n){if(i[n])return i[n].exports;var r=i[n]={exports:{},id:n,loaded:!1};return e[n].call(r.exports,r,r.exports,t),r.loaded=!0,r.exports}var i={};return t.m=e,t.c=i,t.p="",t(0)}([function(e,t,i){var n=i(1),r=function(){function e(e,t,i){void 0===e&&(e=NaN),void 0===t&&(t=NaN),void 0===i&&(i=!1),this._minFPS=t,this._maxFPS=e,this._timeScale=1,this._currentTick=0,this._currentTime=0,this._tickDeltaTime=0,this._isRunning=!1,this._maxInterval=isNaN(this._minFPS)?NaN:1e3/this._minFPS,this._minInterval=isNaN(this._maxFPS)?NaN:1e3/this._maxFPS,this._onResume=new n.default,this._onPause=new n.default,this._onTick=new n.default,this._onTickOncePerFrame=new n.default,i||this.resume();}return e.prototype.updateOnce=function(e){e(this.currentTimeSeconds,this.tickDeltaTimeSeconds,this.currentTick);},e.prototype.resume=function(){this._isRunning||(this._isRunning=!0,this._lastTimeUpdated=this.getTimer(),this._onResume.dispatch(),this.animateOnce());},e.prototype.pause=function(){this._isRunning&&(this._isRunning=!1,this._onPause.dispatch(),window.cancelAnimationFrame(this._animationFrameHandle));},e.prototype.dispose=function(){this.pause(),this._onResume.removeAll(),this._onPause.removeAll(),this._onTick.removeAll();},Object.defineProperty(e.prototype,"currentTick",{get:function(){return this._currentTick},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"currentTimeSeconds",{get:function(){return this._currentTime/1e3},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"tickDeltaTimeSeconds",{get:function(){return this._tickDeltaTime/1e3},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"timeScale",{get:function(){return this._timeScale},set:function(e){this._timeScale!==e&&(this._timeScale=e);},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"onResume",{get:function(){return this._onResume},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"onPause",{get:function(){return this._onPause},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"onTick",{get:function(){return this._onTick},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"onTickOncePerFrame",{get:function(){return this._onTickOncePerFrame},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"isRunning",{get:function(){return this._isRunning},enumerable:!0,configurable:!0}),e.prototype.animateOnce=function(){var e=this;this._animationFrameHandle=window.requestAnimationFrame(function(){return e.onFrame()});},e.prototype.onFrame=function(){if(this._now=this.getTimer(),this._frameDeltaTime=this._now-this._lastTimeUpdated,isNaN(this._minInterval)||this._frameDeltaTime>=this._minInterval)if(isNaN(this._maxInterval))this.update(this._frameDeltaTime*this._timeScale,!0),this._lastTimeUpdated=this._now;else for(this._interval=Math.min(this._frameDeltaTime,this._maxInterval);this._now>=this._lastTimeUpdated+this._interval;)this.update(this._interval*this._timeScale,this._now<=this._lastTimeUpdated+2*this._maxInterval),this._lastTimeUpdated+=this._interval;this._isRunning&&this.animateOnce();},e.prototype.update=function(e,t){void 0===t&&(t=!0),this._currentTick++,this._currentTime+=e,this._tickDeltaTime=e,this._onTick.dispatch(this.currentTimeSeconds,this.tickDeltaTimeSeconds,this.currentTick),t&&this._onTickOncePerFrame.dispatch(this.currentTimeSeconds,this.tickDeltaTimeSeconds,this.currentTick);},e.prototype.getTimer=function(){return Date.now()},e}();Object.defineProperty(t,"__esModule",{value:!0}),t.default=r;},function(e,t,i){!function(t,i){e.exports=i();}(this,function(){return function(e){function t(n){if(i[n])return i[n].exports;var r=i[n]={exports:{},id:n,loaded:!1};return e[n].call(r.exports,r,r.exports,t),r.loaded=!0,r.exports}var i={};return t.m=e,t.c=i,t.p="",t(0)}([function(e,t){var i=function(){function e(){this.functions=[];}return e.prototype.add=function(e){return this.functions.indexOf(e)===-1&&(this.functions.push(e),!0)},e.prototype.remove=function(e){var t=this.functions.indexOf(e);return t>-1&&(this.functions.splice(t,1),!0)},e.prototype.removeAll=function(){return this.functions.length>0&&(this.functions.length=0,!0)},e.prototype.dispatch=function(){for(var e=[],t=0;t<arguments.length;t++)e[t]=arguments[t];var i=this.functions.concat();i.forEach(function(t){t.apply(void 0,e);});},Object.defineProperty(e.prototype,"numItems",{get:function(){return this.functions.length},enumerable:!0,configurable:!0}),e}();Object.defineProperty(t,"__esModule",{value:!0}),t.default=i;}])});}])});
    });

    var _FrameTicker = /*@__PURE__*/getDefaultExportFromCjs(FrameTicker$3);

    function initRange(domain, range) {
      switch (arguments.length) {
        case 0: break;
        case 1: this.range(domain); break;
        default: this.range(range).domain(domain); break;
      }
      return this;
    }

    function define(constructor, factory, prototype) {
      constructor.prototype = factory.prototype = prototype;
      prototype.constructor = constructor;
    }

    function extend(parent, definition) {
      var prototype = Object.create(parent.prototype);
      for (var key in definition) prototype[key] = definition[key];
      return prototype;
    }

    function Color() {}

    var darker = 0.7;
    var brighter = 1 / darker;

    var reI = "\\s*([+-]?\\d+)\\s*",
        reN = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*",
        reP = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*",
        reHex = /^#([0-9a-f]{3,8})$/,
        reRgbInteger = new RegExp(`^rgb\\(${reI},${reI},${reI}\\)$`),
        reRgbPercent = new RegExp(`^rgb\\(${reP},${reP},${reP}\\)$`),
        reRgbaInteger = new RegExp(`^rgba\\(${reI},${reI},${reI},${reN}\\)$`),
        reRgbaPercent = new RegExp(`^rgba\\(${reP},${reP},${reP},${reN}\\)$`),
        reHslPercent = new RegExp(`^hsl\\(${reN},${reP},${reP}\\)$`),
        reHslaPercent = new RegExp(`^hsla\\(${reN},${reP},${reP},${reN}\\)$`);

    var named = {
      aliceblue: 0xf0f8ff,
      antiquewhite: 0xfaebd7,
      aqua: 0x00ffff,
      aquamarine: 0x7fffd4,
      azure: 0xf0ffff,
      beige: 0xf5f5dc,
      bisque: 0xffe4c4,
      black: 0x000000,
      blanchedalmond: 0xffebcd,
      blue: 0x0000ff,
      blueviolet: 0x8a2be2,
      brown: 0xa52a2a,
      burlywood: 0xdeb887,
      cadetblue: 0x5f9ea0,
      chartreuse: 0x7fff00,
      chocolate: 0xd2691e,
      coral: 0xff7f50,
      cornflowerblue: 0x6495ed,
      cornsilk: 0xfff8dc,
      crimson: 0xdc143c,
      cyan: 0x00ffff,
      darkblue: 0x00008b,
      darkcyan: 0x008b8b,
      darkgoldenrod: 0xb8860b,
      darkgray: 0xa9a9a9,
      darkgreen: 0x006400,
      darkgrey: 0xa9a9a9,
      darkkhaki: 0xbdb76b,
      darkmagenta: 0x8b008b,
      darkolivegreen: 0x556b2f,
      darkorange: 0xff8c00,
      darkorchid: 0x9932cc,
      darkred: 0x8b0000,
      darksalmon: 0xe9967a,
      darkseagreen: 0x8fbc8f,
      darkslateblue: 0x483d8b,
      darkslategray: 0x2f4f4f,
      darkslategrey: 0x2f4f4f,
      darkturquoise: 0x00ced1,
      darkviolet: 0x9400d3,
      deeppink: 0xff1493,
      deepskyblue: 0x00bfff,
      dimgray: 0x696969,
      dimgrey: 0x696969,
      dodgerblue: 0x1e90ff,
      firebrick: 0xb22222,
      floralwhite: 0xfffaf0,
      forestgreen: 0x228b22,
      fuchsia: 0xff00ff,
      gainsboro: 0xdcdcdc,
      ghostwhite: 0xf8f8ff,
      gold: 0xffd700,
      goldenrod: 0xdaa520,
      gray: 0x808080,
      green: 0x008000,
      greenyellow: 0xadff2f,
      grey: 0x808080,
      honeydew: 0xf0fff0,
      hotpink: 0xff69b4,
      indianred: 0xcd5c5c,
      indigo: 0x4b0082,
      ivory: 0xfffff0,
      khaki: 0xf0e68c,
      lavender: 0xe6e6fa,
      lavenderblush: 0xfff0f5,
      lawngreen: 0x7cfc00,
      lemonchiffon: 0xfffacd,
      lightblue: 0xadd8e6,
      lightcoral: 0xf08080,
      lightcyan: 0xe0ffff,
      lightgoldenrodyellow: 0xfafad2,
      lightgray: 0xd3d3d3,
      lightgreen: 0x90ee90,
      lightgrey: 0xd3d3d3,
      lightpink: 0xffb6c1,
      lightsalmon: 0xffa07a,
      lightseagreen: 0x20b2aa,
      lightskyblue: 0x87cefa,
      lightslategray: 0x778899,
      lightslategrey: 0x778899,
      lightsteelblue: 0xb0c4de,
      lightyellow: 0xffffe0,
      lime: 0x00ff00,
      limegreen: 0x32cd32,
      linen: 0xfaf0e6,
      magenta: 0xff00ff,
      maroon: 0x800000,
      mediumaquamarine: 0x66cdaa,
      mediumblue: 0x0000cd,
      mediumorchid: 0xba55d3,
      mediumpurple: 0x9370db,
      mediumseagreen: 0x3cb371,
      mediumslateblue: 0x7b68ee,
      mediumspringgreen: 0x00fa9a,
      mediumturquoise: 0x48d1cc,
      mediumvioletred: 0xc71585,
      midnightblue: 0x191970,
      mintcream: 0xf5fffa,
      mistyrose: 0xffe4e1,
      moccasin: 0xffe4b5,
      navajowhite: 0xffdead,
      navy: 0x000080,
      oldlace: 0xfdf5e6,
      olive: 0x808000,
      olivedrab: 0x6b8e23,
      orange: 0xffa500,
      orangered: 0xff4500,
      orchid: 0xda70d6,
      palegoldenrod: 0xeee8aa,
      palegreen: 0x98fb98,
      paleturquoise: 0xafeeee,
      palevioletred: 0xdb7093,
      papayawhip: 0xffefd5,
      peachpuff: 0xffdab9,
      peru: 0xcd853f,
      pink: 0xffc0cb,
      plum: 0xdda0dd,
      powderblue: 0xb0e0e6,
      purple: 0x800080,
      rebeccapurple: 0x663399,
      red: 0xff0000,
      rosybrown: 0xbc8f8f,
      royalblue: 0x4169e1,
      saddlebrown: 0x8b4513,
      salmon: 0xfa8072,
      sandybrown: 0xf4a460,
      seagreen: 0x2e8b57,
      seashell: 0xfff5ee,
      sienna: 0xa0522d,
      silver: 0xc0c0c0,
      skyblue: 0x87ceeb,
      slateblue: 0x6a5acd,
      slategray: 0x708090,
      slategrey: 0x708090,
      snow: 0xfffafa,
      springgreen: 0x00ff7f,
      steelblue: 0x4682b4,
      tan: 0xd2b48c,
      teal: 0x008080,
      thistle: 0xd8bfd8,
      tomato: 0xff6347,
      turquoise: 0x40e0d0,
      violet: 0xee82ee,
      wheat: 0xf5deb3,
      white: 0xffffff,
      whitesmoke: 0xf5f5f5,
      yellow: 0xffff00,
      yellowgreen: 0x9acd32
    };

    define(Color, color, {
      copy(channels) {
        return Object.assign(new this.constructor, this, channels);
      },
      displayable() {
        return this.rgb().displayable();
      },
      hex: color_formatHex, // Deprecated! Use color.formatHex.
      formatHex: color_formatHex,
      formatHex8: color_formatHex8,
      formatHsl: color_formatHsl,
      formatRgb: color_formatRgb,
      toString: color_formatRgb
    });

    function color_formatHex() {
      return this.rgb().formatHex();
    }

    function color_formatHex8() {
      return this.rgb().formatHex8();
    }

    function color_formatHsl() {
      return hslConvert(this).formatHsl();
    }

    function color_formatRgb() {
      return this.rgb().formatRgb();
    }

    function color(format) {
      var m, l;
      format = (format + "").trim().toLowerCase();
      return (m = reHex.exec(format)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn(m) // #ff0000
          : l === 3 ? new Rgb((m >> 8 & 0xf) | (m >> 4 & 0xf0), (m >> 4 & 0xf) | (m & 0xf0), ((m & 0xf) << 4) | (m & 0xf), 1) // #f00
          : l === 8 ? rgba$1(m >> 24 & 0xff, m >> 16 & 0xff, m >> 8 & 0xff, (m & 0xff) / 0xff) // #ff000000
          : l === 4 ? rgba$1((m >> 12 & 0xf) | (m >> 8 & 0xf0), (m >> 8 & 0xf) | (m >> 4 & 0xf0), (m >> 4 & 0xf) | (m & 0xf0), (((m & 0xf) << 4) | (m & 0xf)) / 0xff) // #f000
          : null) // invalid hex
          : (m = reRgbInteger.exec(format)) ? new Rgb(m[1], m[2], m[3], 1) // rgb(255, 0, 0)
          : (m = reRgbPercent.exec(format)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) // rgb(100%, 0%, 0%)
          : (m = reRgbaInteger.exec(format)) ? rgba$1(m[1], m[2], m[3], m[4]) // rgba(255, 0, 0, 1)
          : (m = reRgbaPercent.exec(format)) ? rgba$1(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) // rgb(100%, 0%, 0%, 1)
          : (m = reHslPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) // hsl(120, 50%, 50%)
          : (m = reHslaPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) // hsla(120, 50%, 50%, 1)
          : named.hasOwnProperty(format) ? rgbn(named[format]) // eslint-disable-line no-prototype-builtins
          : format === "transparent" ? new Rgb(NaN, NaN, NaN, 0)
          : null;
    }

    function rgbn(n) {
      return new Rgb(n >> 16 & 0xff, n >> 8 & 0xff, n & 0xff, 1);
    }

    function rgba$1(r, g, b, a) {
      if (a <= 0) r = g = b = NaN;
      return new Rgb(r, g, b, a);
    }

    function rgbConvert(o) {
      if (!(o instanceof Color)) o = color(o);
      if (!o) return new Rgb;
      o = o.rgb();
      return new Rgb(o.r, o.g, o.b, o.opacity);
    }

    function rgb$1(r, g, b, opacity) {
      return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
    }

    function Rgb(r, g, b, opacity) {
      this.r = +r;
      this.g = +g;
      this.b = +b;
      this.opacity = +opacity;
    }

    define(Rgb, rgb$1, extend(Color, {
      brighter(k) {
        k = k == null ? brighter : Math.pow(brighter, k);
        return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
      },
      darker(k) {
        k = k == null ? darker : Math.pow(darker, k);
        return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
      },
      rgb() {
        return this;
      },
      clamp() {
        return new Rgb(clampi(this.r), clampi(this.g), clampi(this.b), clampa(this.opacity));
      },
      displayable() {
        return (-0.5 <= this.r && this.r < 255.5)
            && (-0.5 <= this.g && this.g < 255.5)
            && (-0.5 <= this.b && this.b < 255.5)
            && (0 <= this.opacity && this.opacity <= 1);
      },
      hex: rgb_formatHex, // Deprecated! Use color.formatHex.
      formatHex: rgb_formatHex,
      formatHex8: rgb_formatHex8,
      formatRgb: rgb_formatRgb,
      toString: rgb_formatRgb
    }));

    function rgb_formatHex() {
      return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}`;
    }

    function rgb_formatHex8() {
      return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}${hex((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
    }

    function rgb_formatRgb() {
      const a = clampa(this.opacity);
      return `${a === 1 ? "rgb(" : "rgba("}${clampi(this.r)}, ${clampi(this.g)}, ${clampi(this.b)}${a === 1 ? ")" : `, ${a})`}`;
    }

    function clampa(opacity) {
      return isNaN(opacity) ? 1 : Math.max(0, Math.min(1, opacity));
    }

    function clampi(value) {
      return Math.max(0, Math.min(255, Math.round(value) || 0));
    }

    function hex(value) {
      value = clampi(value);
      return (value < 16 ? "0" : "") + value.toString(16);
    }

    function hsla(h, s, l, a) {
      if (a <= 0) h = s = l = NaN;
      else if (l <= 0 || l >= 1) h = s = NaN;
      else if (s <= 0) h = NaN;
      return new Hsl(h, s, l, a);
    }

    function hslConvert(o) {
      if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);
      if (!(o instanceof Color)) o = color(o);
      if (!o) return new Hsl;
      if (o instanceof Hsl) return o;
      o = o.rgb();
      var r = o.r / 255,
          g = o.g / 255,
          b = o.b / 255,
          min = Math.min(r, g, b),
          max = Math.max(r, g, b),
          h = NaN,
          s = max - min,
          l = (max + min) / 2;
      if (s) {
        if (r === max) h = (g - b) / s + (g < b) * 6;
        else if (g === max) h = (b - r) / s + 2;
        else h = (r - g) / s + 4;
        s /= l < 0.5 ? max + min : 2 - max - min;
        h *= 60;
      } else {
        s = l > 0 && l < 1 ? 0 : h;
      }
      return new Hsl(h, s, l, o.opacity);
    }

    function hsl(h, s, l, opacity) {
      return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);
    }

    function Hsl(h, s, l, opacity) {
      this.h = +h;
      this.s = +s;
      this.l = +l;
      this.opacity = +opacity;
    }

    define(Hsl, hsl, extend(Color, {
      brighter(k) {
        k = k == null ? brighter : Math.pow(brighter, k);
        return new Hsl(this.h, this.s, this.l * k, this.opacity);
      },
      darker(k) {
        k = k == null ? darker : Math.pow(darker, k);
        return new Hsl(this.h, this.s, this.l * k, this.opacity);
      },
      rgb() {
        var h = this.h % 360 + (this.h < 0) * 360,
            s = isNaN(h) || isNaN(this.s) ? 0 : this.s,
            l = this.l,
            m2 = l + (l < 0.5 ? l : 1 - l) * s,
            m1 = 2 * l - m2;
        return new Rgb(
          hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),
          hsl2rgb(h, m1, m2),
          hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2),
          this.opacity
        );
      },
      clamp() {
        return new Hsl(clamph(this.h), clampt(this.s), clampt(this.l), clampa(this.opacity));
      },
      displayable() {
        return (0 <= this.s && this.s <= 1 || isNaN(this.s))
            && (0 <= this.l && this.l <= 1)
            && (0 <= this.opacity && this.opacity <= 1);
      },
      formatHsl() {
        const a = clampa(this.opacity);
        return `${a === 1 ? "hsl(" : "hsla("}${clamph(this.h)}, ${clampt(this.s) * 100}%, ${clampt(this.l) * 100}%${a === 1 ? ")" : `, ${a})`}`;
      }
    }));

    function clamph(value) {
      value = (value || 0) % 360;
      return value < 0 ? value + 360 : value;
    }

    function clampt(value) {
      return Math.max(0, Math.min(1, value || 0));
    }

    /* From FvD 13.37, CSS Color Module Level 3 */
    function hsl2rgb(h, m1, m2) {
      return (h < 60 ? m1 + (m2 - m1) * h / 60
          : h < 180 ? m2
          : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60
          : m1) * 255;
    }

    var constant = x => () => x;

    function linear$1(a, d) {
      return function(t) {
        return a + t * d;
      };
    }

    function exponential(a, b, y) {
      return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function(t) {
        return Math.pow(a + t * b, y);
      };
    }

    function gamma(y) {
      return (y = +y) === 1 ? nogamma : function(a, b) {
        return b - a ? exponential(a, b, y) : constant(isNaN(a) ? b : a);
      };
    }

    function nogamma(a, b) {
      var d = b - a;
      return d ? linear$1(a, d) : constant(isNaN(a) ? b : a);
    }

    var interpolateRgb = (function rgbGamma(y) {
      var color = gamma(y);

      function rgb(start, end) {
        var r = color((start = rgb$1(start)).r, (end = rgb$1(end)).r),
            g = color(start.g, end.g),
            b = color(start.b, end.b),
            opacity = nogamma(start.opacity, end.opacity);
        return function(t) {
          start.r = r(t);
          start.g = g(t);
          start.b = b(t);
          start.opacity = opacity(t);
          return start + "";
        };
      }

      rgb.gamma = rgbGamma;

      return rgb;
    })(1);

    function numberArray(a, b) {
      if (!b) b = [];
      var n = a ? Math.min(b.length, a.length) : 0,
          c = b.slice(),
          i;
      return function(t) {
        for (i = 0; i < n; ++i) c[i] = a[i] * (1 - t) + b[i] * t;
        return c;
      };
    }

    function isNumberArray(x) {
      return ArrayBuffer.isView(x) && !(x instanceof DataView);
    }

    function interpolateArray(a, b) {
      return (isNumberArray(b) ? numberArray : genericArray)(a, b);
    }

    function genericArray(a, b) {
      var nb = b ? b.length : 0,
          na = a ? Math.min(nb, a.length) : 0,
          x = new Array(na),
          c = new Array(nb),
          i;

      for (i = 0; i < na; ++i) x[i] = interpolate(a[i], b[i]);
      for (; i < nb; ++i) c[i] = b[i];

      return function(t) {
        for (i = 0; i < na; ++i) c[i] = x[i](t);
        return c;
      };
    }

    function date(a, b) {
      var d = new Date;
      return a = +a, b = +b, function(t) {
        return d.setTime(a * (1 - t) + b * t), d;
      };
    }

    function interpolateNumber(a, b) {
      return a = +a, b = +b, function(t) {
        return a * (1 - t) + b * t;
      };
    }

    function object(a, b) {
      var i = {},
          c = {},
          k;

      if (a === null || typeof a !== "object") a = {};
      if (b === null || typeof b !== "object") b = {};

      for (k in b) {
        if (k in a) {
          i[k] = interpolate(a[k], b[k]);
        } else {
          c[k] = b[k];
        }
      }

      return function(t) {
        for (k in i) c[k] = i[k](t);
        return c;
      };
    }

    var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,
        reB = new RegExp(reA.source, "g");

    function zero(b) {
      return function() {
        return b;
      };
    }

    function one(b) {
      return function(t) {
        return b(t) + "";
      };
    }

    function interpolateString(a, b) {
      var bi = reA.lastIndex = reB.lastIndex = 0, // scan index for next number in b
          am, // current match in a
          bm, // current match in b
          bs, // string preceding current number in b, if any
          i = -1, // index in s
          s = [], // string constants and placeholders
          q = []; // number interpolators

      // Coerce inputs to strings.
      a = a + "", b = b + "";

      // Interpolate pairs of numbers in a & b.
      while ((am = reA.exec(a))
          && (bm = reB.exec(b))) {
        if ((bs = bm.index) > bi) { // a string precedes the next number in b
          bs = b.slice(bi, bs);
          if (s[i]) s[i] += bs; // coalesce with previous string
          else s[++i] = bs;
        }
        if ((am = am[0]) === (bm = bm[0])) { // numbers in a & b match
          if (s[i]) s[i] += bm; // coalesce with previous string
          else s[++i] = bm;
        } else { // interpolate non-matching numbers
          s[++i] = null;
          q.push({i: i, x: interpolateNumber(am, bm)});
        }
        bi = reB.lastIndex;
      }

      // Add remains of b.
      if (bi < b.length) {
        bs = b.slice(bi);
        if (s[i]) s[i] += bs; // coalesce with previous string
        else s[++i] = bs;
      }

      // Special optimization for only a single match.
      // Otherwise, interpolate each of the numbers and rejoin the string.
      return s.length < 2 ? (q[0]
          ? one(q[0].x)
          : zero(b))
          : (b = q.length, function(t) {
              for (var i = 0, o; i < b; ++i) s[(o = q[i]).i] = o.x(t);
              return s.join("");
            });
    }

    function interpolate(a, b) {
      var t = typeof b, c;
      return b == null || t === "boolean" ? constant(b)
          : (t === "number" ? interpolateNumber
          : t === "string" ? ((c = color(b)) ? (b = c, interpolateRgb) : interpolateString)
          : b instanceof color ? interpolateRgb
          : b instanceof Date ? date
          : isNumberArray(b) ? numberArray
          : Array.isArray(b) ? genericArray
          : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? object
          : interpolateNumber)(a, b);
    }

    function interpolateRound(a, b) {
      return a = +a, b = +b, function(t) {
        return Math.round(a * (1 - t) + b * t);
      };
    }

    function constants(x) {
      return function() {
        return x;
      };
    }

    function number(x) {
      return +x;
    }

    var unit$1 = [0, 1];

    function identity$1(x) {
      return x;
    }

    function normalize(a, b) {
      return (b -= (a = +a))
          ? function(x) { return (x - a) / b; }
          : constants(isNaN(b) ? NaN : 0.5);
    }

    function clamper(a, b) {
      var t;
      if (a > b) t = a, a = b, b = t;
      return function(x) { return Math.max(a, Math.min(b, x)); };
    }

    // normalize(a, b)(x) takes a domain value x in [a,b] and returns the corresponding parameter t in [0,1].
    // interpolate(a, b)(t) takes a parameter t in [0,1] and returns the corresponding range value x in [a,b].
    function bimap(domain, range, interpolate) {
      var d0 = domain[0], d1 = domain[1], r0 = range[0], r1 = range[1];
      if (d1 < d0) d0 = normalize(d1, d0), r0 = interpolate(r1, r0);
      else d0 = normalize(d0, d1), r0 = interpolate(r0, r1);
      return function(x) { return r0(d0(x)); };
    }

    function polymap(domain, range, interpolate) {
      var j = Math.min(domain.length, range.length) - 1,
          d = new Array(j),
          r = new Array(j),
          i = -1;

      // Reverse descending domains.
      if (domain[j] < domain[0]) {
        domain = domain.slice().reverse();
        range = range.slice().reverse();
      }

      while (++i < j) {
        d[i] = normalize(domain[i], domain[i + 1]);
        r[i] = interpolate(range[i], range[i + 1]);
      }

      return function(x) {
        var i = bisect(domain, x, 1, j) - 1;
        return r[i](d[i](x));
      };
    }

    function copy(source, target) {
      return target
          .domain(source.domain())
          .range(source.range())
          .interpolate(source.interpolate())
          .clamp(source.clamp())
          .unknown(source.unknown());
    }

    function transformer() {
      var domain = unit$1,
          range = unit$1,
          interpolate$1 = interpolate,
          transform,
          untransform,
          unknown,
          clamp = identity$1,
          piecewise,
          output,
          input;

      function rescale() {
        var n = Math.min(domain.length, range.length);
        if (clamp !== identity$1) clamp = clamper(domain[0], domain[n - 1]);
        piecewise = n > 2 ? polymap : bimap;
        output = input = null;
        return scale;
      }

      function scale(x) {
        return x == null || isNaN(x = +x) ? unknown : (output || (output = piecewise(domain.map(transform), range, interpolate$1)))(transform(clamp(x)));
      }

      scale.invert = function(y) {
        return clamp(untransform((input || (input = piecewise(range, domain.map(transform), interpolateNumber)))(y)));
      };

      scale.domain = function(_) {
        return arguments.length ? (domain = Array.from(_, number), rescale()) : domain.slice();
      };

      scale.range = function(_) {
        return arguments.length ? (range = Array.from(_), rescale()) : range.slice();
      };

      scale.rangeRound = function(_) {
        return range = Array.from(_), interpolate$1 = interpolateRound, rescale();
      };

      scale.clamp = function(_) {
        return arguments.length ? (clamp = _ ? true : identity$1, rescale()) : clamp !== identity$1;
      };

      scale.interpolate = function(_) {
        return arguments.length ? (interpolate$1 = _, rescale()) : interpolate$1;
      };

      scale.unknown = function(_) {
        return arguments.length ? (unknown = _, scale) : unknown;
      };

      return function(t, u) {
        transform = t, untransform = u;
        return rescale();
      };
    }

    function continuous() {
      return transformer()(identity$1, identity$1);
    }

    function formatDecimal(x) {
      return Math.abs(x = Math.round(x)) >= 1e21
          ? x.toLocaleString("en").replace(/,/g, "")
          : x.toString(10);
    }

    // Computes the decimal coefficient and exponent of the specified number x with
    // significant digits p, where x is positive and p is in [1, 21] or undefined.
    // For example, formatDecimalParts(1.23) returns ["123", 0].
    function formatDecimalParts(x, p) {
      if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf("e")) < 0) return null; // NaN, ±Infinity
      var i, coefficient = x.slice(0, i);

      // The string returned by toExponential either has the form \d\.\d+e[-+]\d+
      // (e.g., 1.2e+3) or the form \de[-+]\d+ (e.g., 1e+3).
      return [
        coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
        +x.slice(i + 1)
      ];
    }

    function exponent(x) {
      return x = formatDecimalParts(Math.abs(x)), x ? x[1] : NaN;
    }

    function formatGroup(grouping, thousands) {
      return function(value, width) {
        var i = value.length,
            t = [],
            j = 0,
            g = grouping[0],
            length = 0;

        while (i > 0 && g > 0) {
          if (length + g + 1 > width) g = Math.max(1, width - length);
          t.push(value.substring(i -= g, i + g));
          if ((length += g + 1) > width) break;
          g = grouping[j = (j + 1) % grouping.length];
        }

        return t.reverse().join(thousands);
      };
    }

    function formatNumerals(numerals) {
      return function(value) {
        return value.replace(/[0-9]/g, function(i) {
          return numerals[+i];
        });
      };
    }

    // [[fill]align][sign][symbol][0][width][,][.precision][~][type]
    var re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;

    function formatSpecifier(specifier) {
      if (!(match = re.exec(specifier))) throw new Error("invalid format: " + specifier);
      var match;
      return new FormatSpecifier({
        fill: match[1],
        align: match[2],
        sign: match[3],
        symbol: match[4],
        zero: match[5],
        width: match[6],
        comma: match[7],
        precision: match[8] && match[8].slice(1),
        trim: match[9],
        type: match[10]
      });
    }

    formatSpecifier.prototype = FormatSpecifier.prototype; // instanceof

    function FormatSpecifier(specifier) {
      this.fill = specifier.fill === undefined ? " " : specifier.fill + "";
      this.align = specifier.align === undefined ? ">" : specifier.align + "";
      this.sign = specifier.sign === undefined ? "-" : specifier.sign + "";
      this.symbol = specifier.symbol === undefined ? "" : specifier.symbol + "";
      this.zero = !!specifier.zero;
      this.width = specifier.width === undefined ? undefined : +specifier.width;
      this.comma = !!specifier.comma;
      this.precision = specifier.precision === undefined ? undefined : +specifier.precision;
      this.trim = !!specifier.trim;
      this.type = specifier.type === undefined ? "" : specifier.type + "";
    }

    FormatSpecifier.prototype.toString = function() {
      return this.fill
          + this.align
          + this.sign
          + this.symbol
          + (this.zero ? "0" : "")
          + (this.width === undefined ? "" : Math.max(1, this.width | 0))
          + (this.comma ? "," : "")
          + (this.precision === undefined ? "" : "." + Math.max(0, this.precision | 0))
          + (this.trim ? "~" : "")
          + this.type;
    };

    // Trims insignificant zeros, e.g., replaces 1.2000k with 1.2k.
    function formatTrim(s) {
      out: for (var n = s.length, i = 1, i0 = -1, i1; i < n; ++i) {
        switch (s[i]) {
          case ".": i0 = i1 = i; break;
          case "0": if (i0 === 0) i0 = i; i1 = i; break;
          default: if (!+s[i]) break out; if (i0 > 0) i0 = 0; break;
        }
      }
      return i0 > 0 ? s.slice(0, i0) + s.slice(i1 + 1) : s;
    }

    var prefixExponent;

    function formatPrefixAuto(x, p) {
      var d = formatDecimalParts(x, p);
      if (!d) return x + "";
      var coefficient = d[0],
          exponent = d[1],
          i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1,
          n = coefficient.length;
      return i === n ? coefficient
          : i > n ? coefficient + new Array(i - n + 1).join("0")
          : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i)
          : "0." + new Array(1 - i).join("0") + formatDecimalParts(x, Math.max(0, p + i - 1))[0]; // less than 1y!
    }

    function formatRounded(x, p) {
      var d = formatDecimalParts(x, p);
      if (!d) return x + "";
      var coefficient = d[0],
          exponent = d[1];
      return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient
          : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1)
          : coefficient + new Array(exponent - coefficient.length + 2).join("0");
    }

    var formatTypes = {
      "%": (x, p) => (x * 100).toFixed(p),
      "b": (x) => Math.round(x).toString(2),
      "c": (x) => x + "",
      "d": formatDecimal,
      "e": (x, p) => x.toExponential(p),
      "f": (x, p) => x.toFixed(p),
      "g": (x, p) => x.toPrecision(p),
      "o": (x) => Math.round(x).toString(8),
      "p": (x, p) => formatRounded(x * 100, p),
      "r": formatRounded,
      "s": formatPrefixAuto,
      "X": (x) => Math.round(x).toString(16).toUpperCase(),
      "x": (x) => Math.round(x).toString(16)
    };

    function identity(x) {
      return x;
    }

    var map = Array.prototype.map,
        prefixes = ["y","z","a","f","p","n","µ","m","","k","M","G","T","P","E","Z","Y"];

    function formatLocale(locale) {
      var group = locale.grouping === undefined || locale.thousands === undefined ? identity : formatGroup(map.call(locale.grouping, Number), locale.thousands + ""),
          currencyPrefix = locale.currency === undefined ? "" : locale.currency[0] + "",
          currencySuffix = locale.currency === undefined ? "" : locale.currency[1] + "",
          decimal = locale.decimal === undefined ? "." : locale.decimal + "",
          numerals = locale.numerals === undefined ? identity : formatNumerals(map.call(locale.numerals, String)),
          percent = locale.percent === undefined ? "%" : locale.percent + "",
          minus = locale.minus === undefined ? "−" : locale.minus + "",
          nan = locale.nan === undefined ? "NaN" : locale.nan + "";

      function newFormat(specifier) {
        specifier = formatSpecifier(specifier);

        var fill = specifier.fill,
            align = specifier.align,
            sign = specifier.sign,
            symbol = specifier.symbol,
            zero = specifier.zero,
            width = specifier.width,
            comma = specifier.comma,
            precision = specifier.precision,
            trim = specifier.trim,
            type = specifier.type;

        // The "n" type is an alias for ",g".
        if (type === "n") comma = true, type = "g";

        // The "" type, and any invalid type, is an alias for ".12~g".
        else if (!formatTypes[type]) precision === undefined && (precision = 12), trim = true, type = "g";

        // If zero fill is specified, padding goes after sign and before digits.
        if (zero || (fill === "0" && align === "=")) zero = true, fill = "0", align = "=";

        // Compute the prefix and suffix.
        // For SI-prefix, the suffix is lazily computed.
        var prefix = symbol === "$" ? currencyPrefix : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "",
            suffix = symbol === "$" ? currencySuffix : /[%p]/.test(type) ? percent : "";

        // What format function should we use?
        // Is this an integer type?
        // Can this type generate exponential notation?
        var formatType = formatTypes[type],
            maybeSuffix = /[defgprs%]/.test(type);

        // Set the default precision if not specified,
        // or clamp the specified precision to the supported range.
        // For significant precision, it must be in [1, 21].
        // For fixed precision, it must be in [0, 20].
        precision = precision === undefined ? 6
            : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision))
            : Math.max(0, Math.min(20, precision));

        function format(value) {
          var valuePrefix = prefix,
              valueSuffix = suffix,
              i, n, c;

          if (type === "c") {
            valueSuffix = formatType(value) + valueSuffix;
            value = "";
          } else {
            value = +value;

            // Determine the sign. -0 is not less than 0, but 1 / -0 is!
            var valueNegative = value < 0 || 1 / value < 0;

            // Perform the initial formatting.
            value = isNaN(value) ? nan : formatType(Math.abs(value), precision);

            // Trim insignificant zeros.
            if (trim) value = formatTrim(value);

            // If a negative value rounds to zero after formatting, and no explicit positive sign is requested, hide the sign.
            if (valueNegative && +value === 0 && sign !== "+") valueNegative = false;

            // Compute the prefix and suffix.
            valuePrefix = (valueNegative ? (sign === "(" ? sign : minus) : sign === "-" || sign === "(" ? "" : sign) + valuePrefix;
            valueSuffix = (type === "s" ? prefixes[8 + prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign === "(" ? ")" : "");

            // Break the formatted value into the integer “value” part that can be
            // grouped, and fractional or exponential “suffix” part that is not.
            if (maybeSuffix) {
              i = -1, n = value.length;
              while (++i < n) {
                if (c = value.charCodeAt(i), 48 > c || c > 57) {
                  valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
                  value = value.slice(0, i);
                  break;
                }
              }
            }
          }

          // If the fill character is not "0", grouping is applied before padding.
          if (comma && !zero) value = group(value, Infinity);

          // Compute the padding.
          var length = valuePrefix.length + value.length + valueSuffix.length,
              padding = length < width ? new Array(width - length + 1).join(fill) : "";

          // If the fill character is "0", grouping is applied after padding.
          if (comma && zero) value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";

          // Reconstruct the final output based on the desired alignment.
          switch (align) {
            case "<": value = valuePrefix + value + valueSuffix + padding; break;
            case "=": value = valuePrefix + padding + value + valueSuffix; break;
            case "^": value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length); break;
            default: value = padding + valuePrefix + value + valueSuffix; break;
          }

          return numerals(value);
        }

        format.toString = function() {
          return specifier + "";
        };

        return format;
      }

      function formatPrefix(specifier, value) {
        var f = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)),
            e = Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3,
            k = Math.pow(10, -e),
            prefix = prefixes[8 + e / 3];
        return function(value) {
          return f(k * value) + prefix;
        };
      }

      return {
        format: newFormat,
        formatPrefix: formatPrefix
      };
    }

    var locale;
    var format$1;
    var formatPrefix;

    defaultLocale({
      thousands: ",",
      grouping: [3],
      currency: ["$", ""]
    });

    function defaultLocale(definition) {
      locale = formatLocale(definition);
      format$1 = locale.format;
      formatPrefix = locale.formatPrefix;
      return locale;
    }

    function precisionFixed(step) {
      return Math.max(0, -exponent(Math.abs(step)));
    }

    function precisionPrefix(step, value) {
      return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3 - exponent(Math.abs(step)));
    }

    function precisionRound(step, max) {
      step = Math.abs(step), max = Math.abs(max) - step;
      return Math.max(0, exponent(max) - exponent(step)) + 1;
    }

    function tickFormat(start, stop, count, specifier) {
      var step = tickStep(start, stop, count),
          precision;
      specifier = formatSpecifier(specifier == null ? ",f" : specifier);
      switch (specifier.type) {
        case "s": {
          var value = Math.max(Math.abs(start), Math.abs(stop));
          if (specifier.precision == null && !isNaN(precision = precisionPrefix(step, value))) specifier.precision = precision;
          return formatPrefix(specifier, value);
        }
        case "":
        case "e":
        case "g":
        case "p":
        case "r": {
          if (specifier.precision == null && !isNaN(precision = precisionRound(step, Math.max(Math.abs(start), Math.abs(stop))))) specifier.precision = precision - (specifier.type === "e");
          break;
        }
        case "f":
        case "%": {
          if (specifier.precision == null && !isNaN(precision = precisionFixed(step))) specifier.precision = precision - (specifier.type === "%") * 2;
          break;
        }
      }
      return format$1(specifier);
    }

    function linearish(scale) {
      var domain = scale.domain;

      scale.ticks = function(count) {
        var d = domain();
        return ticks(d[0], d[d.length - 1], count == null ? 10 : count);
      };

      scale.tickFormat = function(count, specifier) {
        var d = domain();
        return tickFormat(d[0], d[d.length - 1], count == null ? 10 : count, specifier);
      };

      scale.nice = function(count) {
        if (count == null) count = 10;

        var d = domain();
        var i0 = 0;
        var i1 = d.length - 1;
        var start = d[i0];
        var stop = d[i1];
        var prestep;
        var step;
        var maxIter = 10;

        if (stop < start) {
          step = start, start = stop, stop = step;
          step = i0, i0 = i1, i1 = step;
        }
        
        while (maxIter-- > 0) {
          step = tickIncrement(start, stop, count);
          if (step === prestep) {
            d[i0] = start;
            d[i1] = stop;
            return domain(d);
          } else if (step > 0) {
            start = Math.floor(start / step) * step;
            stop = Math.ceil(stop / step) * step;
          } else if (step < 0) {
            start = Math.ceil(start * step) / step;
            stop = Math.floor(stop * step) / step;
          } else {
            break;
          }
          prestep = step;
        }

        return scale;
      };

      return scale;
    }

    function linear() {
      var scale = continuous();

      scale.copy = function() {
        return copy(scale, linear());
      };

      initRange.apply(scale, arguments);

      return linearish(scale);
    }

    const epsilon$1 = 1.1102230246251565e-16;
    const splitter = 134217729;
    const resulterrbound = (3 + 8 * epsilon$1) * epsilon$1;

    // fast_expansion_sum_zeroelim routine from oritinal code
    function sum(elen, e, flen, f, h) {
        let Q, Qnew, hh, bvirt;
        let enow = e[0];
        let fnow = f[0];
        let eindex = 0;
        let findex = 0;
        if ((fnow > enow) === (fnow > -enow)) {
            Q = enow;
            enow = e[++eindex];
        } else {
            Q = fnow;
            fnow = f[++findex];
        }
        let hindex = 0;
        if (eindex < elen && findex < flen) {
            if ((fnow > enow) === (fnow > -enow)) {
                Qnew = enow + Q;
                hh = Q - (Qnew - enow);
                enow = e[++eindex];
            } else {
                Qnew = fnow + Q;
                hh = Q - (Qnew - fnow);
                fnow = f[++findex];
            }
            Q = Qnew;
            if (hh !== 0) {
                h[hindex++] = hh;
            }
            while (eindex < elen && findex < flen) {
                if ((fnow > enow) === (fnow > -enow)) {
                    Qnew = Q + enow;
                    bvirt = Qnew - Q;
                    hh = Q - (Qnew - bvirt) + (enow - bvirt);
                    enow = e[++eindex];
                } else {
                    Qnew = Q + fnow;
                    bvirt = Qnew - Q;
                    hh = Q - (Qnew - bvirt) + (fnow - bvirt);
                    fnow = f[++findex];
                }
                Q = Qnew;
                if (hh !== 0) {
                    h[hindex++] = hh;
                }
            }
        }
        while (eindex < elen) {
            Qnew = Q + enow;
            bvirt = Qnew - Q;
            hh = Q - (Qnew - bvirt) + (enow - bvirt);
            enow = e[++eindex];
            Q = Qnew;
            if (hh !== 0) {
                h[hindex++] = hh;
            }
        }
        while (findex < flen) {
            Qnew = Q + fnow;
            bvirt = Qnew - Q;
            hh = Q - (Qnew - bvirt) + (fnow - bvirt);
            fnow = f[++findex];
            Q = Qnew;
            if (hh !== 0) {
                h[hindex++] = hh;
            }
        }
        if (Q !== 0 || hindex === 0) {
            h[hindex++] = Q;
        }
        return hindex;
    }

    function estimate(elen, e) {
        let Q = e[0];
        for (let i = 1; i < elen; i++) Q += e[i];
        return Q;
    }

    function vec(n) {
        return new Float64Array(n);
    }

    const ccwerrboundA = (3 + 16 * epsilon$1) * epsilon$1;
    const ccwerrboundB = (2 + 12 * epsilon$1) * epsilon$1;
    const ccwerrboundC = (9 + 64 * epsilon$1) * epsilon$1 * epsilon$1;

    const B = vec(4);
    const C1 = vec(8);
    const C2 = vec(12);
    const D = vec(16);
    const u = vec(4);

    function orient2dadapt(ax, ay, bx, by, cx, cy, detsum) {
        let acxtail, acytail, bcxtail, bcytail;
        let bvirt, c, ahi, alo, bhi, blo, _i, _j, _0, s1, s0, t1, t0, u3;

        const acx = ax - cx;
        const bcx = bx - cx;
        const acy = ay - cy;
        const bcy = by - cy;

        s1 = acx * bcy;
        c = splitter * acx;
        ahi = c - (c - acx);
        alo = acx - ahi;
        c = splitter * bcy;
        bhi = c - (c - bcy);
        blo = bcy - bhi;
        s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
        t1 = acy * bcx;
        c = splitter * acy;
        ahi = c - (c - acy);
        alo = acy - ahi;
        c = splitter * bcx;
        bhi = c - (c - bcx);
        blo = bcx - bhi;
        t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
        _i = s0 - t0;
        bvirt = s0 - _i;
        B[0] = s0 - (_i + bvirt) + (bvirt - t0);
        _j = s1 + _i;
        bvirt = _j - s1;
        _0 = s1 - (_j - bvirt) + (_i - bvirt);
        _i = _0 - t1;
        bvirt = _0 - _i;
        B[1] = _0 - (_i + bvirt) + (bvirt - t1);
        u3 = _j + _i;
        bvirt = u3 - _j;
        B[2] = _j - (u3 - bvirt) + (_i - bvirt);
        B[3] = u3;

        let det = estimate(4, B);
        let errbound = ccwerrboundB * detsum;
        if (det >= errbound || -det >= errbound) {
            return det;
        }

        bvirt = ax - acx;
        acxtail = ax - (acx + bvirt) + (bvirt - cx);
        bvirt = bx - bcx;
        bcxtail = bx - (bcx + bvirt) + (bvirt - cx);
        bvirt = ay - acy;
        acytail = ay - (acy + bvirt) + (bvirt - cy);
        bvirt = by - bcy;
        bcytail = by - (bcy + bvirt) + (bvirt - cy);

        if (acxtail === 0 && acytail === 0 && bcxtail === 0 && bcytail === 0) {
            return det;
        }

        errbound = ccwerrboundC * detsum + resulterrbound * Math.abs(det);
        det += (acx * bcytail + bcy * acxtail) - (acy * bcxtail + bcx * acytail);
        if (det >= errbound || -det >= errbound) return det;

        s1 = acxtail * bcy;
        c = splitter * acxtail;
        ahi = c - (c - acxtail);
        alo = acxtail - ahi;
        c = splitter * bcy;
        bhi = c - (c - bcy);
        blo = bcy - bhi;
        s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
        t1 = acytail * bcx;
        c = splitter * acytail;
        ahi = c - (c - acytail);
        alo = acytail - ahi;
        c = splitter * bcx;
        bhi = c - (c - bcx);
        blo = bcx - bhi;
        t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
        _i = s0 - t0;
        bvirt = s0 - _i;
        u[0] = s0 - (_i + bvirt) + (bvirt - t0);
        _j = s1 + _i;
        bvirt = _j - s1;
        _0 = s1 - (_j - bvirt) + (_i - bvirt);
        _i = _0 - t1;
        bvirt = _0 - _i;
        u[1] = _0 - (_i + bvirt) + (bvirt - t1);
        u3 = _j + _i;
        bvirt = u3 - _j;
        u[2] = _j - (u3 - bvirt) + (_i - bvirt);
        u[3] = u3;
        const C1len = sum(4, B, 4, u, C1);

        s1 = acx * bcytail;
        c = splitter * acx;
        ahi = c - (c - acx);
        alo = acx - ahi;
        c = splitter * bcytail;
        bhi = c - (c - bcytail);
        blo = bcytail - bhi;
        s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
        t1 = acy * bcxtail;
        c = splitter * acy;
        ahi = c - (c - acy);
        alo = acy - ahi;
        c = splitter * bcxtail;
        bhi = c - (c - bcxtail);
        blo = bcxtail - bhi;
        t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
        _i = s0 - t0;
        bvirt = s0 - _i;
        u[0] = s0 - (_i + bvirt) + (bvirt - t0);
        _j = s1 + _i;
        bvirt = _j - s1;
        _0 = s1 - (_j - bvirt) + (_i - bvirt);
        _i = _0 - t1;
        bvirt = _0 - _i;
        u[1] = _0 - (_i + bvirt) + (bvirt - t1);
        u3 = _j + _i;
        bvirt = u3 - _j;
        u[2] = _j - (u3 - bvirt) + (_i - bvirt);
        u[3] = u3;
        const C2len = sum(C1len, C1, 4, u, C2);

        s1 = acxtail * bcytail;
        c = splitter * acxtail;
        ahi = c - (c - acxtail);
        alo = acxtail - ahi;
        c = splitter * bcytail;
        bhi = c - (c - bcytail);
        blo = bcytail - bhi;
        s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
        t1 = acytail * bcxtail;
        c = splitter * acytail;
        ahi = c - (c - acytail);
        alo = acytail - ahi;
        c = splitter * bcxtail;
        bhi = c - (c - bcxtail);
        blo = bcxtail - bhi;
        t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
        _i = s0 - t0;
        bvirt = s0 - _i;
        u[0] = s0 - (_i + bvirt) + (bvirt - t0);
        _j = s1 + _i;
        bvirt = _j - s1;
        _0 = s1 - (_j - bvirt) + (_i - bvirt);
        _i = _0 - t1;
        bvirt = _0 - _i;
        u[1] = _0 - (_i + bvirt) + (bvirt - t1);
        u3 = _j + _i;
        bvirt = u3 - _j;
        u[2] = _j - (u3 - bvirt) + (_i - bvirt);
        u[3] = u3;
        const Dlen = sum(C2len, C2, 4, u, D);

        return D[Dlen - 1];
    }

    function orient2d(ax, ay, bx, by, cx, cy) {
        const detleft = (ay - cy) * (bx - cx);
        const detright = (ax - cx) * (by - cy);
        const det = detleft - detright;

        if (detleft === 0 || detright === 0 || (detleft > 0) !== (detright > 0)) return det;

        const detsum = Math.abs(detleft + detright);
        if (Math.abs(det) >= ccwerrboundA * detsum) return det;

        return -orient2dadapt(ax, ay, bx, by, cx, cy, detsum);
    }

    const EPSILON = Math.pow(2, -52);
    const EDGE_STACK = new Uint32Array(512);

    class Delaunator {

        static from(points, getX = defaultGetX, getY = defaultGetY) {
            const n = points.length;
            const coords = new Float64Array(n * 2);

            for (let i = 0; i < n; i++) {
                const p = points[i];
                coords[2 * i] = getX(p);
                coords[2 * i + 1] = getY(p);
            }

            return new Delaunator(coords);
        }

        constructor(coords) {
            const n = coords.length >> 1;
            if (n > 0 && typeof coords[0] !== 'number') throw new Error('Expected coords to contain numbers.');

            this.coords = coords;

            // arrays that will store the triangulation graph
            const maxTriangles = Math.max(2 * n - 5, 0);
            this._triangles = new Uint32Array(maxTriangles * 3);
            this._halfedges = new Int32Array(maxTriangles * 3);

            // temporary arrays for tracking the edges of the advancing convex hull
            this._hashSize = Math.ceil(Math.sqrt(n));
            this._hullPrev = new Uint32Array(n); // edge to prev edge
            this._hullNext = new Uint32Array(n); // edge to next edge
            this._hullTri = new Uint32Array(n); // edge to adjacent triangle
            this._hullHash = new Int32Array(this._hashSize).fill(-1); // angular edge hash

            // temporary arrays for sorting points
            this._ids = new Uint32Array(n);
            this._dists = new Float64Array(n);

            this.update();
        }

        update() {
            const {coords, _hullPrev: hullPrev, _hullNext: hullNext, _hullTri: hullTri, _hullHash: hullHash} =  this;
            const n = coords.length >> 1;

            // populate an array of point indices; calculate input data bbox
            let minX = Infinity;
            let minY = Infinity;
            let maxX = -Infinity;
            let maxY = -Infinity;

            for (let i = 0; i < n; i++) {
                const x = coords[2 * i];
                const y = coords[2 * i + 1];
                if (x < minX) minX = x;
                if (y < minY) minY = y;
                if (x > maxX) maxX = x;
                if (y > maxY) maxY = y;
                this._ids[i] = i;
            }
            const cx = (minX + maxX) / 2;
            const cy = (minY + maxY) / 2;

            let minDist = Infinity;
            let i0, i1, i2;

            // pick a seed point close to the center
            for (let i = 0; i < n; i++) {
                const d = dist(cx, cy, coords[2 * i], coords[2 * i + 1]);
                if (d < minDist) {
                    i0 = i;
                    minDist = d;
                }
            }
            const i0x = coords[2 * i0];
            const i0y = coords[2 * i0 + 1];

            minDist = Infinity;

            // find the point closest to the seed
            for (let i = 0; i < n; i++) {
                if (i === i0) continue;
                const d = dist(i0x, i0y, coords[2 * i], coords[2 * i + 1]);
                if (d < minDist && d > 0) {
                    i1 = i;
                    minDist = d;
                }
            }
            let i1x = coords[2 * i1];
            let i1y = coords[2 * i1 + 1];

            let minRadius = Infinity;

            // find the third point which forms the smallest circumcircle with the first two
            for (let i = 0; i < n; i++) {
                if (i === i0 || i === i1) continue;
                const r = circumradius(i0x, i0y, i1x, i1y, coords[2 * i], coords[2 * i + 1]);
                if (r < minRadius) {
                    i2 = i;
                    minRadius = r;
                }
            }
            let i2x = coords[2 * i2];
            let i2y = coords[2 * i2 + 1];

            if (minRadius === Infinity) {
                // order collinear points by dx (or dy if all x are identical)
                // and return the list as a hull
                for (let i = 0; i < n; i++) {
                    this._dists[i] = (coords[2 * i] - coords[0]) || (coords[2 * i + 1] - coords[1]);
                }
                quicksort(this._ids, this._dists, 0, n - 1);
                const hull = new Uint32Array(n);
                let j = 0;
                for (let i = 0, d0 = -Infinity; i < n; i++) {
                    const id = this._ids[i];
                    if (this._dists[id] > d0) {
                        hull[j++] = id;
                        d0 = this._dists[id];
                    }
                }
                this.hull = hull.subarray(0, j);
                this.triangles = new Uint32Array(0);
                this.halfedges = new Uint32Array(0);
                return;
            }

            // swap the order of the seed points for counter-clockwise orientation
            if (orient2d(i0x, i0y, i1x, i1y, i2x, i2y) < 0) {
                const i = i1;
                const x = i1x;
                const y = i1y;
                i1 = i2;
                i1x = i2x;
                i1y = i2y;
                i2 = i;
                i2x = x;
                i2y = y;
            }

            const center = circumcenter(i0x, i0y, i1x, i1y, i2x, i2y);
            this._cx = center.x;
            this._cy = center.y;

            for (let i = 0; i < n; i++) {
                this._dists[i] = dist(coords[2 * i], coords[2 * i + 1], center.x, center.y);
            }

            // sort the points by distance from the seed triangle circumcenter
            quicksort(this._ids, this._dists, 0, n - 1);

            // set up the seed triangle as the starting hull
            this._hullStart = i0;
            let hullSize = 3;

            hullNext[i0] = hullPrev[i2] = i1;
            hullNext[i1] = hullPrev[i0] = i2;
            hullNext[i2] = hullPrev[i1] = i0;

            hullTri[i0] = 0;
            hullTri[i1] = 1;
            hullTri[i2] = 2;

            hullHash.fill(-1);
            hullHash[this._hashKey(i0x, i0y)] = i0;
            hullHash[this._hashKey(i1x, i1y)] = i1;
            hullHash[this._hashKey(i2x, i2y)] = i2;

            this.trianglesLen = 0;
            this._addTriangle(i0, i1, i2, -1, -1, -1);

            for (let k = 0, xp, yp; k < this._ids.length; k++) {
                const i = this._ids[k];
                const x = coords[2 * i];
                const y = coords[2 * i + 1];

                // skip near-duplicate points
                if (k > 0 && Math.abs(x - xp) <= EPSILON && Math.abs(y - yp) <= EPSILON) continue;
                xp = x;
                yp = y;

                // skip seed triangle points
                if (i === i0 || i === i1 || i === i2) continue;

                // find a visible edge on the convex hull using edge hash
                let start = 0;
                for (let j = 0, key = this._hashKey(x, y); j < this._hashSize; j++) {
                    start = hullHash[(key + j) % this._hashSize];
                    if (start !== -1 && start !== hullNext[start]) break;
                }

                start = hullPrev[start];
                let e = start, q;
                while (q = hullNext[e], orient2d(x, y, coords[2 * e], coords[2 * e + 1], coords[2 * q], coords[2 * q + 1]) >= 0) {
                    e = q;
                    if (e === start) {
                        e = -1;
                        break;
                    }
                }
                if (e === -1) continue; // likely a near-duplicate point; skip it

                // add the first triangle from the point
                let t = this._addTriangle(e, i, hullNext[e], -1, -1, hullTri[e]);

                // recursively flip triangles from the point until they satisfy the Delaunay condition
                hullTri[i] = this._legalize(t + 2);
                hullTri[e] = t; // keep track of boundary triangles on the hull
                hullSize++;

                // walk forward through the hull, adding more triangles and flipping recursively
                let n = hullNext[e];
                while (q = hullNext[n], orient2d(x, y, coords[2 * n], coords[2 * n + 1], coords[2 * q], coords[2 * q + 1]) < 0) {
                    t = this._addTriangle(n, i, q, hullTri[i], -1, hullTri[n]);
                    hullTri[i] = this._legalize(t + 2);
                    hullNext[n] = n; // mark as removed
                    hullSize--;
                    n = q;
                }

                // walk backward from the other side, adding more triangles and flipping
                if (e === start) {
                    while (q = hullPrev[e], orient2d(x, y, coords[2 * q], coords[2 * q + 1], coords[2 * e], coords[2 * e + 1]) < 0) {
                        t = this._addTriangle(q, i, e, -1, hullTri[e], hullTri[q]);
                        this._legalize(t + 2);
                        hullTri[q] = t;
                        hullNext[e] = e; // mark as removed
                        hullSize--;
                        e = q;
                    }
                }

                // update the hull indices
                this._hullStart = hullPrev[i] = e;
                hullNext[e] = hullPrev[n] = i;
                hullNext[i] = n;

                // save the two new edges in the hash table
                hullHash[this._hashKey(x, y)] = i;
                hullHash[this._hashKey(coords[2 * e], coords[2 * e + 1])] = e;
            }

            this.hull = new Uint32Array(hullSize);
            for (let i = 0, e = this._hullStart; i < hullSize; i++) {
                this.hull[i] = e;
                e = hullNext[e];
            }

            // trim typed triangle mesh arrays
            this.triangles = this._triangles.subarray(0, this.trianglesLen);
            this.halfedges = this._halfedges.subarray(0, this.trianglesLen);
        }

        _hashKey(x, y) {
            return Math.floor(pseudoAngle(x - this._cx, y - this._cy) * this._hashSize) % this._hashSize;
        }

        _legalize(a) {
            const {_triangles: triangles, _halfedges: halfedges, coords} = this;

            let i = 0;
            let ar = 0;

            // recursion eliminated with a fixed-size stack
            while (true) {
                const b = halfedges[a];

                /* if the pair of triangles doesn't satisfy the Delaunay condition
                 * (p1 is inside the circumcircle of [p0, pl, pr]), flip them,
                 * then do the same check/flip recursively for the new pair of triangles
                 *
                 *           pl                    pl
                 *          /||\                  /  \
                 *       al/ || \bl            al/    \a
                 *        /  ||  \              /      \
                 *       /  a||b  \    flip    /___ar___\
                 *     p0\   ||   /p1   =>   p0\---bl---/p1
                 *        \  ||  /              \      /
                 *       ar\ || /br             b\    /br
                 *          \||/                  \  /
                 *           pr                    pr
                 */
                const a0 = a - a % 3;
                ar = a0 + (a + 2) % 3;

                if (b === -1) { // convex hull edge
                    if (i === 0) break;
                    a = EDGE_STACK[--i];
                    continue;
                }

                const b0 = b - b % 3;
                const al = a0 + (a + 1) % 3;
                const bl = b0 + (b + 2) % 3;

                const p0 = triangles[ar];
                const pr = triangles[a];
                const pl = triangles[al];
                const p1 = triangles[bl];

                const illegal = inCircle(
                    coords[2 * p0], coords[2 * p0 + 1],
                    coords[2 * pr], coords[2 * pr + 1],
                    coords[2 * pl], coords[2 * pl + 1],
                    coords[2 * p1], coords[2 * p1 + 1]);

                if (illegal) {
                    triangles[a] = p1;
                    triangles[b] = p0;

                    const hbl = halfedges[bl];

                    // edge swapped on the other side of the hull (rare); fix the halfedge reference
                    if (hbl === -1) {
                        let e = this._hullStart;
                        do {
                            if (this._hullTri[e] === bl) {
                                this._hullTri[e] = a;
                                break;
                            }
                            e = this._hullPrev[e];
                        } while (e !== this._hullStart);
                    }
                    this._link(a, hbl);
                    this._link(b, halfedges[ar]);
                    this._link(ar, bl);

                    const br = b0 + (b + 1) % 3;

                    // don't worry about hitting the cap: it can only happen on extremely degenerate input
                    if (i < EDGE_STACK.length) {
                        EDGE_STACK[i++] = br;
                    }
                } else {
                    if (i === 0) break;
                    a = EDGE_STACK[--i];
                }
            }

            return ar;
        }

        _link(a, b) {
            this._halfedges[a] = b;
            if (b !== -1) this._halfedges[b] = a;
        }

        // add a new triangle given vertex indices and adjacent half-edge ids
        _addTriangle(i0, i1, i2, a, b, c) {
            const t = this.trianglesLen;

            this._triangles[t] = i0;
            this._triangles[t + 1] = i1;
            this._triangles[t + 2] = i2;

            this._link(t, a);
            this._link(t + 1, b);
            this._link(t + 2, c);

            this.trianglesLen += 3;

            return t;
        }
    }

    // monotonically increases with real angle, but doesn't need expensive trigonometry
    function pseudoAngle(dx, dy) {
        const p = dx / (Math.abs(dx) + Math.abs(dy));
        return (dy > 0 ? 3 - p : 1 + p) / 4; // [0..1]
    }

    function dist(ax, ay, bx, by) {
        const dx = ax - bx;
        const dy = ay - by;
        return dx * dx + dy * dy;
    }

    function inCircle(ax, ay, bx, by, cx, cy, px, py) {
        const dx = ax - px;
        const dy = ay - py;
        const ex = bx - px;
        const ey = by - py;
        const fx = cx - px;
        const fy = cy - py;

        const ap = dx * dx + dy * dy;
        const bp = ex * ex + ey * ey;
        const cp = fx * fx + fy * fy;

        return dx * (ey * cp - bp * fy) -
               dy * (ex * cp - bp * fx) +
               ap * (ex * fy - ey * fx) < 0;
    }

    function circumradius(ax, ay, bx, by, cx, cy) {
        const dx = bx - ax;
        const dy = by - ay;
        const ex = cx - ax;
        const ey = cy - ay;

        const bl = dx * dx + dy * dy;
        const cl = ex * ex + ey * ey;
        const d = 0.5 / (dx * ey - dy * ex);

        const x = (ey * bl - dy * cl) * d;
        const y = (dx * cl - ex * bl) * d;

        return x * x + y * y;
    }

    function circumcenter(ax, ay, bx, by, cx, cy) {
        const dx = bx - ax;
        const dy = by - ay;
        const ex = cx - ax;
        const ey = cy - ay;

        const bl = dx * dx + dy * dy;
        const cl = ex * ex + ey * ey;
        const d = 0.5 / (dx * ey - dy * ex);

        const x = ax + (ey * bl - dy * cl) * d;
        const y = ay + (dx * cl - ex * bl) * d;

        return {x, y};
    }

    function quicksort(ids, dists, left, right) {
        if (right - left <= 20) {
            for (let i = left + 1; i <= right; i++) {
                const temp = ids[i];
                const tempDist = dists[temp];
                let j = i - 1;
                while (j >= left && dists[ids[j]] > tempDist) ids[j + 1] = ids[j--];
                ids[j + 1] = temp;
            }
        } else {
            const median = (left + right) >> 1;
            let i = left + 1;
            let j = right;
            swap(ids, median, i);
            if (dists[ids[left]] > dists[ids[right]]) swap(ids, left, right);
            if (dists[ids[i]] > dists[ids[right]]) swap(ids, i, right);
            if (dists[ids[left]] > dists[ids[i]]) swap(ids, left, i);

            const temp = ids[i];
            const tempDist = dists[temp];
            while (true) {
                do i++; while (dists[ids[i]] < tempDist);
                do j--; while (dists[ids[j]] > tempDist);
                if (j < i) break;
                swap(ids, i, j);
            }
            ids[left + 1] = ids[j];
            ids[j] = temp;

            if (right - i + 1 >= j - left) {
                quicksort(ids, dists, i, right);
                quicksort(ids, dists, left, j - 1);
            } else {
                quicksort(ids, dists, left, j - 1);
                quicksort(ids, dists, i, right);
            }
        }
    }

    function swap(arr, i, j) {
        const tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
    }

    function defaultGetX(p) {
        return p[0];
    }
    function defaultGetY(p) {
        return p[1];
    }

    /**
     * Unwrap a coordinate from a Point Feature, Geometry or a single coordinate.
     *
     * @name getCoord
     * @param {Array<number>|Geometry<Point>|Feature<Point>} coord GeoJSON Point or an Array of numbers
     * @returns {Array<number>} coordinates
     * @example
     * var pt = turf.point([10, 10]);
     *
     * var coord = turf.getCoord(pt);
     * //= [10, 10]
     */
    function getCoord(coord) {
        if (!coord) {
            throw new Error("coord is required");
        }
        if (!Array.isArray(coord)) {
            if (coord.type === "Feature" &&
                coord.geometry !== null &&
                coord.geometry.type === "Point") {
                return coord.geometry.coordinates;
            }
            if (coord.type === "Point") {
                return coord.coordinates;
            }
        }
        if (Array.isArray(coord) &&
            coord.length >= 2 &&
            !Array.isArray(coord[0]) &&
            !Array.isArray(coord[1])) {
            return coord;
        }
        throw new Error("coord must be GeoJSON Point or an Array of numbers");
    }
    /**
     * Get Geometry from Feature or Geometry Object
     *
     * @param {Feature|Geometry} geojson GeoJSON Feature or Geometry Object
     * @returns {Geometry|null} GeoJSON Geometry Object
     * @throws {Error} if geojson is not a Feature or Geometry Object
     * @example
     * var point = {
     *   "type": "Feature",
     *   "properties": {},
     *   "geometry": {
     *     "type": "Point",
     *     "coordinates": [110, 40]
     *   }
     * }
     * var geom = turf.getGeom(point)
     * //={"type": "Point", "coordinates": [110, 40]}
     */
    function getGeom(geojson) {
        if (geojson.type === "Feature") {
            return geojson.geometry;
        }
        return geojson;
    }

    // http://en.wikipedia.org/wiki/Even%E2%80%93odd_rule
    // modified from: https://github.com/substack/point-in-polygon/blob/master/index.js
    // which was modified from http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html
    /**
     * Takes a {@link Point} and a {@link Polygon} or {@link MultiPolygon} and determines if the point
     * resides inside the polygon. The polygon can be convex or concave. The function accounts for holes.
     *
     * @name booleanPointInPolygon
     * @param {Coord} point input point
     * @param {Feature<Polygon|MultiPolygon>} polygon input polygon or multipolygon
     * @param {Object} [options={}] Optional parameters
     * @param {boolean} [options.ignoreBoundary=false] True if polygon boundary should be ignored when determining if
     * the point is inside the polygon otherwise false.
     * @returns {boolean} `true` if the Point is inside the Polygon; `false` if the Point is not inside the Polygon
     * @example
     * var pt = turf.point([-77, 44]);
     * var poly = turf.polygon([[
     *   [-81, 41],
     *   [-81, 47],
     *   [-72, 47],
     *   [-72, 41],
     *   [-81, 41]
     * ]]);
     *
     * turf.booleanPointInPolygon(pt, poly);
     * //= true
     */
    function booleanPointInPolygon(point, polygon, options) {
        if (options === void 0) { options = {}; }
        // validation
        if (!point) {
            throw new Error("point is required");
        }
        if (!polygon) {
            throw new Error("polygon is required");
        }
        var pt = getCoord(point);
        var geom = getGeom(polygon);
        var type = geom.type;
        var bbox = polygon.bbox;
        var polys = geom.coordinates;
        // Quick elimination if point is not inside bbox
        if (bbox && inBBox(pt, bbox) === false) {
            return false;
        }
        // normalize to multipolygon
        if (type === "Polygon") {
            polys = [polys];
        }
        var insidePoly = false;
        for (var i = 0; i < polys.length && !insidePoly; i++) {
            // check if it is in the outer ring first
            if (inRing(pt, polys[i][0], options.ignoreBoundary)) {
                var inHole = false;
                var k = 1;
                // check for the point in any of the holes
                while (k < polys[i].length && !inHole) {
                    if (inRing(pt, polys[i][k], !options.ignoreBoundary)) {
                        inHole = true;
                    }
                    k++;
                }
                if (!inHole) {
                    insidePoly = true;
                }
            }
        }
        return insidePoly;
    }
    /**
     * inRing
     *
     * @private
     * @param {Array<number>} pt [x,y]
     * @param {Array<Array<number>>} ring [[x,y], [x,y],..]
     * @param {boolean} ignoreBoundary ignoreBoundary
     * @returns {boolean} inRing
     */
    function inRing(pt, ring, ignoreBoundary) {
        var isInside = false;
        if (ring[0][0] === ring[ring.length - 1][0] &&
            ring[0][1] === ring[ring.length - 1][1]) {
            ring = ring.slice(0, ring.length - 1);
        }
        for (var i = 0, j = ring.length - 1; i < ring.length; j = i++) {
            var xi = ring[i][0];
            var yi = ring[i][1];
            var xj = ring[j][0];
            var yj = ring[j][1];
            var onBoundary = pt[1] * (xi - xj) + yi * (xj - pt[0]) + yj * (pt[0] - xi) === 0 &&
                (xi - pt[0]) * (xj - pt[0]) <= 0 &&
                (yi - pt[1]) * (yj - pt[1]) <= 0;
            if (onBoundary) {
                return !ignoreBoundary;
            }
            var intersect = yi > pt[1] !== yj > pt[1] &&
                pt[0] < ((xj - xi) * (pt[1] - yi)) / (yj - yi) + xi;
            if (intersect) {
                isInside = !isInside;
            }
        }
        return isInside;
    }
    /**
     * inBBox
     *
     * @private
     * @param {Position} pt point [x,y]
     * @param {BBox} bbox BBox [west, south, east, north]
     * @returns {boolean} true/false if point is inside BBox
     */
    function inBBox(pt, bbox) {
        return (bbox[0] <= pt[0] && bbox[1] <= pt[1] && bbox[2] >= pt[0] && bbox[3] >= pt[1]);
    }

    const epsilon = 1e-6;

    class Path {
      constructor() {
        this._x0 = this._y0 = // start of current subpath
        this._x1 = this._y1 = null; // end of current subpath
        this._ = "";
      }
      moveTo(x, y) {
        this._ += `M${this._x0 = this._x1 = +x},${this._y0 = this._y1 = +y}`;
      }
      closePath() {
        if (this._x1 !== null) {
          this._x1 = this._x0, this._y1 = this._y0;
          this._ += "Z";
        }
      }
      lineTo(x, y) {
        this._ += `L${this._x1 = +x},${this._y1 = +y}`;
      }
      arc(x, y, r) {
        x = +x, y = +y, r = +r;
        const x0 = x + r;
        const y0 = y;
        if (r < 0) throw new Error("negative radius");
        if (this._x1 === null) this._ += `M${x0},${y0}`;
        else if (Math.abs(this._x1 - x0) > epsilon || Math.abs(this._y1 - y0) > epsilon) this._ += "L" + x0 + "," + y0;
        if (!r) return;
        this._ += `A${r},${r},0,1,1,${x - r},${y}A${r},${r},0,1,1,${this._x1 = x0},${this._y1 = y0}`;
      }
      rect(x, y, w, h) {
        this._ += `M${this._x0 = this._x1 = +x},${this._y0 = this._y1 = +y}h${+w}v${+h}h${-w}Z`;
      }
      value() {
        return this._ || null;
      }
    }

    class Polygon {
      constructor() {
        this._ = [];
      }
      moveTo(x, y) {
        this._.push([x, y]);
      }
      closePath() {
        this._.push(this._[0].slice());
      }
      lineTo(x, y) {
        this._.push([x, y]);
      }
      value() {
        return this._.length ? this._ : null;
      }
    }

    class Voronoi {
      constructor(delaunay, [xmin, ymin, xmax, ymax] = [0, 0, 960, 500]) {
        if (!((xmax = +xmax) >= (xmin = +xmin)) || !((ymax = +ymax) >= (ymin = +ymin))) throw new Error("invalid bounds");
        this.delaunay = delaunay;
        this._circumcenters = new Float64Array(delaunay.points.length * 2);
        this.vectors = new Float64Array(delaunay.points.length * 2);
        this.xmax = xmax, this.xmin = xmin;
        this.ymax = ymax, this.ymin = ymin;
        this._init();
      }
      update() {
        this.delaunay.update();
        this._init();
        return this;
      }
      _init() {
        const {delaunay: {points, hull, triangles}, vectors} = this;

        // Compute circumcenters.
        const circumcenters = this.circumcenters = this._circumcenters.subarray(0, triangles.length / 3 * 2);
        for (let i = 0, j = 0, n = triangles.length, x, y; i < n; i += 3, j += 2) {
          const t1 = triangles[i] * 2;
          const t2 = triangles[i + 1] * 2;
          const t3 = triangles[i + 2] * 2;
          const x1 = points[t1];
          const y1 = points[t1 + 1];
          const x2 = points[t2];
          const y2 = points[t2 + 1];
          const x3 = points[t3];
          const y3 = points[t3 + 1];

          const dx = x2 - x1;
          const dy = y2 - y1;
          const ex = x3 - x1;
          const ey = y3 - y1;
          const ab = (dx * ey - dy * ex) * 2;

          if (Math.abs(ab) < 1e-9) {
            // degenerate case (collinear diagram)
            // almost equal points (degenerate triangle)
            // the circumcenter is at the infinity, in a
            // direction that is:
            // 1. orthogonal to the halfedge.
            let a = 1e9;
            // 2. points away from the center; since the list of triangles starts
            // in the center, the first point of the first triangle
            // will be our reference
            const r = triangles[0] * 2;
            a *= Math.sign((points[r] - x1) * ey - (points[r + 1] - y1) * ex);
            x = (x1 + x3) / 2 - a * ey;
            y = (y1 + y3) / 2 + a * ex;
          } else {
            const d = 1 / ab;
            const bl = dx * dx + dy * dy;
            const cl = ex * ex + ey * ey;
            x = x1 + (ey * bl - dy * cl) * d;
            y = y1 + (dx * cl - ex * bl) * d;
          }
          circumcenters[j] = x;
          circumcenters[j + 1] = y;
        }

        // Compute exterior cell rays.
        let h = hull[hull.length - 1];
        let p0, p1 = h * 4;
        let x0, x1 = points[2 * h];
        let y0, y1 = points[2 * h + 1];
        vectors.fill(0);
        for (let i = 0; i < hull.length; ++i) {
          h = hull[i];
          p0 = p1, x0 = x1, y0 = y1;
          p1 = h * 4, x1 = points[2 * h], y1 = points[2 * h + 1];
          vectors[p0 + 2] = vectors[p1] = y0 - y1;
          vectors[p0 + 3] = vectors[p1 + 1] = x1 - x0;
        }
      }
      render(context) {
        const buffer = context == null ? context = new Path : undefined;
        const {delaunay: {halfedges, inedges, hull}, circumcenters, vectors} = this;
        if (hull.length <= 1) return null;
        for (let i = 0, n = halfedges.length; i < n; ++i) {
          const j = halfedges[i];
          if (j < i) continue;
          const ti = Math.floor(i / 3) * 2;
          const tj = Math.floor(j / 3) * 2;
          const xi = circumcenters[ti];
          const yi = circumcenters[ti + 1];
          const xj = circumcenters[tj];
          const yj = circumcenters[tj + 1];
          this._renderSegment(xi, yi, xj, yj, context);
        }
        let h0, h1 = hull[hull.length - 1];
        for (let i = 0; i < hull.length; ++i) {
          h0 = h1, h1 = hull[i];
          const t = Math.floor(inedges[h1] / 3) * 2;
          const x = circumcenters[t];
          const y = circumcenters[t + 1];
          const v = h0 * 4;
          const p = this._project(x, y, vectors[v + 2], vectors[v + 3]);
          if (p) this._renderSegment(x, y, p[0], p[1], context);
        }
        return buffer && buffer.value();
      }
      renderBounds(context) {
        const buffer = context == null ? context = new Path : undefined;
        context.rect(this.xmin, this.ymin, this.xmax - this.xmin, this.ymax - this.ymin);
        return buffer && buffer.value();
      }
      renderCell(i, context) {
        const buffer = context == null ? context = new Path : undefined;
        const points = this._clip(i);
        if (points === null || !points.length) return;
        context.moveTo(points[0], points[1]);
        let n = points.length;
        while (points[0] === points[n-2] && points[1] === points[n-1] && n > 1) n -= 2;
        for (let i = 2; i < n; i += 2) {
          if (points[i] !== points[i-2] || points[i+1] !== points[i-1])
            context.lineTo(points[i], points[i + 1]);
        }
        context.closePath();
        return buffer && buffer.value();
      }
      *cellPolygons() {
        const {delaunay: {points}} = this;
        for (let i = 0, n = points.length / 2; i < n; ++i) {
          const cell = this.cellPolygon(i);
          if (cell) cell.index = i, yield cell;
        }
      }
      cellPolygon(i) {
        const polygon = new Polygon;
        this.renderCell(i, polygon);
        return polygon.value();
      }
      _renderSegment(x0, y0, x1, y1, context) {
        let S;
        const c0 = this._regioncode(x0, y0);
        const c1 = this._regioncode(x1, y1);
        if (c0 === 0 && c1 === 0) {
          context.moveTo(x0, y0);
          context.lineTo(x1, y1);
        } else if (S = this._clipSegment(x0, y0, x1, y1, c0, c1)) {
          context.moveTo(S[0], S[1]);
          context.lineTo(S[2], S[3]);
        }
      }
      contains(i, x, y) {
        if ((x = +x, x !== x) || (y = +y, y !== y)) return false;
        return this.delaunay._step(i, x, y) === i;
      }
      *neighbors(i) {
        const ci = this._clip(i);
        if (ci) for (const j of this.delaunay.neighbors(i)) {
          const cj = this._clip(j);
          // find the common edge
          if (cj) loop: for (let ai = 0, li = ci.length; ai < li; ai += 2) {
            for (let aj = 0, lj = cj.length; aj < lj; aj += 2) {
              if (ci[ai] == cj[aj]
              && ci[ai + 1] == cj[aj + 1]
              && ci[(ai + 2) % li] == cj[(aj + lj - 2) % lj]
              && ci[(ai + 3) % li] == cj[(aj + lj - 1) % lj]
              ) {
                yield j;
                break loop;
              }
            }
          }
        }
      }
      _cell(i) {
        const {circumcenters, delaunay: {inedges, halfedges, triangles}} = this;
        const e0 = inedges[i];
        if (e0 === -1) return null; // coincident point
        const points = [];
        let e = e0;
        do {
          const t = Math.floor(e / 3);
          points.push(circumcenters[t * 2], circumcenters[t * 2 + 1]);
          e = e % 3 === 2 ? e - 2 : e + 1;
          if (triangles[e] !== i) break; // bad triangulation
          e = halfedges[e];
        } while (e !== e0 && e !== -1);
        return points;
      }
      _clip(i) {
        // degenerate case (1 valid point: return the box)
        if (i === 0 && this.delaunay.hull.length === 1) {
          return [this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax, this.xmin, this.ymin];
        }
        const points = this._cell(i);
        if (points === null) return null;
        const {vectors: V} = this;
        const v = i * 4;
        return V[v] || V[v + 1]
            ? this._clipInfinite(i, points, V[v], V[v + 1], V[v + 2], V[v + 3])
            : this._clipFinite(i, points);
      }
      _clipFinite(i, points) {
        const n = points.length;
        let P = null;
        let x0, y0, x1 = points[n - 2], y1 = points[n - 1];
        let c0, c1 = this._regioncode(x1, y1);
        let e0, e1 = 0;
        for (let j = 0; j < n; j += 2) {
          x0 = x1, y0 = y1, x1 = points[j], y1 = points[j + 1];
          c0 = c1, c1 = this._regioncode(x1, y1);
          if (c0 === 0 && c1 === 0) {
            e0 = e1, e1 = 0;
            if (P) P.push(x1, y1);
            else P = [x1, y1];
          } else {
            let S, sx0, sy0, sx1, sy1;
            if (c0 === 0) {
              if ((S = this._clipSegment(x0, y0, x1, y1, c0, c1)) === null) continue;
              [sx0, sy0, sx1, sy1] = S;
            } else {
              if ((S = this._clipSegment(x1, y1, x0, y0, c1, c0)) === null) continue;
              [sx1, sy1, sx0, sy0] = S;
              e0 = e1, e1 = this._edgecode(sx0, sy0);
              if (e0 && e1) this._edge(i, e0, e1, P, P.length);
              if (P) P.push(sx0, sy0);
              else P = [sx0, sy0];
            }
            e0 = e1, e1 = this._edgecode(sx1, sy1);
            if (e0 && e1) this._edge(i, e0, e1, P, P.length);
            if (P) P.push(sx1, sy1);
            else P = [sx1, sy1];
          }
        }
        if (P) {
          e0 = e1, e1 = this._edgecode(P[0], P[1]);
          if (e0 && e1) this._edge(i, e0, e1, P, P.length);
        } else if (this.contains(i, (this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2)) {
          return [this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax, this.xmin, this.ymin];
        }
        return P;
      }
      _clipSegment(x0, y0, x1, y1, c0, c1) {
        while (true) {
          if (c0 === 0 && c1 === 0) return [x0, y0, x1, y1];
          if (c0 & c1) return null;
          let x, y, c = c0 || c1;
          if (c & 0b1000) x = x0 + (x1 - x0) * (this.ymax - y0) / (y1 - y0), y = this.ymax;
          else if (c & 0b0100) x = x0 + (x1 - x0) * (this.ymin - y0) / (y1 - y0), y = this.ymin;
          else if (c & 0b0010) y = y0 + (y1 - y0) * (this.xmax - x0) / (x1 - x0), x = this.xmax;
          else y = y0 + (y1 - y0) * (this.xmin - x0) / (x1 - x0), x = this.xmin;
          if (c0) x0 = x, y0 = y, c0 = this._regioncode(x0, y0);
          else x1 = x, y1 = y, c1 = this._regioncode(x1, y1);
        }
      }
      _clipInfinite(i, points, vx0, vy0, vxn, vyn) {
        let P = Array.from(points), p;
        if (p = this._project(P[0], P[1], vx0, vy0)) P.unshift(p[0], p[1]);
        if (p = this._project(P[P.length - 2], P[P.length - 1], vxn, vyn)) P.push(p[0], p[1]);
        if (P = this._clipFinite(i, P)) {
          for (let j = 0, n = P.length, c0, c1 = this._edgecode(P[n - 2], P[n - 1]); j < n; j += 2) {
            c0 = c1, c1 = this._edgecode(P[j], P[j + 1]);
            if (c0 && c1) j = this._edge(i, c0, c1, P, j), n = P.length;
          }
        } else if (this.contains(i, (this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2)) {
          P = [this.xmin, this.ymin, this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax];
        }
        return P;
      }
      _edge(i, e0, e1, P, j) {
        while (e0 !== e1) {
          let x, y;
          switch (e0) {
            case 0b0101: e0 = 0b0100; continue; // top-left
            case 0b0100: e0 = 0b0110, x = this.xmax, y = this.ymin; break; // top
            case 0b0110: e0 = 0b0010; continue; // top-right
            case 0b0010: e0 = 0b1010, x = this.xmax, y = this.ymax; break; // right
            case 0b1010: e0 = 0b1000; continue; // bottom-right
            case 0b1000: e0 = 0b1001, x = this.xmin, y = this.ymax; break; // bottom
            case 0b1001: e0 = 0b0001; continue; // bottom-left
            case 0b0001: e0 = 0b0101, x = this.xmin, y = this.ymin; break; // left
          }
          // Note: this implicitly checks for out of bounds: if P[j] or P[j+1] are
          // undefined, the conditional statement will be executed.
          if ((P[j] !== x || P[j + 1] !== y) && this.contains(i, x, y)) {
            P.splice(j, 0, x, y), j += 2;
          }
        }
        if (P.length > 4) {
          for (let i = 0; i < P.length; i+= 2) {
            const j = (i + 2) % P.length, k = (i + 4) % P.length;
            if (P[i] === P[j] && P[j] === P[k]
            || P[i + 1] === P[j + 1] && P[j + 1] === P[k + 1])
              P.splice(j, 2), i -= 2;
          }
        }
        return j;
      }
      _project(x0, y0, vx, vy) {
        let t = Infinity, c, x, y;
        if (vy < 0) { // top
          if (y0 <= this.ymin) return null;
          if ((c = (this.ymin - y0) / vy) < t) y = this.ymin, x = x0 + (t = c) * vx;
        } else if (vy > 0) { // bottom
          if (y0 >= this.ymax) return null;
          if ((c = (this.ymax - y0) / vy) < t) y = this.ymax, x = x0 + (t = c) * vx;
        }
        if (vx > 0) { // right
          if (x0 >= this.xmax) return null;
          if ((c = (this.xmax - x0) / vx) < t) x = this.xmax, y = y0 + (t = c) * vy;
        } else if (vx < 0) { // left
          if (x0 <= this.xmin) return null;
          if ((c = (this.xmin - x0) / vx) < t) x = this.xmin, y = y0 + (t = c) * vy;
        }
        return [x, y];
      }
      _edgecode(x, y) {
        return (x === this.xmin ? 0b0001
            : x === this.xmax ? 0b0010 : 0b0000)
            | (y === this.ymin ? 0b0100
            : y === this.ymax ? 0b1000 : 0b0000);
      }
      _regioncode(x, y) {
        return (x < this.xmin ? 0b0001
            : x > this.xmax ? 0b0010 : 0b0000)
            | (y < this.ymin ? 0b0100
            : y > this.ymax ? 0b1000 : 0b0000);
      }
    }

    const tau = 2 * Math.PI, pow = Math.pow;

    function pointX(p) {
      return p[0];
    }

    function pointY(p) {
      return p[1];
    }

    // A triangulation is collinear if all its triangles have a non-null area
    function collinear(d) {
      const {triangles, coords} = d;
      for (let i = 0; i < triangles.length; i += 3) {
        const a = 2 * triangles[i],
              b = 2 * triangles[i + 1],
              c = 2 * triangles[i + 2],
              cross = (coords[c] - coords[a]) * (coords[b + 1] - coords[a + 1])
                    - (coords[b] - coords[a]) * (coords[c + 1] - coords[a + 1]);
        if (cross > 1e-10) return false;
      }
      return true;
    }

    function jitter(x, y, r) {
      return [x + Math.sin(x + y) * r, y + Math.cos(x - y) * r];
    }

    class Delaunay {
      static from(points, fx = pointX, fy = pointY, that) {
        return new Delaunay("length" in points
            ? flatArray(points, fx, fy, that)
            : Float64Array.from(flatIterable(points, fx, fy, that)));
      }
      constructor(points) {
        this._delaunator = new Delaunator(points);
        this.inedges = new Int32Array(points.length / 2);
        this._hullIndex = new Int32Array(points.length / 2);
        this.points = this._delaunator.coords;
        this._init();
      }
      update() {
        this._delaunator.update();
        this._init();
        return this;
      }
      _init() {
        const d = this._delaunator, points = this.points;

        // check for collinear
        if (d.hull && d.hull.length > 2 && collinear(d)) {
          this.collinear = Int32Array.from({length: points.length/2}, (_,i) => i)
            .sort((i, j) => points[2 * i] - points[2 * j] || points[2 * i + 1] - points[2 * j + 1]); // for exact neighbors
          const e = this.collinear[0], f = this.collinear[this.collinear.length - 1],
            bounds = [ points[2 * e], points[2 * e + 1], points[2 * f], points[2 * f + 1] ],
            r = 1e-8 * Math.hypot(bounds[3] - bounds[1], bounds[2] - bounds[0]);
          for (let i = 0, n = points.length / 2; i < n; ++i) {
            const p = jitter(points[2 * i], points[2 * i + 1], r);
            points[2 * i] = p[0];
            points[2 * i + 1] = p[1];
          }
          this._delaunator = new Delaunator(points);
        } else {
          delete this.collinear;
        }

        const halfedges = this.halfedges = this._delaunator.halfedges;
        const hull = this.hull = this._delaunator.hull;
        const triangles = this.triangles = this._delaunator.triangles;
        const inedges = this.inedges.fill(-1);
        const hullIndex = this._hullIndex.fill(-1);

        // Compute an index from each point to an (arbitrary) incoming halfedge
        // Used to give the first neighbor of each point; for this reason,
        // on the hull we give priority to exterior halfedges
        for (let e = 0, n = halfedges.length; e < n; ++e) {
          const p = triangles[e % 3 === 2 ? e - 2 : e + 1];
          if (halfedges[e] === -1 || inedges[p] === -1) inedges[p] = e;
        }
        for (let i = 0, n = hull.length; i < n; ++i) {
          hullIndex[hull[i]] = i;
        }

        // degenerate case: 1 or 2 (distinct) points
        if (hull.length <= 2 && hull.length > 0) {
          this.triangles = new Int32Array(3).fill(-1);
          this.halfedges = new Int32Array(3).fill(-1);
          this.triangles[0] = hull[0];
          inedges[hull[0]] = 1;
          if (hull.length === 2) {
            inedges[hull[1]] = 0;
            this.triangles[1] = hull[1];
            this.triangles[2] = hull[1];
          }
        }
      }
      voronoi(bounds) {
        return new Voronoi(this, bounds);
      }
      *neighbors(i) {
        const {inedges, hull, _hullIndex, halfedges, triangles, collinear} = this;

        // degenerate case with several collinear points
        if (collinear) {
          const l = collinear.indexOf(i);
          if (l > 0) yield collinear[l - 1];
          if (l < collinear.length - 1) yield collinear[l + 1];
          return;
        }

        const e0 = inedges[i];
        if (e0 === -1) return; // coincident point
        let e = e0, p0 = -1;
        do {
          yield p0 = triangles[e];
          e = e % 3 === 2 ? e - 2 : e + 1;
          if (triangles[e] !== i) return; // bad triangulation
          e = halfedges[e];
          if (e === -1) {
            const p = hull[(_hullIndex[i] + 1) % hull.length];
            if (p !== p0) yield p;
            return;
          }
        } while (e !== e0);
      }
      find(x, y, i = 0) {
        if ((x = +x, x !== x) || (y = +y, y !== y)) return -1;
        const i0 = i;
        let c;
        while ((c = this._step(i, x, y)) >= 0 && c !== i && c !== i0) i = c;
        return c;
      }
      _step(i, x, y) {
        const {inedges, hull, _hullIndex, halfedges, triangles, points} = this;
        if (inedges[i] === -1 || !points.length) return (i + 1) % (points.length >> 1);
        let c = i;
        let dc = pow(x - points[i * 2], 2) + pow(y - points[i * 2 + 1], 2);
        const e0 = inedges[i];
        let e = e0;
        do {
          let t = triangles[e];
          const dt = pow(x - points[t * 2], 2) + pow(y - points[t * 2 + 1], 2);
          if (dt < dc) dc = dt, c = t;
          e = e % 3 === 2 ? e - 2 : e + 1;
          if (triangles[e] !== i) break; // bad triangulation
          e = halfedges[e];
          if (e === -1) {
            e = hull[(_hullIndex[i] + 1) % hull.length];
            if (e !== t) {
              if (pow(x - points[e * 2], 2) + pow(y - points[e * 2 + 1], 2) < dc) return e;
            }
            break;
          }
        } while (e !== e0);
        return c;
      }
      render(context) {
        const buffer = context == null ? context = new Path : undefined;
        const {points, halfedges, triangles} = this;
        for (let i = 0, n = halfedges.length; i < n; ++i) {
          const j = halfedges[i];
          if (j < i) continue;
          const ti = triangles[i] * 2;
          const tj = triangles[j] * 2;
          context.moveTo(points[ti], points[ti + 1]);
          context.lineTo(points[tj], points[tj + 1]);
        }
        this.renderHull(context);
        return buffer && buffer.value();
      }
      renderPoints(context, r) {
        if (r === undefined && (!context || typeof context.moveTo !== "function")) r = context, context = null;
        r = r == undefined ? 2 : +r;
        const buffer = context == null ? context = new Path : undefined;
        const {points} = this;
        for (let i = 0, n = points.length; i < n; i += 2) {
          const x = points[i], y = points[i + 1];
          context.moveTo(x + r, y);
          context.arc(x, y, r, 0, tau);
        }
        return buffer && buffer.value();
      }
      renderHull(context) {
        const buffer = context == null ? context = new Path : undefined;
        const {hull, points} = this;
        const h = hull[0] * 2, n = hull.length;
        context.moveTo(points[h], points[h + 1]);
        for (let i = 1; i < n; ++i) {
          const h = 2 * hull[i];
          context.lineTo(points[h], points[h + 1]);
        }
        context.closePath();
        return buffer && buffer.value();
      }
      hullPolygon() {
        const polygon = new Polygon;
        this.renderHull(polygon);
        return polygon.value();
      }
      renderTriangle(i, context) {
        const buffer = context == null ? context = new Path : undefined;
        const {points, triangles} = this;
        const t0 = triangles[i *= 3] * 2;
        const t1 = triangles[i + 1] * 2;
        const t2 = triangles[i + 2] * 2;
        context.moveTo(points[t0], points[t0 + 1]);
        context.lineTo(points[t1], points[t1 + 1]);
        context.lineTo(points[t2], points[t2 + 1]);
        context.closePath();
        return buffer && buffer.value();
      }
      *trianglePolygons() {
        const {triangles} = this;
        for (let i = 0, n = triangles.length / 3; i < n; ++i) {
          yield this.trianglePolygon(i);
        }
      }
      trianglePolygon(i) {
        const polygon = new Polygon;
        this.renderTriangle(i, polygon);
        return polygon.value();
      }
    }

    function flatArray(points, fx, fy, that) {
      const n = points.length;
      const array = new Float64Array(n * 2);
      for (let i = 0; i < n; ++i) {
        const p = points[i];
        array[i * 2] = fx.call(that, p, i, points);
        array[i * 2 + 1] = fy.call(that, p, i, points);
      }
      return array;
    }

    function* flatIterable(points, fx, fy, that) {
      let i = 0;
      for (const p of points) {
        yield fx.call(that, p, i, points);
        yield fy.call(that, p, i, points);
        ++i;
      }
    }

    const pi = Math.PI;
    const halfPi = pi / 2;

    const degrees = 180 / pi;
    const radians = pi / 180;
    const atan2 = Math.atan2;
    const cos = Math.cos;
    const max$2 = Math.max;
    const min$2 = Math.min;
    const sin = Math.sin;
    const sign$1 =
      Math.sign ||
      function(x) {
        return x > 0 ? 1 : x < 0 ? -1 : 0;
      };
    const sqrt = Math.sqrt;

    function asin(x) {
      return x > 1 ? halfPi : x < -1 ? -halfPi : Math.asin(x);
    }

    function cartesianDot(a, b) {
      return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
    }

    function cartesianCross(a, b) {
      return [
        a[1] * b[2] - a[2] * b[1],
        a[2] * b[0] - a[0] * b[2],
        a[0] * b[1] - a[1] * b[0]
      ];
    }

    function cartesianAdd(a, b) {
      return [a[0] + b[0], a[1] + b[1], a[2] + b[2]];
    }

    function cartesianNormalize(d) {
      var l = sqrt(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);
      return [d[0] / l, d[1] / l, d[2] / l];
    }

    // Converts 3D Cartesian to spherical coordinates (degrees).
    function spherical(cartesian) {
      return [
        atan2(cartesian[1], cartesian[0]) * degrees,
        asin(max$2(-1, min$2(1, cartesian[2]))) * degrees
      ];
    }

    // Converts spherical coordinates (degrees) to 3D Cartesian.
    function cartesian(coordinates) {
      const lambda = coordinates[0] * radians,
        phi = coordinates[1] * radians,
        cosphi = cos(phi);
      return [cosphi * cos(lambda), cosphi * sin(lambda), sin(phi)];
    }

    // Spherical excess of a triangle (in spherical coordinates)
    function excess(triangle) {
      triangle = triangle.map(p => cartesian(p));
      return cartesianDot(triangle[0], cartesianCross(triangle[2], triangle[1]));
    }

    function geoDelaunay(points) {
      const delaunay = geo_delaunay_from(points),
        triangles = geo_triangles(delaunay),
        edges = geo_edges(triangles, points),
        neighbors = geo_neighbors(triangles, points.length),
        find = geo_find(neighbors, points),
        // Voronoi ; could take a center function as an argument
        circumcenters = geo_circumcenters(triangles, points),
        { polygons, centers } = geo_polygons(circumcenters, triangles, points),
        mesh = geo_mesh(polygons),
        hull = geo_hull(triangles, points),
        // Urquhart ; returns a function that takes a distance array as argument.
        urquhart = geo_urquhart(edges, triangles);
      return {
        delaunay,
        edges,
        triangles,
        centers,
        neighbors,
        polygons,
        mesh,
        hull,
        urquhart,
        find
      };
    }

    function geo_find(neighbors, points) {
      function distance2(a,b) {
        let x = a[0] - b[0],
            y = a[1] - b[1],
            z = a[2] - b[2];
        return x * x + y * y + z * z;
      }

      return function find(x, y, next) {
        if (next === undefined) next = 0;
        let cell,
          dist,
          found = next;
        const xyz = cartesian([x, y]);
        do {
          cell = next;
          next = null;
          dist = distance2(xyz, cartesian(points[cell]));
          neighbors[cell].forEach(i => {
            let ndist = distance2(xyz, cartesian(points[i]));
            if (ndist < dist) {
              dist = ndist;
              next = i;
              found = i;
              return;
            }
          });
        } while (next !== null);

        return found;
      };
    }

    function geo_delaunay_from(points) {
      if (points.length < 2) return {};

      // find a valid point to send to infinity
      let pivot = 0;
      while (isNaN(points[pivot][0]+points[pivot][1]) && pivot++ < points.length);

      const r = geoRotation(points[pivot]),
        projection = geoStereographic()
          .translate([0, 0])
          .scale(1)
          .rotate(r.invert([180, 0]));
      points = points.map(projection);

      const zeros = [];
      let max2 = 1;
      for (let i = 0, n = points.length; i < n; i++) {
        let m = points[i][0] ** 2 + points[i][1] ** 2;
        if (!isFinite(m) || m > 1e32) zeros.push(i);
        else if (m > max2) max2 = m;
      }

      const FAR = 1e6 * sqrt(max2);

      zeros.forEach(i => (points[i] = [FAR, 0]));

      // Add infinite horizon points
      points.push([0,FAR]);
      points.push([-FAR,0]);
      points.push([0,-FAR]);

      const delaunay = Delaunay.from(points);

      delaunay.projection = projection;

      // clean up the triangulation
      const {triangles, halfedges, inedges} = delaunay;
      for (let i = 0, l = halfedges.length; i < l; i++) {
        if (halfedges[i] < 0) {
          const j = i % 3 == 2 ? i - 2 : i + 1;
          const k = i % 3 == 0 ? i + 2 : i - 1;
          const a = halfedges[j];
          const b = halfedges[k];
          halfedges[a] = b;
          halfedges[b] = a;
          halfedges[j] = halfedges[k] = -1;
          triangles[i] = triangles[j] = triangles[k] = pivot;
          inedges[triangles[a]] = a % 3 == 0 ? a + 2 : a - 1;
          inedges[triangles[b]] = b % 3 == 0 ? b + 2 : b - 1;
          i += 2 - i % 3;
        } else if (triangles[i] > points.length - 3 - 1) {
          triangles[i] = pivot;
        }
      }
      
      // there should always be 4 degenerate triangles
      // console.warn(degenerate);
      return delaunay;
    }

    function geo_edges(triangles, points) {
      const _index = new Set;
      if (points.length === 2) return [[0, 1]];
      triangles.forEach(tri => {
        if (tri[0] === tri[1]) return;
        if (excess(tri.map(i => points[i])) < 0) return;
        for (let i = 0, j; i < 3; i++) {
          j = (i + 1) % 3;
          _index.add(extent([tri[i], tri[j]]).join("-"));
        }
      });
      return Array.from(_index, d => d.split("-").map(Number));
    }

    function geo_triangles(delaunay) {
      const {triangles} = delaunay;
      if (!triangles) return [];

      const geo_triangles = [];
      for (let i = 0, n = triangles.length / 3; i < n; i++) {
        const a = triangles[3 * i],
          b = triangles[3 * i + 1],
          c = triangles[3 * i + 2];
        if (a !== b && b !== c) {
          geo_triangles.push([a, c, b]);
        }
      }
      return geo_triangles;
    }

    function geo_circumcenters(triangles, points) {
      // if (!use_centroids) {
      return triangles.map(tri => {
        const c = tri.map(i => points[i]).map(cartesian),
          V = cartesianAdd(
            cartesianAdd(cartesianCross(c[1], c[0]), cartesianCross(c[2], c[1])),
            cartesianCross(c[0], c[2])
          );
        return spherical(cartesianNormalize(V));
      });
      /*} else {
        return triangles.map(tri => {
          return d3.geoCentroid({
            type: "MultiPoint",
            coordinates: tri.map(i => points[i])
          });
        });
      }*/
    }

    function geo_neighbors(triangles, npoints) {
      const neighbors = [];
      triangles.forEach(tri => {
        for (let j = 0; j < 3; j++) {
          const a = tri[j],
            b = tri[(j + 1) % 3];
          neighbors[a] = neighbors[a] || [];
          neighbors[a].push(b);
        }
      });

      // degenerate cases
      if (triangles.length === 0) {
        if (npoints === 2) (neighbors[0] = [1]), (neighbors[1] = [0]);
        else if (npoints === 1) neighbors[0] = [];
      }

      return neighbors;
    }

    function geo_polygons(circumcenters, triangles, points) {
      const polygons = [];

      const centers = circumcenters.slice();

      if (triangles.length === 0) {
        if (points.length < 2) return { polygons, centers };
        if (points.length === 2) {
          // two hemispheres
          const a = cartesian(points[0]),
            b = cartesian(points[1]),
            m = cartesianNormalize(cartesianAdd(a, b)),
            d = cartesianNormalize(cartesianCross(a, b)),
            c = cartesianCross(m, d);
          const poly = [
            m,
            cartesianCross(m, c),
            cartesianCross(cartesianCross(m, c), c),
            cartesianCross(cartesianCross(cartesianCross(m, c), c), c)
          ]
            .map(spherical)
            .map(supplement);
          return (
            polygons.push(poly),
            polygons.push(poly.slice().reverse()),
            { polygons, centers }
          );
        }
      }

      triangles.forEach((tri, t) => {
        for (let j = 0; j < 3; j++) {
          const a = tri[j],
            b = tri[(j + 1) % 3],
            c = tri[(j + 2) % 3];
          polygons[a] = polygons[a] || [];
          polygons[a].push([b, c, t, [a, b, c]]);
        }
      });

      // reorder each polygon
      const reordered = polygons.map(poly => {
        const p = [poly[0][2]]; // t
        let k = poly[0][1]; // k = c
        for (let i = 1; i < poly.length; i++) {
          // look for b = k
          for (let j = 0; j < poly.length; j++) {
            if (poly[j][0] == k) {
              k = poly[j][1];
              p.push(poly[j][2]);
              break;
            }
          }
        }

        if (p.length > 2) {
          return p;
        } else if (p.length == 2) {
          const R0 = o_midpoint(
              points[poly[0][3][0]],
              points[poly[0][3][1]],
              centers[p[0]]
            ),
            R1 = o_midpoint(
              points[poly[0][3][2]],
              points[poly[0][3][0]],
              centers[p[0]]
            );
          const i0 = supplement(R0),
            i1 = supplement(R1);
          return [p[0], i1, p[1], i0];
        }
      });

      function supplement(point) {
        let f = -1;
        centers.slice(triangles.length, Infinity).forEach((p, i) => {
          if (p[0] === point[0] && p[1] === point[1]) f = i + triangles.length;
        });
        if (f < 0) (f = centers.length), centers.push(point);
        return f;
      }

      return { polygons: reordered, centers };
    }

    function o_midpoint(a, b, c) {
      a = cartesian(a);
      b = cartesian(b);
      c = cartesian(c);
      const s = sign$1(cartesianDot(cartesianCross(b, a), c));
      return spherical(cartesianNormalize(cartesianAdd(a, b)).map(d => s * d));
    }

    function geo_mesh(polygons) {
      const mesh = [];
      polygons.forEach(poly => {
        if (!poly) return;
        let p = poly[poly.length - 1];
        for (let q of poly) {
          if (q > p) mesh.push([p, q]);
          p = q;
        }
      });
      return mesh;
    }

    function geo_urquhart(edges, triangles) {
      return function(distances) {
        const _lengths = new Map(),
          _urquhart = new Map();
        edges.forEach((edge, i) => {
          const u = edge.join("-");
          _lengths.set(u, distances[i]);
          _urquhart.set(u, true);
        });

        triangles.forEach(tri => {
          let l = 0,
            remove = -1;
          for (let j = 0; j < 3; j++) {
            let u = extent([tri[j], tri[(j + 1) % 3]]).join("-");
            if (_lengths.get(u) > l) {
              l = _lengths.get(u);
              remove = u;
            }
          }
          _urquhart.set(remove,  false);
        });

        return edges.map(edge => _urquhart.get(edge.join("-")));
      };
    }

    function geo_hull(triangles, points) {
      const _hull = new Set(),
        hull = [];
      triangles.map(tri => {
        if (excess(tri.map(i => points[i > points.length ? 0 : i])) > 1e-12) return;
        for (let i = 0; i < 3; i++) {
          let e = [tri[i], tri[(i + 1) % 3]],
            code = `${e[0]}-${e[1]}`;
          if (_hull.has(code)) _hull.delete(code);
          else _hull.add(`${e[1]}-${e[0]}`);
        }
      });

      const _index = new Map;
      let start;
      _hull.forEach(e => {
        e = e.split("-").map(Number);
        _index.set(e[0],e[1]);
        start = e[0];
      });

      if (start === undefined) return hull;

      let next = start;
      do {
        hull.push(next);
        let n = _index.get(next);
        _index.set(next, -1);
        next = n;
      } while (next > -1 && next !== start);

      return hull;
    }

    function geoVoronoi(data) {
      const v = function(data) {
        v.delaunay = null;
        v._data = data;

        if (typeof v._data === "object" && v._data.type === "FeatureCollection") {
          v._data = v._data.features;
        }
        if (typeof v._data === "object") {
          const temp = v._data
            .map(d => [v._vx(d), v._vy(d), d])
            .filter(d => isFinite(d[0] + d[1]));
          v.points = temp.map(d => [d[0], d[1]]);
          v.valid = temp.map(d => d[2]);
          v.delaunay = geoDelaunay(v.points);
        }
        return v;
      };

      v._vx = function(d) {
        if (typeof d == "object" && "type" in d) {
          return geoCentroid(d)[0];
        }
        if (0 in d) return d[0];
      };
      v._vy = function(d) {
        if (typeof d == "object" && "type" in d) {
          return geoCentroid(d)[1];
        }
        if (1 in d) return d[1];
      };

      v.x = function(f) {
        if (!f) return v._vx;
        v._vx = f;
        return v;
      };
      v.y = function(f) {
        if (!f) return v._vy;
        v._vy = f;
        return v;
      };

      v.polygons = function(data) {
        if (data !== undefined) {
          v(data);
        }

        if (!v.delaunay) return false;
        const coll = {
          type: "FeatureCollection",
          features: []
        };
        if (v.valid.length === 0) return coll;
        v.delaunay.polygons.forEach((poly, i) =>
          coll.features.push({
            type: "Feature",
            geometry: !poly
              ? null
              : {
                  type: "Polygon",
                  coordinates: [[...poly, poly[0]].map(i => v.delaunay.centers[i])]
                },
            properties: {
              site: v.valid[i],
              sitecoordinates: v.points[i],
              neighbours: v.delaunay.neighbors[i] // not part of the public API
            }
          })
        );
        if (v.valid.length === 1)
          coll.features.push({
            type: "Feature",
            geometry: { type: "Sphere" },
            properties: {
              site: v.valid[0],
              sitecoordinates: v.points[0],
              neighbours: []
            }
          });
        return coll;
      };

      v.triangles = function(data) {
        if (data !== undefined) {
          v(data);
        }
        if (!v.delaunay) return false;

        return {
          type: "FeatureCollection",
          features: v.delaunay.triangles
            .map((tri, index) => {
              tri = tri.map(i => v.points[i]);
              tri.center = v.delaunay.centers[index];
              return tri;
            })
            .filter(tri => excess(tri) > 0)
            .map(tri => ({
              type: "Feature",
              properties: {
                circumcenter: tri.center
              },
              geometry: {
                type: "Polygon",
                coordinates: [[...tri, tri[0]]]
              }
            }))
        };
      };

      v.links = function(data) {
        if (data !== undefined) {
          v(data);
        }
        if (!v.delaunay) return false;
        const _distances = v.delaunay.edges.map(e =>
            geoDistance(v.points[e[0]], v.points[e[1]])
          ),
          _urquart = v.delaunay.urquhart(_distances);
        return {
          type: "FeatureCollection",
          features: v.delaunay.edges.map((e, i) => ({
            type: "Feature",
            properties: {
              source: v.valid[e[0]],
              target: v.valid[e[1]],
              length: _distances[i],
              urquhart: !!_urquart[i]
            },
            geometry: {
              type: "LineString",
              coordinates: [v.points[e[0]], v.points[e[1]]]
            }
          }))
        };
      };

      v.mesh = function(data) {
        if (data !== undefined) {
          v(data);
        }
        if (!v.delaunay) return false;
        return {
          type: "MultiLineString",
          coordinates: v.delaunay.edges.map(e => [v.points[e[0]], v.points[e[1]]])
        };
      };

      v.cellMesh = function(data) {
        if (data !== undefined) {
          v(data);
        }
        if (!v.delaunay) return false;
        const { centers, polygons } = v.delaunay;
        const coordinates = [];
        for (const p of polygons) {
          if (!p) continue;
          for (
            let n = p.length, p0 = p[n - 1], p1 = p[0], i = 0;
            i < n;
            p0 = p1, p1 = p[++i]
          ) {
            if (p1 > p0) {
              coordinates.push([centers[p0], centers[p1]]);
            }
          }
        }
        return {
          type: "MultiLineString",
          coordinates
        };
      };

      v._found = undefined;
      v.find = function(x, y, radius) {
        v._found = v.delaunay.find(x, y, v._found);
        if (!radius || geoDistance([x, y], v.points[v._found]) < radius)
          return v._found;
      };

      v.hull = function(data) {
        if (data !== undefined) {
          v(data);
        }
        const hull = v.delaunay.hull,
          points = v.points;
        return hull.length === 0
          ? null
          : {
              type: "Polygon",
              coordinates: [[...hull.map(i => points[i]), points[hull[0]]]]
            };
      };

      return data ? v(data) : v;
    }

    function _classCallCheck$1(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties$2(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass$2(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties$2(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties$2(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", {
        writable: false
      });
      return Constructor;
    }
    function _inherits$1(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      Object.defineProperty(subClass, "prototype", {
        writable: false
      });
      if (superClass) _setPrototypeOf$2(subClass, superClass);
    }
    function _getPrototypeOf$2(o) {
      _getPrototypeOf$2 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
      };
      return _getPrototypeOf$2(o);
    }
    function _setPrototypeOf$2(o, p) {
      _setPrototypeOf$2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };
      return _setPrototypeOf$2(o, p);
    }
    function _isNativeReflectConstruct$2() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _assertThisInitialized$2(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _possibleConstructorReturn$1(self, call) {
      if (call && (typeof call === "object" || typeof call === "function")) {
        return call;
      } else if (call !== void 0) {
        throw new TypeError("Derived constructors may only return object or undefined");
      }
      return _assertThisInitialized$2(self);
    }
    function _createSuper$1(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct$2();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf$2(Derived),
          result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf$2(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn$1(this, result);
      };
    }
    function _slicedToArray$2(arr, i) {
      return _arrayWithHoles$2(arr) || _iterableToArrayLimit$2(arr, i) || _unsupportedIterableToArray$3(arr, i) || _nonIterableRest$2();
    }
    function _toConsumableArray$3(arr) {
      return _arrayWithoutHoles$3(arr) || _iterableToArray$3(arr) || _unsupportedIterableToArray$3(arr) || _nonIterableSpread$3();
    }
    function _arrayWithoutHoles$3(arr) {
      if (Array.isArray(arr)) return _arrayLikeToArray$3(arr);
    }
    function _arrayWithHoles$2(arr) {
      if (Array.isArray(arr)) return arr;
    }
    function _iterableToArray$3(iter) {
      if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
    }
    function _iterableToArrayLimit$2(arr, i) {
      var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
      if (_i == null) return;
      var _arr = [];
      var _n = true;
      var _d = false;
      var _s, _e;
      try {
        for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);
          if (i && _arr.length === i) break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"] != null) _i["return"]();
        } finally {
          if (_d) throw _e;
        }
      }
      return _arr;
    }
    function _unsupportedIterableToArray$3(o, minLen) {
      if (!o) return;
      if (typeof o === "string") return _arrayLikeToArray$3(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor) n = o.constructor.name;
      if (n === "Map" || n === "Set") return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$3(o, minLen);
    }
    function _arrayLikeToArray$3(arr, len) {
      if (len == null || len > arr.length) len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
      return arr2;
    }
    function _nonIterableSpread$3() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _nonIterableRest$2() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }

    function geoPolygonTriangulate(polygon) {
      var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        _ref$resolution = _ref.resolution,
        resolution = _ref$resolution === void 0 ? Infinity : _ref$resolution;
      var contour = interpolateContourPoints(polygon, resolution);
      var edgePoints = merge$2(contour);
      var innerPoints = getInnerGeoPoints(polygon, resolution);
      var points = [].concat(_toConsumableArray$3(edgePoints), _toConsumableArray$3(innerPoints));
      var boundariesGeojson = {
        type: 'Polygon',
        coordinates: polygon
      };
      var _geoBounds = geoBounds(boundariesGeojson),
        _geoBounds2 = _slicedToArray$2(_geoBounds, 2),
        _geoBounds2$ = _slicedToArray$2(_geoBounds2[0], 2),
        minLng = _geoBounds2$[0],
        minLat = _geoBounds2$[1],
        _geoBounds2$2 = _slicedToArray$2(_geoBounds2[1], 2),
        maxLng = _geoBounds2$2[0],
        maxLat = _geoBounds2$2[1];
      var crossesPoleOrAntimeridian = minLng > maxLng // crosses antimeridian
      || maxLat >= 89 // crosses north pole
      || minLat <= -89; // crosses south pole

      var indices = [];
      if (crossesPoleOrAntimeridian) {
        // Use d3-geo-voronoi. Slowest, but most accurate for polygons that cross poles or anti-meridian
        var vt = geoVoronoi(points).triangles(); // geoDelaunay generates more triangles than needed
        var pntMap = new Map(points.map(function (_ref2, idx) {
          var _ref3 = _slicedToArray$2(_ref2, 2),
            lng = _ref3[0],
            lat = _ref3[1];
          return ["".concat(lng, "-").concat(lat), idx];
        }));
        vt.features.forEach(function (f) {
          var _indices;
          var triangle = f.geometry.coordinates[0].slice(0, 3).reverse(); // reverse wound to match earcut

          var inds = [];
          triangle.forEach(function (_ref4) {
            var _ref5 = _slicedToArray$2(_ref4, 2),
              lng = _ref5[0],
              lat = _ref5[1];
            var k = "".concat(lng, "-").concat(lat);
            pntMap.has(k) && inds.push(pntMap.get(k));
          });
          if (inds.length !== 3) return; // triangle malfunction

          // exclude edge triangles outside polygon perimeter or through holes
          if (inds.some(function (ind) {
            return ind < edgePoints.length;
          })) {
            var triangleCentroid = f.properties.circumcenter;
            if (!pointInside(triangleCentroid, boundariesGeojson, crossesPoleOrAntimeridian)) return;
          }
          (_indices = indices).push.apply(_indices, inds);
        });
      } else if (!innerPoints.length) {
        // earcut triangulation slightly more performing if it's only using the polygon perimeter
        var _earcut$flatten = earcut_1.flatten(contour),
          vertices = _earcut$flatten.vertices,
          _earcut$flatten$holes = _earcut$flatten.holes,
          holes = _earcut$flatten$holes === void 0 ? [] : _earcut$flatten$holes;
        indices = earcut_1(vertices, holes, 2);
      } else {
        (function () {
          // use delaunator
          var delaunay = Delaunator.from(points);
          var _loop = function _loop(i, len) {
            var _indices2;
            var inds = [2, 1, 0].map(function (idx) {
              return delaunay.triangles[i + idx];
            }); // reverse wound to have same orientation as earcut
            var triangle = inds.map(function (indice) {
              return points[indice];
            });

            // exclude edge triangles outside polygon perimeter or through holes
            if (inds.some(function (ind) {
              return ind < edgePoints.length;
            })) {
              var triangleCentroid = [0, 1].map(function (coordIdx) {
                return mean(triangle, function (p) {
                  return p[coordIdx];
                });
              });
              if (!pointInside(triangleCentroid, boundariesGeojson, crossesPoleOrAntimeridian)) return "continue";
            }
            (_indices2 = indices).push.apply(_indices2, _toConsumableArray$3(inds));
          };
          for (var i = 0, len = delaunay.triangles.length; i < len; i += 3) {
            var _ret = _loop(i);
            if (_ret === "continue") continue;
          }
        })();
      }

      // calc uvs
      var lngUvScale = linear(extent(points, function (d) {
        return d[0];
      }), [0, 1]);
      var latUvScale = linear(extent(points, function (d) {
        return d[1];
      }), [0, 1]);
      var uvs = points.map(function (_ref6) {
        var _ref7 = _slicedToArray$2(_ref6, 2),
          lng = _ref7[0],
          lat = _ref7[1];
        return [lngUvScale(lng), latUvScale(lat)];
      });
      var triangles = {
        points: points,
        indices: indices,
        uvs: uvs
      };
      return {
        contour: contour,
        triangles: triangles
      };
    }
    function interpolateContourPoints(polygon, maxDistance) {
      // add interpolated points for segments that are further apart than the max distance
      return polygon.map(function (coords) {
        var pnts = [];
        var prevPnt;
        coords.forEach(function (pnt) {
          if (prevPnt) {
            var dist = geoDistance(pnt, prevPnt) * 180 / Math.PI;
            if (dist > maxDistance) {
              var interpol = geoInterpolate(prevPnt, pnt);
              var tStep = 1 / Math.ceil(dist / maxDistance);
              var t = tStep;
              while (t < 1) {
                pnts.push(interpol(t));
                t += tStep;
              }
            }
          }
          pnts.push(prevPnt = pnt);
        });
        return pnts;
      });
    }
    function getInnerGeoPoints(polygon, maxDistance) {
      var boundariesGeojson = {
        type: 'Polygon',
        coordinates: polygon
      };
      var _geoBounds3 = geoBounds(boundariesGeojson),
        _geoBounds4 = _slicedToArray$2(_geoBounds3, 2),
        _geoBounds4$ = _slicedToArray$2(_geoBounds4[0], 2),
        minLng = _geoBounds4$[0],
        minLat = _geoBounds4$[1],
        _geoBounds4$2 = _slicedToArray$2(_geoBounds4[1], 2),
        maxLng = _geoBounds4$2[0],
        maxLat = _geoBounds4$2[1];

      // polygon smaller than maxDistance -> no inner points
      if (Math.min(Math.abs(maxLng - minLng), Math.abs(maxLat - minLat)) < maxDistance) return [];
      var crossesPoleOrAntimeridian = minLng > maxLng || maxLat >= 89 || minLat <= -89;
      return getGeoSpiralGrid(maxDistance, {
        minLng: minLng,
        maxLng: maxLng,
        minLat: minLat,
        maxLat: maxLat
      }).filter(function (pnt) {
        return pointInside(pnt, boundariesGeojson, crossesPoleOrAntimeridian);
      });
    }
    function getGeoSpiralGrid(distanceBetweenPoints) {
      var _ref8 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        minLng = _ref8.minLng,
        maxLng = _ref8.maxLng,
        minLat = _ref8.minLat,
        maxLat = _ref8.maxLat;
      var numPoints = Math.round(Math.pow(360 / distanceBetweenPoints, 2) / Math.PI);

      // https://observablehq.com/@mbostock/spherical-fibonacci-lattice
      var phi = (1 + Math.sqrt(5)) / 2; // golden ratio

      var getPntLng = function getPntLng(idx) {
        return idx / phi * 360 % 360 - 180;
      };
      var getPntLat = function getPntLat(idx) {
        return Math.acos(2 * idx / numPoints - 1) / Math.PI * 180 - 90;
      };
      var getPntIdx = function getPntIdx(lat) {
        return numPoints * (Math.cos((lat + 90) * Math.PI / 180) + 1) / 2;
      };
      var pntIdxRange = [maxLat !== undefined ? Math.ceil(getPntIdx(maxLat)) : 0, minLat !== undefined ? Math.floor(getPntIdx(minLat)) : numPoints - 1];
      var isLngInRange = minLng === undefined && maxLng === undefined ? function () {
        return true;
      } : minLng === undefined ? function (lng) {
        return lng <= maxLng;
      } : maxLng === undefined ? function (lng) {
        return lng >= minLng;
      } : maxLng >= minLng ? function (lng) {
        return lng >= minLng && lng <= maxLng;
      } : function (lng) {
        return lng >= minLng || lng <= maxLng;
      }; // for ranges that cross the anti-meridian

      var pnts = [];
      for (var i = pntIdxRange[0]; i <= pntIdxRange[1]; i++) {
        var lng = getPntLng(i);
        isLngInRange(lng) && pnts.push([lng, getPntLat(i)]);
      }
      return pnts;
    }
    function pointInside(pnt, polygon) {
      var crossesPoleOrAntimeridian = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      // turf method is more performing but malfunctions if polygon includes a pole (lat = 90 | -90) or crosses the antimeridian (lng = 180 | -180)
      return crossesPoleOrAntimeridian ? geoContains(polygon, pnt) : booleanPointInPolygon(pnt, polygon);
    }

    var THREE$i = window.THREE ? window.THREE // Prefer consumption from global THREE, if exists
    : {
      BufferGeometry: BufferGeometry,
      Float32BufferAttribute: Float32BufferAttribute
    };

    // support both modes for backwards threejs compatibility
    var setAttributeFn$3 = new THREE$i.BufferGeometry().setAttribute ? 'setAttribute' : 'addAttribute';
    var ConicPolygonBufferGeometry = /*#__PURE__*/function (_THREE$BufferGeometry) {
      _inherits$1(ConicPolygonBufferGeometry, _THREE$BufferGeometry);
      var _super = _createSuper$1(ConicPolygonBufferGeometry);
      function ConicPolygonBufferGeometry(polygonGeoJson, startHeight, endHeight, closedBottom, closedTop, includeSides, curvatureResolution) {
        var _this;
        _classCallCheck$1(this, ConicPolygonBufferGeometry);
        _this = _super.call(this);
        _this.type = 'ConicPolygonBufferGeometry';
        _this.parameters = {
          polygonGeoJson: polygonGeoJson,
          startHeight: startHeight,
          endHeight: endHeight,
          closedBottom: closedBottom,
          closedTop: closedTop,
          includeSides: includeSides,
          curvatureResolution: curvatureResolution
        };

        // defaults
        startHeight = startHeight || 0;
        endHeight = endHeight || 1;
        closedBottom = closedBottom !== undefined ? closedBottom : true;
        closedTop = closedTop !== undefined ? closedTop : true;
        includeSides = includeSides !== undefined ? includeSides : true;
        curvatureResolution = curvatureResolution || 5; // in angular degrees

        // pre-calculate contour, triangulation and UV maps
        var _geoPolygonTriangulat = geoPolygonTriangulate(polygonGeoJson, {
            resolution: curvatureResolution
          }),
          contour = _geoPolygonTriangulat.contour,
          triangles = _geoPolygonTriangulat.triangles;
        var flatUvs = merge$2(triangles.uvs);
        var vertices = [];
        var uvs = [];
        var indices = [];
        var groupCnt = 0; // add groups to apply different materials to torso / caps

        var addGroup = function addGroup(groupData) {
          var prevVertCnt = Math.round(vertices.length / 3);
          var prevIndCnt = indices.length;
          vertices = vertices.concat(groupData.vertices);
          uvs = uvs.concat(groupData.uvs);
          indices = indices.concat(!prevVertCnt ? groupData.indices : groupData.indices.map(function (ind) {
            return ind + prevVertCnt;
          }));
          _this.addGroup(prevIndCnt, indices.length - prevIndCnt, groupCnt++);
        };
        includeSides && addGroup(generateTorso());
        closedBottom && addGroup(generateCap(startHeight, false));
        closedTop && addGroup(generateCap(endHeight, true));

        // build geometry
        _this.setIndex(indices);
        _this[setAttributeFn$3]('position', new THREE$i.Float32BufferAttribute(vertices, 3));
        _this[setAttributeFn$3]('uv', new THREE$i.Float32BufferAttribute(uvs, 2));

        // auto-calculate normals
        _this.computeVertexNormals();

        //

        function generateVertices(polygon, altitude) {
          var coords3d = polygon.map(function (coords) {
            return coords.map(function (_ref) {
              var _ref2 = _slicedToArray$2(_ref, 2),
                lng = _ref2[0],
                lat = _ref2[1];
              return polar2Cartesian$1(lat, lng, altitude);
            });
          });
          // returns { vertices, holes, coordinates }. Each point generates 3 vertice items (x,y,z).
          return earcut_1.flatten(coords3d);
        }
        function generateTorso() {
          var _generateVertices = generateVertices(contour, startHeight),
            bottomVerts = _generateVertices.vertices,
            holes = _generateVertices.holes;
          var _generateVertices2 = generateVertices(contour, endHeight),
            topVerts = _generateVertices2.vertices;
          var vertices = merge$2([topVerts, bottomVerts]);
          var numPoints = Math.round(topVerts.length / 3);
          var holesIdx = new Set(holes);
          var lastHoleIdx = 0;
          var indices = [];
          for (var v0Idx = 0; v0Idx < numPoints; v0Idx++) {
            var v1Idx = v0Idx + 1; // next point
            if (v1Idx === numPoints) {
              v1Idx = lastHoleIdx; // close final loop
            } else if (holesIdx.has(v1Idx)) {
              var holeIdx = v1Idx;
              v1Idx = lastHoleIdx; // close hole loop
              lastHoleIdx = holeIdx;
            }

            // Each pair of coords generates two triangles (faces)
            indices.push(v0Idx, v0Idx + numPoints, v1Idx + numPoints);
            indices.push(v1Idx + numPoints, v1Idx, v0Idx);
          }
          var uvs = []; // wrap texture around perimeter (u), with v=1 on top
          for (var v = 1; v >= 0; v--) {
            for (var i = 0; i < numPoints; i += 1) {
              uvs.push(i / (numPoints - 1), v);
            }
          }
          return {
            indices: indices,
            vertices: vertices,
            uvs: uvs
          };
        }
        function generateCap(radius) {
          var isTop = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
          return {
            // need to reverse-wind the bottom triangles to make them face outwards
            indices: isTop ? triangles.indices : triangles.indices.slice().reverse(),
            vertices: generateVertices([triangles.points], radius).vertices,
            uvs: flatUvs
          };
        }
        return _this;
      }
      return _createClass$2(ConicPolygonBufferGeometry);
    }(THREE$i.BufferGeometry); //
    function polar2Cartesian$1(lat, lng) {
      var r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var phi = (90 - lat) * Math.PI / 180;
      var theta = (90 - lng) * Math.PI / 180;
      return [r * Math.sin(phi) * Math.cos(theta),
      // x
      r * Math.cos(phi),
      // y
      r * Math.sin(phi) * Math.sin(theta) // z
      ];
    }

    // @ts-nocheck
    var libh3 = function (libh3) {
      libh3 = libh3 || {};
      var Module = typeof libh3 !== "undefined" ? libh3 : {};
      var moduleOverrides = {};
      var key;

      for (key in Module) {
        if (Module.hasOwnProperty(key)) {
          moduleOverrides[key] = Module[key];
        }
      }
      var scriptDirectory = "";

      function locateFile(path) {
        if (Module["locateFile"]) {
          return Module["locateFile"](path, scriptDirectory);
        }

        return scriptDirectory + path;
      }

      var readAsync;

      {
        if (document.currentScript) {
          scriptDirectory = document.currentScript.src;
        }

        if (scriptDirectory.indexOf("blob:") !== 0) {
          scriptDirectory = scriptDirectory.substr(0, scriptDirectory.lastIndexOf("/") + 1);
        } else {
          scriptDirectory = "";
        }

        readAsync = function readAsync(url, onload, onerror) {
          var xhr = new XMLHttpRequest();
          xhr.open("GET", url, true);
          xhr.responseType = "arraybuffer";

          xhr.onload = function xhr_onload() {
            if (xhr.status == 200 || xhr.status == 0 && xhr.response) {
              onload(xhr.response);
              return;
            }

            var data = tryParseAsDataURI(url);

            if (data) {
              onload(data.buffer);
              return;
            }

            onerror();
          };

          xhr.onerror = onerror;
          xhr.send(null);
        };
      }

      var out = Module["print"] || console.log.bind(console);
      var err = Module["printErr"] || console.warn.bind(console);

      for (key in moduleOverrides) {
        if (moduleOverrides.hasOwnProperty(key)) {
          Module[key] = moduleOverrides[key];
        }
      }

      moduleOverrides = null;
      if (Module["arguments"]) { Module["arguments"]; }

      var tempRet0 = 0;

      var setTempRet0 = function (value) {
        tempRet0 = value;
      };

      var getTempRet0 = function () {
        return tempRet0;
      };

      var GLOBAL_BASE = 8;

      function setValue(ptr, value, type, noSafe) {
        type = type || "i8";
        if (type.charAt(type.length - 1) === "*") { type = "i32"; }

        switch (type) {
          case "i1":
            HEAP8[ptr >> 0] = value;
            break;

          case "i8":
            HEAP8[ptr >> 0] = value;
            break;

          case "i16":
            HEAP16[ptr >> 1] = value;
            break;

          case "i32":
            HEAP32[ptr >> 2] = value;
            break;

          case "i64":
            tempI64 = [value >>> 0, (tempDouble = value, +Math_abs(tempDouble) >= +1 ? tempDouble > +0 ? (Math_min(+Math_floor(tempDouble / +4294967296), +4294967295) | 0) >>> 0 : ~~+Math_ceil((tempDouble - +(~~tempDouble >>> 0)) / +4294967296) >>> 0 : 0)], HEAP32[ptr >> 2] = tempI64[0], HEAP32[ptr + 4 >> 2] = tempI64[1];
            break;

          case "float":
            HEAPF32[ptr >> 2] = value;
            break;

          case "double":
            HEAPF64[ptr >> 3] = value;
            break;

          default:
            abort("invalid type for setValue: " + type);
        }
      }

      function getValue(ptr, type, noSafe) {
        type = type || "i8";
        if (type.charAt(type.length - 1) === "*") { type = "i32"; }

        switch (type) {
          case "i1":
            return HEAP8[ptr >> 0];

          case "i8":
            return HEAP8[ptr >> 0];

          case "i16":
            return HEAP16[ptr >> 1];

          case "i32":
            return HEAP32[ptr >> 2];

          case "i64":
            return HEAP32[ptr >> 2];

          case "float":
            return HEAPF32[ptr >> 2];

          case "double":
            return HEAPF64[ptr >> 3];

          default:
            abort("invalid type for getValue: " + type);
        }

        return null;
      }

      var ABORT = false;

      function assert(condition, text) {
        if (!condition) {
          abort("Assertion failed: " + text);
        }
      }

      function getCFunc(ident) {
        var func = Module["_" + ident];
        assert(func, "Cannot call unknown function " + ident + ", make sure it is exported");
        return func;
      }

      function ccall(ident, returnType, argTypes, args, opts) {
        var toC = {
          "string": function (str) {
            var ret = 0;

            if (str !== null && str !== undefined && str !== 0) {
              var len = (str.length << 2) + 1;
              ret = stackAlloc(len);
              stringToUTF8(str, ret, len);
            }

            return ret;
          },
          "array": function (arr) {
            var ret = stackAlloc(arr.length);
            writeArrayToMemory(arr, ret);
            return ret;
          }
        };

        function convertReturnValue(ret) {
          if (returnType === "string") { return UTF8ToString(ret); }
          if (returnType === "boolean") { return Boolean(ret); }
          return ret;
        }

        var func = getCFunc(ident);
        var cArgs = [];
        var stack = 0;

        if (args) {
          for (var i = 0; i < args.length; i++) {
            var converter = toC[argTypes[i]];

            if (converter) {
              if (stack === 0) { stack = stackSave(); }
              cArgs[i] = converter(args[i]);
            } else {
              cArgs[i] = args[i];
            }
          }
        }

        var ret = func.apply(null, cArgs);
        ret = convertReturnValue(ret);
        if (stack !== 0) { stackRestore(stack); }
        return ret;
      }

      function cwrap(ident, returnType, argTypes, opts) {
        argTypes = argTypes || [];
        var numericArgs = argTypes.every(function (type) {
          return type === "number";
        });
        var numericRet = returnType !== "string";

        if (numericRet && numericArgs && !opts) {
          return getCFunc(ident);
        }

        return function () {
          return ccall(ident, returnType, argTypes, arguments);
        };
      }
      var UTF8Decoder = typeof TextDecoder !== "undefined" ? new TextDecoder("utf8") : undefined;

      function UTF8ArrayToString(u8Array, idx, maxBytesToRead) {
        var endIdx = idx + maxBytesToRead;
        var endPtr = idx;

        while (u8Array[endPtr] && !(endPtr >= endIdx)) { ++endPtr; }

        if (endPtr - idx > 16 && u8Array.subarray && UTF8Decoder) {
          return UTF8Decoder.decode(u8Array.subarray(idx, endPtr));
        } else {
          var str = "";

          while (idx < endPtr) {
            var u0 = u8Array[idx++];

            if (!(u0 & 128)) {
              str += String.fromCharCode(u0);
              continue;
            }

            var u1 = u8Array[idx++] & 63;

            if ((u0 & 224) == 192) {
              str += String.fromCharCode((u0 & 31) << 6 | u1);
              continue;
            }

            var u2 = u8Array[idx++] & 63;

            if ((u0 & 240) == 224) {
              u0 = (u0 & 15) << 12 | u1 << 6 | u2;
            } else {
              u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | u8Array[idx++] & 63;
            }

            if (u0 < 65536) {
              str += String.fromCharCode(u0);
            } else {
              var ch = u0 - 65536;
              str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);
            }
          }
        }

        return str;
      }

      function UTF8ToString(ptr, maxBytesToRead) {
        return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : "";
      }

      function stringToUTF8Array(str, outU8Array, outIdx, maxBytesToWrite) {
        if (!(maxBytesToWrite > 0)) { return 0; }
        var startIdx = outIdx;
        var endIdx = outIdx + maxBytesToWrite - 1;

        for (var i = 0; i < str.length; ++i) {
          var u = str.charCodeAt(i);

          if (u >= 55296 && u <= 57343) {
            var u1 = str.charCodeAt(++i);
            u = 65536 + ((u & 1023) << 10) | u1 & 1023;
          }

          if (u <= 127) {
            if (outIdx >= endIdx) { break; }
            outU8Array[outIdx++] = u;
          } else if (u <= 2047) {
            if (outIdx + 1 >= endIdx) { break; }
            outU8Array[outIdx++] = 192 | u >> 6;
            outU8Array[outIdx++] = 128 | u & 63;
          } else if (u <= 65535) {
            if (outIdx + 2 >= endIdx) { break; }
            outU8Array[outIdx++] = 224 | u >> 12;
            outU8Array[outIdx++] = 128 | u >> 6 & 63;
            outU8Array[outIdx++] = 128 | u & 63;
          } else {
            if (outIdx + 3 >= endIdx) { break; }
            outU8Array[outIdx++] = 240 | u >> 18;
            outU8Array[outIdx++] = 128 | u >> 12 & 63;
            outU8Array[outIdx++] = 128 | u >> 6 & 63;
            outU8Array[outIdx++] = 128 | u & 63;
          }
        }

        outU8Array[outIdx] = 0;
        return outIdx - startIdx;
      }

      function stringToUTF8(str, outPtr, maxBytesToWrite) {
        return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);
      }

      typeof TextDecoder !== "undefined" ? new TextDecoder("utf-16le") : undefined;

      function writeArrayToMemory(array, buffer) {
        HEAP8.set(array, buffer);
      }

      function alignUp(x, multiple) {
        if (x % multiple > 0) {
          x += multiple - x % multiple;
        }

        return x;
      }

      var buffer, HEAP8, HEAPU8, HEAP16, HEAP32, HEAPF32, HEAPF64;

      function updateGlobalBufferAndViews(buf) {
        buffer = buf;
        Module["HEAP8"] = HEAP8 = new Int8Array(buf);
        Module["HEAP16"] = HEAP16 = new Int16Array(buf);
        Module["HEAP32"] = HEAP32 = new Int32Array(buf);
        Module["HEAPU8"] = HEAPU8 = new Uint8Array(buf);
        Module["HEAPU16"] = new Uint16Array(buf);
        Module["HEAPU32"] = new Uint32Array(buf);
        Module["HEAPF32"] = HEAPF32 = new Float32Array(buf);
        Module["HEAPF64"] = HEAPF64 = new Float64Array(buf);
      }

      var DYNAMIC_BASE = 5266800,
          DYNAMICTOP_PTR = 23888;
      var INITIAL_TOTAL_MEMORY = Module["TOTAL_MEMORY"] || 33554432;

      if (Module["buffer"]) {
        buffer = Module["buffer"];
      } else {
        buffer = new ArrayBuffer(INITIAL_TOTAL_MEMORY);
      }

      INITIAL_TOTAL_MEMORY = buffer.byteLength;
      updateGlobalBufferAndViews(buffer);
      HEAP32[DYNAMICTOP_PTR >> 2] = DYNAMIC_BASE;

      function callRuntimeCallbacks(callbacks) {
        while (callbacks.length > 0) {
          var callback = callbacks.shift();

          if (typeof callback == "function") {
            callback();
            continue;
          }

          var func = callback.func;

          if (typeof func === "number") {
            if (callback.arg === undefined) {
              Module["dynCall_v"](func);
            } else {
              Module["dynCall_vi"](func, callback.arg);
            }
          } else {
            func(callback.arg === undefined ? null : callback.arg);
          }
        }
      }

      var __ATPRERUN__ = [];
      var __ATINIT__ = [];
      var __ATMAIN__ = [];
      var __ATPOSTRUN__ = [];

      function preRun() {
        if (Module["preRun"]) {
          if (typeof Module["preRun"] == "function") { Module["preRun"] = [Module["preRun"]]; }

          while (Module["preRun"].length) {
            addOnPreRun(Module["preRun"].shift());
          }
        }

        callRuntimeCallbacks(__ATPRERUN__);
      }

      function initRuntime() {
        callRuntimeCallbacks(__ATINIT__);
      }

      function preMain() {
        callRuntimeCallbacks(__ATMAIN__);
      }

      function postRun() {
        if (Module["postRun"]) {
          if (typeof Module["postRun"] == "function") { Module["postRun"] = [Module["postRun"]]; }

          while (Module["postRun"].length) {
            addOnPostRun(Module["postRun"].shift());
          }
        }

        callRuntimeCallbacks(__ATPOSTRUN__);
      }

      function addOnPreRun(cb) {
        __ATPRERUN__.unshift(cb);
      }

      function addOnPostRun(cb) {
        __ATPOSTRUN__.unshift(cb);
      }

      var Math_abs = Math.abs;
      var Math_ceil = Math.ceil;
      var Math_floor = Math.floor;
      var Math_min = Math.min;
      var runDependencies = 0;
      var dependenciesFulfilled = null;

      function addRunDependency(id) {
        runDependencies++;

        if (Module["monitorRunDependencies"]) {
          Module["monitorRunDependencies"](runDependencies);
        }
      }

      function removeRunDependency(id) {
        runDependencies--;

        if (Module["monitorRunDependencies"]) {
          Module["monitorRunDependencies"](runDependencies);
        }

        if (runDependencies == 0) {

          if (dependenciesFulfilled) {
            var callback = dependenciesFulfilled;
            dependenciesFulfilled = null;
            callback();
          }
        }
      }

      Module["preloadedImages"] = {};
      Module["preloadedAudios"] = {};
      var memoryInitializer = null;
      var dataURIPrefix = "data:application/octet-stream;base64,";

      function isDataURI(filename) {
        return String.prototype.startsWith ? filename.startsWith(dataURIPrefix) : filename.indexOf(dataURIPrefix) === 0;
      }

      var tempDouble;
      var tempI64;
      memoryInitializer = "data:application/octet-stream;base64,AAAAAAAAAAAAAAAAAQAAAAIAAAADAAAABAAAAAUAAAAGAAAAAQAAAAQAAAADAAAABgAAAAUAAAACAAAAAAAAAAIAAAADAAAAAQAAAAQAAAAGAAAAAAAAAAUAAAADAAAABgAAAAQAAAAFAAAAAAAAAAEAAAACAAAABAAAAAUAAAAGAAAAAAAAAAIAAAADAAAAAQAAAAUAAAACAAAAAAAAAAEAAAADAAAABgAAAAQAAAAGAAAAAAAAAAUAAAACAAAAAQAAAAQAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAEAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAIAAAADAAAAAAAAAAAAAAACAAAAAAAAAAEAAAADAAAAAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAABAAAAAYAAAAAAAAABQAAAAAAAAAAAAAABAAAAAUAAAAAAAAAAAAAAAAAAAACAAAAAAAAAAYAAAAAAAAABgAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAgAAAAMAAAAEAAAABQAAAAYAAAABAAAAAgAAAAMAAAAEAAAABQAAAAYAAAAAAAAAAgAAAAMAAAAEAAAABQAAAAYAAAAAAAAAAQAAAAMAAAAEAAAABQAAAAYAAAAAAAAAAQAAAAIAAAAEAAAABQAAAAYAAAAAAAAAAQAAAAIAAAADAAAABQAAAAYAAAAAAAAAAQAAAAIAAAADAAAABAAAAAYAAAAAAAAAAQAAAAIAAAADAAAABAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAwAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAgAAAAIAAAAAAAAAAAAAAAYAAAAAAAAAAwAAAAIAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAFAAAABAAAAAAAAAABAAAAAAAAAAAAAAAFAAAABQAAAAAAAAAAAAAAAAAAAAYAAAAAAAAABAAAAAAAAAAGAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAFAAAAAgAAAAQAAAADAAAACAAAAAEAAAAHAAAABgAAAAkAAAAAAAAAAwAAAAIAAAACAAAABgAAAAoAAAALAAAAAAAAAAEAAAAFAAAAAwAAAA0AAAABAAAABwAAAAQAAAAMAAAAAAAAAAQAAAB/AAAADwAAAAgAAAADAAAAAAAAAAwAAAAFAAAAAgAAABIAAAAKAAAACAAAAAAAAAAQAAAABgAAAA4AAAALAAAAEQAAAAEAAAAJAAAAAgAAAAcAAAAVAAAACQAAABMAAAADAAAADQAAAAEAAAAIAAAABQAAABYAAAAQAAAABAAAAAAAAAAPAAAACQAAABMAAAAOAAAAFAAAAAEAAAAHAAAABgAAAAoAAAALAAAAGAAAABcAAAAFAAAAAgAAABIAAAALAAAAEQAAABcAAAAZAAAAAgAAAAYAAAAKAAAADAAAABwAAAANAAAAGgAAAAQAAAAPAAAAAwAAAA0AAAAaAAAAFQAAAB0AAAADAAAADAAAAAcAAAAOAAAAfwAAABEAAAAbAAAACQAAABQAAAAGAAAADwAAABYAAAAcAAAAHwAAAAQAAAAIAAAADAAAABAAAAASAAAAIQAAAB4AAAAIAAAABQAAABYAAAARAAAACwAAAA4AAAAGAAAAIwAAABkAAAAbAAAAEgAAABgAAAAeAAAAIAAAAAUAAAAKAAAAEAAAABMAAAAiAAAAFAAAACQAAAAHAAAAFQAAAAkAAAAUAAAADgAAABMAAAAJAAAAKAAAABsAAAAkAAAAFQAAACYAAAATAAAAIgAAAA0AAAAdAAAABwAAABYAAAAQAAAAKQAAACEAAAAPAAAACAAAAB8AAAAXAAAAGAAAAAsAAAAKAAAAJwAAACUAAAAZAAAAGAAAAH8AAAAgAAAAJQAAAAoAAAAXAAAAEgAAABkAAAAXAAAAEQAAAAsAAAAtAAAAJwAAACMAAAAaAAAAKgAAAB0AAAArAAAADAAAABwAAAANAAAAGwAAACgAAAAjAAAALgAAAA4AAAAUAAAAEQAAABwAAAAfAAAAKgAAACwAAAAMAAAADwAAABoAAAAdAAAAKwAAACYAAAAvAAAADQAAABoAAAAVAAAAHgAAACAAAAAwAAAAMgAAABAAAAASAAAAIQAAAB8AAAApAAAALAAAADUAAAAPAAAAFgAAABwAAAAgAAAAHgAAABgAAAASAAAANAAAADIAAAAlAAAAIQAAAB4AAAAxAAAAMAAAABYAAAAQAAAAKQAAACIAAAATAAAAJgAAABUAAAA2AAAAJAAAADMAAAAjAAAALgAAAC0AAAA4AAAAEQAAABsAAAAZAAAAJAAAABQAAAAiAAAAEwAAADcAAAAoAAAANgAAACUAAAAnAAAANAAAADkAAAAYAAAAFwAAACAAAAAmAAAAfwAAACIAAAAzAAAAHQAAAC8AAAAVAAAAJwAAACUAAAAZAAAAFwAAADsAAAA5AAAALQAAACgAAAAbAAAAJAAAABQAAAA8AAAALgAAADcAAAApAAAAMQAAADUAAAA9AAAAFgAAACEAAAAfAAAAKgAAADoAAAArAAAAPgAAABwAAAAsAAAAGgAAACsAAAA+AAAALwAAAEAAAAAaAAAAKgAAAB0AAAAsAAAANQAAADoAAABBAAAAHAAAAB8AAAAqAAAALQAAACcAAAAjAAAAGQAAAD8AAAA7AAAAOAAAAC4AAAA8AAAAOAAAAEQAAAAbAAAAKAAAACMAAAAvAAAAJgAAACsAAAAdAAAARQAAADMAAABAAAAAMAAAADEAAAAeAAAAIQAAAEMAAABCAAAAMgAAADEAAAB/AAAAPQAAAEIAAAAhAAAAMAAAACkAAAAyAAAAMAAAACAAAAAeAAAARgAAAEMAAAA0AAAAMwAAAEUAAAA2AAAARwAAACYAAAAvAAAAIgAAADQAAAA5AAAARgAAAEoAAAAgAAAAJQAAADIAAAA1AAAAPQAAAEEAAABLAAAAHwAAACkAAAAsAAAANgAAAEcAAAA3AAAASQAAACIAAAAzAAAAJAAAADcAAAAoAAAANgAAACQAAABIAAAAPAAAAEkAAAA4AAAARAAAAD8AAABNAAAAIwAAAC4AAAAtAAAAOQAAADsAAABKAAAATgAAACUAAAAnAAAANAAAADoAAAB/AAAAPgAAAEwAAAAsAAAAQQAAACoAAAA7AAAAPwAAAE4AAABPAAAAJwAAAC0AAAA5AAAAPAAAAEgAAABEAAAAUAAAACgAAAA3AAAALgAAAD0AAAA1AAAAMQAAACkAAABRAAAASwAAAEIAAAA+AAAAKwAAADoAAAAqAAAAUgAAAEAAAABMAAAAPwAAAH8AAAA4AAAALQAAAE8AAAA7AAAATQAAAEAAAAAvAAAAPgAAACsAAABUAAAARQAAAFIAAABBAAAAOgAAADUAAAAsAAAAVgAAAEwAAABLAAAAQgAAAEMAAABRAAAAVQAAADEAAAAwAAAAPQAAAEMAAABCAAAAMgAAADAAAABXAAAAVQAAAEYAAABEAAAAOAAAADwAAAAuAAAAWgAAAE0AAABQAAAARQAAADMAAABAAAAALwAAAFkAAABHAAAAVAAAAEYAAABDAAAANAAAADIAAABTAAAAVwAAAEoAAABHAAAAWQAAAEkAAABbAAAAMwAAAEUAAAA2AAAASAAAAH8AAABJAAAANwAAAFAAAAA8AAAAWAAAAEkAAABbAAAASAAAAFgAAAA2AAAARwAAADcAAABKAAAATgAAAFMAAABcAAAANAAAADkAAABGAAAASwAAAEEAAAA9AAAANQAAAF4AAABWAAAAUQAAAEwAAABWAAAAUgAAAGAAAAA6AAAAQQAAAD4AAABNAAAAPwAAAEQAAAA4AAAAXQAAAE8AAABaAAAATgAAAEoAAAA7AAAAOQAAAF8AAABcAAAATwAAAE8AAABOAAAAPwAAADsAAABdAAAAXwAAAE0AAABQAAAARAAAAEgAAAA8AAAAYwAAAFoAAABYAAAAUQAAAFUAAABeAAAAZQAAAD0AAABCAAAASwAAAFIAAABgAAAAVAAAAGIAAAA+AAAATAAAAEAAAABTAAAAfwAAAEoAAABGAAAAZAAAAFcAAABcAAAAVAAAAEUAAABSAAAAQAAAAGEAAABZAAAAYgAAAFUAAABXAAAAZQAAAGYAAABCAAAAQwAAAFEAAABWAAAATAAAAEsAAABBAAAAaAAAAGAAAABeAAAAVwAAAFMAAABmAAAAZAAAAEMAAABGAAAAVQAAAFgAAABIAAAAWwAAAEkAAABjAAAAUAAAAGkAAABZAAAAYQAAAFsAAABnAAAARQAAAFQAAABHAAAAWgAAAE0AAABQAAAARAAAAGoAAABdAAAAYwAAAFsAAABJAAAAWQAAAEcAAABpAAAAWAAAAGcAAABcAAAAUwAAAE4AAABKAAAAbAAAAGQAAABfAAAAXQAAAE8AAABaAAAATQAAAG0AAABfAAAAagAAAF4AAABWAAAAUQAAAEsAAABrAAAAaAAAAGUAAABfAAAAXAAAAE8AAABOAAAAbQAAAGwAAABdAAAAYAAAAGgAAABiAAAAbgAAAEwAAABWAAAAUgAAAGEAAAB/AAAAYgAAAFQAAABnAAAAWQAAAG8AAABiAAAAbgAAAGEAAABvAAAAUgAAAGAAAABUAAAAYwAAAFAAAABpAAAAWAAAAGoAAABaAAAAcQAAAGQAAABmAAAAUwAAAFcAAABsAAAAcgAAAFwAAABlAAAAZgAAAGsAAABwAAAAUQAAAFUAAABeAAAAZgAAAGUAAABXAAAAVQAAAHIAAABwAAAAZAAAAGcAAABbAAAAYQAAAFkAAAB0AAAAaQAAAG8AAABoAAAAawAAAG4AAABzAAAAVgAAAF4AAABgAAAAaQAAAFgAAABnAAAAWwAAAHEAAABjAAAAdAAAAGoAAABdAAAAYwAAAFoAAAB1AAAAbQAAAHEAAABrAAAAfwAAAGUAAABeAAAAcwAAAGgAAABwAAAAbAAAAGQAAABfAAAAXAAAAHYAAAByAAAAbQAAAG0AAABsAAAAXQAAAF8AAAB1AAAAdgAAAGoAAABuAAAAYgAAAGgAAABgAAAAdwAAAG8AAABzAAAAbwAAAGEAAABuAAAAYgAAAHQAAABnAAAAdwAAAHAAAABrAAAAZgAAAGUAAAB4AAAAcwAAAHIAAABxAAAAYwAAAHQAAABpAAAAdQAAAGoAAAB5AAAAcgAAAHAAAABkAAAAZgAAAHYAAAB4AAAAbAAAAHMAAABuAAAAawAAAGgAAAB4AAAAdwAAAHAAAAB0AAAAZwAAAHcAAABvAAAAcQAAAGkAAAB5AAAAdQAAAH8AAABtAAAAdgAAAHEAAAB5AAAAagAAAHYAAAB4AAAAbAAAAHIAAAB1AAAAeQAAAG0AAAB3AAAAbwAAAHMAAABuAAAAeQAAAHQAAAB4AAAAeAAAAHMAAAByAAAAcAAAAHkAAAB3AAAAdgAAAHkAAAB0AAAAeAAAAHcAAAB1AAAAcQAAAHYAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAABAAAABQAAAAEAAAAAAAAAAAAAAAEAAAAAAAAAAQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAACAAAABQAAAAEAAAAAAAAA/////wEAAAAAAAAAAwAAAAQAAAACAAAAAAAAAAAAAAABAAAAAAAAAAEAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAMAAAAFAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAFAAAAAQAAAAAAAAAAAAAAAQAAAAMAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAEAAAADAAAAAAAAAAAAAAABAAAAAAAAAAMAAAADAAAAAwAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAADAAAABQAAAAEAAAAAAAAAAAAAAAEAAAAAAAAAAQAAAAAAAAABAAAAAAAAAP////8DAAAAAAAAAAUAAAACAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAEAAAABQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAMAAAADAAAAAwAAAAMAAAAAAAAAAwAAAAAAAAAAAAAAAAAAAAMAAAAFAAAABQAAAAAAAAAAAAAAAwAAAAMAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAADAAAAAwAAAAAAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAFAAAABQAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAQAAAAAAAAABAAAAAAAAAAMAAAADAAAAAwAAAAAAAAADAAAAAAAAAAAAAAD/////AwAAAAAAAAAFAAAAAgAAAAAAAAAAAAAAAAAAAAAAAAADAAAAAAAAAAAAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAADAAAAAAAAAAAAAAAAAAAAAwAAAAMAAAAAAAAAAAAAAAEAAAAAAAAAAQAAAAAAAAABAAAAAAAAAAAAAAABAAAAAwAAAAAAAAAAAAAAAQAAAAAAAAADAAAAAwAAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAMAAAADAAAAAwAAAAMAAAAAAAAAAwAAAAAAAAAAAAAAAQAAAAMAAAAAAAAAAAAAAAEAAAAAAAAAAwAAAAMAAAADAAAAAwAAAAAAAAADAAAAAAAAAAAAAAADAAAAAAAAAAMAAAAAAAAAAwAAAAAAAAAAAAAAAAAAAAMAAAAAAAAAAAAAAAMAAAAAAAAAAwAAAAAAAAAAAAAAAAAAAAMAAAADAAAAAAAAAP////8DAAAAAAAAAAUAAAACAAAAAAAAAAAAAAADAAAAAAAAAAAAAAADAAAAAwAAAAAAAAAAAAAAAwAAAAAAAAAAAAAAAwAAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAAUAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAFAAAABQAAAAAAAAAAAAAAAwAAAAMAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAwAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAwAAAAAAAAAAAAAAAwAAAAMAAAAAAAAAAAAAAAAAAAADAAAAAAAAAAMAAAAAAAAAAAAAAAMAAAADAAAAAwAAAAAAAAADAAAAAAAAAAAAAAADAAAAAwAAAAMAAAAAAAAAAwAAAAAAAAAAAAAA/////wMAAAAAAAAABQAAAAIAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAAAAAAAAAAAAAwAAAAAAAAADAAAAAAAAAAAAAAAAAAAAAwAAAAMAAAAAAAAAAAAAAAMAAAAAAAAAAwAAAAAAAAADAAAAAAAAAAMAAAADAAAAAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAAAAAAADAAAAAAAAAAMAAAAAAAAAAAAAAAMAAAAAAAAAAAAAAAMAAAADAAAAAAAAAAMAAAADAAAAAwAAAAAAAAAAAAAAAwAAAAAAAAAAAAAAAAAAAAMAAAAAAAAAAwAAAAAAAAAAAAAA/////wMAAAAAAAAABQAAAAIAAAAAAAAAAAAAAAMAAAADAAAAAwAAAAMAAAADAAAAAAAAAAAAAAADAAAAAwAAAAMAAAADAAAAAwAAAAAAAAAAAAAAAwAAAAMAAAADAAAAAwAAAAAAAAADAAAAAAAAAAMAAAADAAAAAwAAAAMAAAAAAAAAAwAAAAAAAAD/////AwAAAAAAAAAFAAAAAgAAAAAAAAAAAAAAAAAAAAAAAAADAAAAAAAAAAAAAAADAAAAAAAAAAMAAAADAAAAAwAAAAAAAAADAAAAAAAAAAAAAAADAAAAAAAAAAAAAAAAAAAAAwAAAAMAAAAAAAAAAwAAAAAAAAAAAAAAAwAAAAMAAAAAAAAAAAAAAAMAAAADAAAAAwAAAAAAAAAAAAAAAAAAAAAAAAADAAAAAAAAAAAAAAADAAAAAwAAAAAAAAAAAAAAAAAAAAMAAAAAAAAAAAAAAAMAAAADAAAAAAAAAAAAAAAAAAAAAwAAAAAAAAADAAAAAAAAAAAAAAD/////AwAAAAAAAAAFAAAAAgAAAAAAAAAAAAAAAwAAAAMAAAADAAAAAAAAAAAAAAADAAAAAAAAAAMAAAADAAAAAwAAAAAAAAAAAAAAAwAAAAAAAAAAAAAAAAAAAAMAAAAAAAAAAAAAAAMAAAAAAAAAAwAAAAAAAAAAAAAAAAAAAAMAAAADAAAAAAAAAAAAAAAAAAAAAwAAAAAAAAAFAAAAAAAAAAAAAAADAAAAAwAAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAADAAAAAQAAAAAAAAABAAAAAAAAAAAAAAABAAAAAwAAAAEAAAAAAAAAAQAAAAAAAAAAAAAAAwAAAAAAAAADAAAAAAAAAAMAAAAAAAAAAAAAAAMAAAAAAAAAAwAAAAAAAAADAAAAAAAAAP////8DAAAAAAAAAAUAAAACAAAAAAAAAAAAAAAAAAAAAwAAAAAAAAAAAAAAAwAAAAMAAAAAAAAAAAAAAAAAAAADAAAAAAAAAAMAAAAAAAAAAAAAAAMAAAAAAAAAAAAAAAMAAAADAAAAAAAAAAAAAAADAAAAAwAAAAMAAAADAAAAAwAAAAAAAAAAAAAAAAAAAAAAAAADAAAAAAAAAAUAAAAAAAAAAAAAAAMAAAADAAAAAwAAAAMAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAwAAAAMAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAAAAAAAFAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAFAAAABQAAAAAAAAAAAAAAAAAAAAMAAAAAAAAAAAAAAAMAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAMAAAAAAAAAAwAAAAAAAAAAAAAA/////wMAAAAAAAAABQAAAAIAAAAAAAAAAAAAAAMAAAADAAAAAwAAAAAAAAAAAAAAAwAAAAAAAAAFAAAAAAAAAAAAAAAFAAAABQAAAAAAAAAAAAAAAAAAAAEAAAADAAAAAQAAAAAAAAABAAAAAAAAAAMAAAADAAAAAwAAAAAAAAAAAAAAAwAAAAAAAAADAAAAAwAAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAADAAAAAQAAAAAAAAABAAAAAAAAAAMAAAADAAAAAwAAAAMAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAEAAAAAAAAAAwAAAAUAAAABAAAAAAAAAP////8DAAAAAAAAAAUAAAACAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAFAAAABQAAAAAAAAAAAAAAAAAAAAEAAAAAAAAABAAAAAUAAAABAAAAAAAAAAMAAAADAAAAAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAADAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAIAAAAFAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAEAAAADAAAAAQAAAAAAAAABAAAAAAAAAAUAAAAAAAAAAAAAAAUAAAAFAAAAAAAAAAAAAAD/////AQAAAAAAAAADAAAABAAAAAIAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAUAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAFAAAAAAAAAAAAAAAFAAAABQAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAQAAAAUAAAABAAAAAAAAAAAAAAABAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAAEAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAAAAAAAAAAAAAEAAAD//////////wEAAAABAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAQAAAAEAAAAAAAAAAAAAAAAAAAADAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAAEAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAsAAAACAAAAAAAAAAAAAAABAAAAAgAAAAYAAAAEAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAYAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAgAAAAAAAAABAAAAAQAAAAAAAAAAAAAAAAAAAAcAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAACAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAYAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAKAAAAAgAAAAAAAAAAAAAAAQAAAAEAAAAFAAAABgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAEAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAABAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAABwAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAsAAAABAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACgAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAACAAAAAAAAAAAAAAABAAAAAwAAAAcAAAAGAAAAAQAAAAAAAAABAAAAAAAAAAAAAAAAAAAABwAAAAEAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAADAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAwAAAAAAAAABAAAAAQAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAGAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAADgAAAAIAAAAAAAAAAAAAAAEAAAAAAAAACQAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACgAAAAEAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAQAAAAEAAAAAAAAAAAAAAAAAAAAMAAAAAQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAABwAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAsAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAKAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADQAAAAIAAAAAAAAAAAAAAAEAAAAEAAAACAAAAAoAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAALAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAACQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAGAAAAAgAAAAAAAAAAAAAAAQAAAAsAAAAPAAAACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAkAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAOAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAEAAAAAAAAAAQAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAQAAAAEAAAAAAAAAAAAAAAAAAAAIAAAAAQAAAAAAAAABAAAAAAAAAAAAAAAAAAAABQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAAAAgAAAAAAAAAAAAAAAQAAAAwAAAAQAAAADAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAoAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAJAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAPAAAAAAAAAAEAAAABAAAAAAAAAAAAAAAAAAAADwAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAADQAAAAEAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAACAAAAAAAAAAAAAAABAAAACgAAABMAAAAIAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAkAAAABAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAEQAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAwAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEQAAAAAAAAABAAAAAQAAAAAAAAAAAAAAAAAAAA8AAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAQAAAAAQAAAAAAAAABAAAAAAAAAAAAAAAAAAAACQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAANAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAAAAIAAAAAAAAAAAAAAAEAAAANAAAAEQAAAA0AAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAARAAAAAQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAEwAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAA4AAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAATAAAAAAAAAAEAAAABAAAAAAAAAAAAAAAAAAAAEQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAA0AAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAARAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAkAAAACAAAAAAAAAAAAAAABAAAADgAAABIAAAAPAAAAAQAAAAAAAAABAAAAAAAAAAAAAAAAAAAADwAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABIAAAAAAAAAAQAAAAEAAAAAAAAAAAAAAAAAAAASAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAEwAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAABEAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAATAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEgAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAABIAAAABAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAATAAAAAgAAAAAAAAAAAAAAAQAAAP//////////EwAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAATAAAAAQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAEgAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAASAAAAAAAAABgAAAAAAAAAIQAAAAAAAAAeAAAAAAAAACAAAAADAAAAMQAAAAEAAAAwAAAAAwAAADIAAAADAAAACAAAAAAAAAAFAAAABQAAAAoAAAAFAAAAFgAAAAAAAAAQAAAAAAAAABIAAAAAAAAAKQAAAAEAAAAhAAAAAAAAAB4AAAAAAAAABAAAAAAAAAAAAAAABQAAAAIAAAAFAAAADwAAAAEAAAAIAAAAAAAAAAUAAAAFAAAAHwAAAAEAAAAWAAAAAAAAABAAAAAAAAAAAgAAAAAAAAAGAAAAAAAAAA4AAAAAAAAACgAAAAAAAAALAAAAAAAAABEAAAADAAAAGAAAAAEAAAAXAAAAAwAAABkAAAADAAAAAAAAAAAAAAABAAAABQAAAAkAAAAFAAAABQAAAAAAAAACAAAAAAAAAAYAAAAAAAAAEgAAAAEAAAAKAAAAAAAAAAsAAAAAAAAABAAAAAEAAAADAAAABQAAAAcAAAAFAAAACAAAAAEAAAAAAAAAAAAAAAEAAAAFAAAAEAAAAAEAAAAFAAAAAAAAAAIAAAAAAAAABwAAAAAAAAAVAAAAAAAAACYAAAAAAAAACQAAAAAAAAATAAAAAAAAACIAAAADAAAADgAAAAEAAAAUAAAAAwAAACQAAAADAAAAAwAAAAAAAAANAAAABQAAAB0AAAAFAAAAAQAAAAAAAAAHAAAAAAAAABUAAAAAAAAABgAAAAEAAAAJAAAAAAAAABMAAAAAAAAABAAAAAIAAAAMAAAABQAAABoAAAAFAAAAAAAAAAEAAAADAAAAAAAAAA0AAAAFAAAAAgAAAAEAAAABAAAAAAAAAAcAAAAAAAAAGgAAAAAAAAAqAAAAAAAAADoAAAAAAAAAHQAAAAAAAAArAAAAAAAAAD4AAAADAAAAJgAAAAEAAAAvAAAAAwAAAEAAAAADAAAADAAAAAAAAAAcAAAABQAAACwAAAAFAAAADQAAAAAAAAAaAAAAAAAAACoAAAAAAAAAFQAAAAEAAAAdAAAAAAAAACsAAAAAAAAABAAAAAMAAAAPAAAABQAAAB8AAAAFAAAAAwAAAAEAAAAMAAAAAAAAABwAAAAFAAAABwAAAAEAAAANAAAAAAAAABoAAAAAAAAAHwAAAAAAAAApAAAAAAAAADEAAAAAAAAALAAAAAAAAAA1AAAAAAAAAD0AAAADAAAAOgAAAAEAAABBAAAAAwAAAEsAAAADAAAADwAAAAAAAAAWAAAABQAAACEAAAAFAAAAHAAAAAAAAAAfAAAAAAAAACkAAAAAAAAAKgAAAAEAAAAsAAAAAAAAADUAAAAAAAAABAAAAAQAAAAIAAAABQAAABAAAAAFAAAADAAAAAEAAAAPAAAAAAAAABYAAAAFAAAAGgAAAAEAAAAcAAAAAAAAAB8AAAAAAAAAMgAAAAAAAAAwAAAAAAAAADEAAAADAAAAIAAAAAAAAAAeAAAAAwAAACEAAAADAAAAGAAAAAMAAAASAAAAAwAAABAAAAADAAAARgAAAAAAAABDAAAAAAAAAEIAAAADAAAANAAAAAMAAAAyAAAAAAAAADAAAAAAAAAAJQAAAAMAAAAgAAAAAAAAAB4AAAADAAAAUwAAAAAAAABXAAAAAwAAAFUAAAADAAAASgAAAAMAAABGAAAAAAAAAEMAAAAAAAAAOQAAAAEAAAA0AAAAAwAAADIAAAAAAAAAGQAAAAAAAAAXAAAAAAAAABgAAAADAAAAEQAAAAAAAAALAAAAAwAAAAoAAAADAAAADgAAAAMAAAAGAAAAAwAAAAIAAAADAAAALQAAAAAAAAAnAAAAAAAAACUAAAADAAAAIwAAAAMAAAAZAAAAAAAAABcAAAAAAAAAGwAAAAMAAAARAAAAAAAAAAsAAAADAAAAPwAAAAAAAAA7AAAAAwAAADkAAAADAAAAOAAAAAMAAAAtAAAAAAAAACcAAAAAAAAALgAAAAMAAAAjAAAAAwAAABkAAAAAAAAAJAAAAAAAAAAUAAAAAAAAAA4AAAADAAAAIgAAAAAAAAATAAAAAwAAAAkAAAADAAAAJgAAAAMAAAAVAAAAAwAAAAcAAAADAAAANwAAAAAAAAAoAAAAAAAAABsAAAADAAAANgAAAAMAAAAkAAAAAAAAABQAAAAAAAAAMwAAAAMAAAAiAAAAAAAAABMAAAADAAAASAAAAAAAAAA8AAAAAwAAAC4AAAADAAAASQAAAAMAAAA3AAAAAAAAACgAAAAAAAAARwAAAAMAAAA2AAAAAwAAACQAAAAAAAAAQAAAAAAAAAAvAAAAAAAAACYAAAADAAAAPgAAAAAAAAArAAAAAwAAAB0AAAADAAAAOgAAAAMAAAAqAAAAAwAAABoAAAADAAAAVAAAAAAAAABFAAAAAAAAADMAAAADAAAAUgAAAAMAAABAAAAAAAAAAC8AAAAAAAAATAAAAAMAAAA+AAAAAAAAACsAAAADAAAAYQAAAAAAAABZAAAAAwAAAEcAAAADAAAAYgAAAAMAAABUAAAAAAAAAEUAAAAAAAAAYAAAAAMAAABSAAAAAwAAAEAAAAAAAAAASwAAAAAAAABBAAAAAAAAADoAAAADAAAAPQAAAAAAAAA1AAAAAwAAACwAAAADAAAAMQAAAAMAAAApAAAAAwAAAB8AAAADAAAAXgAAAAAAAABWAAAAAAAAAEwAAAADAAAAUQAAAAMAAABLAAAAAAAAAEEAAAAAAAAAQgAAAAMAAAA9AAAAAAAAADUAAAADAAAAawAAAAAAAABoAAAAAwAAAGAAAAADAAAAZQAAAAMAAABeAAAAAAAAAFYAAAAAAAAAVQAAAAMAAABRAAAAAwAAAEsAAAAAAAAAOQAAAAAAAAA7AAAAAAAAAD8AAAADAAAASgAAAAAAAABOAAAAAwAAAE8AAAADAAAAUwAAAAMAAABcAAAAAwAAAF8AAAADAAAAJQAAAAAAAAAnAAAAAwAAAC0AAAADAAAANAAAAAAAAAA5AAAAAAAAADsAAAAAAAAARgAAAAMAAABKAAAAAAAAAE4AAAADAAAAGAAAAAAAAAAXAAAAAwAAABkAAAADAAAAIAAAAAMAAAAlAAAAAAAAACcAAAADAAAAMgAAAAMAAAA0AAAAAAAAADkAAAAAAAAALgAAAAAAAAA8AAAAAAAAAEgAAAADAAAAOAAAAAAAAABEAAAAAwAAAFAAAAADAAAAPwAAAAMAAABNAAAAAwAAAFoAAAADAAAAGwAAAAAAAAAoAAAAAwAAADcAAAADAAAAIwAAAAAAAAAuAAAAAAAAADwAAAAAAAAALQAAAAMAAAA4AAAAAAAAAEQAAAADAAAADgAAAAAAAAAUAAAAAwAAACQAAAADAAAAEQAAAAMAAAAbAAAAAAAAACgAAAADAAAAGQAAAAMAAAAjAAAAAAAAAC4AAAAAAAAARwAAAAAAAABZAAAAAAAAAGEAAAADAAAASQAAAAAAAABbAAAAAwAAAGcAAAADAAAASAAAAAMAAABYAAAAAwAAAGkAAAADAAAAMwAAAAAAAABFAAAAAwAAAFQAAAADAAAANgAAAAAAAABHAAAAAAAAAFkAAAAAAAAANwAAAAMAAABJAAAAAAAAAFsAAAADAAAAJgAAAAAAAAAvAAAAAwAAAEAAAAADAAAAIgAAAAMAAAAzAAAAAAAAAEUAAAADAAAAJAAAAAMAAAA2AAAAAAAAAEcAAAAAAAAAYAAAAAAAAABoAAAAAAAAAGsAAAADAAAAYgAAAAAAAABuAAAAAwAAAHMAAAADAAAAYQAAAAMAAABvAAAAAwAAAHcAAAADAAAATAAAAAAAAABWAAAAAwAAAF4AAAADAAAAUgAAAAAAAABgAAAAAAAAAGgAAAAAAAAAVAAAAAMAAABiAAAAAAAAAG4AAAADAAAAOgAAAAAAAABBAAAAAwAAAEsAAAADAAAAPgAAAAMAAABMAAAAAAAAAFYAAAADAAAAQAAAAAMAAABSAAAAAAAAAGAAAAAAAAAAVQAAAAAAAABXAAAAAAAAAFMAAAADAAAAZQAAAAAAAABmAAAAAwAAAGQAAAADAAAAawAAAAMAAABwAAAAAwAAAHIAAAADAAAAQgAAAAAAAABDAAAAAwAAAEYAAAADAAAAUQAAAAAAAABVAAAAAAAAAFcAAAAAAAAAXgAAAAMAAABlAAAAAAAAAGYAAAADAAAAMQAAAAAAAAAwAAAAAwAAADIAAAADAAAAPQAAAAMAAABCAAAAAAAAAEMAAAADAAAASwAAAAMAAABRAAAAAAAAAFUAAAAAAAAAXwAAAAAAAABcAAAAAAAAAFMAAAAAAAAATwAAAAAAAABOAAAAAAAAAEoAAAADAAAAPwAAAAEAAAA7AAAAAwAAADkAAAADAAAAbQAAAAAAAABsAAAAAAAAAGQAAAAFAAAAXQAAAAEAAABfAAAAAAAAAFwAAAAAAAAATQAAAAEAAABPAAAAAAAAAE4AAAAAAAAAdQAAAAQAAAB2AAAABQAAAHIAAAAFAAAAagAAAAEAAABtAAAAAAAAAGwAAAAAAAAAWgAAAAEAAABdAAAAAQAAAF8AAAAAAAAAWgAAAAAAAABNAAAAAAAAAD8AAAAAAAAAUAAAAAAAAABEAAAAAAAAADgAAAADAAAASAAAAAEAAAA8AAAAAwAAAC4AAAADAAAAagAAAAAAAABdAAAAAAAAAE8AAAAFAAAAYwAAAAEAAABaAAAAAAAAAE0AAAAAAAAAWAAAAAEAAABQAAAAAAAAAEQAAAAAAAAAdQAAAAMAAABtAAAABQAAAF8AAAAFAAAAcQAAAAEAAABqAAAAAAAAAF0AAAAAAAAAaQAAAAEAAABjAAAAAQAAAFoAAAAAAAAAaQAAAAAAAABYAAAAAAAAAEgAAAAAAAAAZwAAAAAAAABbAAAAAAAAAEkAAAADAAAAYQAAAAEAAABZAAAAAwAAAEcAAAADAAAAcQAAAAAAAABjAAAAAAAAAFAAAAAFAAAAdAAAAAEAAABpAAAAAAAAAFgAAAAAAAAAbwAAAAEAAABnAAAAAAAAAFsAAAAAAAAAdQAAAAIAAABqAAAABQAAAFoAAAAFAAAAeQAAAAEAAABxAAAAAAAAAGMAAAAAAAAAdwAAAAEAAAB0AAAAAQAAAGkAAAAAAAAAdwAAAAAAAABvAAAAAAAAAGEAAAAAAAAAcwAAAAAAAABuAAAAAAAAAGIAAAADAAAAawAAAAEAAABoAAAAAwAAAGAAAAADAAAAeQAAAAAAAAB0AAAAAAAAAGcAAAAFAAAAeAAAAAEAAAB3AAAAAAAAAG8AAAAAAAAAcAAAAAEAAABzAAAAAAAAAG4AAAAAAAAAdQAAAAEAAABxAAAABQAAAGkAAAAFAAAAdgAAAAEAAAB5AAAAAAAAAHQAAAAAAAAAcgAAAAEAAAB4AAAAAQAAAHcAAAAAAAAAcgAAAAAAAABwAAAAAAAAAGsAAAAAAAAAZAAAAAAAAABmAAAAAAAAAGUAAAADAAAAUwAAAAEAAABXAAAAAwAAAFUAAAADAAAAdgAAAAAAAAB4AAAAAAAAAHMAAAAFAAAAbAAAAAEAAAByAAAAAAAAAHAAAAAAAAAAXAAAAAEAAABkAAAAAAAAAGYAAAAAAAAAdQAAAAAAAAB5AAAABQAAAHcAAAAFAAAAbQAAAAEAAAB2AAAAAAAAAHgAAAAAAAAAXwAAAAEAAABsAAAAAQAAAHIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAEAAAAAAAAAAAAAAAEAAAABAAAAAQAAAAAAAAAAAAAAAQAAAAAAAAABAAAAAQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAGAAAAAgAAAAUAAAABAAAABAAAAAAAAAAAAAAABQAAAAMAAAABAAAABgAAAAQAAAACAAAAAAAAAH6iBfbytuk/Gq6akm/58z/Xrm0Liez0P5doSdOpSwRAWs602ULg8D/dT7Rcbo/1v1N1RQHFNOM/g9Snx7HW3L8HWsP8Q3jfP6VwOLosutk/9rjk1YQcxj+gnmKMsNn6P/HDeuPFY+M/YHwDjqKhB0Ci19/fCVrbP4UxKkDWOP6/pvljWa09tL9wi7wrQXjnv/Z6yLImkM2/3yTlOzY14D+m+WNZrT20PzwKVQnrQwNA9nrIsiaQzT/g40rFrRQFwPa45NWEHMa/kbslHEZq97/xw3rjxWPjv4cLC2SMBci/otff3wla27+rKF5oIAv0P1N1RQHFNOO/iDJPGyWHBUAHWsP8Q3jfvwQf/by16gXAfqIF9vK26b8XrO0Vh0r+v9eubQuJ7PS/BxLrA0ZZ479azrTZQuDwv1MK1EuItPw/yscgV9Z6FkAwHBR2WjQMQJNRzXsQ5vY/GlUHVJYKF0DONuFv2lMNQNCGZ28QJfk/0WUwoIL36D8ggDOMQuATQNqMOeAy/wZAWFYOYM+M2z/LWC4uH3oSQDE+LyTsMgRAkJzhRGWFGEDd4soovCQQQKqk0DJMEP8/rGmNdwOLBUAW2X/9xCbjP4hu3dcqJhNAzuYItRvdB0CgzW3zJW/sPxotm/Y2TxRAQAk9XmdDDEC1Kx9MKgT3P1M+NctcghZAFVqcLlb0C0Bgzd3sB2b2P77mZDPUWhZAFROHJpUGCEDAfma5CxXtPz1DWq/zYxRAmhYY5824F0DOuQKWSbAOQNCMqrvu3fs/L6DR22K2wT9nAAxPBU8RQGiN6mW43AFAZhu25b633D8c1YgmzowSQNM25BRKWARArGS08/lNxD+LFssHwmMRQLC5aNcxBgJABL9HT0WRF0CjCmJmOGEOQHsuaVzMP/s/TWJCaGGwBUCeu1PAPLzjP9nqN9DZOBNAKE4JcydbCkCGtbd1qjPzP8dgm9U8jhVAtPeKTkVwDkCeCLss5l37P401XMPLmBdAFd29VMVQDUBg0yA55h75Pz6odcYLCRdApBM4rBrkAkDyAVWgQxbRP4XDMnK20hFAymLlF7EmzD8GUgo9XBHlP3lbK7T9COc/k+OhPthhy7+YGEpnrOvCPzBFhLs15u4/epbqB6H4uz9IuuLF5svev6lzLKY31es/CaQ0envF5z8ZY0xlUADXv7zaz7HYEuI/CfbK1sn16T8uAQfWwxLWPzKn/YuFN94/5KdbC1AFu793fyCSnlfvPzK2y4doAMY/NRg5t1/X6b/shq4QJaHDP5yNIAKPOeI/vpn7BSE30r/X4YQrO6nrv78Ziv/Thto/DqJ1Y6+y5z9l51NaxFrlv8QlA65HOLS/86dxiEc96z+Hj0+LFjneP6LzBZ8LTc2/DaJ1Y6+y579l51NaxFrlP8QlA65HOLQ/8qdxiEc967+Jj0+LFjnev6LzBZ8LTc0/1qdbC1AFuz93fyCSnlfvvzK2y4doAMa/NRg5t1/X6T/vhq4QJaHDv5yNIAKPOeK/wJn7BSE30j/W4YQrO6nrP78Ziv/Thtq/CaQ0envF578XY0xlUADXP7zaz7HYEuK/CvbK1sn16b8rAQfWwxLWvzKn/YuFN96/zWLlF7EmzL8GUgo9XBHlv3lbK7T9COe/kOOhPthhyz+cGEpnrOvCvzBFhLs15u6/c5bqB6H4u79IuuLF5sveP6lzLKY31eu/AQAAAP////8HAAAA/////zEAAAD/////VwEAAP////9hCQAA/////6dBAAD/////kcsBAP/////3kAwA/////8H2VwAAAAAAAAAAAAAAAAACAAAA/////w4AAAD/////YgAAAP////+uAgAA/////8ISAAD/////ToMAAP////8ilwMA/////+4hGQD/////gu2vAAAAAAAAAAAAAAAAAAAAAAACAAAA//////////8BAAAAAwAAAP//////////////////////////////////////////////////////////////////////////AQAAAAAAAAACAAAA////////////////AwAAAP//////////////////////////////////////////////////////////////////////////AQAAAAAAAAACAAAA////////////////AwAAAP//////////////////////////////////////////////////////////////////////////AQAAAAAAAAACAAAA////////////////AwAAAP//////////////////////////////////////////////////////////AgAAAP//////////AQAAAAAAAAD/////////////////////AwAAAP////////////////////////////////////////////////////8DAAAA/////////////////////wAAAAD/////////////////////AQAAAP///////////////wIAAAD///////////////////////////////8DAAAA/////////////////////wAAAAD///////////////8CAAAAAQAAAP////////////////////////////////////////////////////8DAAAA/////////////////////wAAAAD///////////////8CAAAAAQAAAP////////////////////////////////////////////////////8DAAAA/////////////////////wAAAAD///////////////8CAAAAAQAAAP////////////////////////////////////////////////////8DAAAA/////////////////////wAAAAD///////////////8CAAAAAQAAAP////////////////////////////////////////////////////8BAAAAAgAAAP///////////////wAAAAD/////////////////////AwAAAP////////////////////////////////////////////////////8BAAAAAgAAAP///////////////wAAAAD/////////////////////AwAAAP////////////////////////////////////////////////////8BAAAAAgAAAP///////////////wAAAAD/////////////////////AwAAAP////////////////////////////////////////////////////8BAAAAAgAAAP///////////////wAAAAD/////////////////////AwAAAP///////////////////////////////wIAAAD///////////////8BAAAA/////////////////////wAAAAD/////////////////////AwAAAP////////////////////////////////////////////////////8DAAAA/////////////////////wAAAAABAAAA//////////8CAAAA//////////////////////////////////////////////////////////8DAAAA////////////////AgAAAAAAAAABAAAA//////////////////////////////////////////////////////////////////////////8DAAAA////////////////AgAAAAAAAAABAAAA//////////////////////////////////////////////////////////////////////////8DAAAA////////////////AgAAAAAAAAABAAAA//////////////////////////////////////////////////////////////////////////8DAAAAAQAAAP//////////AgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAACAAAAAAAAAAIAAAABAAAAAQAAAAIAAAACAAAAAAAAAAUAAAAFAAAAAAAAAAIAAAACAAAAAwAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAAAAAAAAgAAAAEAAAACAAAAAgAAAAIAAAAAAAAABQAAAAYAAAAAAAAAAgAAAAIAAAADAAAAAgAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAgAAAAAAAAACAAAAAQAAAAMAAAACAAAAAgAAAAAAAAAFAAAABwAAAAAAAAACAAAAAgAAAAMAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAACAAAAAAAAAAIAAAABAAAABAAAAAIAAAACAAAAAAAAAAUAAAAIAAAAAAAAAAIAAAACAAAAAwAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAAIAAAAAAAAAAgAAAAEAAAAAAAAAAgAAAAIAAAAAAAAABQAAAAkAAAAAAAAAAgAAAAIAAAADAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAKAAAAAgAAAAIAAAAAAAAAAwAAAA4AAAACAAAAAAAAAAIAAAADAAAAAAAAAAAAAAACAAAAAgAAAAMAAAAGAAAAAAAAAAAAAAAAAAAAAAAAAAsAAAACAAAAAgAAAAAAAAADAAAACgAAAAIAAAAAAAAAAgAAAAMAAAABAAAAAAAAAAIAAAACAAAAAwAAAAcAAAAAAAAAAAAAAAAAAAAAAAAADAAAAAIAAAACAAAAAAAAAAMAAAALAAAAAgAAAAAAAAACAAAAAwAAAAIAAAAAAAAAAgAAAAIAAAADAAAACAAAAAAAAAAAAAAAAAAAAAAAAAANAAAAAgAAAAIAAAAAAAAAAwAAAAwAAAACAAAAAAAAAAIAAAADAAAAAwAAAAAAAAACAAAAAgAAAAMAAAAJAAAAAAAAAAAAAAAAAAAAAAAAAA4AAAACAAAAAgAAAAAAAAADAAAADQAAAAIAAAAAAAAAAgAAAAMAAAAEAAAAAAAAAAIAAAACAAAAAwAAAAoAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAIAAAACAAAAAAAAAAMAAAAGAAAAAgAAAAAAAAACAAAAAwAAAA8AAAAAAAAAAgAAAAIAAAADAAAACwAAAAAAAAAAAAAAAAAAAAAAAAAGAAAAAgAAAAIAAAAAAAAAAwAAAAcAAAACAAAAAAAAAAIAAAADAAAAEAAAAAAAAAACAAAAAgAAAAMAAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAcAAAACAAAAAgAAAAAAAAADAAAACAAAAAIAAAAAAAAAAgAAAAMAAAARAAAAAAAAAAIAAAACAAAAAwAAAA0AAAAAAAAAAAAAAAAAAAAAAAAACAAAAAIAAAACAAAAAAAAAAMAAAAJAAAAAgAAAAAAAAACAAAAAwAAABIAAAAAAAAAAgAAAAIAAAADAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAJAAAAAgAAAAIAAAAAAAAAAwAAAAUAAAACAAAAAAAAAAIAAAADAAAAEwAAAAAAAAACAAAAAgAAAAMAAAAPAAAAAAAAAAAAAAAAAAAAAAAAABAAAAACAAAAAAAAAAIAAAABAAAAEwAAAAIAAAACAAAAAAAAAAUAAAAKAAAAAAAAAAIAAAACAAAAAwAAABAAAAAAAAAAAAAAAAAAAAAAAAAAEQAAAAIAAAAAAAAAAgAAAAEAAAAPAAAAAgAAAAIAAAAAAAAABQAAAAsAAAAAAAAAAgAAAAIAAAADAAAAEQAAAAAAAAAAAAAAAAAAAAAAAAASAAAAAgAAAAAAAAACAAAAAQAAABAAAAACAAAAAgAAAAAAAAAFAAAADAAAAAAAAAACAAAAAgAAAAMAAAASAAAAAAAAAAAAAAAAAAAAAAAAABMAAAACAAAAAAAAAAIAAAABAAAAEQAAAAIAAAACAAAAAAAAAAUAAAANAAAAAAAAAAIAAAACAAAAAwAAABMAAAAAAAAAAAAAAAAAAAAAAAAADwAAAAIAAAAAAAAAAgAAAAEAAAASAAAAAgAAAAIAAAAAAAAABQAAAA4AAAAAAAAAAgAAAAIAAAADAAAAAgAAAAEAAAAAAAAAAQAAAAIAAAAAAAAAAAAAAAIAAAABAAAAAAAAAAEAAAACAAAAAQAAAAAAAAACAAAAAAAAAAUAAAAEAAAAAAAAAAEAAAAFAAAAAAAAAAAAAAAFAAAABAAAAAAAAAABAAAABQAAAAQAAAAAAAAABQAAAAAAAAACAAAAAQAAAAAAAAABAAAAAgAAAAAAAAAAAAAAAgAAAAEAAAAAAAAAAQAAAAIAAAABAAAAAAAAAAIAAAACAAAAAAAAAAEAAAAAAAAAAAAAAAUAAAAEAAAAAAAAAAEAAAAFAAAAAAAAAAAAAAAFAAAABAAAAAAAAAABAAAABQAAAAQAAAAAAAAABQAAAAUAAAAAAAAAAQAAAAAAAAAAAAAAOgehWlKfUEEz1zLi+JsiQa2og3wcMfVAWCbHorc0yEDi+Yn/Y6mbQJ11/mfsnG9At6bnG4UQQkBvMCQWKqUUQJVmwwswmOc/3hVgVBL3uj//qqOEOdGOPw/WDN4gnGE/H3ANkCUgND+AA8btKgAHPwTXBqJVSdo+XfRQAqsKrj4fc+zLYbSPQklEmCZHv2FCUP+uDso1NEKYtPhwphUHQptxnyFXYdpB7CddZAMmrkGAt1AxSTqBQUibBVdTsFNBSuX3MV+AJkFocv82SLf5QAqmgj7AY81A23VDSEnLoEDGEJVSeDFzQDYrqvBk70VA8U157pcRGUBWfEF+ZKbsP7KBdLHZTpFAqKYk69AqekDbeGY41MdjQD8AZzHK501A1vcrrjubNkD5LnquvBYhQCbiRRD71QlAqt72EbOH8z8Eu+jL1YbdP4uaox/xUcY/abedg1XfsD+BsUdzJ4KZP5wE9YFySIM/rW1kAKMpbT+rZFthVRhWPy4PKlXIs0A/qMZLlwDnMEHByqEF0I0ZQQYSFD8lUQNBPpY+dFs07UAH8BZImBPWQN9RY0I0sMBA2T7kLfc6qUByFYvfhBKTQMq+0Mis1XxA0XQbeQXMZUBJJ5aEGXpQQP7/SY0a6ThAaMD92b/UIkAs8s8yqXoMQNIegOvCk/U/aOi7NZJP4D8AAAAA/////wAAAAAAAAAAAAAAAAAAAAAAAAAA/////////////////////////////////////wAAAAD/////AAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAA/////wAAAAAAAAAAAQAAAAEAAAAAAAAAAAAAAP////8AAAAABQAAAAAAAAAAAAAAAAAAAAAAAAD/////BQAAAAUAAAAAAAAAAAAAAAAAAAAAAAAA/////wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP////////////////////////////////////8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/////////////////////////////////////AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAABQAAAAEAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/////////////////////////////////////wAAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAEAAAABAAAAAQAAAAAAAAABAAAAAAAAAAUAAAABAAAAAQAAAAAAAAAAAAAAAQAAAAEAAAAAAAAAAQAAAAEAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEAAAAAAAEAAQAAAQEAAAAAAAEAAAABAAAAAQABAAAAAAAAAAAAAAAAAAAAAAcAAAAHAAAAAQAAAAIAAAAEAAAAAwAAAAAAAAAAAAAABwAAAAMAAAABAAAAAgAAAAUAAAAEAAAAAAAAAAAAAAAEAAAABAAAAAAAAAACAAAAAQAAAAMAAAAOAAAABgAAAAsAAAACAAAABwAAAAEAAAAYAAAABQAAAAoAAAABAAAABgAAAAAAAAAmAAAABwAAAAwAAAADAAAACAAAAAIAAAAxAAAACQAAAA4AAAAAAAAABQAAAAQAAAA6AAAACAAAAA0AAAAEAAAACQAAAAMAAAA/AAAACwAAAAYAAAAPAAAACgAAABAAAABIAAAADAAAAAcAAAAQAAAACwAAABEAAABTAAAACgAAAAUAAAATAAAADgAAAA8AAABhAAAADQAAAAgAAAARAAAADAAAABIAAABrAAAADgAAAAkAAAASAAAADQAAABMAAAB1AAAADwAAABMAAAARAAAAEgAAABAAAAAGAAAAAgAAAAMAAAAFAAAABAAAAAAAAAAAAAAAAAAAAAYAAAACAAAAAwAAAAEAAAAFAAAABAAAAAAAAAAAAAAABwAAAAUAAAADAAAABAAAAAEAAAAAAAAAAgAAAAAAAAACAAAAAwAAAAEAAAAFAAAABAAAAAYAAAAAAAAAAAAAAGFkamFjZW50RmFjZURpclt0bXBGaWprLmZhY2VdW2ZpamsuZmFjZV0gPT0gS0kAZmFjZWlqay5jAF9mYWNlSWprUGVudFRvQ2VsbEJvdW5kYXJ5AGFkamFjZW50RmFjZURpcltjZW50ZXJJSksuZmFjZV1bZmFjZTJdID09IEtJAF9mYWNlSWprVG9DZWxsQm91bmRhcnkAcG9seWdvbi0+bmV4dCA9PSBOVUxMAGxpbmtlZEdlby5jAGFkZE5ld0xpbmtlZFBvbHlnb24AbmV4dCAhPSBOVUxMAGxvb3AgIT0gTlVMTABhZGROZXdMaW5rZWRMb29wAHBvbHlnb24tPmZpcnN0ID09IE5VTEwAYWRkTGlua2VkTG9vcABjb29yZCAhPSBOVUxMAGFkZExpbmtlZENvb3JkAGxvb3AtPmZpcnN0ID09IE5VTEwAaW5uZXJMb29wcyAhPSBOVUxMAG5vcm1hbGl6ZU11bHRpUG9seWdvbgBiYm94ZXMgIT0gTlVMTABjYW5kaWRhdGVzICE9IE5VTEwAZmluZFBvbHlnb25Gb3JIb2xlAGNhbmRpZGF0ZUJCb3hlcyAhPSBOVUxMAHJldkRpciAhPSBJTlZBTElEX0RJR0lUAGxvY2FsaWouYwBjZWxsVG9Mb2NhbElqawBiYXNlQ2VsbCAhPSBvcmlnaW5CYXNlQ2VsbAAhKG9yaWdpbk9uUGVudCAmJiBpbmRleE9uUGVudCkAYmFzZUNlbGwgPT0gb3JpZ2luQmFzZUNlbGwAYmFzZUNlbGwgIT0gSU5WQUxJRF9CQVNFX0NFTEwAbG9jYWxJamtUb0NlbGwAIV9pc0Jhc2VDZWxsUGVudGFnb24oYmFzZUNlbGwpAGJhc2VDZWxsUm90YXRpb25zID49IDAAZ3JhcGgtPmJ1Y2tldHMgIT0gTlVMTAB2ZXJ0ZXhHcmFwaC5jAGluaXRWZXJ0ZXhHcmFwaABub2RlICE9IE5VTEwAYWRkVmVydGV4Tm9kZQ==";
      var tempDoublePtr = 23904;

      function demangle(func) {
        return func;
      }

      function demangleAll(text) {
        var regex = /\b__Z[\w\d_]+/g;
        return text.replace(regex, function (x) {
          var y = demangle(x);
          return x === y ? x : y + " [" + x + "]";
        });
      }

      function jsStackTrace() {
        var err = new Error();

        if (!err.stack) {
          try {
            throw new Error(0);
          } catch (e) {
            err = e;
          }

          if (!err.stack) {
            return "(no stack trace available)";
          }
        }

        return err.stack.toString();
      }

      function stackTrace() {
        var js = jsStackTrace();
        if (Module["extraStackTrace"]) { js += "\n" + Module["extraStackTrace"](); }
        return demangleAll(js);
      }

      function ___assert_fail(condition, filename, line, func) {
        abort("Assertion failed: " + UTF8ToString(condition) + ", at: " + [filename ? UTF8ToString(filename) : "unknown filename", line, func ? UTF8ToString(func) : "unknown function"]);
      }

      function _emscripten_get_heap_size() {
        return HEAP8.length;
      }

      function _emscripten_memcpy_big(dest, src, num) {
        HEAPU8.set(HEAPU8.subarray(src, src + num), dest);
      }

      function ___setErrNo(value) {
        if (Module["___errno_location"]) { HEAP32[Module["___errno_location"]() >> 2] = value; }
        return value;
      }

      function abortOnCannotGrowMemory(requestedSize) {
        abort("OOM");
      }

      function emscripten_realloc_buffer(size) {
        try {
          var newBuffer = new ArrayBuffer(size);
          if (newBuffer.byteLength != size) { return; }
          new Int8Array(newBuffer).set(HEAP8);

          _emscripten_replace_memory(newBuffer);

          updateGlobalBufferAndViews(newBuffer);
          return 1;
        } catch (e) {}
      }

      function _emscripten_resize_heap(requestedSize) {
        var oldSize = _emscripten_get_heap_size();

        var PAGE_MULTIPLE = 16777216;
        var LIMIT = 2147483648 - PAGE_MULTIPLE;

        if (requestedSize > LIMIT) {
          return false;
        }

        var MIN_TOTAL_MEMORY = 16777216;
        var newSize = Math.max(oldSize, MIN_TOTAL_MEMORY);

        while (newSize < requestedSize) {
          if (newSize <= 536870912) {
            newSize = alignUp(2 * newSize, PAGE_MULTIPLE);
          } else {
            newSize = Math.min(alignUp((3 * newSize + 2147483648) / 4, PAGE_MULTIPLE), LIMIT);
          }
        }

        var replacement = emscripten_realloc_buffer(newSize);

        if (!replacement) {
          return false;
        }

        return true;
      }

      var decodeBase64 = typeof atob === "function" ? atob : function (input) {
        var keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
        var output = "";
        var chr1, chr2, chr3;
        var enc1, enc2, enc3, enc4;
        var i = 0;
        input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");

        do {
          enc1 = keyStr.indexOf(input.charAt(i++));
          enc2 = keyStr.indexOf(input.charAt(i++));
          enc3 = keyStr.indexOf(input.charAt(i++));
          enc4 = keyStr.indexOf(input.charAt(i++));
          chr1 = enc1 << 2 | enc2 >> 4;
          chr2 = (enc2 & 15) << 4 | enc3 >> 2;
          chr3 = (enc3 & 3) << 6 | enc4;
          output = output + String.fromCharCode(chr1);

          if (enc3 !== 64) {
            output = output + String.fromCharCode(chr2);
          }

          if (enc4 !== 64) {
            output = output + String.fromCharCode(chr3);
          }
        } while (i < input.length);

        return output;
      };

      function intArrayFromBase64(s) {
        try {
          var decoded = decodeBase64(s);
          var bytes = new Uint8Array(decoded.length);

          for (var i = 0; i < decoded.length; ++i) {
            bytes[i] = decoded.charCodeAt(i);
          }

          return bytes;
        } catch (_) {
          throw new Error("Converting base64 string to bytes failed.");
        }
      }

      function tryParseAsDataURI(filename) {
        if (!isDataURI(filename)) {
          return;
        }

        return intArrayFromBase64(filename.slice(dataURIPrefix.length));
      }

      var asmGlobalArg = {
        "Math": Math,
        "Int8Array": Int8Array,
        "Int32Array": Int32Array,
        "Uint8Array": Uint8Array,
        "Float32Array": Float32Array,
        "Float64Array": Float64Array
      };
      var asmLibraryArg = {
        "a": abort,
        "b": setTempRet0,
        "c": getTempRet0,
        "d": ___assert_fail,
        "e": ___setErrNo,
        "f": _emscripten_get_heap_size,
        "g": _emscripten_memcpy_big,
        "h": _emscripten_resize_heap,
        "i": abortOnCannotGrowMemory,
        "j": demangle,
        "k": demangleAll,
        "l": emscripten_realloc_buffer,
        "m": jsStackTrace,
        "n": stackTrace,
        "o": tempDoublePtr,
        "p": DYNAMICTOP_PTR
      }; // EMSCRIPTEN_START_ASM

      var asm =
      /** @suppress {uselessCode} */
      function (global, env, buffer) {
        "almost asm";

        var a = new global.Int8Array(buffer),
            b = new global.Int32Array(buffer);
            new global.Uint8Array(buffer);
            new global.Float32Array(buffer);
            var e = new global.Float64Array(buffer),
            f = env.o | 0,
            g = env.p | 0,
            p = global.Math.floor,
            q = global.Math.abs,
            r = global.Math.sqrt,
            s = global.Math.pow,
            t = global.Math.cos,
            u = global.Math.sin,
            v = global.Math.tan,
            w = global.Math.acos,
            x = global.Math.asin,
            y = global.Math.atan,
            z = global.Math.atan2,
            A = global.Math.ceil,
            B = global.Math.imul,
            C = global.Math.min,
            D = global.Math.clz32,
            F = env.b,
            G = env.c,
            H = env.d,
            I = env.e,
            J = env.f,
            K = env.g,
            L = env.h,
            M = env.i,
            S = 23920;

        function V(newBuffer) {
          a = new Int8Array(newBuffer);
          b = new Int32Array(newBuffer);
          e = new Float64Array(newBuffer);
          buffer = newBuffer;
          return true;
        } // EMSCRIPTEN_START_FUNCS


        function W(a) {
          a = a | 0;
          var b = 0;
          b = S;
          S = S + a | 0;
          S = S + 15 & -16;
          return b | 0;
        }

        function X() {
          return S | 0;
        }

        function Y(a) {
          a = a | 0;
          S = a;
        }

        function Z(a, b) {
          a = a | 0;
          S = a;
        }

        function _(a, c) {
          a = a | 0;
          c = c | 0;
          var d = 0,
              e = 0,
              f = 0;

          if ((a | 0) < 0) {
            c = 2;
            return c | 0;
          }

          if ((a | 0) > 13780509) {
            c = dc(15, c) | 0;
            return c | 0;
          } else {
            d = ((a | 0) < 0) << 31 >> 31;
            f = md(a | 0, d | 0, 3, 0) | 0;
            e = G() | 0;
            d = gd(a | 0, d | 0, 1, 0) | 0;
            d = md(f | 0, e | 0, d | 0, G() | 0) | 0;
            d = gd(d | 0, G() | 0, 1, 0) | 0;
            a = G() | 0;
            b[c >> 2] = d;
            b[c + 4 >> 2] = a;
            c = 0;
            return c | 0;
          }
        }

        function $(a, b, c, d) {
          a = a | 0;
          b = b | 0;
          c = c | 0;
          d = d | 0;
          return aa(a, b, c, d, 0) | 0;
        }

        function aa(a, c, d, e, f) {
          a = a | 0;
          c = c | 0;
          d = d | 0;
          e = e | 0;
          f = f | 0;
          var g = 0,
              h = 0,
              i = 0,
              j = 0,
              k = 0;
          j = S;
          S = S + 16 | 0;
          h = j;

          if (!(ba(a, c, d, e, f) | 0)) {
            e = 0;
            S = j;
            return e | 0;
          }

          do { if ((d | 0) >= 0) {
            if ((d | 0) > 13780509) {
              g = dc(15, h) | 0;
              if (g | 0) { break; }
              i = h;
              h = b[i >> 2] | 0;
              i = b[i + 4 >> 2] | 0;
            } else {
              g = ((d | 0) < 0) << 31 >> 31;
              k = md(d | 0, g | 0, 3, 0) | 0;
              i = G() | 0;
              g = gd(d | 0, g | 0, 1, 0) | 0;
              g = md(k | 0, i | 0, g | 0, G() | 0) | 0;
              g = gd(g | 0, G() | 0, 1, 0) | 0;
              i = G() | 0;
              b[h >> 2] = g;
              b[h + 4 >> 2] = i;
              h = g;
            }

            vd(e | 0, 0, h << 3 | 0) | 0;

            if (f | 0) {
              vd(f | 0, 0, h << 2 | 0) | 0;
              g = ca(a, c, d, e, f, h, i, 0) | 0;
              break;
            }

            g = fd(h, 4) | 0;
            if (!g) { g = 13; }else {
              k = ca(a, c, d, e, g, h, i, 0) | 0;
              ed(g);
              g = k;
            }
          } else { g = 2; } } while (0);

          k = g;
          S = j;
          return k | 0;
        }

        function ba(a, c, d, e, f) {
          a = a | 0;
          c = c | 0;
          d = d | 0;
          e = e | 0;
          f = f | 0;
          var g = 0,
              h = 0,
              i = 0,
              j = 0,
              k = 0,
              l = 0,
              m = 0,
              n = 0,
              o = 0,
              p = 0,
              q = 0;
          q = S;
          S = S + 16 | 0;
          o = q;
          p = q + 8 | 0;
          n = o;
          b[n >> 2] = a;
          b[n + 4 >> 2] = c;

          if ((d | 0) < 0) {
            p = 2;
            S = q;
            return p | 0;
          }

          g = e;
          b[g >> 2] = a;
          b[g + 4 >> 2] = c;
          g = (f | 0) != 0;
          if (g) { b[f >> 2] = 0; }

          if (ub(a, c) | 0) {
            p = 9;
            S = q;
            return p | 0;
          }

          b[p >> 2] = 0;

          a: do { if ((d | 0) >= 1) {
            if (g) {
              l = 1;
              k = 0;
              m = 0;
              n = 1;
              g = a;

              while (1) {
                if (!(k | m)) {
                  g = da(g, c, 4, p, o) | 0;
                  if (g | 0) { break a; }
                  c = o;
                  g = b[c >> 2] | 0;
                  c = b[c + 4 >> 2] | 0;

                  if (ub(g, c) | 0) {
                    g = 9;
                    break a;
                  }
                }

                g = da(g, c, b[22384 + (m << 2) >> 2] | 0, p, o) | 0;
                if (g | 0) { break a; }
                c = o;
                g = b[c >> 2] | 0;
                c = b[c + 4 >> 2] | 0;
                a = e + (l << 3) | 0;
                b[a >> 2] = g;
                b[a + 4 >> 2] = c;
                b[f + (l << 2) >> 2] = n;
                a = k + 1 | 0;
                h = (a | 0) == (n | 0);
                i = m + 1 | 0;
                j = (i | 0) == 6;

                if (ub(g, c) | 0) {
                  g = 9;
                  break a;
                }

                n = n + (j & h & 1) | 0;

                if ((n | 0) > (d | 0)) {
                  g = 0;
                  break;
                } else {
                  l = l + 1 | 0;
                  k = h ? 0 : a;
                  m = h ? j ? 0 : i : m;
                }
              }
            } else {
              l = 1;
              k = 0;
              m = 0;
              n = 1;
              g = a;

              while (1) {
                if (!(k | m)) {
                  g = da(g, c, 4, p, o) | 0;
                  if (g | 0) { break a; }
                  c = o;
                  g = b[c >> 2] | 0;
                  c = b[c + 4 >> 2] | 0;

                  if (ub(g, c) | 0) {
                    g = 9;
                    break a;
                  }
                }

                g = da(g, c, b[22384 + (m << 2) >> 2] | 0, p, o) | 0;
                if (g | 0) { break a; }
                c = o;
                g = b[c >> 2] | 0;
                c = b[c + 4 >> 2] | 0;
                a = e + (l << 3) | 0;
                b[a >> 2] = g;
                b[a + 4 >> 2] = c;
                a = k + 1 | 0;
                h = (a | 0) == (n | 0);
                i = m + 1 | 0;
                j = (i | 0) == 6;

                if (ub(g, c) | 0) {
                  g = 9;
                  break a;
                }

                n = n + (j & h & 1) | 0;

                if ((n | 0) > (d | 0)) {
                  g = 0;
                  break;
                } else {
                  l = l + 1 | 0;
                  k = h ? 0 : a;
                  m = h ? j ? 0 : i : m;
                }
              }
            }
          } else { g = 0; } } while (0);

          p = g;
          S = q;
          return p | 0;
        }

        function ca(a, c, d, e, f, g, h, i) {
          a = a | 0;
          c = c | 0;
          d = d | 0;
          e = e | 0;
          f = f | 0;
          g = g | 0;
          h = h | 0;
          i = i | 0;
          var j = 0,
              k = 0,
              l = 0,
              m = 0,
              n = 0,
              o = 0,
              p = 0,
              q = 0,
              r = 0,
              s = 0;
          q = S;
          S = S + 16 | 0;
          o = q + 8 | 0;
          p = q;
          j = od(a | 0, c | 0, g | 0, h | 0) | 0;
          l = G() | 0;
          m = e + (j << 3) | 0;
          r = m;
          s = b[r >> 2] | 0;
          r = b[r + 4 >> 2] | 0;
          k = (s | 0) == (a | 0) & (r | 0) == (c | 0);
          if (!((s | 0) == 0 & (r | 0) == 0 | k)) { do {
            j = gd(j | 0, l | 0, 1, 0) | 0;
            j = nd(j | 0, G() | 0, g | 0, h | 0) | 0;
            l = G() | 0;
            m = e + (j << 3) | 0;
            s = m;
            r = b[s >> 2] | 0;
            s = b[s + 4 >> 2] | 0;
            k = (r | 0) == (a | 0) & (s | 0) == (c | 0);
          } while (!((r | 0) == 0 & (s | 0) == 0 | k)); }
          j = f + (j << 2) | 0;

          if (k ? (b[j >> 2] | 0) <= (i | 0) : 0) {
            s = 0;
            S = q;
            return s | 0;
          }

          s = m;
          b[s >> 2] = a;
          b[s + 4 >> 2] = c;
          b[j >> 2] = i;

          if ((i | 0) >= (d | 0)) {
            s = 0;
            S = q;
            return s | 0;
          }

          k = i + 1 | 0;
          b[o >> 2] = 0;
          j = da(a, c, 2, o, p) | 0;

          switch (j | 0) {
            case 9:
              {
                n = 9;
                break;
              }

            case 0:
              {
                j = p;
                j = ca(b[j >> 2] | 0, b[j + 4 >> 2] | 0, d, e, f, g, h, k) | 0;
                if (!j) { n = 9; }
                break;
              }

          }

          a: do { if ((n | 0) == 9) {
            b[o >> 2] = 0;
            j = da(a, c, 3, o, p) | 0;

            switch (j | 0) {
              case 9:
                break;

              case 0:
                {
                  j = p;
                  j = ca(b[j >> 2] | 0, b[j + 4 >> 2] | 0, d, e, f, g, h, k) | 0;
                  if (j | 0) { break a; }
                  break;
                }

              default:
                break a;
            }

            b[o >> 2] = 0;
            j = da(a, c, 1, o, p) | 0;

            switch (j | 0) {
              case 9:
                break;

              case 0:
                {
                  j = p;
                  j = ca(b[j >> 2] | 0, b[j + 4 >> 2] | 0, d, e, f, g, h, k) | 0;
                  if (j | 0) { break a; }
                  break;
                }

              default:
                break a;
            }

            b[o >> 2] = 0;
            j = da(a, c, 5, o, p) | 0;

            switch (j | 0) {
              case 9:
                break;

              case 0:
                {
                  j = p;
                  j = ca(b[j >> 2] | 0, b[j + 4 >> 2] | 0, d, e, f, g, h, k) | 0;
                  if (j | 0) { break a; }
                  break;
                }

              default:
                break a;
            }

            b[o >> 2] = 0;
            j = da(a, c, 4, o, p) | 0;

            switch (j | 0) {
              case 9:
                break;

              case 0:
                {
                  j = p;
                  j = ca(b[j >> 2] | 0, b[j + 4 >> 2] | 0, d, e, f, g, h, k) | 0;
                  if (j | 0) { break a; }
                  break;
                }

              default:
                break a;
            }

            b[o >> 2] = 0;
            j = da(a, c, 6, o, p) | 0;

            switch (j | 0) {
              case 9:
                break;

              case 0:
                {
                  j = p;
                  j = ca(b[j >> 2] | 0, b[j + 4 >> 2] | 0, d, e, f, g, h, k) | 0;
                  if (j | 0) { break a; }
                  break;
                }

              default:
                break a;
            }

            s = 0;
            S = q;
            return s | 0;
          } } while (0);

          s = j;
          S = q;
          return s | 0;
        }

        function da(a, c, d, e, f) {
          a = a | 0;
          c = c | 0;
          d = d | 0;
          e = e | 0;
          f = f | 0;
          var g = 0,
              h = 0,
              i = 0,
              j = 0,
              k = 0,
              l = 0,
              m = 0,
              n = 0,
              o = 0,
              p = 0;

          if (d >>> 0 > 6) {
            f = 1;
            return f | 0;
          }

          if ((b[e >> 2] | 0) > 0) {
            g = 0;

            do {
              d = Pa(d) | 0;
              g = g + 1 | 0;
            } while ((g | 0) < (b[e >> 2] | 0));
          }

          m = qd(a | 0, c | 0, 45) | 0;
          G() | 0;
          l = m & 127;

          if (l >>> 0 > 121) {
            f = 5;
            return f | 0;
          }

          j = Cb(a, c) | 0;
          g = qd(a | 0, c | 0, 52) | 0;
          G() | 0;
          g = g & 15;

          a: do { if (!g) { k = 8; }else {
            while (1) {
              h = (15 - g | 0) * 3 | 0;
              i = qd(a | 0, c | 0, h | 0) | 0;
              G() | 0;
              i = i & 7;

              if ((i | 0) == 7) {
                c = 5;
                break;
              }

              p = (Ib(g) | 0) == 0;
              g = g + -1 | 0;
              n = rd(7, 0, h | 0) | 0;
              c = c & ~(G() | 0);
              o = rd(b[(p ? 432 : 16) + (i * 28 | 0) + (d << 2) >> 2] | 0, 0, h | 0) | 0;
              h = G() | 0;
              d = b[(p ? 640 : 224) + (i * 28 | 0) + (d << 2) >> 2] | 0;
              a = o | a & ~n;
              c = h | c;

              if (!d) {
                d = 0;
                break a;
              }

              if (!g) {
                k = 8;
                break a;
              }
            }

            return c | 0;
          } } while (0);

          if ((k | 0) == 8) {
            p = b[848 + (l * 28 | 0) + (d << 2) >> 2] | 0;
            o = rd(p | 0, 0, 45) | 0;
            a = o | a;
            c = G() | 0 | c & -1040385;
            d = b[4272 + (l * 28 | 0) + (d << 2) >> 2] | 0;

            if ((p & 127 | 0) == 127) {
              p = rd(b[848 + (l * 28 | 0) + 20 >> 2] | 0, 0, 45) | 0;
              c = G() | 0 | c & -1040385;
              d = b[4272 + (l * 28 | 0) + 20 >> 2] | 0;
              a = Eb(p | a, c) | 0;
              c = G() | 0;
              b[e >> 2] = (b[e >> 2] | 0) + 1;
            }
          }

          i = qd(a | 0, c | 0, 45) | 0;
          G() | 0;
          i = i & 127;

          b: do { if (!(la(i) | 0)) {
            if ((d | 0) > 0) {
              g = 0;

              do {
                a = Eb(a, c) | 0;
                c = G() | 0;
                g = g + 1 | 0;
              } while ((g | 0) != (d | 0));
            }
          } else {
            c: do { if ((Cb(a, c) | 0) == 1) {
              if ((l | 0) != (i | 0)) { if (ra(i, b[7696 + (l * 28 | 0) >> 2] | 0) | 0) {
                a = Gb(a, c) | 0;
                h = 1;
                c = G() | 0;
                break;
              } else {
                a = Eb(a, c) | 0;
                h = 1;
                c = G() | 0;
                break;
              } }

              switch (j | 0) {
                case 3:
                  {
                    a = Eb(a, c) | 0;
                    c = G() | 0;
                    b[e >> 2] = (b[e >> 2] | 0) + 1;
                    h = 0;
                    break c;
                  }

                case 5:
                  {
                    a = Gb(a, c) | 0;
                    c = G() | 0;
                    b[e >> 2] = (b[e >> 2] | 0) + 5;
                    h = 0;
                    break c;
                  }

                case 0:
                  {
                    p = 9;
                    return p | 0;
                  }

                default:
                  {
                    p = 1;
                    return p | 0;
                  }
              }
            } else { h = 0; } } while (0);

            if ((d | 0) > 0) {
              g = 0;

              do {
                a = Db(a, c) | 0;
                c = G() | 0;
                g = g + 1 | 0;
              } while ((g | 0) != (d | 0));
            }

            if ((l | 0) != (i | 0)) {
              if (!(ma(i) | 0)) {
                if ((h | 0) != 0 | (Cb(a, c) | 0) != 5) { break; }
                b[e >> 2] = (b[e >> 2] | 0) + 1;
                break;
              }

              switch (m & 127) {
                case 8:
                case 118:
                  break b;

              }

              if ((Cb(a, c) | 0) != 3) { b[e >> 2] = (b[e >> 2] | 0) + 1; }
            }
          } } while (0);

          b[e >> 2] = ((b[e >> 2] | 0) + d | 0) % 6 | 0;
          p = f;
          b[p >> 2] = a;
          b[p + 4 >> 2] = c;
          p = 0;
          return p | 0;
        }

        function ea(a, c, d, e) {
          a = a | 0;
          c = c | 0;
          d = d | 0;
          e = e | 0;
          var f = 0,
              g = 0,
              h = 0,
              i = 0,
              j = 0,
              k = 0;
          i = S;
          S = S + 16 | 0;
          g = i;
          h = i + 8 | 0;
          f = (ub(a, c) | 0) == 0;
          f = f ? 1 : 2;

          while (1) {
            b[h >> 2] = 0;
            k = (da(a, c, f, h, g) | 0) == 0;
            j = g;

            if (k & ((b[j >> 2] | 0) == (d | 0) ? (b[j + 4 >> 2] | 0) == (e | 0) : 0)) {
              a = 4;
              break;
            }

            f = f + 1 | 0;

            if (f >>> 0 >= 7) {
              f = 7;
              a = 4;
              break;
            }
          }

          if ((a | 0) == 4) {
            S = i;
            return f | 0;
          }

          return 0;
        }

        function fa(a, c, d, e) {
          a = a | 0;
          c = c | 0;
          d = d | 0;
          e = e | 0;
          var f = 0,
              g = 0,
              h = 0,
              i = 0,
              j = 0,
              k = 0,
              l = 0,
              m = 0,
              n = 0,
              o = 0,
              p = 0;
          p = S;
          S = S + 16 | 0;
          n = p;
          o = p + 8 | 0;
          m = n;
          b[m >> 2] = a;
          b[m + 4 >> 2] = c;

          if (!d) {
            o = e;
            b[o >> 2] = a;
            b[o + 4 >> 2] = c;
            o = 0;
            S = p;
            return o | 0;
          }

          b[o >> 2] = 0;

          a: do { if (!(ub(a, c) | 0)) {
            g = (d | 0) > 0;

            if (g) {
              f = 0;
              m = a;

              do {
                a = da(m, c, 4, o, n) | 0;
                if (a | 0) { break a; }
                c = n;
                m = b[c >> 2] | 0;
                c = b[c + 4 >> 2] | 0;
                f = f + 1 | 0;

                if (ub(m, c) | 0) {
                  a = 9;
                  break a;
                }
              } while ((f | 0) < (d | 0));

              l = e;
              b[l >> 2] = m;
              b[l + 4 >> 2] = c;
              l = d + -1 | 0;

              if (g) {
                k = 0;
                a = 1;

                do {
                  f = 22384 + (k << 2) | 0;

                  if ((k | 0) == 5) {
                    h = b[f >> 2] | 0;
                    g = 0;
                    f = a;

                    while (1) {
                      a = n;
                      a = da(b[a >> 2] | 0, b[a + 4 >> 2] | 0, h, o, n) | 0;
                      if (a | 0) { break a; }

                      if ((g | 0) != (l | 0)) {
                        j = n;
                        i = b[j >> 2] | 0;
                        j = b[j + 4 >> 2] | 0;
                        a = e + (f << 3) | 0;
                        b[a >> 2] = i;
                        b[a + 4 >> 2] = j;
                        if (!(ub(i, j) | 0)) { a = f + 1 | 0; }else {
                          a = 9;
                          break a;
                        }
                      } else { a = f; }

                      g = g + 1 | 0;
                      if ((g | 0) >= (d | 0)) { break; }else { f = a; }
                    }
                  } else {
                    h = n;
                    j = b[f >> 2] | 0;
                    i = 0;
                    f = a;
                    g = b[h >> 2] | 0;
                    h = b[h + 4 >> 2] | 0;

                    while (1) {
                      a = da(g, h, j, o, n) | 0;
                      if (a | 0) { break a; }
                      h = n;
                      g = b[h >> 2] | 0;
                      h = b[h + 4 >> 2] | 0;
                      a = e + (f << 3) | 0;
                      b[a >> 2] = g;
                      b[a + 4 >> 2] = h;
                      a = f + 1 | 0;

                      if (ub(g, h) | 0) {
                        a = 9;
                        break a;
                      }

                      i = i + 1 | 0;
                      if ((i | 0) >= (d | 0)) { break; }else { f = a; }
                    }
                  }

                  k = k + 1 | 0;
                } while (k >>> 0 < 6);

                a = n;
                h = m;
                f = b[a >> 2] | 0;
                g = c;
                a = b[a + 4 >> 2] | 0;
              } else {
                h = m;
                f = m;
                g = c;
                a = c;
              }
            } else {
              h = e;
              b[h >> 2] = a;
              b[h + 4 >> 2] = c;
              h = a;
              f = a;
              g = c;
              a = c;
            }

            a = (h | 0) == (f | 0) & (g | 0) == (a | 0) ? 0 : 9;
          } else { a = 9; } } while (0);

          o = a;
          S = p;
          return o | 0;
        }

        function ga(a, c, d, e) {
          a = a | 0;
          c = c | 0;
          d = d | 0;
          e = e | 0;
          var f = 0,
              g = 0,
              h = 0,
              i = 0,
              j = 0,
              k = 0;
          i = S;
          S = S + 48 | 0;
          f = i + 16 | 0;
          g = i + 8 | 0;
          h = i;

          if (d | 0) {
            h = 15;
            S = i;
            return h | 0;
          }

          k = a;
          j = b[k + 4 >> 2] | 0;
          d = g;
          b[d >> 2] = b[k >> 2];
          b[d + 4 >> 2] = j;
          zc(g, f);
          c = ya(f, c, h) | 0;

          if (!c) {
            d = b[g >> 2] | 0;
            g = b[a + 8 >> 2] | 0;

            if ((g | 0) > 0) {
              f = b[a + 12 >> 2] | 0;
              c = 0;

              do {
                d = (b[f + (c << 3) >> 2] | 0) + d | 0;
                c = c + 1 | 0;
              } while ((c | 0) < (g | 0));
            }

            c = h;
            f = b[c >> 2] | 0;
            c = b[c + 4 >> 2] | 0;
            g = ((d | 0) < 0) << 31 >> 31;

            if ((c | 0) < (g | 0) | (c | 0) == (g | 0) & f >>> 0 < d >>> 0) {
              c = h;
              b[c >> 2] = d;
              b[c + 4 >> 2] = g;
              c = g;
            } else { d = f; }

            j = gd(d | 0, c | 0, 12, 0) | 0;
            k = G() | 0;
            c = h;
            b[c >> 2] = j;
            b[c + 4 >> 2] = k;
            c = e;
            b[c >> 2] = j;
            b[c + 4 >> 2] = k;
            c = 0;
          }

          k = c;
          S = i;
          return k | 0;
        }

        function ha(a, c, d, f, g, h, i) {
          a = a | 0;
          c = c | 0;
          d = d | 0;
          f = f | 0;
          g = g | 0;
          h = h | 0;
          i = i | 0;
          var j = 0,
              k = 0,
              l = 0,
              m = 0,
              n = 0,
              o = 0,
              p = 0,
              q = 0,
              r = 0,
              s = 0,
              t = 0,
              u = 0,
              v = 0,
              w = 0,
              x = 0,
              y = 0,
              z = 0,
              A = 0,
              B = 0,
              C = 0,
              D = 0,
              E = 0,
              F = 0,
              H = 0,
              I = 0,
              J = 0.0,
              K = 0.0,
              L = 0.0,
              M = 0.0;
          I = S;
          S = S + 64 | 0;
          D = I + 48 | 0;
          E = I + 32 | 0;
          F = I + 24 | 0;
          x = I + 8 | 0;
          y = I;
          k = b[a >> 2] | 0;

          if ((k | 0) <= 0) {
            H = 0;
            S = I;
            return H | 0;
          }

          z = a + 4 | 0;
          A = D + 8 | 0;
          B = E + 8 | 0;
          C = x + 8 | 0;
          j = 0;
          v = 0;

          while (1) {
            l = b[z >> 2] | 0;
            u = l + (v << 4) | 0;
            b[D >> 2] = b[u >> 2];
            b[D + 4 >> 2] = b[u + 4 >> 2];
            b[D + 8 >> 2] = b[u + 8 >> 2];
            b[D + 12 >> 2] = b[u + 12 >> 2];

            if ((v | 0) == (k + -1 | 0)) {
              b[E >> 2] = b[l >> 2];
              b[E + 4 >> 2] = b[l + 4 >> 2];
              b[E + 8 >> 2] = b[l + 8 >> 2];
              b[E + 12 >> 2] = b[l + 12 >> 2];
            } else {
              u = l + (v + 1 << 4) | 0;
              b[E >> 2] = b[u >> 2];
              b[E + 4 >> 2] = b[u + 4 >> 2];
              b[E + 8 >> 2] = b[u + 8 >> 2];
              b[E + 12 >> 2] = b[u + 12 >> 2];
            }

            k = za(D, E, f, F) | 0;

            a: do { if (!k) {
              l = F;
              k = b[l >> 2] | 0;
              l = b[l + 4 >> 2] | 0;

              if ((l | 0) > 0 | (l | 0) == 0 & k >>> 0 > 0) {
                t = 0;
                u = 0;

                b: while (1) {
                  M = +e[D >> 3];
                  s = hd(k | 0, l | 0, t | 0, u | 0) | 0;
                  L = +(s >>> 0) + 4294967296.0 * +(G() | 0);
                  J = +(k >>> 0) + 4294967296.0 * +(l | 0);
                  K = +(t >>> 0) + 4294967296.0 * +(u | 0);
                  e[x >> 3] = M * L / J + +e[E >> 3] * K / J;
                  e[C >> 3] = +e[A >> 3] * L / J + +e[B >> 3] * K / J;
                  k = Jb(x, f, y) | 0;

                  if (k | 0) {
                    j = k;
                    break;
                  }

                  s = y;
                  r = b[s >> 2] | 0;
                  s = b[s + 4 >> 2] | 0;
                  o = od(r | 0, s | 0, c | 0, d | 0) | 0;
                  m = G() | 0;
                  k = i + (o << 3) | 0;
                  n = k;
                  l = b[n >> 2] | 0;
                  n = b[n + 4 >> 2] | 0;

                  c: do { if ((l | 0) == 0 & (n | 0) == 0) {
                    w = k;
                    H = 16;
                  } else {
                    p = 0;
                    q = 0;

                    while (1) {
                      if ((p | 0) > (d | 0) | (p | 0) == (d | 0) & q >>> 0 > c >>> 0) {
                        j = 1;
                        break b;
                      }

                      if ((l | 0) == (r | 0) & (n | 0) == (s | 0)) { break c; }
                      k = gd(o | 0, m | 0, 1, 0) | 0;
                      o = nd(k | 0, G() | 0, c | 0, d | 0) | 0;
                      m = G() | 0;
                      q = gd(q | 0, p | 0, 1, 0) | 0;
                      p = G() | 0;
                      k = i + (o << 3) | 0;
                      n = k;
                      l = b[n >> 2] | 0;
                      n = b[n + 4 >> 2] | 0;

                      if ((l | 0) == 0 & (n | 0) == 0) {
                        w = k;
                        H = 16;
                        break;
                      }
                    }
                  } } while (0);

                  if ((H | 0) == 16 ? (H = 0, !((r | 0) == 0 & (s | 0) == 0)) : 0) {
                    q = w;
                    b[q >> 2] = r;
                    b[q + 4 >> 2] = s;
                    q = h + (b[g >> 2] << 3) | 0;
                    b[q >> 2] = r;
                    b[q + 4 >> 2] = s;
                    q = g;
                    q = gd(b[q >> 2] | 0, b[q + 4 >> 2] | 0, 1, 0) | 0;
                    r = G() | 0;
                    s = g;
                    b[s >> 2] = q;
                    b[s + 4 >> 2] = r;
                  }

                  t = gd(t | 0, u | 0, 1, 0) | 0;
                  u = G() | 0;
                  l = F;
                  k = b[l >> 2] | 0;
                  l = b[l + 4 >> 2] | 0;

                  if (!((l | 0) > (u | 0) | (l | 0) == (u | 0) & k >>> 0 > t >>> 0)) {
                    l = 1;
                    break a;
                  }
                }

                l = 0;
              } else { l = 1; }
            } else {
              l = 0;
              j = k;
            } } while (0);

            v = v + 1 | 0;

            if (!l) {
              H = 21;
              break;
            }

            k = b[a >> 2] | 0;

            if ((v | 0) >= (k | 0)) {
              j = 0;
              H = 21;
              break;
            }
          }

          if ((H | 0) == 21) {
            S = I;
            return j | 0;
          }

          return 0;
        }

        function ia(a, c, d, e) {
          a = a | 0;
          c = c | 0;
          d = d | 0;
          e = e | 0;
          var f = 0,
              g = 0,
              h = 0,
              i = 0,
              j = 0,
              k = 0,
              l = 0,
              m = 0,
              n = 0,
              o = 0,
              p = 0,
              q = 0,
              r = 0,
              s = 0,
              t = 0,
              u = 0,
              v = 0,
              w = 0,
              x = 0,
              y = 0,
              z = 0,
              A = 0,
              B = 0,
              C = 0,
              D = 0,
              E = 0,
              F = 0,
              H = 0,
              I = 0,
              J = 0,
              K = 0;
          K = S;
          S = S + 112 | 0;
          F = K + 80 | 0;
          j = K + 72 | 0;
          H = K;
          I = K + 56 | 0;

          if (d | 0) {
            J = 15;
            S = K;
            return J | 0;
          }

          k = a + 8 | 0;
          J = dd((b[k >> 2] << 5) + 32 | 0) | 0;

          if (!J) {
            J = 13;
            S = K;
            return J | 0;
          }

          Ac(a, J);
          D = a;
          E = b[D + 4 >> 2] | 0;
          d = j;
          b[d >> 2] = b[D >> 2];
          b[d + 4 >> 2] = E;
          zc(j, F);
          d = ya(F, c, H) | 0;

          if (!d) {
            d = b[j >> 2] | 0;
            g = b[k >> 2] | 0;

            if ((g | 0) > 0) {
              h = b[a + 12 >> 2] | 0;
              f = 0;

              do {
                d = (b[h + (f << 3) >> 2] | 0) + d | 0;
                f = f + 1 | 0;
              } while ((f | 0) != (g | 0));

              f = d;
            } else { f = d; }

            d = H;
            g = b[d >> 2] | 0;
            d = b[d + 4 >> 2] | 0;
            h = ((f | 0) < 0) << 31 >> 31;

            if ((d | 0) < (h | 0) | (d | 0) == (h | 0) & g >>> 0 < f >>> 0) {
              d = H;
              b[d >> 2] = f;
              b[d + 4 >> 2] = h;
              d = h;
            } else { f = g; }

            D = gd(f | 0, d | 0, 12, 0) | 0;
            E = G() | 0;
            d = H;
            b[d >> 2] = D;
            b[d + 4 >> 2] = E;
            d = 0;
          } else {
            D = 0;
            E = 0;
          }

          if (d | 0) {
            ed(J);
            J = d;
            S = K;
            return J | 0;
          }

          f = fd(D, 8) | 0;

          if (!f) {
            ed(J);
            J = 13;
            S = K;
            return J | 0;
          }

          i = fd(D, 8) | 0;

          if (!i) {
            ed(J);
            ed(f);
            J = 13;
            S = K;
            return J | 0;
          }

          B = F;
          b[B >> 2] = 0;
          b[B + 4 >> 2] = 0;
          B = a;
          C = b[B + 4 >> 2] | 0;
          d = j;
          b[d >> 2] = b[B >> 2];
          b[d + 4 >> 2] = C;
          d = ha(j, D, E, c, F, f, i) | 0;

          a: do { if (!d) {
            b: do { if ((b[k >> 2] | 0) > 0) {
              h = a + 12 | 0;
              g = 0;

              while (1) {
                d = ha((b[h >> 2] | 0) + (g << 3) | 0, D, E, c, F, f, i) | 0;
                g = g + 1 | 0;
                if (d | 0) { break; }
                if ((g | 0) >= (b[k >> 2] | 0)) { break b; }
              }

              ed(f);
              ed(i);
              ed(J);
              break a;
            } } while (0);

            if ((E | 0) > 0 | (E | 0) == 0 & D >>> 0 > 0) { vd(i | 0, 0, D << 3 | 0) | 0; }
            C = F;
            B = b[C + 4 >> 2] | 0;

            c: do { if ((B | 0) > 0 | (B | 0) == 0 & (b[C >> 2] | 0) >>> 0 > 0) {
              y = f;
              z = i;
              A = f;
              B = i;
              C = f;
              d = f;
              v = f;
              w = i;
              x = i;
              f = i;

              d: while (1) {
                r = 0;
                s = 0;
                t = 0;
                u = 0;
                g = 0;
                h = 0;

                while (1) {
                  i = H;
                  j = i + 56 | 0;

                  do {
                    b[i >> 2] = 0;
                    i = i + 4 | 0;
                  } while ((i | 0) < (j | 0));

                  c = y + (r << 3) | 0;
                  k = b[c >> 2] | 0;
                  c = b[c + 4 >> 2] | 0;

                  if (ba(k, c, 1, H, 0) | 0) {
                    i = H;
                    j = i + 56 | 0;

                    do {
                      b[i >> 2] = 0;
                      i = i + 4 | 0;
                    } while ((i | 0) < (j | 0));

                    i = fd(7, 4) | 0;

                    if (i | 0) {
                      ca(k, c, 1, H, i, 7, 0, 0) | 0;
                      ed(i);
                    }
                  }

                  q = 0;

                  while (1) {
                    p = H + (q << 3) | 0;
                    o = b[p >> 2] | 0;
                    p = b[p + 4 >> 2] | 0;

                    e: do { if (!((o | 0) == 0 & (p | 0) == 0)) {
                      l = od(o | 0, p | 0, D | 0, E | 0) | 0;
                      k = G() | 0;
                      i = e + (l << 3) | 0;
                      c = i;
                      j = b[c >> 2] | 0;
                      c = b[c + 4 >> 2] | 0;

                      if (!((j | 0) == 0 & (c | 0) == 0)) {
                        m = 0;
                        n = 0;

                        do {
                          if ((m | 0) > (E | 0) | (m | 0) == (E | 0) & n >>> 0 > D >>> 0) { break d; }

                          if ((j | 0) == (o | 0) & (c | 0) == (p | 0)) {
                            i = g;
                            j = h;
                            break e;
                          }

                          i = gd(l | 0, k | 0, 1, 0) | 0;
                          l = nd(i | 0, G() | 0, D | 0, E | 0) | 0;
                          k = G() | 0;
                          n = gd(n | 0, m | 0, 1, 0) | 0;
                          m = G() | 0;
                          i = e + (l << 3) | 0;
                          c = i;
                          j = b[c >> 2] | 0;
                          c = b[c + 4 >> 2] | 0;
                        } while (!((j | 0) == 0 & (c | 0) == 0));
                      }

                      if (!((o | 0) == 0 & (p | 0) == 0)) {
                        Mb(o, p, I) | 0;

                        if (Bc(a, J, I) | 0) {
                          n = gd(g | 0, h | 0, 1, 0) | 0;
                          h = G() | 0;
                          m = i;
                          b[m >> 2] = o;
                          b[m + 4 >> 2] = p;
                          g = z + (g << 3) | 0;
                          b[g >> 2] = o;
                          b[g + 4 >> 2] = p;
                          g = n;
                        }

                        i = g;
                        j = h;
                      } else {
                        i = g;
                        j = h;
                      }
                    } else {
                      i = g;
                      j = h;
                    } } while (0);

                    q = q + 1 | 0;
                    if (q >>> 0 >= 7) { break; }else {
                      g = i;
                      h = j;
                    }
                  }

                  r = gd(r | 0, s | 0, 1, 0) | 0;
                  s = G() | 0;
                  t = gd(t | 0, u | 0, 1, 0) | 0;
                  u = G() | 0;
                  h = F;
                  g = b[h >> 2] | 0;
                  h = b[h + 4 >> 2] | 0;
                  if (!((u | 0) < (h | 0) | (u | 0) == (h | 0) & t >>> 0 < g >>> 0)) { break; }else {
                    g = i;
                    h = j;
                  }
                }

                if ((h | 0) > 0 | (h | 0) == 0 & g >>> 0 > 0) {
                  g = 0;
                  h = 0;

                  do {
                    u = y + (g << 3) | 0;
                    b[u >> 2] = 0;
                    b[u + 4 >> 2] = 0;
                    g = gd(g | 0, h | 0, 1, 0) | 0;
                    h = G() | 0;
                    u = F;
                    t = b[u + 4 >> 2] | 0;
                  } while ((h | 0) < (t | 0) | ((h | 0) == (t | 0) ? g >>> 0 < (b[u >> 2] | 0) >>> 0 : 0));
                }

                u = F;
                b[u >> 2] = i;
                b[u + 4 >> 2] = j;

                if ((j | 0) > 0 | (j | 0) == 0 & i >>> 0 > 0) {
                  q = f;
                  r = x;
                  s = C;
                  t = w;
                  u = z;
                  f = v;
                  x = d;
                  w = A;
                  v = q;
                  d = r;
                  C = B;
                  B = s;
                  A = t;
                  z = y;
                  y = u;
                } else { break c; }
              }

              ed(A);
              ed(B);
              ed(J);
              d = 1;
              break a;
            } else { d = i; } } while (0);

            ed(J);
            ed(f);
            ed(d);
            d = 0;
          } else {
            ed(f);
            ed(i);
            ed(J);
          } } while (0);

          J = d;
          S = K;
          return J | 0;
        }

        function ja(a, c, d) {
          a = a | 0;
          c = c | 0;
          d = d | 0;
          var e = 0,
              f = 0,
              g = 0,
              h = 0,
              i = 0,
              j = 0,
              k = 0,
              l = 0;
          l = S;
          S = S + 176 | 0;
          j = l;

          if ((c | 0) < 1) {
            Vc(d, 0, 0);
            k = 0;
            S = l;
            return k | 0;
          }

          i = a;
          i = qd(b[i >> 2] | 0, b[i + 4 >> 2] | 0, 52) | 0;
          G() | 0;
          Vc(d, (c | 0) > 6 ? c : 6, i & 15);
          i = 0;

          while (1) {
            e = a + (i << 3) | 0;
            e = Nb(b[e >> 2] | 0, b[e + 4 >> 2] | 0, j) | 0;
            if (e | 0) { break; }
            e = b[j >> 2] | 0;

            if ((e | 0) > 0) {
              h = 0;

              do {
                g = j + 8 + (h << 4) | 0;
                h = h + 1 | 0;
                e = j + 8 + (((h | 0) % (e | 0) | 0) << 4) | 0;
                f = _c(d, e, g) | 0;
                if (!f) { Zc(d, g, e) | 0; }else { Yc(d, f) | 0; }
                e = b[j >> 2] | 0;
              } while ((h | 0) < (e | 0));
            }

            i = i + 1 | 0;

            if ((i | 0) >= (c | 0)) {
              e = 0;
              k = 13;
              break;
            }
          }

          if ((k | 0) == 13) {
            S = l;
            return e | 0;
          }

          Wc(d);
          k = e;
          S = l;
          return k | 0;
        }

        function ka(a, c, d) {
          a = a | 0;
          c = c | 0;
          d = d | 0;
          var e = 0,
              f = 0,
              g = 0,
              h = 0;
          g = S;
          S = S + 32 | 0;
          e = g;
          f = g + 16 | 0;
          a = ja(a, c, f) | 0;

          if (a | 0) {
            d = a;
            S = g;
            return d | 0;
          }

          b[d >> 2] = 0;
          b[d + 4 >> 2] = 0;
          b[d + 8 >> 2] = 0;
          a = Xc(f) | 0;
          if (a | 0) { do {
            c = lc(d) | 0;

            do {
              mc(c, a) | 0;
              h = a + 16 | 0;
              b[e >> 2] = b[h >> 2];
              b[e + 4 >> 2] = b[h + 4 >> 2];
              b[e + 8 >> 2] = b[h + 8 >> 2];
              b[e + 12 >> 2] = b[h + 12 >> 2];
              Yc(f, a) | 0;
              a = $c(f, e) | 0;
            } while ((a | 0) != 0);

            a = Xc(f) | 0;
          } while ((a | 0) != 0); }
          Wc(f);
          a = oc(d) | 0;

          if (!a) {
            h = 0;
            S = g;
            return h | 0;
          }

          nc(d);
          h = a;
          S = g;
          return h | 0;
        }

        function la(a) {
          a = a | 0;

          if (a >>> 0 > 121) {
            a = 0;
            return a | 0;
          }

          a = b[7696 + (a * 28 | 0) + 16 >> 2] | 0;
          return a | 0;
        }

        function ma(a) {
          a = a | 0;
          return (a | 0) == 4 | (a | 0) == 117 | 0;
        }

        function na(a) {
          a = a | 0;
          return b[11120 + ((b[a >> 2] | 0) * 216 | 0) + ((b[a + 4 >> 2] | 0) * 72 | 0) + ((b[a + 8 >> 2] | 0) * 24 | 0) + (b[a + 12 >> 2] << 3) >> 2] | 0;
        }

        function oa(a) {
          a = a | 0;
          return b[11120 + ((b[a >> 2] | 0) * 216 | 0) + ((b[a + 4 >> 2] | 0) * 72 | 0) + ((b[a + 8 >> 2] | 0) * 24 | 0) + (b[a + 12 >> 2] << 3) + 4 >> 2] | 0;
        }

        function pa(a, c) {
          a = a | 0;
          c = c | 0;
          a = 7696 + (a * 28 | 0) | 0;
          b[c >> 2] = b[a >> 2];
          b[c + 4 >> 2] = b[a + 4 >> 2];
          b[c + 8 >> 2] = b[a + 8 >> 2];
          b[c + 12 >> 2] = b[a + 12 >> 2];
          return;
        }

        function qa(a, c) {
          a = a | 0;
          c = c | 0;
          var d = 0,
              e = 0;

          if (c >>> 0 > 20) {
            c = -1;
            return c | 0;
          }

          do { if ((b[11120 + (c * 216 | 0) >> 2] | 0) != (a | 0)) {
            if ((b[11120 + (c * 216 | 0) + 8 >> 2] | 0) != (a | 0)) {
              if ((b[11120 + (c * 216 | 0) + 16 >> 2] | 0) != (a | 0)) {
                if ((b[11120 + (c * 216 | 0) + 24 >> 2] | 0) != (a | 0)) {
                  if ((b[11120 + (c * 216 | 0) + 32 >> 2] | 0) != (a | 0)) {
                    if ((b[11120 + (c * 216 | 0) + 40 >> 2] | 0) != (a | 0)) {
                      if ((b[11120 + (c * 216 | 0) + 48 >> 2] | 0) != (a | 0)) {
                        if ((b[11120 + (c * 216 | 0) + 56 >> 2] | 0) != (a | 0)) {
                          if ((b[11120 + (c * 216 | 0) + 64 >> 2] | 0) != (a | 0)) {
                            if ((b[11120 + (c * 216 | 0) + 72 >> 2] | 0) != (a | 0)) {
                              if ((b[11120 + (c * 216 | 0) + 80 >> 2] | 0) != (a | 0)) {
                                if ((b[11120 + (c * 216 | 0) + 88 >> 2] | 0) != (a | 0)) {
                                  if ((b[11120 + (c * 216 | 0) + 96 >> 2] | 0) != (a | 0)) {
                                    if ((b[11120 + (c * 216 | 0) + 104 >> 2] | 0) != (a | 0)) {
                                      if ((b[11120 + (c * 216 | 0) + 112 >> 2] | 0) != (a | 0)) {
                                        if ((b[11120 + (c * 216 | 0) + 120 >> 2] | 0) != (a | 0)) {
                                          if ((b[11120 + (c * 216 | 0) + 128 >> 2] | 0) != (a | 0)) {
                                            if ((b[11120 + (c * 216 | 0) + 136 >> 2] | 0) == (a | 0)) {
                                              a = 2;
                                              d = 1;
                                              e = 2;
                                            } else {
                                              if ((b[11120 + (c * 216 | 0) + 144 >> 2] | 0) == (a | 0)) {
                                                a = 0;
                                                d = 2;
                                                e = 0;
                                                break;
                                              }

                                              if ((b[11120 + (c * 216 | 0) + 152 >> 2] | 0) == (a | 0)) {
                                                a = 0;
                                                d = 2;
                                                e = 1;
                                                break;
                                              }

                                              if ((b[11120 + (c * 216 | 0) + 160 >> 2] | 0) == (a | 0)) {
                                                a = 0;
                                                d = 2;
                                                e = 2;
                                                break;
                                              }

                                              if ((b[11120 + (c * 216 | 0) + 168 >> 2] | 0) == (a | 0)) {
                                                a = 1;
                                                d = 2;
                                                e = 0;
                                                break;
                                              }

                                              if ((b[11120 + (c * 216 | 0) + 176 >> 2] | 0) == (a | 0)) {
                                                a = 1;
                                                d = 2;
                                                e = 1;
                                                break;
                                              }

                                              if ((b[11120 + (c * 216 | 0) + 184 >> 2] | 0) == (a | 0)) {
                                                a = 1;
                                                d = 2;
                                                e = 2;
                                                break;
                                              }

                                              if ((b[11120 + (c * 216 | 0) + 192 >> 2] | 0) == (a | 0)) {
                                                a = 2;
                                                d = 2;
                                                e = 0;
                                                break;
                                              }

                                              if ((b[11120 + (c * 216 | 0) + 200 >> 2] | 0) == (a | 0)) {
                                                a = 2;
                                                d = 2;
                                                e = 1;
                                                break;
                                              }

                                              if ((b[11120 + (c * 216 | 0) + 208 >> 2] | 0) == (a | 0)) {
                                                a = 2;
                                                d = 2;
                                                e = 2;
                                                break;
                                              } else { a = -1; }

                                              return a | 0;
                                            }
                                          } else {
                                            a = 2;
                                            d = 1;
                                            e = 1;
                                          }
                                        } else {
                                          a = 2;
                                          d = 1;
                                          e = 0;
                                        }
                                      } else {
                                        a = 1;
                                        d = 1;
                                        e = 2;
                                      }
                                    } else {
                                      a = 1;
                                      d = 1;
                                      e = 1;
                                    }
                                  } else {
                                    a = 1;
                                    d = 1;
                                    e = 0;
                                  }
                                } else {
                                  a = 0;
                                  d = 1;
                                  e = 2;
                                }
                              } else {
                                a = 0;
                                d = 1;
                                e = 1;
                              }
                            } else {
                              a = 0;
                              d = 1;
                              e = 0;
                            }
                          } else {
                            a = 2;
                            d = 0;
                            e = 2;
                          }
                        } else {
                          a = 2;
                          d = 0;
                          e = 1;
                        }
                      } else {
                        a = 2;
                        d = 0;
                        e = 0;
                      }
                    } else {
                      a = 1;
                      d = 0;
                      e = 2;
                    }
                  } else {
                    a = 1;
                    d = 0;
                    e = 1;
                  }
                } else {
                  a = 1;
                  d = 0;
                  e = 0;
                }
              } else {
                a = 0;
                d = 0;
                e = 2;
              }
            } else {
              a = 0;
              d = 0;
              e = 1;
            }
          } else {
            a = 0;
            d = 0;
            e = 0;
          } } while (0);

          c = b[11120 + (c * 216 | 0) + (d * 72 | 0) + (a * 24 | 0) + (e << 3) + 4 >> 2] | 0;
          return c | 0;
        }

        function ra(a, c) {
          a = a | 0;
          c = c | 0;

          if ((b[7696 + (a * 28 | 0) + 20 >> 2] | 0) == (c | 0)) {
            c = 1;
            return c | 0;
          }

          c = (b[7696 + (a * 28 | 0) + 24 >> 2] | 0) == (c | 0);
          return c | 0;
        }

        function sa(a, c) {
          a = a | 0;
          c = c | 0;
          return b[848 + (a * 28 | 0) + (c << 2) >> 2] | 0;
        }

        function ta(a, c) {
          a = a | 0;
          c = c | 0;

          if ((b[848 + (a * 28 | 0) >> 2] | 0) == (c | 0)) {
            c = 0;
            return c | 0;
          }

          if ((b[848 + (a * 28 | 0) + 4 >> 2] | 0) == (c | 0)) {
            c = 1;
            return c | 0;
          }

          if ((b[848 + (a * 28 | 0) + 8 >> 2] | 0) == (c | 0)) {
            c = 2;
            return c | 0;
          }

          if ((b[848 + (a * 28 | 0) + 12 >> 2] | 0) == (c | 0)) {
            c = 3;
            return c | 0;
          }

          if ((b[848 + (a * 28 | 0) + 16 >> 2] | 0) == (c | 0)) {
            c = 4;
            return c | 0;
          }

          if ((b[848 + (a * 28 | 0) + 20 >> 2] | 0) == (c | 0)) {
            c = 5;
            return c | 0;
          } else { return ((b[848 + (a * 28 | 0) + 24 >> 2] | 0) == (c | 0) ? 6 : 7) | 0; }
        }

        function ua() {
          return 122;
        }

        function va(a) {
          a = a | 0;
          var c = 0,
              d = 0,
              e = 0;
          c = 0;

          do {
            rd(c | 0, 0, 45) | 0;
            e = G() | 0 | 134225919;
            d = a + (c << 3) | 0;
            b[d >> 2] = -1;
            b[d + 4 >> 2] = e;
            c = c + 1 | 0;
          } while ((c | 0) != 122);

          return 0;
        }

        function wa(a) {
          a = a | 0;
          return +e[a + 16 >> 3] < +e[a + 24 >> 3] | 0;
        }

        function xa(a, b) {
          a = a | 0;
          b = b | 0;
          var c = 0.0,
              d = 0.0,
              f = 0.0;
          c = +e[b >> 3];

          if (!(c >= +e[a + 8 >> 3])) {
            b = 0;
            return b | 0;
          }

          if (!(c <= +e[a >> 3])) {
            b = 0;
            return b | 0;
          }

          d = +e[a + 16 >> 3];
          c = +e[a + 24 >> 3];
          f = +e[b + 8 >> 3];
          b = f >= c;
          a = f <= d & 1;

          if (d < c) {
            if (b) { a = 1; }
          } else if (!b) { a = 0; }

          b = (a | 0) != 0;
          return b | 0;
        }

        function ya(a, c, d) {
          a = a | 0;
          c = c | 0;
          d = d | 0;
          var g = 0,
              h = 0,
              i = 0,
              j = 0,
              k = 0,
              l = 0,
              m = 0.0,
              n = 0.0;
          l = S;
          S = S + 288 | 0;
          i = l + 264 | 0;
          j = l + 96 | 0;
          k = l;
          g = k;
          h = g + 96 | 0;

          do {
            b[g >> 2] = 0;
            g = g + 4 | 0;
          } while ((g | 0) < (h | 0));

          c = Rb(c, k) | 0;

          if (c | 0) {
            d = c;
            S = l;
            return d | 0;
          }

          g = k;
          c = b[g >> 2] | 0;
          g = b[g + 4 >> 2] | 0;
          Mb(c, g, i) | 0;
          Nb(c, g, j) | 0;
          m = +Xb(i, j + 8 | 0);
          e[i >> 3] = +e[a >> 3];
          g = i + 8 | 0;
          e[g >> 3] = +e[a + 16 >> 3];
          e[j >> 3] = +e[a + 8 >> 3];
          c = j + 8 | 0;
          e[c >> 3] = +e[a + 24 >> 3];
          n = +Xb(i, j);
          m = +A(+(n * n / +sd(+ +q(+((+e[g >> 3] - +e[c >> 3]) / (+e[i >> 3] - +e[j >> 3]))), 3.0) / (m * (m * 2.59807621135) * .8)));
          e[f >> 3] = m;
          c = ~~m >>> 0;
          g = +q(m) >= 1.0 ? m > 0.0 ? ~~+C(+p(m / 4294967296.0), 4294967295.0) >>> 0 : ~~+A((m - +(~~m >>> 0)) / 4294967296.0) >>> 0 : 0;
          if ((b[f + 4 >> 2] & 2146435072 | 0) == 2146435072) { c = 1; }else {
            k = (c | 0) == 0 & (g | 0) == 0;
            b[d >> 2] = k ? 1 : c;
            b[d + 4 >> 2] = k ? 0 : g;
            c = 0;
          }
          d = c;
          S = l;
          return d | 0;
        }

        function za(a, c, d, g) {
          a = a | 0;
          c = c | 0;
          d = d | 0;
          g = g | 0;
          var h = 0,
              i = 0,
              j = 0,
              k = 0,
              l = 0,
              m = 0,
              n = 0.0;
          m = S;
          S = S + 288 | 0;
          j = m + 264 | 0;
          k = m + 96 | 0;
          l = m;
          h = l;
          i = h + 96 | 0;

          do {
            b[h >> 2] = 0;
            h = h + 4 | 0;
          } while ((h | 0) < (i | 0));

          d = Rb(d, l) | 0;

          if (d | 0) {
            g = d;
            S = m;
            return g | 0;
          }

          d = l;
          h = b[d >> 2] | 0;
          d = b[d + 4 >> 2] | 0;
          Mb(h, d, j) | 0;
          Nb(h, d, k) | 0;
          n = +Xb(j, k + 8 | 0);
          n = +A(+(+Xb(a, c) / (n * 2.0)));
          e[f >> 3] = n;
          d = ~~n >>> 0;
          h = +q(n) >= 1.0 ? n > 0.0 ? ~~+C(+p(n / 4294967296.0), 4294967295.0) >>> 0 : ~~+A((n - +(~~n >>> 0)) / 4294967296.0) >>> 0 : 0;

          if ((b[f + 4 >> 2] & 2146435072 | 0) == 2146435072) {
            g = 1;
            S = m;
            return g | 0;
          }

          l = (d | 0) == 0 & (h | 0) == 0;
          b[g >> 2] = l ? 1 : d;
          b[g + 4 >> 2] = l ? 0 : h;
          g = 0;
          S = m;
          return g | 0;
        }

        function Aa(a, c, d, e) {
          a = a | 0;
          c = c | 0;
          d = d | 0;
          e = e | 0;
          b[a >> 2] = c;
          b[a + 4 >> 2] = d;
          b[a + 8 >> 2] = e;
          return;
        }

        function Ba(a, c) {
          a = a | 0;
          c = c | 0;
          var d = 0,
              f = 0,
              g = 0,
              h = 0,
              i = 0.0,
              j = 0.0,
              k = 0.0,
              l = 0.0,
              m = 0,
              n = 0,
              o = 0.0;
          n = c + 8 | 0;
          b[n >> 2] = 0;
          k = +e[a >> 3];
          i = +q(+k);
          l = +e[a + 8 >> 3];
          j = +q(+l) / .8660254037844386;
          i = i + j * .5;
          d = ~~i;
          a = ~~j;
          i = i - +(d | 0);
          j = j - +(a | 0);

          do { if (i < .5) {
            if (i < .3333333333333333) {
              b[c >> 2] = d;

              if (j < (i + 1.0) * .5) {
                b[c + 4 >> 2] = a;
                break;
              } else {
                a = a + 1 | 0;
                b[c + 4 >> 2] = a;
                break;
              }
            } else {
              o = 1.0 - i;
              a = (!(j < o) & 1) + a | 0;
              b[c + 4 >> 2] = a;

              if (o <= j & j < i * 2.0) {
                d = d + 1 | 0;
                b[c >> 2] = d;
                break;
              } else {
                b[c >> 2] = d;
                break;
              }
            }
          } else {
            if (!(i < .6666666666666666)) {
              d = d + 1 | 0;
              b[c >> 2] = d;

              if (j < i * .5) {
                b[c + 4 >> 2] = a;
                break;
              } else {
                a = a + 1 | 0;
                b[c + 4 >> 2] = a;
                break;
              }
            }

            if (j < 1.0 - i) {
              b[c + 4 >> 2] = a;

              if (i * 2.0 + -1.0 < j) {
                b[c >> 2] = d;
                break;
              }
            } else {
              a = a + 1 | 0;
              b[c + 4 >> 2] = a;
            }

            d = d + 1 | 0;
            b[c >> 2] = d;
          } } while (0);

          do { if (k < 0.0) { if (!(a & 1)) {
            m = (a | 0) / 2 | 0;
            m = hd(d | 0, ((d | 0) < 0) << 31 >> 31 | 0, m | 0, ((m | 0) < 0) << 31 >> 31 | 0) | 0;
            d = ~~(+(d | 0) - (+(m >>> 0) + 4294967296.0 * +(G() | 0)) * 2.0);
            b[c >> 2] = d;
            break;
          } else {
            m = (a + 1 | 0) / 2 | 0;
            m = hd(d | 0, ((d | 0) < 0) << 31 >> 31 | 0, m | 0, ((m | 0) < 0) << 31 >> 31 | 0) | 0;
            d = ~~(+(d | 0) - ((+(m >>> 0) + 4294967296.0 * +(G() | 0)) * 2.0 + 1.0));
            b[c >> 2] = d;
            break;
          } } } while (0);

          m = c + 4 | 0;

          if (l < 0.0) {
            d = d - ((a << 1 | 1 | 0) / 2 | 0) | 0;
            b[c >> 2] = d;
            a = 0 - a | 0;
            b[m >> 2] = a;
          }

          f = a - d | 0;

          if ((d | 0) < 0) {
            g = 0 - d | 0;
            b[m >> 2] = f;
            b[n >> 2] = g;
            b[c >> 2] = 0;
            a = f;
            d = 0;
          } else { g = 0; }

          if ((a | 0) < 0) {
            d = d - a | 0;
            b[c >> 2] = d;
            g = g - a | 0;
            b[n >> 2] = g;
            b[m >> 2] = 0;
            a = 0;
          }

          h = d - g | 0;
          f = a - g | 0;

          if ((g | 0) < 0) {
            b[c >> 2] = h;
            b[m >> 2] = f;
            b[n >> 2] = 0;
            a = f;
            d = h;
            g = 0;
          }

          f = (a | 0) < (d | 0) ? a : d;
          f = (g | 0) < (f | 0) ? g : f;
          if ((f | 0) <= 0) { return; }
          b[c >> 2] = d - f;
          b[m >> 2] = a - f;
          b[n >> 2] = g - f;
          return;
        }

        function Ca(a) {
          a = a | 0;
          var c = 0,
              d = 0,
              e = 0,
              f = 0,
              g = 0,
              h = 0;
          c = b[a >> 2] | 0;
          h = a + 4 | 0;
          d = b[h >> 2] | 0;

          if ((c | 0) < 0) {
            d = d - c | 0;
            b[h >> 2] = d;
            g = a + 8 | 0;
            b[g >> 2] = (b[g >> 2] | 0) - c;
            b[a >> 2] = 0;
            c = 0;
          }

          if ((d | 0) < 0) {
            c = c - d | 0;
            b[a >> 2] = c;
            g = a + 8 | 0;
            f = (b[g >> 2] | 0) - d | 0;
            b[g >> 2] = f;
            b[h >> 2] = 0;
            d = 0;
          } else {
            f = a + 8 | 0;
            g = f;
            f = b[f >> 2] | 0;
          }

          if ((f | 0) < 0) {
            c = c - f | 0;
            b[a >> 2] = c;
            d = d - f | 0;
            b[h >> 2] = d;
            b[g >> 2] = 0;
            f = 0;
          }

          e = (d | 0) < (c | 0) ? d : c;
          e = (f | 0) < (e | 0) ? f : e;
          if ((e | 0) <= 0) { return; }
          b[a >> 2] = c - e;
          b[h >> 2] = d - e;
          b[g >> 2] = f - e;
          return;
        }

        function Da(a, c) {
          a = a | 0;
          c = c | 0;
          var d = 0.0,
              f = 0;
          f = b[a + 8 >> 2] | 0;
          d = +((b[a + 4 >> 2] | 0) - f | 0);
          e[c >> 3] = +((b[a >> 2] | 0) - f | 0) - d * .5;
          e[c + 8 >> 3] = d * .8660254037844386;
          return;
        }

        function Ea(a, c, d) {
          a = a | 0;
          c = c | 0;
          d = d | 0;
          b[d >> 2] = (b[c >> 2] | 0) + (b[a >> 2] | 0);
          b[d + 4 >> 2] = (b[c + 4 >> 2] | 0) + (b[a + 4 >> 2] | 0);
          b[d + 8 >> 2] = (b[c + 8 >> 2] | 0) + (b[a + 8 >> 2] | 0);
          return;
        }

        function Fa(a, c, d) {
          a = a | 0;
          c = c | 0;
          d = d | 0;
          b[d >> 2] = (b[a >> 2] | 0) - (b[c >> 2] | 0);
          b[d + 4 >> 2] = (b[a + 4 >> 2] | 0) - (b[c + 4 >> 2] | 0);
          b[d + 8 >> 2] = (b[a + 8 >> 2] | 0) - (b[c + 8 >> 2] | 0);
          return;
        }

        function Ga(a, c) {
          a = a | 0;
          c = c | 0;
          var d = 0,
              e = 0;
          d = B(b[a >> 2] | 0, c) | 0;
          b[a >> 2] = d;
          d = a + 4 | 0;
          e = B(b[d >> 2] | 0, c) | 0;
          b[d >> 2] = e;
          a = a + 8 | 0;
          c = B(b[a >> 2] | 0, c) | 0;
          b[a >> 2] = c;
          return;
        }

        function Ha(a) {
          a = a | 0;
          var c = 0,
              d = 0,
              e = 0,
              f = 0,
              g = 0,
              h = 0,
              i = 0;
          h = b[a >> 2] | 0;
          i = (h | 0) < 0;
          e = (b[a + 4 >> 2] | 0) - (i ? h : 0) | 0;
          g = (e | 0) < 0;
          f = (g ? 0 - e | 0 : 0) + ((b[a + 8 >> 2] | 0) - (i ? h : 0)) | 0;
          d = (f | 0) < 0;
          a = d ? 0 : f;
          c = (g ? 0 : e) - (d ? f : 0) | 0;
          f = (i ? 0 : h) - (g ? e : 0) - (d ? f : 0) | 0;
          d = (c | 0) < (f | 0) ? c : f;
          d = (a | 0) < (d | 0) ? a : d;
          e = (d | 0) > 0;
          a = a - (e ? d : 0) | 0;
          c = c - (e ? d : 0) | 0;

          a: do { switch (f - (e ? d : 0) | 0) {
            case 0:
              switch (c | 0) {
                case 0:
                  {
                    i = (a | 0) == 0 ? 0 : (a | 0) == 1 ? 1 : 7;
                    return i | 0;
                  }

                case 1:
                  {
                    i = (a | 0) == 0 ? 2 : (a | 0) == 1 ? 3 : 7;
                    return i | 0;
                  }

                default:
                  break a;
              }

            case 1:
              switch (c | 0) {
                case 0:
                  {
                    i = (a | 0) == 0 ? 4 : (a | 0) == 1 ? 5 : 7;
                    return i | 0;
                  }

                case 1:
                  {
                    if (!a) { a = 6; }else { break a; }
                    return a | 0;
                  }

                default:
                  break a;
              }

          } } while (0);

          i = 7;
          return i | 0;
        }

        function Ia(a) {
          a = a | 0;
          var c = 0,
              d = 0,
              e = 0,
              f = 0,
              g = 0,
              h = 0,
              i = 0;
          h = a + 8 | 0;
          d = b[h >> 2] | 0;
          c = (b[a >> 2] | 0) - d | 0;
          i = a + 4 | 0;
          d = (b[i >> 2] | 0) - d | 0;
          e = cd(+((c * 3 | 0) - d | 0) / 7.0) | 0;
          b[a >> 2] = e;
          c = cd(+((d << 1) + c | 0) / 7.0) | 0;
          b[i >> 2] = c;
          b[h >> 2] = 0;
          d = c - e | 0;

          if ((e | 0) < 0) {
            g = 0 - e | 0;
            b[i >> 2] = d;
            b[h >> 2] = g;
            b[a >> 2] = 0;
            c = d;
            e = 0;
            d = g;
          } else { d = 0; }

          if ((c | 0) < 0) {
            e = e - c | 0;
            b[a >> 2] = e;
            d = d - c | 0;
            b[h >> 2] = d;
            b[i >> 2] = 0;
            c = 0;
          }

          g = e - d | 0;
          f = c - d | 0;

          if ((d | 0) < 0) {
            b[a >> 2] = g;
            b[i >> 2] = f;
            b[h >> 2] = 0;
            c = f;
            f = g;
            d = 0;
          } else { f = e; }

          e = (c | 0) < (f | 0) ? c : f;
          e = (d | 0) < (e | 0) ? d : e;
          if ((e | 0) <= 0) { return; }
          b[a >> 2] = f - e;
          b[i >> 2] = c - e;
          b[h >> 2] = d - e;
          return;
        }

        function Ja(a) {
          a = a | 0;
          var c = 0,
              d = 0,
              e = 0,
              f = 0,
              g = 0,
              h = 0,
              i = 0;
          h = a + 8 | 0;
          d = b[h >> 2] | 0;
          c = (b[a >> 2] | 0) - d | 0;
          i = a + 4 | 0;
          d = (b[i >> 2] | 0) - d | 0;
          e = cd(+((c << 1) + d | 0) / 7.0) | 0;
          b[a >> 2] = e;
          c = cd(+((d * 3 | 0) - c | 0) / 7.0) | 0;
          b[i >> 2] = c;
          b[h >> 2] = 0;
          d = c - e | 0;

          if ((e | 0) < 0) {
            g = 0 - e | 0;
            b[i >> 2] = d;
            b[h >> 2] = g;
            b[a >> 2] = 0;
            c = d;
            e = 0;
            d = g;
          } else { d = 0; }

          if ((c | 0) < 0) {
            e = e - c | 0;
            b[a >> 2] = e;
            d = d - c | 0;
            b[h >> 2] = d;
            b[i >> 2] = 0;
            c = 0;
          }

          g = e - d | 0;
          f = c - d | 0;

          if ((d | 0) < 0) {
            b[a >> 2] = g;
            b[i >> 2] = f;
            b[h >> 2] = 0;
            c = f;
            f = g;
            d = 0;
          } else { f = e; }

          e = (c | 0) < (f | 0) ? c : f;
          e = (d | 0) < (e | 0) ? d : e;
          if ((e | 0) <= 0) { return; }
          b[a >> 2] = f - e;
          b[i >> 2] = c - e;
          b[h >> 2] = d - e;
          return;
        }

        function Ka(a) {
          a = a | 0;
          var c = 0,
              d = 0,
              e = 0,
              f = 0,
              g = 0,
              h = 0,
              i = 0;
          c = b[a >> 2] | 0;
          h = a + 4 | 0;
          d = b[h >> 2] | 0;
          i = a + 8 | 0;
          e = b[i >> 2] | 0;
          f = d + (c * 3 | 0) | 0;
          b[a >> 2] = f;
          d = e + (d * 3 | 0) | 0;
          b[h >> 2] = d;
          c = (e * 3 | 0) + c | 0;
          b[i >> 2] = c;
          e = d - f | 0;

          if ((f | 0) < 0) {
            c = c - f | 0;
            b[h >> 2] = e;
            b[i >> 2] = c;
            b[a >> 2] = 0;
            d = e;
            e = 0;
          } else { e = f; }

          if ((d | 0) < 0) {
            e = e - d | 0;
            b[a >> 2] = e;
            c = c - d | 0;
            b[i >> 2] = c;
            b[h >> 2] = 0;
            d = 0;
          }

          g = e - c | 0;
          f = d - c | 0;

          if ((c | 0) < 0) {
            b[a >> 2] = g;
            b[h >> 2] = f;
            b[i >> 2] = 0;
            e = g;
            c = 0;
          } else { f = d; }

          d = (f | 0) < (e | 0) ? f : e;
          d = (c | 0) < (d | 0) ? c : d;
          if ((d | 0) <= 0) { return; }
          b[a >> 2] = e - d;
          b[h >> 2] = f - d;
          b[i >> 2] = c - d;
          return;
        }

        function La(a) {
          a = a | 0;
          var c = 0,
              d = 0,
              e = 0,
              f = 0,
              g = 0,
              h = 0,
              i = 0;
          f = b[a >> 2] | 0;
          h = a + 4 | 0;
          c = b[h >> 2] | 0;
          i = a + 8 | 0;
          d = b[i >> 2] | 0;
          e = (c * 3 | 0) + f | 0;
          f = d + (f * 3 | 0) | 0;
          b[a >> 2] = f;
          b[h >> 2] = e;
          c = (d * 3 | 0) + c | 0;
          b[i >> 2] = c;
          d = e - f | 0;

          if ((f | 0) < 0) {
            c = c - f | 0;
            b[h >> 2] = d;
            b[i >> 2] = c;
            b[a >> 2] = 0;
            f = 0;
          } else { d = e; }

          if ((d | 0) < 0) {
            f = f - d | 0;
            b[a >> 2] = f;
            c = c - d | 0;
            b[i >> 2] = c;
            b[h >> 2] = 0;
            d = 0;
          }

          g = f - c | 0;
          e = d - c | 0;

          if ((c | 0) < 0) {
            b[a >> 2] = g;
            b[h >> 2] = e;
            b[i >> 2] = 0;
            f = g;
            c = 0;
          } else { e = d; }

          d = (e | 0) < (f | 0) ? e : f;
          d = (c | 0) < (d | 0) ? c : d;
          if ((d | 0) <= 0) { return; }
          b[a >> 2] = f - d;
          b[h >> 2] = e - d;
          b[i >> 2] = c - d;
          return;
        }

        function Ma(a, c) {
          a = a | 0;
          c = c | 0;
          var d = 0,
              e = 0,
              f = 0,
              g = 0,
              h = 0,
              i = 0;
          if ((c + -1 | 0) >>> 0 >= 6) { return; }
          f = (b[15440 + (c * 12 | 0) >> 2] | 0) + (b[a >> 2] | 0) | 0;
          b[a >> 2] = f;
          i = a + 4 | 0;
          e = (b[15440 + (c * 12 | 0) + 4 >> 2] | 0) + (b[i >> 2] | 0) | 0;
          b[i >> 2] = e;
          h = a + 8 | 0;
          c = (b[15440 + (c * 12 | 0) + 8 >> 2] | 0) + (b[h >> 2] | 0) | 0;
          b[h >> 2] = c;
          d = e - f | 0;

          if ((f | 0) < 0) {
            c = c - f | 0;
            b[i >> 2] = d;
            b[h >> 2] = c;
            b[a >> 2] = 0;
            e = 0;
          } else {
            d = e;
            e = f;
          }

          if ((d | 0) < 0) {
            e = e - d | 0;
            b[a >> 2] = e;
            c = c - d | 0;
            b[h >> 2] = c;
            b[i >> 2] = 0;
            d = 0;
          }

          g = e - c | 0;
          f = d - c | 0;

          if ((c | 0) < 0) {
            b[a >> 2] = g;
            b[i >> 2] = f;
            b[h >> 2] = 0;
            e = g;
            c = 0;
          } else { f = d; }

          d = (f | 0) < (e | 0) ? f : e;
          d = (c | 0) < (d | 0) ? c : d;
          if ((d | 0) <= 0) { return; }
          b[a >> 2] = e - d;
          b[i >> 2] = f - d;
          b[h >> 2] = c - d;
          return;
        }

        function Na(a) {
          a = a | 0;
          var c = 0,
              d = 0,
              e = 0,
              f = 0,
              g = 0,
              h = 0,
              i = 0;
          f = b[a >> 2] | 0;
          h = a + 4 | 0;
          c = b[h >> 2] | 0;
          i = a + 8 | 0;
          d = b[i >> 2] | 0;
          e = c + f | 0;
          f = d + f | 0;
          b[a >> 2] = f;
          b[h >> 2] = e;
          c = d + c | 0;
          b[i >> 2] = c;
          d = e - f | 0;

          if ((f | 0) < 0) {
            c = c - f | 0;
            b[h >> 2] = d;
            b[i >> 2] = c;
            b[a >> 2] = 0;
            e = 0;
          } else {
            d = e;
            e = f;
          }

          if ((d | 0) < 0) {
            e = e - d | 0;
            b[a >> 2] = e;
            c = c - d | 0;
            b[i >> 2] = c;
            b[h >> 2] = 0;
            d = 0;
          }

          g = e - c | 0;
          f = d - c | 0;

          if ((c | 0) < 0) {
            b[a >> 2] = g;
            b[h >> 2] = f;
            b[i >> 2] = 0;
            e = g;
            c = 0;
          } else { f = d; }

          d = (f | 0) < (e | 0) ? f : e;
          d = (c | 0) < (d | 0) ? c : d;
          if ((d | 0) <= 0) { return; }
          b[a >> 2] = e - d;
          b[h >> 2] = f - d;
          b[i >> 2] = c - d;
          return;
        }

        function Oa(a) {
          a = a | 0;
          var c = 0,
              d = 0,
              e = 0,
              f = 0,
              g = 0,
              h = 0,
              i = 0;
          c = b[a >> 2] | 0;
          h = a + 4 | 0;
          e = b[h >> 2] | 0;
          i = a + 8 | 0;
          d = b[i >> 2] | 0;
          f = e + c | 0;
          b[a >> 2] = f;
          e = d + e | 0;
          b[h >> 2] = e;
          c = d + c | 0;
          b[i >> 2] = c;
          d = e - f | 0;

          if ((f | 0) < 0) {
            c = c - f | 0;
            b[h >> 2] = d;
            b[i >> 2] = c;
            b[a >> 2] = 0;
            e = 0;
          } else {
            d = e;
            e = f;
          }

          if ((d | 0) < 0) {
            e = e - d | 0;
            b[a >> 2] = e;
            c = c - d | 0;
            b[i >> 2] = c;
            b[h >> 2] = 0;
            d = 0;
          }

          g = e - c | 0;
          f = d - c | 0;

          if ((c | 0) < 0) {
            b[a >> 2] = g;
            b[h >> 2] = f;
            b[i >> 2] = 0;
            e = g;
            c = 0;
          } else { f = d; }

          d = (f | 0) < (e | 0) ? f : e;
          d = (c | 0) < (d | 0) ? c : d;
          if ((d | 0) <= 0) { return; }
          b[a >> 2] = e - d;
          b[h >> 2] = f - d;
          b[i >> 2] = c - d;
          return;
        }

        function Pa(a) {
          a = a | 0;

          switch (a | 0) {
            case 1:
              {
                a = 5;
                break;
              }

            case 5:
              {
                a = 4;
                break;
              }

            case 4:
              {
                a = 6;
                break;
              }

            case 6:
              {
                a = 2;
                break;
              }

            case 2:
              {
                a = 3;
                break;
              }

            case 3:
              {
                a = 1;
                break;
              }

          }

          return a | 0;
        }

        function Qa(a) {
          a = a | 0;

          switch (a | 0) {
            case 1:
              {
                a = 3;
                break;
              }

            case 3:
              {
                a = 2;
                break;
              }

            case 2:
              {
                a = 6;
                break;
              }

            case 6:
              {
                a = 4;
                break;
              }

            case 4:
              {
                a = 5;
                break;
              }

            case 5:
              {
                a = 1;
                break;
              }

          }

          return a | 0;
        }

        function Ra(a) {
          a = a | 0;
          var c = 0,
              d = 0,
              e = 0,
              f = 0,
              g = 0,
              h = 0,
              i = 0;
          c = b[a >> 2] | 0;
          h = a + 4 | 0;
          d = b[h >> 2] | 0;
          i = a + 8 | 0;
          e = b[i >> 2] | 0;
          f = d + (c << 1) | 0;
          b[a >> 2] = f;
          d = e + (d << 1) | 0;
          b[h >> 2] = d;
          c = (e << 1) + c | 0;
          b[i >> 2] = c;
          e = d - f | 0;

          if ((f | 0) < 0) {
            c = c - f | 0;
            b[h >> 2] = e;
            b[i >> 2] = c;
            b[a >> 2] = 0;
            d = e;
            e = 0;
          } else { e = f; }

          if ((d | 0) < 0) {
            e = e - d | 0;
            b[a >> 2] = e;
            c = c - d | 0;
            b[i >> 2] = c;
            b[h >> 2] = 0;
            d = 0;
          }

          g = e - c | 0;
          f = d - c | 0;

          if ((c | 0) < 0) {
            b[a >> 2] = g;
            b[h >> 2] = f;
            b[i >> 2] = 0;
            e = g;
            c = 0;
          } else { f = d; }

          d = (f | 0) < (e | 0) ? f : e;
          d = (c | 0) < (d | 0) ? c : d;
          if ((d | 0) <= 0) { return; }
          b[a >> 2] = e - d;
          b[h >> 2] = f - d;
          b[i >> 2] = c - d;
          return;
        }

        function Sa(a) {
          a = a | 0;
          var c = 0,
              d = 0,
              e = 0,
              f = 0,
              g = 0,
              h = 0,
              i = 0;
          f = b[a >> 2] | 0;
          h = a + 4 | 0;
          c = b[h >> 2] | 0;
          i = a + 8 | 0;
          d = b[i >> 2] | 0;
          e = (c << 1) + f | 0;
          f = d + (f << 1) | 0;
          b[a >> 2] = f;
          b[h >> 2] = e;
          c = (d << 1) + c | 0;
          b[i >> 2] = c;
          d = e - f | 0;

          if ((f | 0) < 0) {
            c = c - f | 0;
            b[h >> 2] = d;
            b[i >> 2] = c;
            b[a >> 2] = 0;
            f = 0;
          } else { d = e; }

          if ((d | 0) < 0) {
            f = f - d | 0;
            b[a >> 2] = f;
            c = c - d | 0;
            b[i >> 2] = c;
            b[h >> 2] = 0;
            d = 0;
          }

          g = f - c | 0;
          e = d - c | 0;

          if ((c | 0) < 0) {
            b[a >> 2] = g;
            b[h >> 2] = e;
            b[i >> 2] = 0;
            f = g;
            c = 0;
          } else { e = d; }

          d = (e | 0) < (f | 0) ? e : f;
          d = (c | 0) < (d | 0) ? c : d;
          if ((d | 0) <= 0) { return; }
          b[a >> 2] = f - d;
          b[h >> 2] = e - d;
          b[i >> 2] = c - d;
          return;
        }

        function Ta(a, c) {
          a = a | 0;
          c = c | 0;
          var d = 0,
              e = 0,
              f = 0,
              g = 0,
              h = 0,
              i = 0;
          h = (b[a >> 2] | 0) - (b[c >> 2] | 0) | 0;
          i = (h | 0) < 0;
          e = (b[a + 4 >> 2] | 0) - (b[c + 4 >> 2] | 0) - (i ? h : 0) | 0;
          g = (e | 0) < 0;
          f = (i ? 0 - h | 0 : 0) + (b[a + 8 >> 2] | 0) - (b[c + 8 >> 2] | 0) + (g ? 0 - e | 0 : 0) | 0;
          a = (f | 0) < 0;
          c = a ? 0 : f;
          d = (g ? 0 : e) - (a ? f : 0) | 0;
          f = (i ? 0 : h) - (g ? e : 0) - (a ? f : 0) | 0;
          a = (d | 0) < (f | 0) ? d : f;
          a = (c | 0) < (a | 0) ? c : a;
          e = (a | 0) > 0;
          c = c - (e ? a : 0) | 0;
          d = d - (e ? a : 0) | 0;
          a = f - (e ? a : 0) | 0;
          a = (a | 0) > -1 ? a : 0 - a | 0;
          d = (d | 0) > -1 ? d : 0 - d | 0;
          c = (c | 0) > -1 ? c : 0 - c | 0;
          c = (d | 0) > (c | 0) ? d : c;
          return ((a | 0) > (c | 0) ? a : c) | 0;
        }

        function Ua(a, c) {
          a = a | 0;
          c = c | 0;
          var d = 0;
          d = b[a + 8 >> 2] | 0;
          b[c >> 2] = (b[a >> 2] | 0) - d;
          b[c + 4 >> 2] = (b[a + 4 >> 2] | 0) - d;
          return;
        }

        function Va(a, c) {
          a = a | 0;
          c = c | 0;
          var d = 0,
              e = 0,
              f = 0,
              g = 0,
              h = 0,
              i = 0;
          e = b[a >> 2] | 0;
          b[c >> 2] = e;
          a = b[a + 4 >> 2] | 0;
          h = c + 4 | 0;
          b[h >> 2] = a;
          i = c + 8 | 0;
          b[i >> 2] = 0;
          d = a - e | 0;

          if ((e | 0) < 0) {
            a = 0 - e | 0;
            b[h >> 2] = d;
            b[i >> 2] = a;
            b[c >> 2] = 0;
            e = 0;
          } else {
            d = a;
            a = 0;
          }

          if ((d | 0) < 0) {
            e = e - d | 0;
            b[c >> 2] = e;
            a = a - d | 0;
            b[i >> 2] = a;
            b[h >> 2] = 0;
            d = 0;
          }

          g = e - a | 0;
          f = d - a | 0;

          if ((a | 0) < 0) {
            b[c >> 2] = g;
            b[h >> 2] = f;
            b[i >> 2] = 0;
            d = f;
            f = g;
            a = 0;
          } else { f = e; }

          e = (d | 0) < (f | 0) ? d : f;
          e = (a | 0) < (e | 0) ? a : e;
          if ((e | 0) <= 0) { return; }
          b[c >> 2] = f - e;
          b[h >> 2] = d - e;
          b[i >> 2] = a - e;
          return;
        }

        function Wa(a) {
          a = a | 0;
          var c = 0,
              d = 0,
              e = 0,
              f = 0;
          c = a + 8 | 0;
          f = b[c >> 2] | 0;
          d = f - (b[a >> 2] | 0) | 0;
          b[a >> 2] = d;
          e = a + 4 | 0;
          a = (b[e >> 2] | 0) - f | 0;
          b[e >> 2] = a;
          b[c >> 2] = 0 - (a + d);
          return;
        }

        function Xa(a) {
          a = a | 0;
          var c = 0,
              d = 0,
              e = 0,
              f = 0,
              g = 0,
              h = 0,
              i = 0;
          d = b[a >> 2] | 0;
          c = 0 - d | 0;
          b[a >> 2] = c;
          h = a + 8 | 0;
          b[h >> 2] = 0;
          i = a + 4 | 0;
          e = b[i >> 2] | 0;
          f = e + d | 0;

          if ((d | 0) > 0) {
            b[i >> 2] = f;
            b[h >> 2] = d;
            b[a >> 2] = 0;
            c = 0;
            e = f;
          } else { d = 0; }

          if ((e | 0) < 0) {
            g = c - e | 0;
            b[a >> 2] = g;
            d = d - e | 0;
            b[h >> 2] = d;
            b[i >> 2] = 0;
            f = g - d | 0;
            c = 0 - d | 0;

            if ((d | 0) < 0) {
              b[a >> 2] = f;
              b[i >> 2] = c;
              b[h >> 2] = 0;
              e = c;
              d = 0;
            } else {
              e = 0;
              f = g;
            }
          } else { f = c; }

          c = (e | 0) < (f | 0) ? e : f;
          c = (d | 0) < (c | 0) ? d : c;
          if ((c | 0) <= 0) { return; }
          b[a >> 2] = f - c;
          b[i >> 2] = e - c;
          b[h >> 2] = d - c;
          return;
        }

        function Ya(a, c, d, e, f) {
          a = a | 0;
          c = c | 0;
          d = d | 0;
          e = e | 0;
          f = f | 0;
          var g = 0,
              h = 0,
              i = 0,
              j = 0,
              k = 0,
              l = 0,
              m = 0;
          m = S;
          S = S + 64 | 0;
          l = m;
          i = m + 56 | 0;

          if (!(0 == 0 & (c & 2013265920 | 0) == 134217728 & (0 == 0 & (e & 2013265920 | 0) == 134217728))) {
            f = 5;
            S = m;
            return f | 0;
          }

          if ((a | 0) == (d | 0) & (c | 0) == (e | 0)) {
            b[f >> 2] = 0;
            f = 0;
            S = m;
            return f | 0;
          }

          h = qd(a | 0, c | 0, 52) | 0;
          G() | 0;
          h = h & 15;
          k = qd(d | 0, e | 0, 52) | 0;
          G() | 0;

          if ((h | 0) != (k & 15 | 0)) {
            f = 12;
            S = m;
            return f | 0;
          }

          g = h + -1 | 0;

          if (h >>> 0 > 1) {
            sb(a, c, g, l) | 0;
            sb(d, e, g, i) | 0;
            k = l;
            j = b[k >> 2] | 0;
            k = b[k + 4 >> 2] | 0;

            a: do { if ((j | 0) == (b[i >> 2] | 0) ? (k | 0) == (b[i + 4 >> 2] | 0) : 0) {
              h = (h ^ 15) * 3 | 0;
              g = qd(a | 0, c | 0, h | 0) | 0;
              G() | 0;
              g = g & 7;
              h = qd(d | 0, e | 0, h | 0) | 0;
              G() | 0;
              h = h & 7;

              do { if (!((g | 0) == 0 | (h | 0) == 0)) {
                if ((g | 0) == 7) { g = 5; }else {
                  if ((g | 0) == 1 | (h | 0) == 1 ? ub(j, k) | 0 : 0) {
                    g = 5;
                    break;
                  }

                  if ((b[15536 + (g << 2) >> 2] | 0) != (h | 0) ? (b[15568 + (g << 2) >> 2] | 0) != (h | 0) : 0) { break a; }
                  b[f >> 2] = 1;
                  g = 0;
                }
              } else {
                b[f >> 2] = 1;
                g = 0;
              } } while (0);

              f = g;
              S = m;
              return f | 0;
            } } while (0);
          }

          g = l;
          h = g + 56 | 0;

          do {
            b[g >> 2] = 0;
            g = g + 4 | 0;
          } while ((g | 0) < (h | 0));

          $(a, c, 1, l) | 0;
          c = l;

          if (((((!((b[c >> 2] | 0) == (d | 0) ? (b[c + 4 >> 2] | 0) == (e | 0) : 0) ? (c = l + 8 | 0, !((b[c >> 2] | 0) == (d | 0) ? (b[c + 4 >> 2] | 0) == (e | 0) : 0)) : 0) ? (c = l + 16 | 0, !((b[c >> 2] | 0) == (d | 0) ? (b[c + 4 >> 2] | 0) == (e | 0) : 0)) : 0) ? (c = l + 24 | 0, !((b[c >> 2] | 0) == (d | 0) ? (b[c + 4 >> 2] | 0) == (e | 0) : 0)) : 0) ? (c = l + 32 | 0, !((b[c >> 2] | 0) == (d | 0) ? (b[c + 4 >> 2] | 0) == (e | 0) : 0)) : 0) ? (c = l + 40 | 0, !((b[c >> 2] | 0) == (d | 0) ? (b[c + 4 >> 2] | 0) == (e | 0) : 0)) : 0) {
            g = l + 48 | 0;
            g = ((b[g >> 2] | 0) == (d | 0) ? (b[g + 4 >> 2] | 0) == (e | 0) : 0) & 1;
          } else { g = 1; }

          b[f >> 2] = g;
          f = 0;
          S = m;
          return f | 0;
        }

        function Za(a, c, d, e, f) {
          a = a | 0;
          c = c | 0;
          d = d | 0;
          e = e | 0;
          f = f | 0;
          d = ea(a, c, d, e) | 0;

          if ((d | 0) == 7) {
            f = 11;
            return f | 0;
          }

          e = rd(d | 0, 0, 56) | 0;
          c = c & -2130706433 | (G() | 0) | 268435456;
          b[f >> 2] = a | e;
          b[f + 4 >> 2] = c;
          f = 0;
          return f | 0;
        }

        function _a(a, c, d) {
          a = a | 0;
          c = c | 0;
          d = d | 0;

          if (!(0 == 0 & (c & 2013265920 | 0) == 268435456)) {
            d = 6;
            return d | 0;
          }

          b[d >> 2] = a;
          b[d + 4 >> 2] = c & -2130706433 | 134217728;
          d = 0;
          return d | 0;
        }

        function $a(a, c, d) {
          a = a | 0;
          c = c | 0;
          d = d | 0;
          var e = 0,
              f = 0,
              g = 0;
          f = S;
          S = S + 16 | 0;
          e = f;
          b[e >> 2] = 0;

          if (!(0 == 0 & (c & 2013265920 | 0) == 268435456)) {
            e = 6;
            S = f;
            return e | 0;
          }

          g = qd(a | 0, c | 0, 56) | 0;
          G() | 0;
          e = da(a, c & -2130706433 | 134217728, g & 7, e, d) | 0;
          S = f;
          return e | 0;
        }

        function ab(a, b) {
          a = a | 0;
          b = b | 0;
          var c = 0;
          c = qd(a | 0, b | 0, 56) | 0;
          G() | 0;

          switch (c & 7) {
            case 0:
            case 7:
              {
                c = 0;
                return c | 0;
              }

          }

          c = b & -2130706433 | 134217728;

          if (!(0 == 0 & (b & 2013265920 | 0) == 268435456)) {
            c = 0;
            return c | 0;
          }

          if (0 == 0 & (b & 117440512 | 0) == 16777216 & (ub(a, c) | 0) != 0) {
            c = 0;
            return c | 0;
          }

          c = rb(a, c) | 0;
          return c | 0;
        }

        function bb(a, c, d) {
          a = a | 0;
          c = c | 0;
          d = d | 0;
          var e = 0,
              f = 0,
              g = 0,
              h = 0;
          f = S;
          S = S + 16 | 0;
          e = f;

          if (!(0 == 0 & (c & 2013265920 | 0) == 268435456)) {
            e = 6;
            S = f;
            return e | 0;
          }

          g = c & -2130706433 | 134217728;
          h = d;
          b[h >> 2] = a;
          b[h + 4 >> 2] = g;
          b[e >> 2] = 0;
          c = qd(a | 0, c | 0, 56) | 0;
          G() | 0;
          e = da(a, g, c & 7, e, d + 8 | 0) | 0;
          S = f;
          return e | 0;
        }

        function cb(a, c, d) {
          a = a | 0;
          c = c | 0;
          d = d | 0;
          var e = 0,
              f = 0;
          f = (ub(a, c) | 0) == 0;
          c = c & -2130706433;
          e = d;
          b[e >> 2] = f ? a : 0;
          b[e + 4 >> 2] = f ? c | 285212672 : 0;
          e = d + 8 | 0;
          b[e >> 2] = a;
          b[e + 4 >> 2] = c | 301989888;
          e = d + 16 | 0;
          b[e >> 2] = a;
          b[e + 4 >> 2] = c | 318767104;
          e = d + 24 | 0;
          b[e >> 2] = a;
          b[e + 4 >> 2] = c | 335544320;
          e = d + 32 | 0;
          b[e >> 2] = a;
          b[e + 4 >> 2] = c | 352321536;
          d = d + 40 | 0;
          b[d >> 2] = a;
          b[d + 4 >> 2] = c | 369098752;
          return 0;
        }

        function db(a, c, d) {
          a = a | 0;
          c = c | 0;
          d = d | 0;
          var e = 0,
              f = 0,
              g = 0,
              h = 0,
              i = 0;
          i = S;
          S = S + 16 | 0;
          g = i;
          h = c & -2130706433 | 134217728;

          if (!(0 == 0 & (c & 2013265920 | 0) == 268435456)) {
            h = 6;
            S = i;
            return h | 0;
          }

          f = qd(a | 0, c | 0, 56) | 0;
          G() | 0;
          f = Pc(a, h, f & 7) | 0;

          if ((f | 0) == -1) {
            b[d >> 2] = 0;
            h = 6;
            S = i;
            return h | 0;
          }

          e = Lb(a, h, g) | 0;

          do { if (!e) {
            e = qd(a | 0, c | 0, 52) | 0;
            G() | 0;
            e = e & 15;

            if (!(ub(a, h) | 0)) {
              nb(g, e, f, 2, d);
              e = 0;
              break;
            } else {
              jb(g, e, f, 2, d);
              e = 0;
              break;
            }
          } } while (0);

          h = e;
          S = i;
          return h | 0;
        }

        function eb(a, b, c) {
          a = a | 0;
          b = b | 0;
          c = c | 0;
          var d = 0,
              e = 0;
          d = S;
          S = S + 16 | 0;
          e = d;
          fb(a, b, c, e);
          Ba(e, c + 4 | 0);
          S = d;
          return;
        }

        function fb(a, c, d, f) {
          a = a | 0;
          c = c | 0;
          d = d | 0;
          f = f | 0;
          var g = 0.0,
              h = 0.0,
              i = 0.0,
              j = 0,
              k = 0;
          j = S;
          S = S + 16 | 0;
          k = j;
          gb(a, d, k);
          h = +w(+(1.0 - +e[k >> 3] * .5));

          if (h < 1.0e-16) {
            b[f >> 2] = 0;
            b[f + 4 >> 2] = 0;
            b[f + 8 >> 2] = 0;
            b[f + 12 >> 2] = 0;
            S = j;
            return;
          }

          k = b[d >> 2] | 0;
          g = +e[15920 + (k * 24 | 0) >> 3];
          g = +Ub(g - +Ub(+Zb(15600 + (k << 4) | 0, a)));
          if (!(Ib(c) | 0)) { i = g; }else { i = +Ub(g + -.3334731722518321); }
          g = +v(+h) / .381966011250105;

          if ((c | 0) > 0) {
            a = 0;

            do {
              g = g * 2.6457513110645907;
              a = a + 1 | 0;
            } while ((a | 0) != (c | 0));
          }

          h = +t(+i) * g;
          e[f >> 3] = h;
          i = +u(+i) * g;
          e[f + 8 >> 3] = i;
          S = j;
          return;
        }

        function gb(a, c, d) {
          a = a | 0;
          c = c | 0;
          d = d | 0;
          var f = 0.0,
              g = 0,
              h = 0;
          h = S;
          S = S + 32 | 0;
          g = h;
          Oc(a, g);
          b[c >> 2] = 0;
          e[d >> 3] = 5.0;
          f = +Nc(16400, g);

          if (f < +e[d >> 3]) {
            b[c >> 2] = 0;
            e[d >> 3] = f;
          }

          f = +Nc(16424, g);

          if (f < +e[d >> 3]) {
            b[c >> 2] = 1;
            e[d >> 3] = f;
          }

          f = +Nc(16448, g);

          if (f < +e[d >> 3]) {
            b[c >> 2] = 2;
            e[d >> 3] = f;
          }

          f = +Nc(16472, g);

          if (f < +e[d >> 3]) {
            b[c >> 2] = 3;
            e[d >> 3] = f;
          }

          f = +Nc(16496, g);

          if (f < +e[d >> 3]) {
            b[c >> 2] = 4;
            e[d >> 3] = f;
          }

          f = +Nc(16520, g);

          if (f < +e[d >> 3]) {
            b[c >> 2] = 5;
            e[d >> 3] = f;
          }

          f = +Nc(16544, g);

          if (f < +e[d >> 3]) {
            b[c >> 2] = 6;
            e[d >> 3] = f;
          }

          f = +Nc(16568, g);

          if (f < +e[d >> 3]) {
            b[c >> 2] = 7;
            e[d >> 3] = f;
          }

          f = +Nc(16592, g);

          if (f < +e[d >> 3]) {
            b[c >> 2] = 8;
            e[d >> 3] = f;
          }

          f = +Nc(16616, g);

          if (f < +e[d >> 3]) {
            b[c >> 2] = 9;
            e[d >> 3] = f;
          }

          f = +Nc(16640, g);

          if (f < +e[d >> 3]) {
            b[c >> 2] = 10;
            e[d >> 3] = f;
          }

          f = +Nc(16664, g);

          if (f < +e[d >> 3]) {
            b[c >> 2] = 11;
            e[d >> 3] = f;
          }

          f = +Nc(16688, g);

          if (f < +e[d >> 3]) {
            b[c >> 2] = 12;
            e[d >> 3] = f;
          }

          f = +Nc(16712, g);

          if (f < +e[d >> 3]) {
            b[c >> 2] = 13;
            e[d >> 3] = f;
          }

          f = +Nc(16736, g);

          if (f < +e[d >> 3]) {
            b[c >> 2] = 14;
            e[d >> 3] = f;
          }

          f = +Nc(16760, g);

          if (f < +e[d >> 3]) {
            b[c >> 2] = 15;
            e[d >> 3] = f;
          }

          f = +Nc(16784, g);

          if (f < +e[d >> 3]) {
            b[c >> 2] = 16;
            e[d >> 3] = f;
          }

          f = +Nc(16808, g);

          if (f < +e[d >> 3]) {
            b[c >> 2] = 17;
            e[d >> 3] = f;
          }

          f = +Nc(16832, g);

          if (f < +e[d >> 3]) {
            b[c >> 2] = 18;
            e[d >> 3] = f;
          }

          f = +Nc(16856, g);

          if (!(f < +e[d >> 3])) {
            S = h;
            return;
          }

          b[c >> 2] = 19;
          e[d >> 3] = f;
          S = h;
          return;
        }

        function hb(a, c, d, f, g) {
          a = a | 0;
          c = c | 0;
          d = d | 0;
          f = f | 0;
          g = g | 0;
          var h = 0.0,
              i = 0.0;
          h = +Kc(a);

          if (h < 1.0e-16) {
            c = 15600 + (c << 4) | 0;
            b[g >> 2] = b[c >> 2];
            b[g + 4 >> 2] = b[c + 4 >> 2];
            b[g + 8 >> 2] = b[c + 8 >> 2];
            b[g + 12 >> 2] = b[c + 12 >> 2];
            return;
          }

          i = +z(+ +e[a + 8 >> 3], + +e[a >> 3]);

          if ((d | 0) > 0) {
            a = 0;

            do {
              h = h / 2.6457513110645907;
              a = a + 1 | 0;
            } while ((a | 0) != (d | 0));
          }

          if (!f) {
            h = +y(+(h * .381966011250105));
            if (Ib(d) | 0) { i = +Ub(i + .3334731722518321); }
          } else {
            h = h / 3.0;
            d = (Ib(d) | 0) == 0;
            h = +y(+((d ? h : h / 2.6457513110645907) * .381966011250105));
          }

          _b(15600 + (c << 4) | 0, +Ub(+e[15920 + (c * 24 | 0) >> 3] - i), h, g);

          return;
        }

        function ib(a, c, d) {
          a = a | 0;
          c = c | 0;
          d = d | 0;
          var e = 0,
              f = 0;
          e = S;
          S = S + 16 | 0;
          f = e;
          Da(a + 4 | 0, f);
          hb(f, b[a >> 2] | 0, c, 0, d);
          S = e;
          return;
        }

        function jb(a, c, d, f, g) {
          a = a | 0;
          c = c | 0;
          d = d | 0;
          f = f | 0;
          g = g | 0;
          var h = 0,
              i = 0,
              j = 0,
              k = 0,
              l = 0,
              m = 0,
              n = 0,
              o = 0,
              p = 0,
              q = 0,
              r = 0,
              s = 0,
              t = 0,
              u = 0,
              v = 0,
              w = 0,
              x = 0,
              y = 0,
              z = 0,
              A = 0,
              B = 0,
              C = 0,
              D = 0,
              E = 0,
              F = 0,
              G = 0,
              I = 0.0,
              J = 0.0;
          G = S;
          S = S + 272 | 0;
          h = G + 256 | 0;
          u = G + 240 | 0;
          D = G;
          E = G + 224 | 0;
          F = G + 208 | 0;
          v = G + 176 | 0;
          w = G + 160 | 0;
          x = G + 192 | 0;
          y = G + 144 | 0;
          z = G + 128 | 0;
          A = G + 112 | 0;
          B = G + 96 | 0;
          C = G + 80 | 0;
          b[h >> 2] = c;
          b[u >> 2] = b[a >> 2];
          b[u + 4 >> 2] = b[a + 4 >> 2];
          b[u + 8 >> 2] = b[a + 8 >> 2];
          b[u + 12 >> 2] = b[a + 12 >> 2];
          kb(u, h, D);
          b[g >> 2] = 0;
          u = f + d + ((f | 0) == 5 & 1) | 0;

          if ((u | 0) <= (d | 0)) {
            S = G;
            return;
          }

          k = b[h >> 2] | 0;
          l = E + 4 | 0;
          m = v + 4 | 0;
          n = d + 5 | 0;
          o = 16880 + (k << 2) | 0;
          p = 16960 + (k << 2) | 0;
          q = z + 8 | 0;
          r = A + 8 | 0;
          s = B + 8 | 0;
          t = F + 4 | 0;
          j = d;

          a: while (1) {
            i = D + (((j | 0) % 5 | 0) << 4) | 0;
            b[F >> 2] = b[i >> 2];
            b[F + 4 >> 2] = b[i + 4 >> 2];
            b[F + 8 >> 2] = b[i + 8 >> 2];
            b[F + 12 >> 2] = b[i + 12 >> 2];

            do {} while ((lb(F, k, 0, 1) | 0) == 2);

            if ((j | 0) > (d | 0) & (Ib(c) | 0) != 0) {
              b[v >> 2] = b[F >> 2];
              b[v + 4 >> 2] = b[F + 4 >> 2];
              b[v + 8 >> 2] = b[F + 8 >> 2];
              b[v + 12 >> 2] = b[F + 12 >> 2];
              Da(l, w);
              f = b[v >> 2] | 0;
              h = b[17040 + (f * 80 | 0) + (b[E >> 2] << 2) >> 2] | 0;
              b[v >> 2] = b[18640 + (f * 80 | 0) + (h * 20 | 0) >> 2];
              i = b[18640 + (f * 80 | 0) + (h * 20 | 0) + 16 >> 2] | 0;

              if ((i | 0) > 0) {
                a = 0;

                do {
                  Na(m);
                  a = a + 1 | 0;
                } while ((a | 0) < (i | 0));
              }

              i = 18640 + (f * 80 | 0) + (h * 20 | 0) + 4 | 0;
              b[x >> 2] = b[i >> 2];
              b[x + 4 >> 2] = b[i + 4 >> 2];
              b[x + 8 >> 2] = b[i + 8 >> 2];
              Ga(x, (b[o >> 2] | 0) * 3 | 0);
              Ea(m, x, m);
              Ca(m);
              Da(m, y);
              I = +(b[p >> 2] | 0);
              e[z >> 3] = I * 3.0;
              e[q >> 3] = 0.0;
              J = I * -1.5;
              e[A >> 3] = J;
              e[r >> 3] = I * 2.598076211353316;
              e[B >> 3] = J;
              e[s >> 3] = I * -2.598076211353316;

              switch (b[17040 + ((b[v >> 2] | 0) * 80 | 0) + (b[F >> 2] << 2) >> 2] | 0) {
                case 1:
                  {
                    a = A;
                    f = z;
                    break;
                  }

                case 3:
                  {
                    a = B;
                    f = A;
                    break;
                  }

                case 2:
                  {
                    a = z;
                    f = B;
                    break;
                  }

                default:
                  {
                    a = 12;
                    break a;
                  }
              }

              Lc(w, y, f, a, C);
              hb(C, b[v >> 2] | 0, k, 1, g + 8 + (b[g >> 2] << 4) | 0);
              b[g >> 2] = (b[g >> 2] | 0) + 1;
            }

            if ((j | 0) < (n | 0)) {
              Da(t, v);
              hb(v, b[F >> 2] | 0, k, 1, g + 8 + (b[g >> 2] << 4) | 0);
              b[g >> 2] = (b[g >> 2] | 0) + 1;
            }
            b[E >> 2] = b[F >> 2];
            b[E + 4 >> 2] = b[F + 4 >> 2];
            b[E + 8 >> 2] = b[F + 8 >> 2];
            b[E + 12 >> 2] = b[F + 12 >> 2];
            j = j + 1 | 0;

            if ((j | 0) >= (u | 0)) {
              a = 3;
              break;
            }
          }

          if ((a | 0) == 3) {
            S = G;
            return;
          } else if ((a | 0) == 12) { H(22416, 22463, 571, 22473); }
        }

        function kb(a, c, d) {
          a = a | 0;
          c = c | 0;
          d = d | 0;
          var e = 0,
              f = 0,
              g = 0,
              h = 0,
              i = 0,
              j = 0;
          j = S;
          S = S + 128 | 0;
          e = j + 64 | 0;
          f = j;
          g = e;
          h = 20240;
          i = g + 60 | 0;

          do {
            b[g >> 2] = b[h >> 2];
            g = g + 4 | 0;
            h = h + 4 | 0;
          } while ((g | 0) < (i | 0));

          g = f;
          h = 20304;
          i = g + 60 | 0;

          do {
            b[g >> 2] = b[h >> 2];
            g = g + 4 | 0;
            h = h + 4 | 0;
          } while ((g | 0) < (i | 0));

          i = (Ib(b[c >> 2] | 0) | 0) == 0;
          e = i ? e : f;
          f = a + 4 | 0;
          Ra(f);
          Sa(f);

          if (Ib(b[c >> 2] | 0) | 0) {
            La(f);
            b[c >> 2] = (b[c >> 2] | 0) + 1;
          }

          b[d >> 2] = b[a >> 2];
          c = d + 4 | 0;
          Ea(f, e, c);
          Ca(c);
          b[d + 16 >> 2] = b[a >> 2];
          c = d + 20 | 0;
          Ea(f, e + 12 | 0, c);
          Ca(c);
          b[d + 32 >> 2] = b[a >> 2];
          c = d + 36 | 0;
          Ea(f, e + 24 | 0, c);
          Ca(c);
          b[d + 48 >> 2] = b[a >> 2];
          c = d + 52 | 0;
          Ea(f, e + 36 | 0, c);
          Ca(c);
          b[d + 64 >> 2] = b[a >> 2];
          d = d + 68 | 0;
          Ea(f, e + 48 | 0, d);
          Ca(d);
          S = j;
          return;
        }

        function lb(a, c, d, e) {
          a = a | 0;
          c = c | 0;
          d = d | 0;
          e = e | 0;
          var f = 0,
              g = 0,
              h = 0,
              i = 0,
              j = 0,
              k = 0,
              l = 0,
              m = 0,
              n = 0,
              o = 0,
              p = 0;
          p = S;
          S = S + 32 | 0;
          n = p + 12 | 0;
          i = p;
          o = a + 4 | 0;
          m = b[16960 + (c << 2) >> 2] | 0;
          l = (e | 0) != 0;
          m = l ? m * 3 | 0 : m;
          f = b[o >> 2] | 0;
          k = a + 8 | 0;
          h = b[k >> 2] | 0;

          if (l) {
            g = a + 12 | 0;
            e = b[g >> 2] | 0;
            f = h + f + e | 0;

            if ((f | 0) == (m | 0)) {
              o = 1;
              S = p;
              return o | 0;
            } else { j = g; }
          } else {
            j = a + 12 | 0;
            e = b[j >> 2] | 0;
            f = h + f + e | 0;
          }

          if ((f | 0) <= (m | 0)) {
            o = 0;
            S = p;
            return o | 0;
          }

          do { if ((e | 0) > 0) {
            e = b[a >> 2] | 0;

            if ((h | 0) > 0) {
              g = 18640 + (e * 80 | 0) + 60 | 0;
              e = a;
              break;
            }

            e = 18640 + (e * 80 | 0) + 40 | 0;

            if (!d) {
              g = e;
              e = a;
            } else {
              Aa(n, m, 0, 0);
              Fa(o, n, i);
              Oa(i);
              Ea(i, n, o);
              g = e;
              e = a;
            }
          } else {
            g = 18640 + ((b[a >> 2] | 0) * 80 | 0) + 20 | 0;
            e = a;
          } } while (0);

          b[e >> 2] = b[g >> 2];
          f = g + 16 | 0;

          if ((b[f >> 2] | 0) > 0) {
            e = 0;

            do {
              Na(o);
              e = e + 1 | 0;
            } while ((e | 0) < (b[f >> 2] | 0));
          }

          a = g + 4 | 0;
          b[n >> 2] = b[a >> 2];
          b[n + 4 >> 2] = b[a + 4 >> 2];
          b[n + 8 >> 2] = b[a + 8 >> 2];
          c = b[16880 + (c << 2) >> 2] | 0;
          Ga(n, l ? c * 3 | 0 : c);
          Ea(o, n, o);
          Ca(o);
          if (l) { e = ((b[k >> 2] | 0) + (b[o >> 2] | 0) + (b[j >> 2] | 0) | 0) == (m | 0) ? 1 : 2; }else { e = 2; }
          o = e;
          S = p;
          return o | 0;
        }

        function mb(a, b) {
          a = a | 0;
          b = b | 0;
          var c = 0;

          do { c = lb(a, b, 0, 1) | 0; } while ((c | 0) == 2);

          return c | 0;
        }

        function nb(a, c, d, f, g) {
          a = a | 0;
          c = c | 0;
          d = d | 0;
          f = f | 0;
          g = g | 0;
          var h = 0,
              i = 0,
              j = 0,
              k = 0,
              l = 0,
              m = 0,
              n = 0,
              o = 0,
              p = 0,
              q = 0,
              r = 0,
              s = 0,
              t = 0,
              u = 0,
              v = 0,
              w = 0,
              x = 0,
              y = 0,
              z = 0,
              A = 0,
              B = 0,
              C = 0.0,
              D = 0.0;
          B = S;
          S = S + 240 | 0;
          h = B + 224 | 0;
          x = B + 208 | 0;
          y = B;
          z = B + 192 | 0;
          A = B + 176 | 0;
          s = B + 160 | 0;
          t = B + 144 | 0;
          u = B + 128 | 0;
          v = B + 112 | 0;
          w = B + 96 | 0;
          b[h >> 2] = c;
          b[x >> 2] = b[a >> 2];
          b[x + 4 >> 2] = b[a + 4 >> 2];
          b[x + 8 >> 2] = b[a + 8 >> 2];
          b[x + 12 >> 2] = b[a + 12 >> 2];
          ob(x, h, y);
          b[g >> 2] = 0;
          r = f + d + ((f | 0) == 6 & 1) | 0;

          if ((r | 0) <= (d | 0)) {
            S = B;
            return;
          }

          k = b[h >> 2] | 0;
          l = d + 6 | 0;
          m = 16960 + (k << 2) | 0;
          n = t + 8 | 0;
          o = u + 8 | 0;
          p = v + 8 | 0;
          q = z + 4 | 0;
          i = 0;
          j = d;
          f = -1;

          a: while (1) {
            h = (j | 0) % 6 | 0;
            a = y + (h << 4) | 0;
            b[z >> 2] = b[a >> 2];
            b[z + 4 >> 2] = b[a + 4 >> 2];
            b[z + 8 >> 2] = b[a + 8 >> 2];
            b[z + 12 >> 2] = b[a + 12 >> 2];
            a = i;
            i = lb(z, k, 0, 1) | 0;

            if ((j | 0) > (d | 0) & (Ib(c) | 0) != 0 ? (a | 0) != 1 ? (b[z >> 2] | 0) != (f | 0) : 0 : 0) {
              Da(y + (((h + 5 | 0) % 6 | 0) << 4) + 4 | 0, A);
              Da(y + (h << 4) + 4 | 0, s);
              C = +(b[m >> 2] | 0);
              e[t >> 3] = C * 3.0;
              e[n >> 3] = 0.0;
              D = C * -1.5;
              e[u >> 3] = D;
              e[o >> 3] = C * 2.598076211353316;
              e[v >> 3] = D;
              e[p >> 3] = C * -2.598076211353316;
              h = b[x >> 2] | 0;

              switch (b[17040 + (h * 80 | 0) + (((f | 0) == (h | 0) ? b[z >> 2] | 0 : f) << 2) >> 2] | 0) {
                case 1:
                  {
                    a = u;
                    f = t;
                    break;
                  }

                case 3:
                  {
                    a = v;
                    f = u;
                    break;
                  }

                case 2:
                  {
                    a = t;
                    f = v;
                    break;
                  }

                default:
                  {
                    a = 8;
                    break a;
                  }
              }

              Lc(A, s, f, a, w);

              if (!(Mc(A, w) | 0) ? !(Mc(s, w) | 0) : 0) {
                hb(w, b[x >> 2] | 0, k, 1, g + 8 + (b[g >> 2] << 4) | 0);
                b[g >> 2] = (b[g >> 2] | 0) + 1;
              }
            }

            if ((j | 0) < (l | 0)) {
              Da(q, A);
              hb(A, b[z >> 2] | 0, k, 1, g + 8 + (b[g >> 2] << 4) | 0);
              b[g >> 2] = (b[g >> 2] | 0) + 1;
            }

            j = j + 1 | 0;

            if ((j | 0) >= (r | 0)) {
              a = 3;
              break;
            } else { f = b[z >> 2] | 0; }
          }

          if ((a | 0) == 3) {
            S = B;
            return;
          } else if ((a | 0) == 8) { H(22500, 22463, 736, 22545); }
        }

        function ob(a, c, d) {
          a = a | 0;
          c = c | 0;
          d = d | 0;
          var e = 0,
              f = 0,
              g = 0,
              h = 0,
              i = 0,
              j = 0;
          j = S;
          S = S + 160 | 0;
          e = j + 80 | 0;
          f = j;
          g = e;
          h = 20368;
          i = g + 72 | 0;

          do {
            b[g >> 2] = b[h >> 2];
            g = g + 4 | 0;
            h = h + 4 | 0;
          } while ((g | 0) < (i | 0));

          g = f;
          h = 20448;
          i = g + 72 | 0;

          do {
            b[g >> 2] = b[h >> 2];
            g = g + 4 | 0;
            h = h + 4 | 0;
          } while ((g | 0) < (i | 0));

          i = (Ib(b[c >> 2] | 0) | 0) == 0;
          e = i ? e : f;
          f = a + 4 | 0;
          Ra(f);
          Sa(f);

          if (Ib(b[c >> 2] | 0) | 0) {
            La(f);
            b[c >> 2] = (b[c >> 2] | 0) + 1;
          }

          b[d >> 2] = b[a >> 2];
          c = d + 4 | 0;
          Ea(f, e, c);
          Ca(c);
          b[d + 16 >> 2] = b[a >> 2];
          c = d + 20 | 0;
          Ea(f, e + 12 | 0, c);
          Ca(c);
          b[d + 32 >> 2] = b[a >> 2];
          c = d + 36 | 0;
          Ea(f, e + 24 | 0, c);
          Ca(c);
          b[d + 48 >> 2] = b[a >> 2];
          c = d + 52 | 0;
          Ea(f, e + 36 | 0, c);
          Ca(c);
          b[d + 64 >> 2] = b[a >> 2];
          c = d + 68 | 0;
          Ea(f, e + 48 | 0, c);
          Ca(c);
          b[d + 80 >> 2] = b[a >> 2];
          d = d + 84 | 0;
          Ea(f, e + 60 | 0, d);
          Ca(d);
          S = j;
          return;
        }

        function pb(a, b) {
          a = a | 0;
          b = b | 0;
          b = qd(a | 0, b | 0, 52) | 0;
          G() | 0;
          return b & 15 | 0;
        }

        function qb(a, b) {
          a = a | 0;
          b = b | 0;
          b = qd(a | 0, b | 0, 45) | 0;
          G() | 0;
          return b & 127 | 0;
        }

        function rb(a, b) {
          a = a | 0;
          b = b | 0;
          var c = 0,
              d = 0,
              e = 0,
              f = 0,
              g = 0,
              h = 0;

          if (!(0 == 0 & (b & -16777216 | 0) == 134217728)) {
            b = 0;
            return b | 0;
          }

          g = qd(a | 0, b | 0, 45) | 0;
          G() | 0;
          g = g & 127;

          if (g >>> 0 > 121) {
            b = 0;
            return b | 0;
          }

          c = qd(a | 0, b | 0, 52) | 0;
          G() | 0;
          c = c & 15;

          do { if (c | 0) {
            e = 1;
            d = 0;

            while (1) {
              f = qd(a | 0, b | 0, (15 - e | 0) * 3 | 0) | 0;
              G() | 0;
              f = f & 7;
              if ((f | 0) != 0 & (d ^ 1)) { if ((f | 0) == 1 & (la(g) | 0) != 0) {
                h = 0;
                d = 13;
                break;
              } else { d = 1; } }

              if ((f | 0) == 7) {
                h = 0;
                d = 13;
                break;
              }

              if (e >>> 0 < c >>> 0) { e = e + 1 | 0; }else {
                d = 9;
                break;
              }
            }

            if ((d | 0) == 9) {
              if ((c | 0) == 15) { h = 1; }else { break; }
              return h | 0;
            } else if ((d | 0) == 13) { return h | 0; }
          } } while (0);

          while (1) {
            h = qd(a | 0, b | 0, (14 - c | 0) * 3 | 0) | 0;
            G() | 0;

            if (!((h & 7 | 0) == 7 & 0 == 0)) {
              h = 0;
              d = 13;
              break;
            }

            if (c >>> 0 < 14) { c = c + 1 | 0; }else {
              h = 1;
              d = 13;
              break;
            }
          }

          if ((d | 0) == 13) { return h | 0; }
          return 0;
        }

        function sb(a, c, d, e) {
          a = a | 0;
          c = c | 0;
          d = d | 0;
          e = e | 0;
          var f = 0,
              g = 0;
          g = qd(a | 0, c | 0, 52) | 0;
          G() | 0;
          g = g & 15;

          if (d >>> 0 > 15) {
            e = 4;
            return e | 0;
          }

          if ((g | 0) < (d | 0)) {
            e = 12;
            return e | 0;
          }

          if ((g | 0) == (d | 0)) {
            b[e >> 2] = a;
            b[e + 4 >> 2] = c;
            e = 0;
            return e | 0;
          }

          f = rd(d | 0, 0, 52) | 0;
          f = f | a;
          a = G() | 0 | c & -15728641;
          if ((g | 0) > (d | 0)) { do {
            c = rd(7, 0, (14 - d | 0) * 3 | 0) | 0;
            d = d + 1 | 0;
            f = c | f;
            a = G() | 0 | a;
          } while ((d | 0) < (g | 0)); }
          b[e >> 2] = f;
          b[e + 4 >> 2] = a;
          e = 0;
          return e | 0;
        }

        function tb(a, c, d, e) {
          a = a | 0;
          c = c | 0;
          d = d | 0;
          e = e | 0;
          var f = 0,
              g = 0,
              h = 0;
          g = qd(a | 0, c | 0, 52) | 0;
          G() | 0;
          g = g & 15;

          if (!((d | 0) < 16 & (g | 0) <= (d | 0))) {
            e = 4;
            return e | 0;
          }

          f = d - g | 0;
          d = qd(a | 0, c | 0, 45) | 0;
          G() | 0;

          a: do { if (!(la(d & 127) | 0)) {
            d = xc(7, 0, f, ((f | 0) < 0) << 31 >> 31) | 0;
            f = G() | 0;
          } else {
            b: do { if (g | 0) {
              d = 1;

              while (1) {
                h = rd(7, 0, (15 - d | 0) * 3 | 0) | 0;
                if (!((h & a | 0) == 0 & ((G() | 0) & c | 0) == 0)) { break; }
                if (d >>> 0 < g >>> 0) { d = d + 1 | 0; }else { break b; }
              }

              d = xc(7, 0, f, ((f | 0) < 0) << 31 >> 31) | 0;
              f = G() | 0;
              break a;
            } } while (0);

            d = xc(7, 0, f, ((f | 0) < 0) << 31 >> 31) | 0;
            d = md(d | 0, G() | 0, 5, 0) | 0;
            d = gd(d | 0, G() | 0, -5, -1) | 0;
            d = kd(d | 0, G() | 0, 6, 0) | 0;
            d = gd(d | 0, G() | 0, 1, 0) | 0;
            f = G() | 0;
          } } while (0);

          h = e;
          b[h >> 2] = d;
          b[h + 4 >> 2] = f;
          h = 0;
          return h | 0;
        }

        function ub(a, b) {
          a = a | 0;
          b = b | 0;
          var c = 0,
              d = 0,
              e = 0;
          e = qd(a | 0, b | 0, 45) | 0;
          G() | 0;

          if (!(la(e & 127) | 0)) {
            e = 0;
            return e | 0;
          }

          e = qd(a | 0, b | 0, 52) | 0;
          G() | 0;
          e = e & 15;

          a: do { if (!e) { c = 0; }else {
            d = 1;

            while (1) {
              c = qd(a | 0, b | 0, (15 - d | 0) * 3 | 0) | 0;
              G() | 0;
              c = c & 7;
              if (c | 0) { break a; }
              if (d >>> 0 < e >>> 0) { d = d + 1 | 0; }else {
                c = 0;
                break;
              }
            }
          } } while (0);

          e = (c | 0) == 0 & 1;
          return e | 0;
        }

        function vb(a, c, d, e) {
          a = a | 0;
          c = c | 0;
          d = d | 0;
          e = e | 0;
          var f = 0,
              g = 0,
              h = 0,
              i = 0;
          h = S;
          S = S + 16 | 0;
          g = h;
          Sb(g, a, c, d);
          c = g;
          a = b[c >> 2] | 0;
          c = b[c + 4 >> 2] | 0;

          if ((a | 0) == 0 & (c | 0) == 0) {
            S = h;
            return 0;
          }

          f = 0;
          d = 0;

          do {
            i = e + (f << 3) | 0;
            b[i >> 2] = a;
            b[i + 4 >> 2] = c;
            f = gd(f | 0, d | 0, 1, 0) | 0;
            d = G() | 0;
            Tb(g);
            i = g;
            a = b[i >> 2] | 0;
            c = b[i + 4 >> 2] | 0;
          } while (!((a | 0) == 0 & (c | 0) == 0));

          S = h;
          return 0;
        }

        function wb(a, b, c, d) {
          a = a | 0;
          b = b | 0;
          c = c | 0;
          d = d | 0;

          if ((d | 0) < (c | 0)) {
            c = b;
            d = a;
            F(c | 0);
            return d | 0;
          }

          c = rd(-1, -1, ((d - c | 0) * 3 | 0) + 3 | 0) | 0;
          d = rd(~c | 0, ~(G() | 0) | 0, (15 - d | 0) * 3 | 0) | 0;
          c = ~(G() | 0) & b;
          d = ~d & a;
          F(c | 0);
          return d | 0;
        }

        function xb(a, c, d, e) {
          a = a | 0;
          c = c | 0;
          d = d | 0;
          e = e | 0;
          var f = 0;
          f = qd(a | 0, c | 0, 52) | 0;
          G() | 0;
          f = f & 15;

          if (!((d | 0) < 16 & (f | 0) <= (d | 0))) {
            e = 4;
            return e | 0;
          }

          if ((f | 0) < (d | 0)) {
            f = rd(-1, -1, ((d + -1 - f | 0) * 3 | 0) + 3 | 0) | 0;
            f = rd(~f | 0, ~(G() | 0) | 0, (15 - d | 0) * 3 | 0) | 0;
            c = ~(G() | 0) & c;
            a = ~f & a;
          }

          f = rd(d | 0, 0, 52) | 0;
          d = c & -15728641 | (G() | 0);
          b[e >> 2] = a | f;
          b[e + 4 >> 2] = d;
          e = 0;
          return e | 0;
        }

        function yb(a, c, d, e) {
          a = a | 0;
          c = c | 0;
          d = d | 0;
          e = e | 0;
          var f = 0,
              g = 0,
              h = 0,
              i = 0,
              j = 0,
              k = 0,
              l = 0,
              m = 0,
              n = 0,
              o = 0,
              p = 0,
              q = 0,
              r = 0,
              s = 0,
              t = 0,
              u = 0,
              v = 0,
              w = 0,
              x = 0,
              y = 0,
              z = 0;

          if ((d | 0) == 0 & (e | 0) == 0) {
            y = 0;
            return y | 0;
          }

          f = a;
          g = b[f >> 2] | 0;
          f = b[f + 4 >> 2] | 0;

          if (0 == 0 & (f & 15728640 | 0) == 0) {
            if (!((e | 0) > 0 | (e | 0) == 0 & d >>> 0 > 0)) {
              y = 0;
              return y | 0;
            }

            y = c;
            b[y >> 2] = g;
            b[y + 4 >> 2] = f;

            if ((d | 0) == 1 & (e | 0) == 0) {
              y = 0;
              return y | 0;
            }

            f = 1;

            do {
              w = a + (f << 3) | 0;
              x = b[w + 4 >> 2] | 0;
              y = c + (f << 3) | 0;
              b[y >> 2] = b[w >> 2];
              b[y + 4 >> 2] = x;
              f = f + 1 | 0;
            } while (0 < (e | 0) | 0 == (e | 0) & f >>> 0 < d >>> 0);

            f = 0;
            return f | 0;
          }

          v = d << 3;
          x = dd(v) | 0;

          if (!x) {
            y = 13;
            return y | 0;
          }

          ud(x | 0, a | 0, v | 0) | 0;
          w = fd(d, 8) | 0;

          if (!w) {
            ed(x);
            y = 13;
            return y | 0;
          }

          a: do { if (d | 0) {
            b: while (1) {
              f = x;
              s = b[f >> 2] | 0;
              f = b[f + 4 >> 2] | 0;
              t = qd(s | 0, f | 0, 52) | 0;
              G() | 0;
              t = t & 15;
              u = t + -1 | 0;
              r = (d | 0) > 0;

              c: do { if ((t | 0) != 0 & r) {
                o = ((d | 0) < 0) << 31 >> 31;
                p = rd(u | 0, 0, 52) | 0;
                q = G() | 0;

                if (u >>> 0 > 15) {
                  if (!((s | 0) == 0 & (f | 0) == 0)) {
                    y = 17;
                    break b;
                  }

                  g = 0;

                  while (1) {
                    g = g + 1 | 0;
                    if ((g | 0) >= (d | 0)) { break c; }
                    e = x + (g << 3) | 0;
                    q = b[e >> 2] | 0;
                    e = b[e + 4 >> 2] | 0;

                    if (!((q | 0) == 0 & (e | 0) == 0)) {
                      f = e;
                      y = 17;
                      break b;
                    }
                  }
                }

                g = 0;
                a = s;
                e = f;

                while (1) {
                  if (!((a | 0) == 0 & (e | 0) == 0)) {
                    if (!(0 == 0 & (e & 117440512 | 0) == 0)) {
                      y = 22;
                      break b;
                    }

                    i = qd(a | 0, e | 0, 52) | 0;
                    G() | 0;
                    i = i & 15;

                    if ((i | 0) < (u | 0)) {
                      f = 12;
                      y = 28;
                      break b;
                    }

                    if ((i | 0) != (u | 0)) {
                      a = a | p;
                      e = e & -15728641 | q;

                      if (i >>> 0 >= t >>> 0) {
                        h = u;

                        do {
                          n = rd(7, 0, (14 - h | 0) * 3 | 0) | 0;
                          h = h + 1 | 0;
                          a = n | a;
                          e = G() | 0 | e;
                        } while (h >>> 0 < i >>> 0);
                      }
                    }

                    h = od(a | 0, e | 0, d | 0, o | 0) | 0;
                    G() | 0;
                    k = w + (h << 3) | 0;
                    i = k;
                    j = b[i >> 2] | 0;
                    i = b[i + 4 >> 2] | 0;
                    if ((j | 0) == 0 & (i | 0) == 0) { h = k; }else {
                      n = 0;

                      while (1) {
                        if ((n | 0) > (d | 0)) {
                          y = 32;
                          break b;
                        }

                        if ((j | 0) == (a | 0) & (i & -117440513 | 0) == (e | 0)) {
                          l = qd(j | 0, i | 0, 56) | 0;
                          G() | 0;
                          l = l & 7;
                          m = l + 1 | 0;
                          z = qd(j | 0, i | 0, 45) | 0;
                          G() | 0;

                          d: do { if (!(la(z & 127) | 0)) { i = 7; }else {
                            j = qd(j | 0, i | 0, 52) | 0;
                            G() | 0;
                            j = j & 15;

                            if (!j) {
                              i = 6;
                              break;
                            }

                            i = 1;

                            while (1) {
                              z = rd(7, 0, (15 - i | 0) * 3 | 0) | 0;

                              if (!((z & a | 0) == 0 & ((G() | 0) & e | 0) == 0)) {
                                i = 7;
                                break d;
                              }

                              if (i >>> 0 < j >>> 0) { i = i + 1 | 0; }else {
                                i = 6;
                                break;
                              }
                            }
                          } } while (0);

                          if ((l + 2 | 0) >>> 0 > i >>> 0) {
                            y = 42;
                            break b;
                          }

                          z = rd(m | 0, 0, 56) | 0;
                          e = G() | 0 | e & -117440513;
                          m = k;
                          b[m >> 2] = 0;
                          b[m + 4 >> 2] = 0;
                          a = z | a;
                        } else { h = (h + 1 | 0) % (d | 0) | 0; }

                        k = w + (h << 3) | 0;
                        i = k;
                        j = b[i >> 2] | 0;
                        i = b[i + 4 >> 2] | 0;

                        if ((j | 0) == 0 & (i | 0) == 0) {
                          h = k;
                          break;
                        } else { n = n + 1 | 0; }
                      }
                    }
                    z = h;
                    b[z >> 2] = a;
                    b[z + 4 >> 2] = e;
                  }

                  g = g + 1 | 0;
                  if ((g | 0) >= (d | 0)) { break c; }
                  e = x + (g << 3) | 0;
                  a = b[e >> 2] | 0;
                  e = b[e + 4 >> 2] | 0;
                }
              } } while (0);

              if ((d + 5 | 0) >>> 0 < 11) {
                y = 85;
                break;
              }

              q = fd((d | 0) / 6 | 0, 8) | 0;

              if (!q) {
                y = 49;
                break;
              }

              e: do { if (r) {
                n = 0;
                m = 0;

                do {
                  i = w + (n << 3) | 0;
                  e = i;
                  g = b[e >> 2] | 0;
                  e = b[e + 4 >> 2] | 0;

                  if (!((g | 0) == 0 & (e | 0) == 0)) {
                    j = qd(g | 0, e | 0, 56) | 0;
                    G() | 0;
                    j = j & 7;
                    a = j + 1 | 0;
                    k = e & -117440513;
                    z = qd(g | 0, e | 0, 45) | 0;
                    G() | 0;

                    f: do { if (la(z & 127) | 0) {
                      l = qd(g | 0, e | 0, 52) | 0;
                      G() | 0;
                      l = l & 15;

                      if (l | 0) {
                        h = 1;

                        while (1) {
                          z = rd(7, 0, (15 - h | 0) * 3 | 0) | 0;
                          if (!((g & z | 0) == 0 & (k & (G() | 0) | 0) == 0)) { break f; }
                          if (h >>> 0 < l >>> 0) { h = h + 1 | 0; }else { break; }
                        }
                      }

                      e = rd(a | 0, 0, 56) | 0;
                      g = e | g;
                      e = G() | 0 | k;
                      a = i;
                      b[a >> 2] = g;
                      b[a + 4 >> 2] = e;
                      a = j + 2 | 0;
                    } } while (0);

                    if ((a | 0) == 7) {
                      z = q + (m << 3) | 0;
                      b[z >> 2] = g;
                      b[z + 4 >> 2] = e & -117440513;
                      m = m + 1 | 0;
                    }
                  }

                  n = n + 1 | 0;
                } while ((n | 0) != (d | 0));

                if (r) {
                  n = ((d | 0) < 0) << 31 >> 31;
                  o = rd(u | 0, 0, 52) | 0;
                  p = G() | 0;

                  if (u >>> 0 > 15) {
                    if (!((s | 0) == 0 & (f | 0) == 0)) {
                      f = 4;
                      y = 75;
                      break b;
                    }

                    f = 0;

                    while (1) {
                      f = f + 1 | 0;

                      if ((f | 0) >= (d | 0)) {
                        g = 0;
                        f = m;
                        break e;
                      }

                      z = x + (f << 3) | 0;

                      if (!((b[z >> 2] | 0) == 0 & (b[z + 4 >> 2] | 0) == 0)) {
                        f = 4;
                        y = 75;
                        break b;
                      }
                    }
                  }

                  l = 0;
                  g = 0;
                  k = s;

                  while (1) {
                    do { if (!((k | 0) == 0 & (f | 0) == 0)) {
                      i = qd(k | 0, f | 0, 52) | 0;
                      G() | 0;
                      i = i & 15;

                      if ((i | 0) < (u | 0)) {
                        f = 12;
                        y = 75;
                        break b;
                      }

                      do { if ((i | 0) == (u | 0)) {
                        e = k;
                        i = f;
                      } else {
                        e = k | o;
                        a = f & -15728641 | p;

                        if (i >>> 0 < t >>> 0) {
                          i = a;
                          break;
                        }

                        h = u;

                        do {
                          z = rd(7, 0, (14 - h | 0) * 3 | 0) | 0;
                          h = h + 1 | 0;
                          e = z | e;
                          a = G() | 0 | a;
                        } while (h >>> 0 < i >>> 0);

                        i = a;
                      } } while (0);

                      h = od(e | 0, i | 0, d | 0, n | 0) | 0;
                      G() | 0;
                      a = 0;

                      while (1) {
                        if ((a | 0) > (d | 0)) {
                          y = 78;
                          break b;
                        }

                        z = w + (h << 3) | 0;
                        j = b[z + 4 >> 2] | 0;

                        if ((j & -117440513 | 0) == (i | 0) ? (b[z >> 2] | 0) == (e | 0) : 0) {
                          y = 80;
                          break;
                        }

                        h = (h + 1 | 0) % (d | 0) | 0;
                        z = w + (h << 3) | 0;
                        if ((b[z >> 2] | 0) == (e | 0) ? (b[z + 4 >> 2] | 0) == (i | 0) : 0) { break; }else { a = a + 1 | 0; }
                      }

                      if ((y | 0) == 80 ? (y = 0, 0 == 0 & (j & 117440512 | 0) == 100663296) : 0) { break; }
                      z = c + (g << 3) | 0;
                      b[z >> 2] = k;
                      b[z + 4 >> 2] = f;
                      g = g + 1 | 0;
                    } } while (0);

                    f = l + 1 | 0;

                    if ((f | 0) >= (d | 0)) {
                      f = m;
                      break e;
                    }

                    z = x + (f << 3) | 0;
                    l = f;
                    k = b[z >> 2] | 0;
                    f = b[z + 4 >> 2] | 0;
                  }
                } else {
                  g = 0;
                  f = m;
                }
              } else {
                g = 0;
                f = 0;
              } } while (0);

              vd(w | 0, 0, v | 0) | 0;
              ud(x | 0, q | 0, f << 3 | 0) | 0;
              ed(q);
              if (!f) { break a; }else {
                c = c + (g << 3) | 0;
                d = f;
              }
            }

            if ((y | 0) == 17) {
              if (0 == 0 & (f & 117440512 | 0) == 0) {
                f = 4;
                y = 28;
              } else { y = 22; }
            } else if ((y | 0) == 32) {
              ed(x);
              ed(w);
              z = 1;
              return z | 0;
            } else if ((y | 0) == 42) {
              ed(x);
              ed(w);
              z = 10;
              return z | 0;
            } else if ((y | 0) == 49) {
              ed(x);
              ed(w);
              z = 13;
              return z | 0;
            } else if ((y | 0) == 75) {
              ed(q);
              ed(x);
              ed(w);
              z = f;
              return z | 0;
            } else if ((y | 0) == 78) {
              ed(q);
              ed(x);
              ed(w);
              z = 1;
              return z | 0;
            } else if ((y | 0) == 85) {
              ud(c | 0, x | 0, d << 3 | 0) | 0;
              break;
            }

            if ((y | 0) == 22) {
              ed(x);
              ed(w);
              z = 5;
              return z | 0;
            } else if ((y | 0) == 28) {
              ed(x);
              ed(w);
              z = f;
              return z | 0;
            }
          } } while (0);

          ed(x);
          ed(w);
          z = 0;
          return z | 0;
        }

        function zb(a, c, d, e, f, g, h) {
          a = a | 0;
          c = c | 0;
          d = d | 0;
          e = e | 0;
          f = f | 0;
          g = g | 0;
          h = h | 0;
          var i = 0,
              j = 0,
              k = 0,
              l = 0,
              m = 0,
              n = 0,
              o = 0,
              p = 0,
              q = 0;
          q = S;
          S = S + 16 | 0;
          p = q;

          if (!((d | 0) > 0 | (d | 0) == 0 & c >>> 0 > 0)) {
            p = 0;
            S = q;
            return p | 0;
          }

          if ((h | 0) >= 16) {
            p = 12;
            S = q;
            return p | 0;
          }

          n = 0;
          o = 0;
          m = 0;
          i = 0;

          a: while (1) {
            k = a + (n << 3) | 0;
            j = b[k >> 2] | 0;
            k = b[k + 4 >> 2] | 0;
            l = qd(j | 0, k | 0, 52) | 0;
            G() | 0;

            if ((l & 15 | 0) > (h | 0)) {
              i = 12;
              j = 11;
              break;
            }

            Sb(p, j, k, h);
            l = p;
            k = b[l >> 2] | 0;
            l = b[l + 4 >> 2] | 0;
            if ((k | 0) == 0 & (l | 0) == 0) { j = m; }else {
              j = m;

              do {
                if (!((i | 0) < (g | 0) | (i | 0) == (g | 0) & j >>> 0 < f >>> 0)) {
                  j = 10;
                  break a;
                }

                m = e + (j << 3) | 0;
                b[m >> 2] = k;
                b[m + 4 >> 2] = l;
                j = gd(j | 0, i | 0, 1, 0) | 0;
                i = G() | 0;
                Tb(p);
                m = p;
                k = b[m >> 2] | 0;
                l = b[m + 4 >> 2] | 0;
              } while (!((k | 0) == 0 & (l | 0) == 0));
            }
            n = gd(n | 0, o | 0, 1, 0) | 0;
            o = G() | 0;

            if (!((o | 0) < (d | 0) | (o | 0) == (d | 0) & n >>> 0 < c >>> 0)) {
              i = 0;
              j = 11;
              break;
            } else { m = j; }
          }

          if ((j | 0) == 10) {
            p = 14;
            S = q;
            return p | 0;
          } else if ((j | 0) == 11) {
            S = q;
            return i | 0;
          }

          return 0;
        }

        function Ab(a, c, d, e, f) {
          a = a | 0;
          c = c | 0;
          d = d | 0;
          e = e | 0;
          f = f | 0;
          var g = 0,
              h = 0,
              i = 0,
              j = 0,
              k = 0,
              l = 0,
              m = 0,
              n = 0;
          n = S;
          S = S + 16 | 0;
          m = n;

          a: do { if ((d | 0) > 0 | (d | 0) == 0 & c >>> 0 > 0) {
            k = 0;
            h = 0;
            g = 0;
            l = 0;

            while (1) {
              j = a + (k << 3) | 0;
              i = b[j >> 2] | 0;
              j = b[j + 4 >> 2] | 0;

              if (!((i | 0) == 0 & (j | 0) == 0)) {
                j = (tb(i, j, e, m) | 0) == 0;
                i = m;
                h = gd(b[i >> 2] | 0, b[i + 4 >> 2] | 0, h | 0, g | 0) | 0;
                g = G() | 0;

                if (!j) {
                  g = 12;
                  break;
                }
              }

              k = gd(k | 0, l | 0, 1, 0) | 0;
              l = G() | 0;
              if (!((l | 0) < (d | 0) | (l | 0) == (d | 0) & k >>> 0 < c >>> 0)) { break a; }
            }

            S = n;
            return g | 0;
          } else {
            h = 0;
            g = 0;
          } } while (0);

          b[f >> 2] = h;
          b[f + 4 >> 2] = g;
          f = 0;
          S = n;
          return f | 0;
        }

        function Bb(a, b) {
          a = a | 0;
          b = b | 0;
          b = qd(a | 0, b | 0, 52) | 0;
          G() | 0;
          return b & 1 | 0;
        }

        function Cb(a, b) {
          a = a | 0;
          b = b | 0;
          var c = 0,
              d = 0,
              e = 0;
          e = qd(a | 0, b | 0, 52) | 0;
          G() | 0;
          e = e & 15;

          if (!e) {
            e = 0;
            return e | 0;
          }

          d = 1;

          while (1) {
            c = qd(a | 0, b | 0, (15 - d | 0) * 3 | 0) | 0;
            G() | 0;
            c = c & 7;

            if (c | 0) {
              d = 5;
              break;
            }

            if (d >>> 0 < e >>> 0) { d = d + 1 | 0; }else {
              c = 0;
              d = 5;
              break;
            }
          }

          if ((d | 0) == 5) { return c | 0; }
          return 0;
        }

        function Db(a, b) {
          a = a | 0;
          b = b | 0;
          var c = 0,
              d = 0,
              e = 0,
              f = 0,
              g = 0,
              h = 0,
              i = 0;
          i = qd(a | 0, b | 0, 52) | 0;
          G() | 0;
          i = i & 15;

          if (!i) {
            h = b;
            i = a;
            F(h | 0);
            return i | 0;
          }

          h = 1;
          c = 0;

          while (1) {
            f = (15 - h | 0) * 3 | 0;
            d = rd(7, 0, f | 0) | 0;
            e = G() | 0;
            g = qd(a | 0, b | 0, f | 0) | 0;
            G() | 0;
            f = rd(Pa(g & 7) | 0, 0, f | 0) | 0;
            g = G() | 0;
            a = f | a & ~d;
            b = g | b & ~e;

            a: do { if (!c) { if (!((f & d | 0) == 0 & (g & e | 0) == 0)) {
              d = qd(a | 0, b | 0, 52) | 0;
              G() | 0;
              d = d & 15;
              if (!d) { c = 1; }else {
                c = 1;

                b: while (1) {
                  g = qd(a | 0, b | 0, (15 - c | 0) * 3 | 0) | 0;
                  G() | 0;

                  switch (g & 7) {
                    case 1:
                      break b;

                    case 0:
                      break;

                    default:
                      {
                        c = 1;
                        break a;
                      }
                  }

                  if (c >>> 0 < d >>> 0) { c = c + 1 | 0; }else {
                    c = 1;
                    break a;
                  }
                }

                c = 1;

                while (1) {
                  g = (15 - c | 0) * 3 | 0;
                  e = qd(a | 0, b | 0, g | 0) | 0;
                  G() | 0;
                  f = rd(7, 0, g | 0) | 0;
                  b = b & ~(G() | 0);
                  g = rd(Pa(e & 7) | 0, 0, g | 0) | 0;
                  a = a & ~f | g;
                  b = b | (G() | 0);
                  if (c >>> 0 < d >>> 0) { c = c + 1 | 0; }else {
                    c = 1;
                    break;
                  }
                }
              }
            } else { c = 0; } } } while (0);

            if (h >>> 0 < i >>> 0) { h = h + 1 | 0; }else { break; }
          }

          F(b | 0);
          return a | 0;
        }

        function Eb(a, b) {
          a = a | 0;
          b = b | 0;
          var c = 0,
              d = 0,
              e = 0,
              f = 0,
              g = 0;
          d = qd(a | 0, b | 0, 52) | 0;
          G() | 0;
          d = d & 15;

          if (!d) {
            c = b;
            d = a;
            F(c | 0);
            return d | 0;
          }

          c = 1;

          while (1) {
            f = (15 - c | 0) * 3 | 0;
            g = qd(a | 0, b | 0, f | 0) | 0;
            G() | 0;
            e = rd(7, 0, f | 0) | 0;
            b = b & ~(G() | 0);
            f = rd(Pa(g & 7) | 0, 0, f | 0) | 0;
            a = f | a & ~e;
            b = G() | 0 | b;
            if (c >>> 0 < d >>> 0) { c = c + 1 | 0; }else { break; }
          }

          F(b | 0);
          return a | 0;
        }

        function Fb(a, b) {
          a = a | 0;
          b = b | 0;
          var c = 0,
              d = 0,
              e = 0,
              f = 0,
              g = 0,
              h = 0,
              i = 0;
          i = qd(a | 0, b | 0, 52) | 0;
          G() | 0;
          i = i & 15;

          if (!i) {
            h = b;
            i = a;
            F(h | 0);
            return i | 0;
          }

          h = 1;
          c = 0;

          while (1) {
            f = (15 - h | 0) * 3 | 0;
            d = rd(7, 0, f | 0) | 0;
            e = G() | 0;
            g = qd(a | 0, b | 0, f | 0) | 0;
            G() | 0;
            f = rd(Qa(g & 7) | 0, 0, f | 0) | 0;
            g = G() | 0;
            a = f | a & ~d;
            b = g | b & ~e;

            a: do { if (!c) { if (!((f & d | 0) == 0 & (g & e | 0) == 0)) {
              d = qd(a | 0, b | 0, 52) | 0;
              G() | 0;
              d = d & 15;
              if (!d) { c = 1; }else {
                c = 1;

                b: while (1) {
                  g = qd(a | 0, b | 0, (15 - c | 0) * 3 | 0) | 0;
                  G() | 0;

                  switch (g & 7) {
                    case 1:
                      break b;

                    case 0:
                      break;

                    default:
                      {
                        c = 1;
                        break a;
                      }
                  }

                  if (c >>> 0 < d >>> 0) { c = c + 1 | 0; }else {
                    c = 1;
                    break a;
                  }
                }

                c = 1;

                while (1) {
                  e = (15 - c | 0) * 3 | 0;
                  f = rd(7, 0, e | 0) | 0;
                  g = b & ~(G() | 0);
                  b = qd(a | 0, b | 0, e | 0) | 0;
                  G() | 0;
                  b = rd(Qa(b & 7) | 0, 0, e | 0) | 0;
                  a = a & ~f | b;
                  b = g | (G() | 0);
                  if (c >>> 0 < d >>> 0) { c = c + 1 | 0; }else {
                    c = 1;
                    break;
                  }
                }
              }
            } else { c = 0; } } } while (0);

            if (h >>> 0 < i >>> 0) { h = h + 1 | 0; }else { break; }
          }

          F(b | 0);
          return a | 0;
        }

        function Gb(a, b) {
          a = a | 0;
          b = b | 0;
          var c = 0,
              d = 0,
              e = 0,
              f = 0,
              g = 0;
          d = qd(a | 0, b | 0, 52) | 0;
          G() | 0;
          d = d & 15;

          if (!d) {
            c = b;
            d = a;
            F(c | 0);
            return d | 0;
          }

          c = 1;

          while (1) {
            g = (15 - c | 0) * 3 | 0;
            f = rd(7, 0, g | 0) | 0;
            e = b & ~(G() | 0);
            b = qd(a | 0, b | 0, g | 0) | 0;
            G() | 0;
            b = rd(Qa(b & 7) | 0, 0, g | 0) | 0;
            a = b | a & ~f;
            b = G() | 0 | e;
            if (c >>> 0 < d >>> 0) { c = c + 1 | 0; }else { break; }
          }

          F(b | 0);
          return a | 0;
        }

        function Hb(a, c) {
          a = a | 0;
          c = c | 0;
          var d = 0,
              e = 0,
              f = 0,
              g = 0,
              h = 0,
              i = 0,
              j = 0,
              k = 0,
              l = 0;
          j = S;
          S = S + 64 | 0;
          i = j + 40 | 0;
          e = j + 24 | 0;
          f = j + 12 | 0;
          g = j;
          rd(c | 0, 0, 52) | 0;
          d = G() | 0 | 134225919;

          if (!c) {
            if ((b[a + 4 >> 2] | 0) > 2) {
              h = 0;
              i = 0;
              F(h | 0);
              S = j;
              return i | 0;
            }

            if ((b[a + 8 >> 2] | 0) > 2) {
              h = 0;
              i = 0;
              F(h | 0);
              S = j;
              return i | 0;
            }

            if ((b[a + 12 >> 2] | 0) > 2) {
              h = 0;
              i = 0;
              F(h | 0);
              S = j;
              return i | 0;
            }

            rd(na(a) | 0, 0, 45) | 0;
            h = G() | 0 | d;
            i = -1;
            F(h | 0);
            S = j;
            return i | 0;
          }
          b[i >> 2] = b[a >> 2];
          b[i + 4 >> 2] = b[a + 4 >> 2];
          b[i + 8 >> 2] = b[a + 8 >> 2];
          b[i + 12 >> 2] = b[a + 12 >> 2];
          h = i + 4 | 0;

          if ((c | 0) > 0) {
            a = -1;

            while (1) {
              b[e >> 2] = b[h >> 2];
              b[e + 4 >> 2] = b[h + 4 >> 2];
              b[e + 8 >> 2] = b[h + 8 >> 2];

              if (!(c & 1)) {
                Ja(h);
                b[f >> 2] = b[h >> 2];
                b[f + 4 >> 2] = b[h + 4 >> 2];
                b[f + 8 >> 2] = b[h + 8 >> 2];
                La(f);
              } else {
                Ia(h);
                b[f >> 2] = b[h >> 2];
                b[f + 4 >> 2] = b[h + 4 >> 2];
                b[f + 8 >> 2] = b[h + 8 >> 2];
                Ka(f);
              }

              Fa(e, f, g);
              Ca(g);
              l = (15 - c | 0) * 3 | 0;
              k = rd(7, 0, l | 0) | 0;
              d = d & ~(G() | 0);
              l = rd(Ha(g) | 0, 0, l | 0) | 0;
              a = l | a & ~k;
              d = G() | 0 | d;
              if ((c | 0) > 1) { c = c + -1 | 0; }else { break; }
            }
          } else { a = -1; }

          a: do { if (((b[h >> 2] | 0) <= 2 ? (b[i + 8 >> 2] | 0) <= 2 : 0) ? (b[i + 12 >> 2] | 0) <= 2 : 0) {
            e = na(i) | 0;
            c = rd(e | 0, 0, 45) | 0;
            c = c | a;
            a = G() | 0 | d & -1040385;
            g = oa(i) | 0;

            if (!(la(e) | 0)) {
              if ((g | 0) <= 0) { break; }
              f = 0;

              while (1) {
                e = qd(c | 0, a | 0, 52) | 0;
                G() | 0;
                e = e & 15;

                if (e) {
                  d = 1;

                  while (1) {
                    l = (15 - d | 0) * 3 | 0;
                    i = qd(c | 0, a | 0, l | 0) | 0;
                    G() | 0;
                    k = rd(7, 0, l | 0) | 0;
                    a = a & ~(G() | 0);
                    l = rd(Pa(i & 7) | 0, 0, l | 0) | 0;
                    c = c & ~k | l;
                    a = a | (G() | 0);
                    if (d >>> 0 < e >>> 0) { d = d + 1 | 0; }else { break; }
                  }
                }

                f = f + 1 | 0;
                if ((f | 0) == (g | 0)) { break a; }
              }
            }

            f = qd(c | 0, a | 0, 52) | 0;
            G() | 0;
            f = f & 15;

            b: do { if (f) {
              d = 1;

              c: while (1) {
                l = qd(c | 0, a | 0, (15 - d | 0) * 3 | 0) | 0;
                G() | 0;

                switch (l & 7) {
                  case 1:
                    break c;

                  case 0:
                    break;

                  default:
                    break b;
                }

                if (d >>> 0 < f >>> 0) { d = d + 1 | 0; }else { break b; }
              }

              if (ra(e, b[i >> 2] | 0) | 0) {
                d = 1;

                while (1) {
                  i = (15 - d | 0) * 3 | 0;
                  k = rd(7, 0, i | 0) | 0;
                  l = a & ~(G() | 0);
                  a = qd(c | 0, a | 0, i | 0) | 0;
                  G() | 0;
                  a = rd(Qa(a & 7) | 0, 0, i | 0) | 0;
                  c = c & ~k | a;
                  a = l | (G() | 0);
                  if (d >>> 0 < f >>> 0) { d = d + 1 | 0; }else { break; }
                }
              } else {
                d = 1;

                while (1) {
                  l = (15 - d | 0) * 3 | 0;
                  i = qd(c | 0, a | 0, l | 0) | 0;
                  G() | 0;
                  k = rd(7, 0, l | 0) | 0;
                  a = a & ~(G() | 0);
                  l = rd(Pa(i & 7) | 0, 0, l | 0) | 0;
                  c = c & ~k | l;
                  a = a | (G() | 0);
                  if (d >>> 0 < f >>> 0) { d = d + 1 | 0; }else { break; }
                }
              }
            } } while (0);

            if ((g | 0) > 0) {
              d = 0;

              do {
                c = Db(c, a) | 0;
                a = G() | 0;
                d = d + 1 | 0;
              } while ((d | 0) != (g | 0));
            }
          } else {
            c = 0;
            a = 0;
          } } while (0);

          k = a;
          l = c;
          F(k | 0);
          S = j;
          return l | 0;
        }

        function Ib(a) {
          a = a | 0;
          return (a | 0) % 2 | 0 | 0;
        }

        function Jb(a, c, d) {
          a = a | 0;
          c = c | 0;
          d = d | 0;
          var e = 0,
              f = 0;
          f = S;
          S = S + 16 | 0;
          e = f;

          if (c >>> 0 > 15) {
            e = 4;
            S = f;
            return e | 0;
          }

          if ((b[a + 4 >> 2] & 2146435072 | 0) == 2146435072) {
            e = 3;
            S = f;
            return e | 0;
          }

          if ((b[a + 8 + 4 >> 2] & 2146435072 | 0) == 2146435072) {
            e = 3;
            S = f;
            return e | 0;
          }

          eb(a, c, e);
          c = Hb(e, c) | 0;
          e = G() | 0;
          b[d >> 2] = c;
          b[d + 4 >> 2] = e;
          e = (c | 0) == 0 & (e | 0) == 0 & 1;
          S = f;
          return e | 0;
        }

        function Kb(a, c, d) {
          a = a | 0;
          c = c | 0;
          d = d | 0;
          var e = 0,
              f = 0,
              g = 0,
              h = 0;
          f = d + 4 | 0;
          g = qd(a | 0, c | 0, 52) | 0;
          G() | 0;
          g = g & 15;
          h = qd(a | 0, c | 0, 45) | 0;
          G() | 0;
          e = (g | 0) == 0;

          if (!(la(h & 127) | 0)) {
            if (e) {
              h = 0;
              return h | 0;
            }

            if ((b[f >> 2] | 0) == 0 ? (b[d + 8 >> 2] | 0) == 0 : 0) { e = (b[d + 12 >> 2] | 0) != 0 & 1; }else { e = 1; }
          } else if (e) {
            h = 1;
            return h | 0;
          } else { e = 1; }

          d = 1;

          while (1) {
            if (!(d & 1)) { La(f); }else { Ka(f); }
            h = qd(a | 0, c | 0, (15 - d | 0) * 3 | 0) | 0;
            G() | 0;
            Ma(f, h & 7);
            if (d >>> 0 < g >>> 0) { d = d + 1 | 0; }else { break; }
          }

          return e | 0;
        }

        function Lb(a, c, d) {
          a = a | 0;
          c = c | 0;
          d = d | 0;
          var e = 0,
              f = 0,
              g = 0,
              h = 0,
              i = 0,
              j = 0,
              k = 0,
              l = 0;
          l = S;
          S = S + 16 | 0;
          j = l;
          k = qd(a | 0, c | 0, 45) | 0;
          G() | 0;
          k = k & 127;

          if (k >>> 0 > 121) {
            b[d >> 2] = 0;
            b[d + 4 >> 2] = 0;
            b[d + 8 >> 2] = 0;
            b[d + 12 >> 2] = 0;
            k = 5;
            S = l;
            return k | 0;
          }

          a: do { if ((la(k) | 0) != 0 ? (g = qd(a | 0, c | 0, 52) | 0, G() | 0, g = g & 15, (g | 0) != 0) : 0) {
            e = 1;

            b: while (1) {
              i = qd(a | 0, c | 0, (15 - e | 0) * 3 | 0) | 0;
              G() | 0;

              switch (i & 7) {
                case 5:
                  break b;

                case 0:
                  break;

                default:
                  {
                    e = c;
                    break a;
                  }
              }

              if (e >>> 0 < g >>> 0) { e = e + 1 | 0; }else {
                e = c;
                break a;
              }
            }

            f = 1;
            e = c;

            while (1) {
              c = (15 - f | 0) * 3 | 0;
              h = rd(7, 0, c | 0) | 0;
              i = e & ~(G() | 0);
              e = qd(a | 0, e | 0, c | 0) | 0;
              G() | 0;
              e = rd(Qa(e & 7) | 0, 0, c | 0) | 0;
              a = a & ~h | e;
              e = i | (G() | 0);
              if (f >>> 0 < g >>> 0) { f = f + 1 | 0; }else { break; }
            }
          } else { e = c; } } while (0);

          i = 7696 + (k * 28 | 0) | 0;
          b[d >> 2] = b[i >> 2];
          b[d + 4 >> 2] = b[i + 4 >> 2];
          b[d + 8 >> 2] = b[i + 8 >> 2];
          b[d + 12 >> 2] = b[i + 12 >> 2];

          if (!(Kb(a, e, d) | 0)) {
            k = 0;
            S = l;
            return k | 0;
          }

          h = d + 4 | 0;
          b[j >> 2] = b[h >> 2];
          b[j + 4 >> 2] = b[h + 4 >> 2];
          b[j + 8 >> 2] = b[h + 8 >> 2];
          g = qd(a | 0, e | 0, 52) | 0;
          G() | 0;
          i = g & 15;
          if (!(g & 1)) { g = i; }else {
            La(h);
            g = i + 1 | 0;
          }
          if (!(la(k) | 0)) { e = 0; }else {
            c: do { if (!i) { e = 0; }else {
              c = 1;

              while (1) {
                f = qd(a | 0, e | 0, (15 - c | 0) * 3 | 0) | 0;
                G() | 0;
                f = f & 7;

                if (f | 0) {
                  e = f;
                  break c;
                }

                if (c >>> 0 < i >>> 0) { c = c + 1 | 0; }else {
                  e = 0;
                  break;
                }
              }
            } } while (0);

            e = (e | 0) == 4 & 1;
          }

          if (!(lb(d, g, e, 0) | 0)) {
            if ((g | 0) != (i | 0)) {
              b[h >> 2] = b[j >> 2];
              b[h + 4 >> 2] = b[j + 4 >> 2];
              b[h + 8 >> 2] = b[j + 8 >> 2];
            }
          } else {
            if (la(k) | 0) { do {} while ((lb(d, g, 0, 0) | 0) != 0); }
            if ((g | 0) != (i | 0)) { Ja(h); }
          }

          k = 0;
          S = l;
          return k | 0;
        }

        function Mb(a, b, c) {
          a = a | 0;
          b = b | 0;
          c = c | 0;
          var d = 0,
              e = 0,
              f = 0;
          f = S;
          S = S + 16 | 0;
          d = f;
          e = Lb(a, b, d) | 0;

          if (e | 0) {
            S = f;
            return e | 0;
          }

          e = qd(a | 0, b | 0, 52) | 0;
          G() | 0;
          ib(d, e & 15, c);
          e = 0;
          S = f;
          return e | 0;
        }

        function Nb(a, b, c) {
          a = a | 0;
          b = b | 0;
          c = c | 0;
          var d = 0,
              e = 0,
              f = 0,
              g = 0,
              h = 0;
          g = S;
          S = S + 16 | 0;
          f = g;
          d = Lb(a, b, f) | 0;

          if (d | 0) {
            f = d;
            S = g;
            return f | 0;
          }

          d = qd(a | 0, b | 0, 45) | 0;
          G() | 0;
          d = (la(d & 127) | 0) == 0;
          e = qd(a | 0, b | 0, 52) | 0;
          G() | 0;
          e = e & 15;

          a: do { if (!d) {
            if (e | 0) {
              d = 1;

              while (1) {
                h = rd(7, 0, (15 - d | 0) * 3 | 0) | 0;
                if (!((h & a | 0) == 0 & ((G() | 0) & b | 0) == 0)) { break a; }
                if (d >>> 0 < e >>> 0) { d = d + 1 | 0; }else { break; }
              }
            }

            jb(f, e, 0, 5, c);
            h = 0;
            S = g;
            return h | 0;
          } } while (0);

          nb(f, e, 0, 6, c);
          h = 0;
          S = g;
          return h | 0;
        }

        function Ob(a, c, d) {
          a = a | 0;
          c = c | 0;
          d = d | 0;
          var e = 0,
              f = 0,
              g = 0;
          f = qd(a | 0, c | 0, 45) | 0;
          G() | 0;

          if (!(la(f & 127) | 0)) {
            f = 2;
            b[d >> 2] = f;
            return 0;
          }

          f = qd(a | 0, c | 0, 52) | 0;
          G() | 0;
          f = f & 15;

          if (!f) {
            f = 5;
            b[d >> 2] = f;
            return 0;
          }

          e = 1;

          while (1) {
            g = rd(7, 0, (15 - e | 0) * 3 | 0) | 0;

            if (!((g & a | 0) == 0 & ((G() | 0) & c | 0) == 0)) {
              e = 2;
              a = 6;
              break;
            }

            if (e >>> 0 < f >>> 0) { e = e + 1 | 0; }else {
              e = 5;
              a = 6;
              break;
            }
          }

          if ((a | 0) == 6) {
            b[d >> 2] = e;
            return 0;
          }

          return 0;
        }

        function Pb(a, c, d) {
          a = a | 0;
          c = c | 0;
          d = d | 0;
          var e = 0,
              f = 0,
              g = 0,
              h = 0,
              i = 0,
              j = 0,
              k = 0,
              l = 0,
              m = 0;
          m = S;
          S = S + 128 | 0;
          k = m + 112 | 0;
          g = m + 96 | 0;
          l = m;
          f = qd(a | 0, c | 0, 52) | 0;
          G() | 0;
          i = f & 15;
          b[k >> 2] = i;
          h = qd(a | 0, c | 0, 45) | 0;
          G() | 0;
          h = h & 127;

          a: do { if (la(h) | 0) {
            if (i | 0) {
              e = 1;

              while (1) {
                j = rd(7, 0, (15 - e | 0) * 3 | 0) | 0;

                if (!((j & a | 0) == 0 & ((G() | 0) & c | 0) == 0)) {
                  f = 0;
                  break a;
                }

                if (e >>> 0 < i >>> 0) { e = e + 1 | 0; }else { break; }
              }
            }

            if (!(f & 1)) {
              j = rd(i + 1 | 0, 0, 52) | 0;
              l = G() | 0 | c & -15728641;
              k = rd(7, 0, (14 - i | 0) * 3 | 0) | 0;
              l = Pb((j | a) & ~k, l & ~(G() | 0), d) | 0;
              S = m;
              return l | 0;
            } else { f = 1; }
          } else { f = 0; } } while (0);

          e = Lb(a, c, g) | 0;

          if (!e) {
            if (f) {
              kb(g, k, l);
              j = 5;
            } else {
              ob(g, k, l);
              j = 6;
            }

            b: do { if (la(h) | 0) {
              if (!i) { a = 5; }else {
                e = 1;

                while (1) {
                  h = rd(7, 0, (15 - e | 0) * 3 | 0) | 0;

                  if (!((h & a | 0) == 0 & ((G() | 0) & c | 0) == 0)) {
                    a = 2;
                    break b;
                  }

                  if (e >>> 0 < i >>> 0) { e = e + 1 | 0; }else {
                    a = 5;
                    break;
                  }
                }
              }
            } else { a = 2; } } while (0);

            vd(d | 0, -1, a << 2 | 0) | 0;

            c: do { if (f) {
              g = 0;

              while (1) {
                h = l + (g << 4) | 0;
                mb(h, b[k >> 2] | 0) | 0;
                h = b[h >> 2] | 0;
                i = b[d >> 2] | 0;
                if ((i | 0) == -1 | (i | 0) == (h | 0)) { e = d; }else {
                  f = 0;

                  do {
                    f = f + 1 | 0;

                    if (f >>> 0 >= a >>> 0) {
                      e = 1;
                      break c;
                    }

                    e = d + (f << 2) | 0;
                    i = b[e >> 2] | 0;
                  } while (!((i | 0) == -1 | (i | 0) == (h | 0)));
                }
                b[e >> 2] = h;
                g = g + 1 | 0;

                if (g >>> 0 >= j >>> 0) {
                  e = 0;
                  break;
                }
              }
            } else {
              g = 0;

              while (1) {
                h = l + (g << 4) | 0;
                lb(h, b[k >> 2] | 0, 0, 1) | 0;
                h = b[h >> 2] | 0;
                i = b[d >> 2] | 0;
                if ((i | 0) == -1 | (i | 0) == (h | 0)) { e = d; }else {
                  f = 0;

                  do {
                    f = f + 1 | 0;

                    if (f >>> 0 >= a >>> 0) {
                      e = 1;
                      break c;
                    }

                    e = d + (f << 2) | 0;
                    i = b[e >> 2] | 0;
                  } while (!((i | 0) == -1 | (i | 0) == (h | 0)));
                }
                b[e >> 2] = h;
                g = g + 1 | 0;

                if (g >>> 0 >= j >>> 0) {
                  e = 0;
                  break;
                }
              }
            } } while (0);
          }

          l = e;
          S = m;
          return l | 0;
        }

        function Qb() {
          return 12;
        }

        function Rb(a, c) {
          a = a | 0;
          c = c | 0;
          var d = 0,
              e = 0,
              f = 0,
              g = 0,
              h = 0,
              i = 0,
              j = 0;

          if (a >>> 0 > 15) {
            i = 4;
            return i | 0;
          }

          rd(a | 0, 0, 52) | 0;
          i = G() | 0 | 134225919;

          if (!a) {
            d = 0;
            e = 0;

            do {
              if (la(e) | 0) {
                rd(e | 0, 0, 45) | 0;
                h = i | (G() | 0);
                a = c + (d << 3) | 0;
                b[a >> 2] = -1;
                b[a + 4 >> 2] = h;
                d = d + 1 | 0;
              }

              e = e + 1 | 0;
            } while ((e | 0) != 122);

            d = 0;
            return d | 0;
          }

          d = 0;
          h = 0;

          do {
            if (la(h) | 0) {
              rd(h | 0, 0, 45) | 0;
              e = 1;
              f = -1;
              g = i | (G() | 0);

              while (1) {
                j = rd(7, 0, (15 - e | 0) * 3 | 0) | 0;
                f = f & ~j;
                g = g & ~(G() | 0);
                if ((e | 0) == (a | 0)) { break; }else { e = e + 1 | 0; }
              }

              j = c + (d << 3) | 0;
              b[j >> 2] = f;
              b[j + 4 >> 2] = g;
              d = d + 1 | 0;
            }

            h = h + 1 | 0;
          } while ((h | 0) != 122);

          d = 0;
          return d | 0;
        }

        function Sb(a, c, d, e) {
          a = a | 0;
          c = c | 0;
          d = d | 0;
          e = e | 0;
          var f = 0,
              g = 0;
          f = qd(c | 0, d | 0, 52) | 0;
          G() | 0;
          f = f & 15;

          if ((c | 0) == 0 & (d | 0) == 0 | ((e | 0) > 15 | (f | 0) > (e | 0))) {
            e = -1;
            f = -1;
            c = 0;
            d = 0;
          } else {
            g = wb(c, d, f + 1 | 0, e) | 0;
            d = (G() | 0) & -15728641;
            c = rd(e | 0, 0, 52) | 0;
            c = g | c;
            d = d | (G() | 0);
            g = (ub(c, d) | 0) == 0;
            e = g ? -1 : e;
          }

          g = a;
          b[g >> 2] = c;
          b[g + 4 >> 2] = d;
          b[a + 8 >> 2] = f;
          b[a + 12 >> 2] = e;
          return;
        }

        function Tb(a) {
          a = a | 0;
          var c = 0,
              d = 0,
              e = 0,
              f = 0,
              g = 0,
              h = 0,
              i = 0,
              j = 0,
              k = 0;
          d = a;
          c = b[d >> 2] | 0;
          d = b[d + 4 >> 2] | 0;
          if ((c | 0) == 0 & (d | 0) == 0) { return; }
          e = qd(c | 0, d | 0, 52) | 0;
          G() | 0;
          e = e & 15;
          i = rd(1, 0, (e ^ 15) * 3 | 0) | 0;
          c = gd(i | 0, G() | 0, c | 0, d | 0) | 0;
          d = G() | 0;
          i = a;
          b[i >> 2] = c;
          b[i + 4 >> 2] = d;
          i = a + 8 | 0;
          h = b[i >> 2] | 0;
          if ((e | 0) < (h | 0)) { return; }
          j = a + 12 | 0;
          g = e;

          while (1) {
            if ((g | 0) == (h | 0)) {
              e = 5;
              break;
            }

            k = (g | 0) == (b[j >> 2] | 0);
            f = (15 - g | 0) * 3 | 0;
            e = qd(c | 0, d | 0, f | 0) | 0;
            G() | 0;
            e = e & 7;

            if (k & ((e | 0) == 1 & 0 == 0)) {
              e = 7;
              break;
            }

            if (!((e | 0) == 7 & 0 == 0)) {
              e = 10;
              break;
            }

            k = rd(1, 0, f | 0) | 0;
            c = gd(c | 0, d | 0, k | 0, G() | 0) | 0;
            d = G() | 0;
            k = a;
            b[k >> 2] = c;
            b[k + 4 >> 2] = d;
            if ((g | 0) > (h | 0)) { g = g + -1 | 0; }else {
              e = 10;
              break;
            }
          }

          if ((e | 0) == 5) {
            k = a;
            b[k >> 2] = 0;
            b[k + 4 >> 2] = 0;
            b[i >> 2] = -1;
            b[j >> 2] = -1;
            return;
          } else if ((e | 0) == 7) {
            h = rd(1, 0, f | 0) | 0;
            h = gd(c | 0, d | 0, h | 0, G() | 0) | 0;
            i = G() | 0;
            k = a;
            b[k >> 2] = h;
            b[k + 4 >> 2] = i;
            b[j >> 2] = g + -1;
            return;
          } else if ((e | 0) == 10) { return; }
        }

        function Ub(a) {
          a = +a;
          var b = 0.0;
          b = a < 0.0 ? a + 6.283185307179586 : a;
          return +(!(a >= 6.283185307179586) ? b : b + -6.283185307179586);
        }

        function Vb(a, b) {
          a = a | 0;
          b = b | 0;

          if (!(+q(+(+e[a >> 3] - +e[b >> 3])) < 1.7453292519943298e-11)) {
            b = 0;
            return b | 0;
          }

          b = +q(+(+e[a + 8 >> 3] - +e[b + 8 >> 3])) < 1.7453292519943298e-11;
          return b | 0;
        }

        function Wb(a, b) {
          a = a | 0;
          b = b | 0;
          var c = 0.0,
              d = 0.0,
              f = 0.0,
              g = 0.0;
          f = +e[b >> 3];
          d = +e[a >> 3];
          g = +u(+((f - d) * .5));
          c = +u(+((+e[b + 8 >> 3] - +e[a + 8 >> 3]) * .5));
          c = g * g + c * (+t(+f) * +t(+d) * c);
          return +(+z(+ +r(+c), + +r(+(1.0 - c))) * 2.0);
        }

        function Xb(a, b) {
          a = a | 0;
          b = b | 0;
          var c = 0.0,
              d = 0.0,
              f = 0.0,
              g = 0.0;
          f = +e[b >> 3];
          d = +e[a >> 3];
          g = +u(+((f - d) * .5));
          c = +u(+((+e[b + 8 >> 3] - +e[a + 8 >> 3]) * .5));
          c = g * g + c * (+t(+f) * +t(+d) * c);
          return +(+z(+ +r(+c), + +r(+(1.0 - c))) * 2.0 * 6371.007180918475);
        }

        function Yb(a, b) {
          a = a | 0;
          b = b | 0;
          var c = 0.0,
              d = 0.0,
              f = 0.0,
              g = 0.0;
          f = +e[b >> 3];
          d = +e[a >> 3];
          g = +u(+((f - d) * .5));
          c = +u(+((+e[b + 8 >> 3] - +e[a + 8 >> 3]) * .5));
          c = g * g + c * (+t(+f) * +t(+d) * c);
          return +(+z(+ +r(+c), + +r(+(1.0 - c))) * 2.0 * 6371.007180918475 * 1.0e3);
        }

        function Zb(a, b) {
          a = a | 0;
          b = b | 0;
          var c = 0.0,
              d = 0.0,
              f = 0.0,
              g = 0.0,
              h = 0.0;
          g = +e[b >> 3];
          d = +t(+g);
          f = +e[b + 8 >> 3] - +e[a + 8 >> 3];
          h = d * +u(+f);
          c = +e[a >> 3];
          return + +z(+h, +(+u(+g) * +t(+c) - +t(+f) * (d * +u(+c))));
        }

        function _b(a, c, d, f) {
          a = a | 0;
          c = +c;
          d = +d;
          f = f | 0;
          var g = 0,
              h = 0.0,
              i = 0.0,
              j = 0.0;

          if (d < 1.0e-16) {
            b[f >> 2] = b[a >> 2];
            b[f + 4 >> 2] = b[a + 4 >> 2];
            b[f + 8 >> 2] = b[a + 8 >> 2];
            b[f + 12 >> 2] = b[a + 12 >> 2];
            return;
          }

          h = c < 0.0 ? c + 6.283185307179586 : c;
          h = !(c >= 6.283185307179586) ? h : h + -6.283185307179586;

          do { if (h < 1.0e-16) {
            c = +e[a >> 3] + d;
            e[f >> 3] = c;
            g = f;
          } else {
            g = +q(+(h + -3.141592653589793)) < 1.0e-16;
            c = +e[a >> 3];

            if (g) {
              c = c - d;
              e[f >> 3] = c;
              g = f;
              break;
            }

            i = +t(+d);
            d = +u(+d);
            c = i * +u(+c) + +t(+h) * (d * +t(+c));
            c = c > 1.0 ? 1.0 : c;
            c = +x(+(c < -1.0 ? -1.0 : c));
            e[f >> 3] = c;

            if (+q(+(c + -1.5707963267948966)) < 1.0e-16) {
              e[f >> 3] = 1.5707963267948966;
              e[f + 8 >> 3] = 0.0;
              return;
            }

            if (+q(+(c + 1.5707963267948966)) < 1.0e-16) {
              e[f >> 3] = -1.5707963267948966;
              e[f + 8 >> 3] = 0.0;
              return;
            }

            j = +t(+c);
            h = d * +u(+h) / j;
            d = +e[a >> 3];
            c = (i - +u(+c) * +u(+d)) / +t(+d) / j;
            i = h > 1.0 ? 1.0 : h;
            c = c > 1.0 ? 1.0 : c;
            c = +e[a + 8 >> 3] + +z(+(i < -1.0 ? -1.0 : i), +(c < -1.0 ? -1.0 : c));
            if (c > 3.141592653589793) { do { c = c + -6.283185307179586; } while (c > 3.141592653589793); }
            if (c < -3.141592653589793) { do { c = c + 6.283185307179586; } while (c < -3.141592653589793); }
            e[f + 8 >> 3] = c;
            return;
          } } while (0);

          if (+q(+(c + -1.5707963267948966)) < 1.0e-16) {
            e[g >> 3] = 1.5707963267948966;
            e[f + 8 >> 3] = 0.0;
            return;
          }

          if (+q(+(c + 1.5707963267948966)) < 1.0e-16) {
            e[g >> 3] = -1.5707963267948966;
            e[f + 8 >> 3] = 0.0;
            return;
          }

          c = +e[a + 8 >> 3];
          if (c > 3.141592653589793) { do { c = c + -6.283185307179586; } while (c > 3.141592653589793); }
          if (c < -3.141592653589793) { do { c = c + 6.283185307179586; } while (c < -3.141592653589793); }
          e[f + 8 >> 3] = c;
          return;
        }

        function $b(a, b) {
          a = a | 0;
          b = b | 0;

          if (a >>> 0 > 15) {
            b = 4;
            return b | 0;
          }

          e[b >> 3] = +e[20528 + (a << 3) >> 3];
          b = 0;
          return b | 0;
        }

        function ac(a, b) {
          a = a | 0;
          b = b | 0;

          if (a >>> 0 > 15) {
            b = 4;
            return b | 0;
          }

          e[b >> 3] = +e[20656 + (a << 3) >> 3];
          b = 0;
          return b | 0;
        }

        function bc(a, b) {
          a = a | 0;
          b = b | 0;

          if (a >>> 0 > 15) {
            b = 4;
            return b | 0;
          }

          e[b >> 3] = +e[20784 + (a << 3) >> 3];
          b = 0;
          return b | 0;
        }

        function cc(a, b) {
          a = a | 0;
          b = b | 0;

          if (a >>> 0 > 15) {
            b = 4;
            return b | 0;
          }

          e[b >> 3] = +e[20912 + (a << 3) >> 3];
          b = 0;
          return b | 0;
        }

        function dc(a, c) {
          a = a | 0;
          c = c | 0;
          var d = 0;

          if (a >>> 0 > 15) {
            c = 4;
            return c | 0;
          }

          d = xc(7, 0, a, ((a | 0) < 0) << 31 >> 31) | 0;
          d = md(d | 0, G() | 0, 120, 0) | 0;
          a = G() | 0;
          b[c >> 2] = d | 2;
          b[c + 4 >> 2] = a;
          c = 0;
          return c | 0;
        }

        function ec(a, b, c) {
          a = a | 0;
          b = b | 0;
          c = c | 0;
          var d = 0.0,
              f = 0.0,
              g = 0.0,
              h = 0.0,
              i = 0.0,
              j = 0.0,
              k = 0.0,
              l = 0.0,
              m = 0.0,
              n = 0.0;
          n = +e[b >> 3];
          l = +e[a >> 3];
          j = +u(+((n - l) * .5));
          g = +e[b + 8 >> 3];
          k = +e[a + 8 >> 3];
          h = +u(+((g - k) * .5));
          i = +t(+l);
          m = +t(+n);
          h = j * j + h * (m * i * h);
          h = +z(+ +r(+h), + +r(+(1.0 - h))) * 2.0;
          j = +e[c >> 3];
          n = +u(+((j - n) * .5));
          d = +e[c + 8 >> 3];
          g = +u(+((d - g) * .5));
          f = +t(+j);
          g = n * n + g * (m * f * g);
          g = +z(+ +r(+g), + +r(+(1.0 - g))) * 2.0;
          j = +u(+((l - j) * .5));
          d = +u(+((k - d) * .5));
          d = j * j + d * (i * f * d);
          d = +z(+ +r(+d), + +r(+(1.0 - d))) * 2.0;
          f = (h + g + d) * .5;
          return +(+y(+ +r(+(+v(+(f * .5)) * +v(+((f - h) * .5)) * +v(+((f - g) * .5)) * +v(+((f - d) * .5))))) * 4.0);
        }

        function fc(a, c, d) {
          a = a | 0;
          c = c | 0;
          d = d | 0;
          var f = 0.0,
              g = 0,
              h = 0,
              i = 0,
              j = 0;
          j = S;
          S = S + 192 | 0;
          h = j + 168 | 0;
          i = j;
          g = Mb(a, c, h) | 0;

          if (g | 0) {
            d = g;
            S = j;
            return d | 0;
          }

          a = Nb(a, c, i) | 0;

          if (a | 0) {
            d = a;
            S = j;
            return d | 0;
          }

          c = b[i >> 2] | 0;

          if ((c | 0) > 0) {
            f = +ec(i + 8 | 0, i + 8 + (((c | 0) != 1 & 1) << 4) | 0, h) + 0.0;

            if ((c | 0) != 1) {
              a = 1;

              do {
                g = a;
                a = a + 1 | 0;
                f = f + +ec(i + 8 + (g << 4) | 0, i + 8 + (((a | 0) % (c | 0) | 0) << 4) | 0, h);
              } while ((a | 0) < (c | 0));
            }
          } else { f = 0.0; }

          e[d >> 3] = f;
          d = 0;
          S = j;
          return d | 0;
        }

        function gc(a, c, d) {
          a = a | 0;
          c = c | 0;
          d = d | 0;
          var f = 0,
              g = 0.0,
              h = 0,
              i = 0,
              j = 0;
          j = S;
          S = S + 192 | 0;
          h = j + 168 | 0;
          i = j;
          f = Mb(a, c, h) | 0;

          if (!f) {
            f = Nb(a, c, i) | 0;

            if (!f) {
              a = b[i >> 2] | 0;

              if ((a | 0) > 0) {
                g = +ec(i + 8 | 0, i + 8 + (((a | 0) != 1 & 1) << 4) | 0, h) + 0.0;

                if ((a | 0) != 1) {
                  f = 1;

                  do {
                    c = f;
                    f = f + 1 | 0;
                    g = g + +ec(i + 8 + (c << 4) | 0, i + 8 + (((f | 0) % (a | 0) | 0) << 4) | 0, h);
                  } while ((f | 0) < (a | 0));
                }
              } else { g = 0.0; }

              e[d >> 3] = g * 6371.007180918475 * 6371.007180918475;
              d = 0;
              S = j;
              return d | 0;
            }
          }

          d = f;
          S = j;
          return d | 0;
        }

        function hc(a, b, c) {
          a = a | 0;
          b = b | 0;
          c = c | 0;
          a = gc(a, b, c) | 0;
          if (a | 0) { return a | 0; }
          e[c >> 3] = +e[c >> 3] * 1.0e3 * 1.0e3;
          return a | 0;
        }

        function ic(a, c, d) {
          a = a | 0;
          c = c | 0;
          d = d | 0;
          var f = 0.0,
              g = 0.0,
              h = 0.0,
              i = 0,
              j = 0,
              k = 0.0,
              l = 0.0,
              m = 0.0;
          j = S;
          S = S + 176 | 0;
          i = j;
          a = db(a, c, i) | 0;

          if (a | 0) {
            i = a;
            S = j;
            return i | 0;
          }

          e[d >> 3] = 0.0;
          a = b[i >> 2] | 0;

          if ((a | 0) <= 1) {
            i = 0;
            S = j;
            return i | 0;
          }

          c = a + -1 | 0;
          a = 0;
          f = +e[i + 8 >> 3];
          g = +e[i + 16 >> 3];
          h = 0.0;

          do {
            a = a + 1 | 0;
            l = f;
            f = +e[i + 8 + (a << 4) >> 3];
            m = +u(+((f - l) * .5));
            k = g;
            g = +e[i + 8 + (a << 4) + 8 >> 3];
            k = +u(+((g - k) * .5));
            k = m * m + k * (+t(+f) * +t(+l) * k);
            h = h + +z(+ +r(+k), + +r(+(1.0 - k))) * 2.0;
          } while ((a | 0) < (c | 0));

          e[d >> 3] = h;
          i = 0;
          S = j;
          return i | 0;
        }

        function jc(a, c, d) {
          a = a | 0;
          c = c | 0;
          d = d | 0;
          var f = 0.0,
              g = 0.0,
              h = 0.0,
              i = 0,
              j = 0,
              k = 0.0,
              l = 0.0,
              m = 0.0;
          j = S;
          S = S + 176 | 0;
          i = j;
          a = db(a, c, i) | 0;

          if (a | 0) {
            i = a;
            h = +e[d >> 3];
            h = h * 6371.007180918475;
            e[d >> 3] = h;
            S = j;
            return i | 0;
          }

          e[d >> 3] = 0.0;
          a = b[i >> 2] | 0;

          if ((a | 0) <= 1) {
            i = 0;
            h = 0.0;
            h = h * 6371.007180918475;
            e[d >> 3] = h;
            S = j;
            return i | 0;
          }

          c = a + -1 | 0;
          a = 0;
          f = +e[i + 8 >> 3];
          g = +e[i + 16 >> 3];
          h = 0.0;

          do {
            a = a + 1 | 0;
            l = f;
            f = +e[i + 8 + (a << 4) >> 3];
            m = +u(+((f - l) * .5));
            k = g;
            g = +e[i + 8 + (a << 4) + 8 >> 3];
            k = +u(+((g - k) * .5));
            k = m * m + k * (+t(+l) * +t(+f) * k);
            h = h + +z(+ +r(+k), + +r(+(1.0 - k))) * 2.0;
          } while ((a | 0) != (c | 0));

          e[d >> 3] = h;
          i = 0;
          m = h;
          m = m * 6371.007180918475;
          e[d >> 3] = m;
          S = j;
          return i | 0;
        }

        function kc(a, c, d) {
          a = a | 0;
          c = c | 0;
          d = d | 0;
          var f = 0.0,
              g = 0.0,
              h = 0.0,
              i = 0,
              j = 0,
              k = 0.0,
              l = 0.0,
              m = 0.0;
          j = S;
          S = S + 176 | 0;
          i = j;
          a = db(a, c, i) | 0;

          if (a | 0) {
            i = a;
            h = +e[d >> 3];
            h = h * 6371.007180918475;
            h = h * 1.0e3;
            e[d >> 3] = h;
            S = j;
            return i | 0;
          }

          e[d >> 3] = 0.0;
          a = b[i >> 2] | 0;

          if ((a | 0) <= 1) {
            i = 0;
            h = 0.0;
            h = h * 6371.007180918475;
            h = h * 1.0e3;
            e[d >> 3] = h;
            S = j;
            return i | 0;
          }

          c = a + -1 | 0;
          a = 0;
          f = +e[i + 8 >> 3];
          g = +e[i + 16 >> 3];
          h = 0.0;

          do {
            a = a + 1 | 0;
            l = f;
            f = +e[i + 8 + (a << 4) >> 3];
            m = +u(+((f - l) * .5));
            k = g;
            g = +e[i + 8 + (a << 4) + 8 >> 3];
            k = +u(+((g - k) * .5));
            k = m * m + k * (+t(+l) * +t(+f) * k);
            h = h + +z(+ +r(+k), + +r(+(1.0 - k))) * 2.0;
          } while ((a | 0) != (c | 0));

          e[d >> 3] = h;
          i = 0;
          m = h;
          m = m * 6371.007180918475;
          m = m * 1.0e3;
          e[d >> 3] = m;
          S = j;
          return i | 0;
        }

        function lc(a) {
          a = a | 0;
          var c = 0,
              d = 0,
              e = 0;
          c = fd(1, 12) | 0;
          if (!c) { H(22635, 22590, 49, 22648); }
          d = a + 4 | 0;
          e = b[d >> 2] | 0;

          if (e | 0) {
            e = e + 8 | 0;
            b[e >> 2] = c;
            b[d >> 2] = c;
            return c | 0;
          }

          if (b[a >> 2] | 0) { H(22665, 22590, 61, 22688); }
          e = a;
          b[e >> 2] = c;
          b[d >> 2] = c;
          return c | 0;
        }

        function mc(a, c) {
          a = a | 0;
          c = c | 0;
          var d = 0,
              e = 0;
          e = dd(24) | 0;
          if (!e) { H(22702, 22590, 78, 22716); }
          b[e >> 2] = b[c >> 2];
          b[e + 4 >> 2] = b[c + 4 >> 2];
          b[e + 8 >> 2] = b[c + 8 >> 2];
          b[e + 12 >> 2] = b[c + 12 >> 2];
          b[e + 16 >> 2] = 0;
          c = a + 4 | 0;
          d = b[c >> 2] | 0;

          if (d | 0) {
            b[d + 16 >> 2] = e;
            b[c >> 2] = e;
            return e | 0;
          }

          if (b[a >> 2] | 0) { H(22731, 22590, 82, 22716); }
          b[a >> 2] = e;
          b[c >> 2] = e;
          return e | 0;
        }

        function nc(a) {
          a = a | 0;
          var c = 0,
              d = 0,
              e = 0,
              f = 0;
          if (!a) { return; }
          e = 1;

          while (1) {
            c = b[a >> 2] | 0;
            if (c | 0) { do {
              d = b[c >> 2] | 0;
              if (d | 0) { do {
                f = d;
                d = b[d + 16 >> 2] | 0;
                ed(f);
              } while ((d | 0) != 0); }
              f = c;
              c = b[c + 8 >> 2] | 0;
              ed(f);
            } while ((c | 0) != 0); }
            c = a;
            a = b[a + 8 >> 2] | 0;
            if (!e) { ed(c); }
            if (!a) { break; }else { e = 0; }
          }

          return;
        }

        function oc(a) {
          a = a | 0;
          var c = 0,
              d = 0,
              f = 0,
              g = 0,
              h = 0.0,
              i = 0,
              j = 0.0,
              k = 0.0,
              l = 0,
              m = 0,
              n = 0,
              o = 0,
              p = 0,
              r = 0,
              s = 0.0,
              t = 0.0,
              u = 0.0,
              v = 0.0,
              w = 0.0,
              x = 0.0,
              y = 0,
              z = 0,
              A = 0,
              B = 0,
              C = 0,
              D = 0,
              E = 0,
              F = 0,
              G = 0,
              I = 0,
              J = 0,
              K = 0;
          g = a + 8 | 0;

          if (b[g >> 2] | 0) {
            K = 1;
            return K | 0;
          }

          f = b[a >> 2] | 0;

          if (!f) {
            K = 0;
            return K | 0;
          }

          c = f;
          d = 0;

          do {
            d = d + 1 | 0;
            c = b[c + 8 >> 2] | 0;
          } while ((c | 0) != 0);

          if (d >>> 0 < 2) {
            K = 0;
            return K | 0;
          }

          I = dd(d << 2) | 0;
          if (!I) { H(22751, 22590, 317, 22770); }
          G = dd(d << 5) | 0;
          if (!G) { H(22792, 22590, 321, 22770); }
          b[a >> 2] = 0;
          z = a + 4 | 0;
          b[z >> 2] = 0;
          b[g >> 2] = 0;
          d = 0;
          F = 0;
          y = 0;
          n = 0;

          a: while (1) {
            m = b[f >> 2] | 0;

            if (m) {
              h = 0.0;
              i = m;

              do {
                k = +e[i + 8 >> 3];
                c = i;
                i = b[i + 16 >> 2] | 0;
                l = (i | 0) == 0;
                g = l ? m : i;
                j = +e[g + 8 >> 3];

                if (+q(+(k - j)) > 3.141592653589793) {
                  K = 14;
                  break;
                }

                h = h + (j - k) * (+e[c >> 3] + +e[g >> 3]);
              } while (!l);

              if ((K | 0) == 14) {
                K = 0;
                h = 0.0;
                c = m;

                do {
                  x = +e[c + 8 >> 3];
                  E = c + 16 | 0;
                  D = b[E >> 2] | 0;
                  D = (D | 0) == 0 ? m : D;
                  w = +e[D + 8 >> 3];
                  h = h + (+e[c >> 3] + +e[D >> 3]) * ((w < 0.0 ? w + 6.283185307179586 : w) - (x < 0.0 ? x + 6.283185307179586 : x));
                  c = b[((c | 0) == 0 ? f : E) >> 2] | 0;
                } while ((c | 0) != 0);
              }

              if (h > 0.0) {
                b[I + (F << 2) >> 2] = f;
                F = F + 1 | 0;
                g = y;
                c = n;
              } else { K = 19; }
            } else { K = 19; }

            if ((K | 0) == 19) {
              K = 0;

              do { if (!d) {
                if (!n) {
                  if (!(b[a >> 2] | 0)) {
                    g = z;
                    i = a;
                    c = f;
                    d = a;
                    break;
                  } else {
                    K = 27;
                    break a;
                  }
                } else {
                  g = z;
                  i = n + 8 | 0;
                  c = f;
                  d = a;
                  break;
                }
              } else {
                c = d + 8 | 0;

                if (b[c >> 2] | 0) {
                  K = 21;
                  break a;
                }

                d = fd(1, 12) | 0;

                if (!d) {
                  K = 23;
                  break a;
                }

                b[c >> 2] = d;
                g = d + 4 | 0;
                i = d;
                c = n;
              } } while (0);

              b[i >> 2] = f;
              b[g >> 2] = f;
              i = G + (y << 5) | 0;
              l = b[f >> 2] | 0;

              if (l) {
                m = G + (y << 5) + 8 | 0;
                e[m >> 3] = 1797693134862315708145274.0e284;
                n = G + (y << 5) + 24 | 0;
                e[n >> 3] = 1797693134862315708145274.0e284;
                e[i >> 3] = -1797693134862315708145274.0e284;
                o = G + (y << 5) + 16 | 0;
                e[o >> 3] = -1797693134862315708145274.0e284;
                u = 1797693134862315708145274.0e284;
                v = -1797693134862315708145274.0e284;
                g = 0;
                p = l;
                k = 1797693134862315708145274.0e284;
                s = 1797693134862315708145274.0e284;
                t = -1797693134862315708145274.0e284;
                j = -1797693134862315708145274.0e284;

                while (1) {
                  h = +e[p >> 3];
                  x = +e[p + 8 >> 3];
                  p = b[p + 16 >> 2] | 0;
                  r = (p | 0) == 0;
                  w = +e[(r ? l : p) + 8 >> 3];

                  if (h < k) {
                    e[m >> 3] = h;
                    k = h;
                  }

                  if (x < s) {
                    e[n >> 3] = x;
                    s = x;
                  }

                  if (h > t) { e[i >> 3] = h; }else { h = t; }

                  if (x > j) {
                    e[o >> 3] = x;
                    j = x;
                  }

                  u = x > 0.0 & x < u ? x : u;
                  v = x < 0.0 & x > v ? x : v;
                  g = g | +q(+(x - w)) > 3.141592653589793;
                  if (r) { break; }else { t = h; }
                }

                if (g) {
                  e[o >> 3] = v;
                  e[n >> 3] = u;
                }
              } else {
                b[i >> 2] = 0;
                b[i + 4 >> 2] = 0;
                b[i + 8 >> 2] = 0;
                b[i + 12 >> 2] = 0;
                b[i + 16 >> 2] = 0;
                b[i + 20 >> 2] = 0;
                b[i + 24 >> 2] = 0;
                b[i + 28 >> 2] = 0;
              }

              g = y + 1 | 0;
            }

            E = f + 8 | 0;
            f = b[E >> 2] | 0;
            b[E >> 2] = 0;

            if (!f) {
              K = 45;
              break;
            } else {
              y = g;
              n = c;
            }
          }

          if ((K | 0) == 21) { H(22568, 22590, 35, 22602); }else if ((K | 0) == 23) { H(22622, 22590, 37, 22602); }else if ((K | 0) == 27) { H(22665, 22590, 61, 22688); }else if ((K | 0) == 45) {
            b: do { if ((F | 0) > 0) {
              E = (g | 0) == 0;
              C = g << 2;
              D = (a | 0) == 0;
              B = 0;
              c = 0;

              while (1) {
                A = b[I + (B << 2) >> 2] | 0;

                if (!E) {
                  y = dd(C) | 0;

                  if (!y) {
                    K = 50;
                    break;
                  }

                  z = dd(C) | 0;

                  if (!z) {
                    K = 52;
                    break;
                  }

                  c: do { if (!D) {
                    g = 0;
                    d = 0;
                    i = a;

                    while (1) {
                      f = G + (g << 5) | 0;

                      if (pc(b[i >> 2] | 0, f, b[A >> 2] | 0) | 0) {
                        b[y + (d << 2) >> 2] = i;
                        b[z + (d << 2) >> 2] = f;
                        r = d + 1 | 0;
                      } else { r = d; }

                      i = b[i + 8 >> 2] | 0;
                      if (!i) { break; }else {
                        g = g + 1 | 0;
                        d = r;
                      }
                    }

                    if ((r | 0) > 0) {
                      f = b[y >> 2] | 0;
                      if ((r | 0) == 1) { d = f; }else {
                        o = 0;
                        p = -1;
                        d = f;
                        n = f;

                        while (1) {
                          l = b[n >> 2] | 0;
                          f = 0;
                          i = 0;

                          while (1) {
                            g = b[b[y + (i << 2) >> 2] >> 2] | 0;
                            if ((g | 0) == (l | 0)) { m = f; }else { m = f + ((pc(g, b[z + (i << 2) >> 2] | 0, b[l >> 2] | 0) | 0) & 1) | 0; }
                            i = i + 1 | 0;
                            if ((i | 0) == (r | 0)) { break; }else { f = m; }
                          }

                          g = (m | 0) > (p | 0);
                          d = g ? n : d;
                          f = o + 1 | 0;
                          if ((f | 0) == (r | 0)) { break c; }
                          o = f;
                          p = g ? m : p;
                          n = b[y + (f << 2) >> 2] | 0;
                        }
                      }
                    } else { d = 0; }
                  } else { d = 0; } } while (0);

                  ed(y);
                  ed(z);

                  if (d) {
                    g = d + 4 | 0;
                    f = b[g >> 2] | 0;

                    if (!f) {
                      if (b[d >> 2] | 0) {
                        K = 70;
                        break;
                      }
                    } else { d = f + 8 | 0; }

                    b[d >> 2] = A;
                    b[g >> 2] = A;
                  } else { K = 73; }
                } else { K = 73; }

                if ((K | 0) == 73) {
                  K = 0;
                  c = b[A >> 2] | 0;
                  if (c | 0) { do {
                    z = c;
                    c = b[c + 16 >> 2] | 0;
                    ed(z);
                  } while ((c | 0) != 0); }
                  ed(A);
                  c = 1;
                }

                B = B + 1 | 0;

                if ((B | 0) >= (F | 0)) {
                  J = c;
                  break b;
                }
              }

              if ((K | 0) == 50) { H(22807, 22590, 249, 22826); }else if ((K | 0) == 52) { H(22845, 22590, 252, 22826); }else if ((K | 0) == 70) { H(22665, 22590, 61, 22688); }
            } else { J = 0; } } while (0);

            ed(I);
            ed(G);
            K = J;
            return K | 0;
          }
          return 0;
        }

        function pc(a, c, d) {
          a = a | 0;
          c = c | 0;
          d = d | 0;
          var f = 0.0,
              g = 0.0,
              h = 0.0,
              i = 0.0,
              j = 0.0,
              k = 0.0,
              l = 0.0,
              m = 0;

          if (!(xa(c, d) | 0)) {
            a = 0;
            return a | 0;
          }

          c = wa(c) | 0;
          f = +e[d >> 3];
          g = +e[d + 8 >> 3];
          g = c & g < 0.0 ? g + 6.283185307179586 : g;
          a = b[a >> 2] | 0;

          if (!a) {
            a = 0;
            return a | 0;
          }

          if (c) {
            c = 0;
            l = g;
            d = a;

            a: while (1) {
              while (1) {
                i = +e[d >> 3];
                g = +e[d + 8 >> 3];
                d = d + 16 | 0;
                m = b[d >> 2] | 0;
                m = (m | 0) == 0 ? a : m;
                h = +e[m >> 3];
                j = +e[m + 8 >> 3];

                if (i > h) {
                  k = i;
                  i = j;
                } else {
                  k = h;
                  h = i;
                  i = g;
                  g = j;
                }

                f = f == h | f == k ? f + 2.220446049250313e-16 : f;
                if (!(f < h | f > k)) { break; }
                d = b[d >> 2] | 0;

                if (!d) {
                  d = 22;
                  break a;
                }
              }

              j = i < 0.0 ? i + 6.283185307179586 : i;
              i = g < 0.0 ? g + 6.283185307179586 : g;
              l = j == l | i == l ? l + -2.220446049250313e-16 : l;
              k = j + (i - j) * ((f - h) / (k - h));
              if ((k < 0.0 ? k + 6.283185307179586 : k) > l) { c = c ^ 1; }
              d = b[d >> 2] | 0;

              if (!d) {
                d = 22;
                break;
              }
            }

            if ((d | 0) == 22) { return c | 0; }
          } else {
            c = 0;
            l = g;
            d = a;

            b: while (1) {
              while (1) {
                i = +e[d >> 3];
                g = +e[d + 8 >> 3];
                d = d + 16 | 0;
                m = b[d >> 2] | 0;
                m = (m | 0) == 0 ? a : m;
                h = +e[m >> 3];
                j = +e[m + 8 >> 3];

                if (i > h) {
                  k = i;
                  i = j;
                } else {
                  k = h;
                  h = i;
                  i = g;
                  g = j;
                }

                f = f == h | f == k ? f + 2.220446049250313e-16 : f;
                if (!(f < h | f > k)) { break; }
                d = b[d >> 2] | 0;

                if (!d) {
                  d = 22;
                  break b;
                }
              }

              l = i == l | g == l ? l + -2.220446049250313e-16 : l;
              if (i + (g - i) * ((f - h) / (k - h)) > l) { c = c ^ 1; }
              d = b[d >> 2] | 0;

              if (!d) {
                d = 22;
                break;
              }
            }

            if ((d | 0) == 22) { return c | 0; }
          }

          return 0;
        }

        function qc(c, d, e, f, g) {
          c = c | 0;
          d = d | 0;
          e = e | 0;
          f = f | 0;
          g = g | 0;
          var h = 0,
              i = 0,
              j = 0,
              k = 0,
              l = 0,
              m = 0,
              n = 0,
              o = 0,
              p = 0,
              q = 0,
              r = 0,
              s = 0,
              t = 0,
              u = 0;
          u = S;
          S = S + 32 | 0;
          t = u + 16 | 0;
          s = u;
          h = qd(c | 0, d | 0, 52) | 0;
          G() | 0;
          h = h & 15;
          p = qd(e | 0, f | 0, 52) | 0;
          G() | 0;

          if ((h | 0) != (p & 15 | 0)) {
            t = 12;
            S = u;
            return t | 0;
          }

          l = qd(c | 0, d | 0, 45) | 0;
          G() | 0;
          l = l & 127;
          m = qd(e | 0, f | 0, 45) | 0;
          G() | 0;
          m = m & 127;

          if (l >>> 0 > 121 | m >>> 0 > 121) {
            t = 5;
            S = u;
            return t | 0;
          }

          p = (l | 0) != (m | 0);

          if (p) {
            j = ta(l, m) | 0;

            if ((j | 0) == 7) {
              t = 1;
              S = u;
              return t | 0;
            }

            k = ta(m, l) | 0;
            if ((k | 0) == 7) { H(22869, 22893, 161, 22903); }else {
              q = j;
              i = k;
            }
          } else {
            q = 0;
            i = 0;
          }

          n = la(l) | 0;
          o = la(m) | 0;
          b[t >> 2] = 0;
          b[t + 4 >> 2] = 0;
          b[t + 8 >> 2] = 0;
          b[t + 12 >> 2] = 0;

          do { if (!q) {
            Kb(e, f, t) | 0;

            if ((n | 0) != 0 & (o | 0) != 0) {
              if ((m | 0) != (l | 0)) { H(22976, 22893, 261, 22903); }
              i = Cb(c, d) | 0;
              h = Cb(e, f) | 0;
              if (!((i | 0) == 7 | (h | 0) == 7)) {
                if (!(a[21872 + (i * 7 | 0) + h >> 0] | 0)) {
                  i = b[21040 + (i * 28 | 0) + (h << 2) >> 2] | 0;

                  if ((i | 0) > 0) {
                    j = t + 4 | 0;
                    h = 0;

                    do {
                      Oa(j);
                      h = h + 1 | 0;
                    } while ((h | 0) != (i | 0));

                    r = 51;
                  } else { r = 51; }
                } else { h = 1; }
              } else { h = 5; }
            } else { r = 51; }
          } else {
            m = b[4272 + (l * 28 | 0) + (q << 2) >> 2] | 0;
            j = (m | 0) > 0;
            if (!o) {
              if (j) {
                l = 0;
                k = e;
                j = f;

                do {
                  k = Gb(k, j) | 0;
                  j = G() | 0;
                  i = Qa(i) | 0;
                  l = l + 1 | 0;
                } while ((l | 0) != (m | 0));

                m = i;
                l = k;
                k = j;
              } else {
                m = i;
                l = e;
                k = f;
              }
            } else if (j) {
              l = 0;
              k = e;
              j = f;

              do {
                k = Fb(k, j) | 0;
                j = G() | 0;
                i = Qa(i) | 0;
                if ((i | 0) == 1) { i = Qa(1) | 0; }
                l = l + 1 | 0;
              } while ((l | 0) != (m | 0));

              m = i;
              l = k;
              k = j;
            } else {
              m = i;
              l = e;
              k = f;
            }
            Kb(l, k, t) | 0;
            if (!p) { H(22918, 22893, 191, 22903); }
            j = (n | 0) != 0;
            i = (o | 0) != 0;
            if (j & i) { H(22945, 22893, 192, 22903); }
            if (!j) {
              if (i) {
                i = Cb(l, k) | 0;

                if ((i | 0) == 7) {
                  h = 5;
                  break;
                }

                if (a[21872 + (i * 7 | 0) + m >> 0] | 0) {
                  h = 1;
                  break;
                }

                l = 0;
                k = b[21040 + (m * 28 | 0) + (i << 2) >> 2] | 0;
              } else {
                l = 0;
                k = 0;
              }
            } else {
              i = Cb(c, d) | 0;

              if ((i | 0) == 7) {
                h = 5;
                break;
              }

              if (a[21872 + (i * 7 | 0) + q >> 0] | 0) {
                h = 1;
                break;
              }

              k = b[21040 + (i * 28 | 0) + (q << 2) >> 2] | 0;
              l = k;
            }
            if ((l | k | 0) < 0) { h = 5; }else {
              if ((k | 0) > 0) {
                j = t + 4 | 0;
                i = 0;

                do {
                  Oa(j);
                  i = i + 1 | 0;
                } while ((i | 0) != (k | 0));
              }
              b[s >> 2] = 0;
              b[s + 4 >> 2] = 0;
              b[s + 8 >> 2] = 0;
              Ma(s, q);
              if (h | 0) { while (1) {
                if (!(Ib(h) | 0)) { La(s); }else { Ka(s); }
                if ((h | 0) > 1) { h = h + -1 | 0; }else { break; }
              } }

              if ((l | 0) > 0) {
                h = 0;

                do {
                  Oa(s);
                  h = h + 1 | 0;
                } while ((h | 0) != (l | 0));
              }

              r = t + 4 | 0;
              Ea(r, s, r);
              Ca(r);
              r = 51;
            }
          } } while (0);

          if ((r | 0) == 51) {
            h = t + 4 | 0;
            b[g >> 2] = b[h >> 2];
            b[g + 4 >> 2] = b[h + 4 >> 2];
            b[g + 8 >> 2] = b[h + 8 >> 2];
            h = 0;
          }

          t = h;
          S = u;
          return t | 0;
        }

        function rc(a, c, d, e) {
          a = a | 0;
          c = c | 0;
          d = d | 0;
          e = e | 0;
          var f = 0,
              g = 0,
              h = 0,
              i = 0,
              j = 0,
              k = 0,
              l = 0,
              m = 0,
              n = 0,
              o = 0,
              p = 0,
              q = 0,
              r = 0,
              s = 0,
              t = 0;
          p = S;
          S = S + 48 | 0;
          h = p + 36 | 0;
          i = p + 24 | 0;
          j = p + 12 | 0;
          k = p;
          g = qd(a | 0, c | 0, 52) | 0;
          G() | 0;
          g = g & 15;
          n = qd(a | 0, c | 0, 45) | 0;
          G() | 0;
          n = n & 127;

          if (n >>> 0 > 121) {
            e = 5;
            S = p;
            return e | 0;
          }

          l = la(n) | 0;
          rd(g | 0, 0, 52) | 0;
          r = G() | 0 | 134225919;
          q = e;
          b[q >> 2] = -1;
          b[q + 4 >> 2] = r;

          if (!g) {
            f = Ha(d) | 0;

            if ((f | 0) == 7) {
              r = 1;
              S = p;
              return r | 0;
            }

            f = sa(n, f) | 0;

            if ((f | 0) == 127) {
              r = 1;
              S = p;
              return r | 0;
            }

            o = rd(f | 0, 0, 45) | 0;
            q = G() | 0;
            n = e;
            q = b[n + 4 >> 2] & -1040385 | q;
            r = e;
            b[r >> 2] = b[n >> 2] | o;
            b[r + 4 >> 2] = q;
            r = 0;
            S = p;
            return r | 0;
          }
          b[h >> 2] = b[d >> 2];
          b[h + 4 >> 2] = b[d + 4 >> 2];
          b[h + 8 >> 2] = b[d + 8 >> 2];

          while (1) {
            b[i >> 2] = b[h >> 2];
            b[i + 4 >> 2] = b[h + 4 >> 2];
            b[i + 8 >> 2] = b[h + 8 >> 2];

            if (!(Ib(g) | 0)) {
              Ja(h);
              b[j >> 2] = b[h >> 2];
              b[j + 4 >> 2] = b[h + 4 >> 2];
              b[j + 8 >> 2] = b[h + 8 >> 2];
              La(j);
            } else {
              Ia(h);
              b[j >> 2] = b[h >> 2];
              b[j + 4 >> 2] = b[h + 4 >> 2];
              b[j + 8 >> 2] = b[h + 8 >> 2];
              Ka(j);
            }

            Fa(i, j, k);
            Ca(k);
            q = e;
            s = b[q >> 2] | 0;
            q = b[q + 4 >> 2] | 0;
            t = (15 - g | 0) * 3 | 0;
            d = rd(7, 0, t | 0) | 0;
            q = q & ~(G() | 0);
            t = rd(Ha(k) | 0, 0, t | 0) | 0;
            q = G() | 0 | q;
            r = e;
            b[r >> 2] = t | s & ~d;
            b[r + 4 >> 2] = q;
            if ((g | 0) > 1) { g = g + -1 | 0; }else { break; }
          }

          a: do { if (((b[h >> 2] | 0) <= 1 ? (b[h + 4 >> 2] | 0) <= 1 : 0) ? (b[h + 8 >> 2] | 0) <= 1 : 0) {
            d = Ha(h) | 0;
            i = sa(n, d) | 0;
            if ((i | 0) == 127) { k = 0; }else { k = la(i) | 0; }

            b: do { if (!d) {
              if ((l | 0) != 0 & (k | 0) != 0) {
                f = Cb(a, c) | 0;
                g = e;
                g = Cb(b[g >> 2] | 0, b[g + 4 >> 2] | 0) | 0;

                if ((f | 0) == 7 | (g | 0) == 7) {
                  f = 5;
                  break a;
                }

                g = b[21248 + (f * 28 | 0) + (g << 2) >> 2] | 0;

                if ((g | 0) < 0) {
                  f = 5;
                  break a;
                }

                if (!g) {
                  f = i;
                  g = 54;
                } else {
                  h = e;
                  f = 0;
                  d = b[h >> 2] | 0;
                  h = b[h + 4 >> 2] | 0;

                  do {
                    d = Eb(d, h) | 0;
                    h = G() | 0;
                    t = e;
                    b[t >> 2] = d;
                    b[t + 4 >> 2] = h;
                    f = f + 1 | 0;
                  } while ((f | 0) < (g | 0));

                  f = i;
                  g = 53;
                }
              } else {
                f = i;
                g = 53;
              }
            } else {
              if (l) {
                g = Cb(a, c) | 0;

                if ((g | 0) == 7) {
                  f = 5;
                  break a;
                }

                h = b[21248 + (g * 28 | 0) + (d << 2) >> 2] | 0;

                if ((h | 0) > 0) {
                  g = d;
                  d = 0;

                  do {
                    g = Pa(g) | 0;
                    d = d + 1 | 0;
                  } while ((d | 0) != (h | 0));
                } else { g = d; }

                if ((g | 0) == 1) {
                  f = 9;
                  break a;
                }

                d = sa(n, g) | 0;
                if ((d | 0) == 127) { H(23003, 22893, 406, 23033); }

                if (!(la(d) | 0)) {
                  f = d;
                  o = h;
                  m = g;
                } else { H(23048, 22893, 407, 23033); }
              } else {
                f = i;
                o = 0;
                m = d;
              }

              j = b[4272 + (n * 28 | 0) + (m << 2) >> 2] | 0;
              if ((j | 0) <= -1) { H(23079, 22893, 414, 23033); }

              if (!k) {
                if ((o | 0) < 0) {
                  f = 5;
                  break a;
                }

                if (o | 0) {
                  h = e;
                  g = 0;
                  d = b[h >> 2] | 0;
                  h = b[h + 4 >> 2] | 0;

                  do {
                    d = Eb(d, h) | 0;
                    h = G() | 0;
                    t = e;
                    b[t >> 2] = d;
                    b[t + 4 >> 2] = h;
                    g = g + 1 | 0;
                  } while ((g | 0) < (o | 0));
                }

                if ((j | 0) <= 0) {
                  g = 53;
                  break;
                }

                h = e;
                g = 0;
                d = b[h >> 2] | 0;
                h = b[h + 4 >> 2] | 0;

                while (1) {
                  d = Eb(d, h) | 0;
                  h = G() | 0;
                  t = e;
                  b[t >> 2] = d;
                  b[t + 4 >> 2] = h;
                  g = g + 1 | 0;

                  if ((g | 0) == (j | 0)) {
                    g = 53;
                    break b;
                  }
                }
              }

              i = ta(f, n) | 0;
              if ((i | 0) == 7) { H(22869, 22893, 423, 23033); }
              g = e;
              d = b[g >> 2] | 0;
              g = b[g + 4 >> 2] | 0;

              if ((j | 0) > 0) {
                h = 0;

                do {
                  d = Eb(d, g) | 0;
                  g = G() | 0;
                  t = e;
                  b[t >> 2] = d;
                  b[t + 4 >> 2] = g;
                  h = h + 1 | 0;
                } while ((h | 0) != (j | 0));
              }

              g = Cb(d, g) | 0;

              if ((g | 0) == 7) {
                f = 5;
                break a;
              }

              d = ma(f) | 0;
              d = b[(d ? 21664 : 21456) + (i * 28 | 0) + (g << 2) >> 2] | 0;

              if ((d | 0) < 0) {
                f = 5;
                break a;
              }

              if (!d) { g = 53; }else {
                i = e;
                g = 0;
                h = b[i >> 2] | 0;
                i = b[i + 4 >> 2] | 0;

                do {
                  h = Db(h, i) | 0;
                  i = G() | 0;
                  t = e;
                  b[t >> 2] = h;
                  b[t + 4 >> 2] = i;
                  g = g + 1 | 0;
                } while ((g | 0) < (d | 0));

                g = 53;
              }
            } } while (0);

            if ((g | 0) == 53) { if (k) { g = 54; } }

            if ((g | 0) == 54) {
              t = e;

              if ((Cb(b[t >> 2] | 0, b[t + 4 >> 2] | 0) | 0) == 1) {
                f = 9;
                break;
              }
            }

            t = e;
            r = b[t >> 2] | 0;
            t = b[t + 4 >> 2] & -1040385;
            s = rd(f | 0, 0, 45) | 0;
            t = t | (G() | 0);
            f = e;
            b[f >> 2] = r | s;
            b[f + 4 >> 2] = t;
            f = 0;
          } else { f = 1; } } while (0);

          t = f;
          S = p;
          return t | 0;
        }

        function sc(a, b, c, d, e, f) {
          a = a | 0;
          b = b | 0;
          c = c | 0;
          d = d | 0;
          e = e | 0;
          f = f | 0;
          var g = 0,
              h = 0;
          h = S;
          S = S + 16 | 0;
          g = h;

          if (!e) {
            a = qc(a, b, c, d, g) | 0;

            if (!a) {
              Ua(g, f);
              a = 0;
            }
          } else { a = 15; }

          S = h;
          return a | 0;
        }

        function tc(a, b, c, d, e) {
          a = a | 0;
          b = b | 0;
          c = c | 0;
          d = d | 0;
          e = e | 0;
          var f = 0,
              g = 0;
          g = S;
          S = S + 16 | 0;
          f = g;

          if (!d) {
            Va(c, f);
            a = rc(a, b, f, e) | 0;
          } else { a = 15; }

          S = g;
          return a | 0;
        }

        function uc(a, c, d, e, f) {
          a = a | 0;
          c = c | 0;
          d = d | 0;
          e = e | 0;
          f = f | 0;
          var g = 0,
              h = 0,
              i = 0,
              j = 0;
          j = S;
          S = S + 32 | 0;
          h = j + 12 | 0;
          i = j;
          g = qc(a, c, a, c, h) | 0;

          if (g | 0) {
            i = g;
            S = j;
            return i | 0;
          }

          a = qc(a, c, d, e, i) | 0;

          if (a | 0) {
            i = a;
            S = j;
            return i | 0;
          }

          h = Ta(h, i) | 0;
          i = f;
          b[i >> 2] = h;
          b[i + 4 >> 2] = ((h | 0) < 0) << 31 >> 31;
          i = 0;
          S = j;
          return i | 0;
        }

        function vc(a, c, d, e, f) {
          a = a | 0;
          c = c | 0;
          d = d | 0;
          e = e | 0;
          f = f | 0;
          var g = 0,
              h = 0,
              i = 0,
              j = 0;
          j = S;
          S = S + 32 | 0;
          h = j + 12 | 0;
          i = j;
          g = qc(a, c, a, c, h) | 0;

          if (!g) {
            g = qc(a, c, d, e, i) | 0;

            if (!g) {
              e = Ta(h, i) | 0;
              e = gd(e | 0, ((e | 0) < 0) << 31 >> 31 | 0, 1, 0) | 0;
              h = G() | 0;
              i = f;
              b[i >> 2] = e;
              b[i + 4 >> 2] = h;
              i = 0;
              S = j;
              return i | 0;
            }
          }

          i = g;
          S = j;
          return i | 0;
        }

        function wc(a, c, d, e, f) {
          a = a | 0;
          c = c | 0;
          d = d | 0;
          e = e | 0;
          f = f | 0;
          var g = 0,
              h = 0,
              i = 0,
              j = 0.0,
              k = 0.0,
              l = 0,
              m = 0,
              n = 0,
              o = 0,
              p = 0.0,
              r = 0.0,
              s = 0.0,
              t = 0,
              u = 0,
              v = 0,
              w = 0,
              x = 0,
              y = 0,
              z = 0,
              A = 0.0;
          z = S;
          S = S + 48 | 0;
          h = z + 24 | 0;
          i = z + 12 | 0;
          y = z;
          g = qc(a, c, a, c, h) | 0;

          if (!g) {
            g = qc(a, c, d, e, i) | 0;

            if (!g) {
              w = Ta(h, i) | 0;
              x = ((w | 0) < 0) << 31 >> 31;
              b[h >> 2] = 0;
              b[h + 4 >> 2] = 0;
              b[h + 8 >> 2] = 0;
              b[i >> 2] = 0;
              b[i + 4 >> 2] = 0;
              b[i + 8 >> 2] = 0;
              g = qc(a, c, a, c, h) | 0;

              if (!g) {
                g = qc(a, c, d, e, i) | 0;

                if (!g) {
                  Wa(h);
                  Wa(i);

                  if (!w) {
                    g = h + 4 | 0;
                    d = h + 8 | 0;
                    t = g;
                    u = d;
                    v = h;
                    e = b[h >> 2] | 0;
                    g = b[g >> 2] | 0;
                    d = b[d >> 2] | 0;
                    r = 0.0;
                    s = 0.0;
                    p = 0.0;
                  } else {
                    m = b[h >> 2] | 0;
                    p = +(w | 0);
                    t = h + 4 | 0;
                    n = b[t >> 2] | 0;
                    u = h + 8 | 0;
                    o = b[u >> 2] | 0;
                    v = h;
                    e = m;
                    g = n;
                    d = o;
                    r = +((b[i >> 2] | 0) - m | 0) / p;
                    s = +((b[i + 4 >> 2] | 0) - n | 0) / p;
                    p = +((b[i + 8 >> 2] | 0) - o | 0) / p;
                  }

                  b[y >> 2] = e;
                  o = y + 4 | 0;
                  b[o >> 2] = g;
                  n = y + 8 | 0;
                  b[n >> 2] = d;

                  a: do { if ((w | 0) < 0) { g = 0; }else {
                    l = 0;
                    m = 0;
                    g = e;

                    while (1) {
                      k = +(m >>> 0) + 4294967296.0 * +(l | 0);
                      A = r * k + +(g | 0);
                      j = s * k + +(b[t >> 2] | 0);
                      k = p * k + +(b[u >> 2] | 0);
                      d = ~~+td(+A);
                      h = ~~+td(+j);
                      g = ~~+td(+k);
                      A = +q(+(+(d | 0) - A));
                      j = +q(+(+(h | 0) - j));
                      k = +q(+(+(g | 0) - k));

                      do { if (!(A > j & A > k)) {
                        i = 0 - d | 0;

                        if (j > k) {
                          e = i - g | 0;
                          break;
                        } else {
                          e = h;
                          g = i - h | 0;
                          break;
                        }
                      } else {
                        d = 0 - (h + g) | 0;
                        e = h;
                      } } while (0);

                      b[y >> 2] = d;
                      b[o >> 2] = e;
                      b[n >> 2] = g;
                      Xa(y);
                      g = rc(a, c, y, f + (m << 3) | 0) | 0;
                      if (g | 0) { break a; }

                      if (!((l | 0) < (x | 0) | (l | 0) == (x | 0) & m >>> 0 < w >>> 0)) {
                        g = 0;
                        break a;
                      }

                      g = gd(m | 0, l | 0, 1, 0) | 0;
                      i = G() | 0;
                      l = i;
                      m = g;
                      g = b[v >> 2] | 0;
                    }
                  } } while (0);
                }
              }

              y = g;
              S = z;
              return y | 0;
            }
          }

          y = g;
          S = z;
          return y | 0;
        }

        function xc(a, b, c, d) {
          a = a | 0;
          b = b | 0;
          c = c | 0;
          d = d | 0;
          var e = 0,
              f = 0,
              g = 0;

          if ((c | 0) == 0 & (d | 0) == 0) {
            e = 0;
            f = 1;
            F(e | 0);
            return f | 0;
          }

          f = a;
          e = b;
          a = 1;
          b = 0;

          do {
            g = (c & 1 | 0) == 0 & 0 == 0;
            a = md((g ? 1 : f) | 0, (g ? 0 : e) | 0, a | 0, b | 0) | 0;
            b = G() | 0;
            c = pd(c | 0, d | 0, 1) | 0;
            d = G() | 0;
            f = md(f | 0, e | 0, f | 0, e | 0) | 0;
            e = G() | 0;
          } while (!((c | 0) == 0 & (d | 0) == 0));

          F(b | 0);
          return a | 0;
        }

        function yc(a, c, d) {
          a = a | 0;
          c = c | 0;
          d = d | 0;
          var f = 0.0,
              g = 0.0,
              h = 0.0,
              i = 0.0,
              j = 0.0,
              k = 0.0,
              l = 0,
              m = 0.0,
              n = 0,
              o = 0;

          if (!(xa(c, d) | 0)) {
            o = 0;
            return o | 0;
          }

          c = wa(c) | 0;
          f = +e[d >> 3];
          g = +e[d + 8 >> 3];
          g = c & g < 0.0 ? g + 6.283185307179586 : g;
          o = b[a >> 2] | 0;

          if ((o | 0) <= 0) {
            o = 0;
            return o | 0;
          }

          n = b[a + 4 >> 2] | 0;

          if (c) {
            c = 0;
            m = g;
            d = -1;
            a = 0;

            a: while (1) {
              l = a;

              while (1) {
                i = +e[n + (l << 4) >> 3];
                g = +e[n + (l << 4) + 8 >> 3];
                a = (d + 2 | 0) % (o | 0) | 0;
                h = +e[n + (a << 4) >> 3];
                j = +e[n + (a << 4) + 8 >> 3];

                if (i > h) {
                  k = i;
                  i = j;
                } else {
                  k = h;
                  h = i;
                  i = g;
                  g = j;
                }

                f = f == h | f == k ? f + 2.220446049250313e-16 : f;
                if (!(f < h | f > k)) { break; }
                d = l + 1 | 0;

                if ((d | 0) >= (o | 0)) {
                  d = 22;
                  break a;
                } else {
                  a = l;
                  l = d;
                  d = a;
                }
              }

              j = i < 0.0 ? i + 6.283185307179586 : i;
              i = g < 0.0 ? g + 6.283185307179586 : g;
              m = j == m | i == m ? m + -2.220446049250313e-16 : m;
              k = j + (i - j) * ((f - h) / (k - h));
              if ((k < 0.0 ? k + 6.283185307179586 : k) > m) { c = c ^ 1; }
              a = l + 1 | 0;

              if ((a | 0) >= (o | 0)) {
                d = 22;
                break;
              } else { d = l; }
            }

            if ((d | 0) == 22) { return c | 0; }
          } else {
            c = 0;
            m = g;
            d = -1;
            a = 0;

            b: while (1) {
              l = a;

              while (1) {
                i = +e[n + (l << 4) >> 3];
                g = +e[n + (l << 4) + 8 >> 3];
                a = (d + 2 | 0) % (o | 0) | 0;
                h = +e[n + (a << 4) >> 3];
                j = +e[n + (a << 4) + 8 >> 3];

                if (i > h) {
                  k = i;
                  i = j;
                } else {
                  k = h;
                  h = i;
                  i = g;
                  g = j;
                }

                f = f == h | f == k ? f + 2.220446049250313e-16 : f;
                if (!(f < h | f > k)) { break; }
                d = l + 1 | 0;

                if ((d | 0) >= (o | 0)) {
                  d = 22;
                  break b;
                } else {
                  a = l;
                  l = d;
                  d = a;
                }
              }

              m = i == m | g == m ? m + -2.220446049250313e-16 : m;
              if (i + (g - i) * ((f - h) / (k - h)) > m) { c = c ^ 1; }
              a = l + 1 | 0;

              if ((a | 0) >= (o | 0)) {
                d = 22;
                break;
              } else { d = l; }
            }

            if ((d | 0) == 22) { return c | 0; }
          }

          return 0;
        }

        function zc(a, c) {
          a = a | 0;
          c = c | 0;
          var d = 0.0,
              f = 0.0,
              g = 0.0,
              h = 0.0,
              i = 0.0,
              j = 0.0,
              k = 0.0,
              l = 0.0,
              m = 0.0,
              n = 0,
              o = 0,
              p = 0,
              r = 0,
              s = 0,
              t = 0,
              u = 0,
              v = 0;
          r = b[a >> 2] | 0;

          if (!r) {
            b[c >> 2] = 0;
            b[c + 4 >> 2] = 0;
            b[c + 8 >> 2] = 0;
            b[c + 12 >> 2] = 0;
            b[c + 16 >> 2] = 0;
            b[c + 20 >> 2] = 0;
            b[c + 24 >> 2] = 0;
            b[c + 28 >> 2] = 0;
            return;
          }

          s = c + 8 | 0;
          e[s >> 3] = 1797693134862315708145274.0e284;
          t = c + 24 | 0;
          e[t >> 3] = 1797693134862315708145274.0e284;
          e[c >> 3] = -1797693134862315708145274.0e284;
          u = c + 16 | 0;
          e[u >> 3] = -1797693134862315708145274.0e284;
          if ((r | 0) <= 0) { return; }
          o = b[a + 4 >> 2] | 0;
          l = 1797693134862315708145274.0e284;
          m = -1797693134862315708145274.0e284;
          n = 0;
          a = -1;
          h = 1797693134862315708145274.0e284;
          i = 1797693134862315708145274.0e284;
          k = -1797693134862315708145274.0e284;
          f = -1797693134862315708145274.0e284;
          p = 0;

          while (1) {
            d = +e[o + (p << 4) >> 3];
            j = +e[o + (p << 4) + 8 >> 3];
            a = a + 2 | 0;
            g = +e[o + (((a | 0) == (r | 0) ? 0 : a) << 4) + 8 >> 3];

            if (d < h) {
              e[s >> 3] = d;
              h = d;
            }

            if (j < i) {
              e[t >> 3] = j;
              i = j;
            }

            if (d > k) { e[c >> 3] = d; }else { d = k; }

            if (j > f) {
              e[u >> 3] = j;
              f = j;
            }

            l = j > 0.0 & j < l ? j : l;
            m = j < 0.0 & j > m ? j : m;
            n = n | +q(+(j - g)) > 3.141592653589793;
            a = p + 1 | 0;
            if ((a | 0) == (r | 0)) { break; }else {
              v = p;
              k = d;
              p = a;
              a = v;
            }
          }

          if (!n) { return; }
          e[u >> 3] = m;
          e[t >> 3] = l;
          return;
        }

        function Ac(a, c) {
          a = a | 0;
          c = c | 0;
          var d = 0,
              f = 0,
              g = 0,
              h = 0.0,
              i = 0.0,
              j = 0.0,
              k = 0.0,
              l = 0.0,
              m = 0.0,
              n = 0.0,
              o = 0.0,
              p = 0.0,
              r = 0,
              s = 0,
              t = 0,
              u = 0,
              v = 0,
              w = 0,
              x = 0,
              y = 0,
              z = 0,
              A = 0;
          r = b[a >> 2] | 0;

          if (r) {
            s = c + 8 | 0;
            e[s >> 3] = 1797693134862315708145274.0e284;
            t = c + 24 | 0;
            e[t >> 3] = 1797693134862315708145274.0e284;
            e[c >> 3] = -1797693134862315708145274.0e284;
            u = c + 16 | 0;
            e[u >> 3] = -1797693134862315708145274.0e284;

            if ((r | 0) > 0) {
              g = b[a + 4 >> 2] | 0;
              o = 1797693134862315708145274.0e284;
              p = -1797693134862315708145274.0e284;
              f = 0;
              d = -1;
              k = 1797693134862315708145274.0e284;
              l = 1797693134862315708145274.0e284;
              n = -1797693134862315708145274.0e284;
              i = -1797693134862315708145274.0e284;
              v = 0;

              while (1) {
                h = +e[g + (v << 4) >> 3];
                m = +e[g + (v << 4) + 8 >> 3];
                z = d + 2 | 0;
                j = +e[g + (((z | 0) == (r | 0) ? 0 : z) << 4) + 8 >> 3];

                if (h < k) {
                  e[s >> 3] = h;
                  k = h;
                }

                if (m < l) {
                  e[t >> 3] = m;
                  l = m;
                }

                if (h > n) { e[c >> 3] = h; }else { h = n; }

                if (m > i) {
                  e[u >> 3] = m;
                  i = m;
                }

                o = m > 0.0 & m < o ? m : o;
                p = m < 0.0 & m > p ? m : p;
                f = f | +q(+(m - j)) > 3.141592653589793;
                d = v + 1 | 0;
                if ((d | 0) == (r | 0)) { break; }else {
                  z = v;
                  n = h;
                  v = d;
                  d = z;
                }
              }

              if (f) {
                e[u >> 3] = p;
                e[t >> 3] = o;
              }
            }
          } else {
            b[c >> 2] = 0;
            b[c + 4 >> 2] = 0;
            b[c + 8 >> 2] = 0;
            b[c + 12 >> 2] = 0;
            b[c + 16 >> 2] = 0;
            b[c + 20 >> 2] = 0;
            b[c + 24 >> 2] = 0;
            b[c + 28 >> 2] = 0;
          }

          z = a + 8 | 0;
          d = b[z >> 2] | 0;
          if ((d | 0) <= 0) { return; }
          y = a + 12 | 0;
          x = 0;

          do {
            g = b[y >> 2] | 0;
            f = x;
            x = x + 1 | 0;
            t = c + (x << 5) | 0;
            u = b[g + (f << 3) >> 2] | 0;

            if (u) {
              v = c + (x << 5) + 8 | 0;
              e[v >> 3] = 1797693134862315708145274.0e284;
              a = c + (x << 5) + 24 | 0;
              e[a >> 3] = 1797693134862315708145274.0e284;
              e[t >> 3] = -1797693134862315708145274.0e284;
              w = c + (x << 5) + 16 | 0;
              e[w >> 3] = -1797693134862315708145274.0e284;

              if ((u | 0) > 0) {
                r = b[g + (f << 3) + 4 >> 2] | 0;
                o = 1797693134862315708145274.0e284;
                p = -1797693134862315708145274.0e284;
                g = 0;
                f = -1;
                s = 0;
                k = 1797693134862315708145274.0e284;
                l = 1797693134862315708145274.0e284;
                m = -1797693134862315708145274.0e284;
                i = -1797693134862315708145274.0e284;

                while (1) {
                  h = +e[r + (s << 4) >> 3];
                  n = +e[r + (s << 4) + 8 >> 3];
                  f = f + 2 | 0;
                  j = +e[r + (((f | 0) == (u | 0) ? 0 : f) << 4) + 8 >> 3];

                  if (h < k) {
                    e[v >> 3] = h;
                    k = h;
                  }

                  if (n < l) {
                    e[a >> 3] = n;
                    l = n;
                  }

                  if (h > m) { e[t >> 3] = h; }else { h = m; }

                  if (n > i) {
                    e[w >> 3] = n;
                    i = n;
                  }

                  o = n > 0.0 & n < o ? n : o;
                  p = n < 0.0 & n > p ? n : p;
                  g = g | +q(+(n - j)) > 3.141592653589793;
                  f = s + 1 | 0;
                  if ((f | 0) == (u | 0)) { break; }else {
                    A = s;
                    s = f;
                    m = h;
                    f = A;
                  }
                }

                if (g) {
                  e[w >> 3] = p;
                  e[a >> 3] = o;
                }
              }
            } else {
              b[t >> 2] = 0;
              b[t + 4 >> 2] = 0;
              b[t + 8 >> 2] = 0;
              b[t + 12 >> 2] = 0;
              b[t + 16 >> 2] = 0;
              b[t + 20 >> 2] = 0;
              b[t + 24 >> 2] = 0;
              b[t + 28 >> 2] = 0;
              d = b[z >> 2] | 0;
            }
          } while ((x | 0) < (d | 0));

          return;
        }

        function Bc(a, c, d) {
          a = a | 0;
          c = c | 0;
          d = d | 0;
          var e = 0,
              f = 0,
              g = 0;

          if (!(yc(a, c, d) | 0)) {
            f = 0;
            return f | 0;
          }

          f = a + 8 | 0;

          if ((b[f >> 2] | 0) <= 0) {
            f = 1;
            return f | 0;
          }

          e = a + 12 | 0;
          a = 0;

          while (1) {
            g = a;
            a = a + 1 | 0;

            if (yc((b[e >> 2] | 0) + (g << 3) | 0, c + (a << 5) | 0, d) | 0) {
              a = 0;
              e = 6;
              break;
            }

            if ((a | 0) >= (b[f >> 2] | 0)) {
              a = 1;
              e = 6;
              break;
            }
          }

          if ((e | 0) == 6) { return a | 0; }
          return 0;
        }

        function Cc() {
          return 8;
        }

        function Dc() {
          return 16;
        }

        function Ec() {
          return 168;
        }

        function Fc() {
          return 8;
        }

        function Gc() {
          return 16;
        }

        function Hc() {
          return 12;
        }

        function Ic() {
          return 8;
        }

        function Jc(a) {
          a = a | 0;
          return +(+((b[a >> 2] | 0) >>> 0) + 4294967296.0 * +(b[a + 4 >> 2] | 0));
        }

        function Kc(a) {
          a = a | 0;
          var b = 0.0,
              c = 0.0;
          c = +e[a >> 3];
          b = +e[a + 8 >> 3];
          return + +r(+(c * c + b * b));
        }

        function Lc(a, b, c, d, f) {
          a = a | 0;
          b = b | 0;
          c = c | 0;
          d = d | 0;
          f = f | 0;
          var g = 0.0,
              h = 0.0,
              i = 0.0,
              j = 0.0,
              k = 0.0,
              l = 0.0,
              m = 0.0,
              n = 0.0;
          k = +e[a >> 3];
          j = +e[b >> 3] - k;
          i = +e[a + 8 >> 3];
          h = +e[b + 8 >> 3] - i;
          m = +e[c >> 3];
          g = +e[d >> 3] - m;
          n = +e[c + 8 >> 3];
          l = +e[d + 8 >> 3] - n;
          g = (g * (i - n) - (k - m) * l) / (j * l - h * g);
          e[f >> 3] = k + j * g;
          e[f + 8 >> 3] = i + h * g;
          return;
        }

        function Mc(a, b) {
          a = a | 0;
          b = b | 0;

          if (!(+q(+(+e[a >> 3] - +e[b >> 3])) < 1.1920928955078125e-07)) {
            b = 0;
            return b | 0;
          }

          b = +q(+(+e[a + 8 >> 3] - +e[b + 8 >> 3])) < 1.1920928955078125e-07;
          return b | 0;
        }

        function Nc(a, b) {
          a = a | 0;
          b = b | 0;
          var c = 0.0,
              d = 0.0,
              f = 0.0;
          f = +e[a >> 3] - +e[b >> 3];
          d = +e[a + 8 >> 3] - +e[b + 8 >> 3];
          c = +e[a + 16 >> 3] - +e[b + 16 >> 3];
          return +(f * f + d * d + c * c);
        }

        function Oc(a, b) {
          a = a | 0;
          b = b | 0;
          var c = 0.0,
              d = 0.0,
              f = 0.0;
          c = +e[a >> 3];
          d = +t(+c);
          c = +u(+c);
          e[b + 16 >> 3] = c;
          c = +e[a + 8 >> 3];
          f = d * +t(+c);
          e[b >> 3] = f;
          c = d * +u(+c);
          e[b + 8 >> 3] = c;
          return;
        }

        function Pc(a, c, d) {
          a = a | 0;
          c = c | 0;
          d = d | 0;
          var e = 0,
              f = 0,
              g = 0;
          g = S;
          S = S + 16 | 0;
          f = g;
          e = ub(a, c) | 0;

          if ((d + -1 | 0) >>> 0 > 5) {
            f = -1;
            S = g;
            return f | 0;
          }

          e = (e | 0) != 0;

          if ((d | 0) == 1 & e) {
            f = -1;
            S = g;
            return f | 0;
          }

          do { if (!(Qc(a, c, f) | 0)) {
            if (e) {
              e = ((b[21936 + (d << 2) >> 2] | 0) + 5 - (b[f >> 2] | 0) | 0) % 5 | 0;
              break;
            } else {
              e = ((b[21968 + (d << 2) >> 2] | 0) + 6 - (b[f >> 2] | 0) | 0) % 6 | 0;
              break;
            }
          } else { e = -1; } } while (0);

          f = e;
          S = g;
          return f | 0;
        }

        function Qc(a, c, d) {
          a = a | 0;
          c = c | 0;
          d = d | 0;
          var e = 0,
              f = 0,
              g = 0,
              h = 0,
              i = 0,
              j = 0,
              k = 0,
              l = 0;
          l = S;
          S = S + 32 | 0;
          i = l + 16 | 0;
          j = l;
          e = Lb(a, c, i) | 0;

          if (e | 0) {
            d = e;
            S = l;
            return d | 0;
          }

          f = qb(a, c) | 0;
          k = Cb(a, c) | 0;
          pa(f, j);
          e = qa(f, b[i >> 2] | 0) | 0;

          do { if (la(f) | 0) {
            do { switch (f | 0) {
              case 4:
                {
                  a = 0;
                  g = 15;
                  break;
                }

              case 14:
                {
                  a = 1;
                  g = 15;
                  break;
                }

              case 24:
                {
                  a = 2;
                  g = 15;
                  break;
                }

              case 38:
                {
                  a = 3;
                  g = 15;
                  break;
                }

              case 49:
                {
                  a = 4;
                  g = 15;
                  break;
                }

              case 58:
                {
                  a = 5;
                  g = 15;
                  break;
                }

              case 63:
                {
                  a = 6;
                  g = 15;
                  break;
                }

              case 72:
                {
                  a = 7;
                  g = 15;
                  break;
                }

              case 83:
                {
                  a = 8;
                  g = 15;
                  break;
                }

              case 97:
                {
                  a = 9;
                  g = 15;
                  break;
                }

              case 107:
                {
                  a = 10;
                  g = 15;
                  break;
                }

              case 117:
                {
                  a = 11;
                  g = 15;
                  break;
                }

              default:
                {
                  h = 0;
                  c = 0;
                }
            } } while (0);

            if ((g | 0) == 15) {
              h = b[22e3 + (a * 24 | 0) + 8 >> 2] | 0;
              c = b[22e3 + (a * 24 | 0) + 16 >> 2] | 0;
            }

            a = b[i >> 2] | 0;

            if ((a | 0) != (b[j >> 2] | 0)) {
              j = ma(f) | 0;
              a = b[i >> 2] | 0;
              if (j | (a | 0) == (c | 0)) { e = (e + 1 | 0) % 6 | 0; }
            }

            if ((k | 0) == 3 & (a | 0) == (c | 0)) {
              e = (e + 5 | 0) % 6 | 0;
              break;
            }

            if ((k | 0) == 5 & (a | 0) == (h | 0)) { e = (e + 1 | 0) % 6 | 0; }
          } } while (0);

          b[d >> 2] = e;
          d = 0;
          S = l;
          return d | 0;
        }

        function Rc(a, c, d, e) {
          a = a | 0;
          c = c | 0;
          d = d | 0;
          e = e | 0;
          var f = 0,
              g = 0,
              h = 0,
              i = 0,
              j = 0,
              k = 0,
              l = 0,
              m = 0,
              n = 0,
              o = 0,
              p = 0,
              q = 0,
              r = 0,
              s = 0,
              t = 0,
              u = 0;
          u = S;
          S = S + 32 | 0;
          t = u + 24 | 0;
          r = u + 20 | 0;
          p = u + 8 | 0;
          o = u + 16 | 0;
          n = u;
          j = (ub(a, c) | 0) == 0;
          j = j ? 6 : 5;
          l = qd(a | 0, c | 0, 52) | 0;
          G() | 0;
          l = l & 15;

          if (j >>> 0 <= d >>> 0) {
            e = 2;
            S = u;
            return e | 0;
          }

          m = (l | 0) == 0;
          if (!m ? (q = rd(7, 0, (l ^ 15) * 3 | 0) | 0, (q & a | 0) == 0 & ((G() | 0) & c | 0) == 0) : 0) { f = d; }else { g = 4; }

          a: do { if ((g | 0) == 4) {
            f = (ub(a, c) | 0) != 0;

            if (((f ? 4 : 5) | 0) < (d | 0)) {
              e = 1;
              S = u;
              return e | 0;
            }

            if (Qc(a, c, t) | 0) {
              e = 1;
              S = u;
              return e | 0;
            }

            g = (b[t >> 2] | 0) + d | 0;
            if (f) { f = 22288 + (((g | 0) % 5 | 0) << 2) | 0; }else { f = 22320 + (((g | 0) % 6 | 0) << 2) | 0; }
            q = b[f >> 2] | 0;

            if ((q | 0) == 7) {
              e = 1;
              S = u;
              return e | 0;
            }

            b[r >> 2] = 0;
            f = da(a, c, q, r, p) | 0;

            do { if (!f) {
              i = p;
              k = b[i >> 2] | 0;
              i = b[i + 4 >> 2] | 0;
              h = i >>> 0 < c >>> 0 | (i | 0) == (c | 0) & k >>> 0 < a >>> 0;
              g = h ? k : a;
              h = h ? i : c;
              if (!m ? (m = rd(7, 0, (l ^ 15) * 3 | 0) | 0, (k & m | 0) == 0 & (i & (G() | 0) | 0) == 0) : 0) { f = d; }else {
                i = (d + -1 + j | 0) % (j | 0) | 0;
                f = ub(a, c) | 0;

                if ((i | 0) < 0) {
                  f = 1;
                  break;
                }

                j = (f | 0) != 0;

                if (((j ? 4 : 5) | 0) < (i | 0)) {
                  f = 1;
                  break;
                }

                if (Qc(a, c, t) | 0) {
                  f = 1;
                  break;
                }

                f = (b[t >> 2] | 0) + i | 0;
                if (j) { f = 22288 + (((f | 0) % 5 | 0) << 2) | 0; }else { f = 22320 + (((f | 0) % 6 | 0) << 2) | 0; }
                i = b[f >> 2] | 0;

                if ((i | 0) == 7) {
                  f = 1;
                  break;
                }

                b[o >> 2] = 0;
                f = da(a, c, i, o, n) | 0;
                if (f | 0) { break; }
                k = n;
                j = b[k >> 2] | 0;
                k = b[k + 4 >> 2] | 0;

                do { if (k >>> 0 < h >>> 0 | (k | 0) == (h | 0) & j >>> 0 < g >>> 0) {
                  if (!(ub(j, k) | 0)) { g = b[22384 + ((((b[o >> 2] | 0) + (b[22352 + (i << 2) >> 2] | 0) | 0) % 6 | 0) << 2) >> 2] | 0; }else { g = ea(j, k, a, c) | 0; }
                  f = ub(j, k) | 0;

                  if ((g + -1 | 0) >>> 0 > 5) {
                    f = -1;
                    g = j;
                    h = k;
                    break;
                  }

                  f = (f | 0) != 0;

                  if ((g | 0) == 1 & f) {
                    f = -1;
                    g = j;
                    h = k;
                    break;
                  }

                  do { if (!(Qc(j, k, t) | 0)) {
                    if (f) {
                      f = ((b[21936 + (g << 2) >> 2] | 0) + 5 - (b[t >> 2] | 0) | 0) % 5 | 0;
                      break;
                    } else {
                      f = ((b[21968 + (g << 2) >> 2] | 0) + 6 - (b[t >> 2] | 0) | 0) % 6 | 0;
                      break;
                    }
                  } else { f = -1; } } while (0);

                  g = j;
                  h = k;
                } else { f = d; } } while (0);

                i = p;
                k = b[i >> 2] | 0;
                i = b[i + 4 >> 2] | 0;
              }

              if ((g | 0) == (k | 0) & (h | 0) == (i | 0)) {
                j = (ub(k, i) | 0) != 0;
                if (j) { a = ea(k, i, a, c) | 0; }else { a = b[22384 + ((((b[r >> 2] | 0) + (b[22352 + (q << 2) >> 2] | 0) | 0) % 6 | 0) << 2) >> 2] | 0; }
                f = ub(k, i) | 0;
                if ((a + -1 | 0) >>> 0 <= 5 ? (s = (f | 0) != 0, !((a | 0) == 1 & s)) : 0) {
                  do { if (!(Qc(k, i, t) | 0)) {
                    if (s) {
                      f = ((b[21936 + (a << 2) >> 2] | 0) + 5 - (b[t >> 2] | 0) | 0) % 5 | 0;
                      break;
                    } else {
                      f = ((b[21968 + (a << 2) >> 2] | 0) + 6 - (b[t >> 2] | 0) | 0) % 6 | 0;
                      break;
                    }
                  } else { f = -1; } } while (0);
                } else { f = -1; }
                f = f + 1 | 0;
                f = (f | 0) == 6 | j & (f | 0) == 5 ? 0 : f;
              }

              c = h;
              a = g;
              break a;
            } } while (0);

            e = f;
            S = u;
            return e | 0;
          } } while (0);

          s = rd(f | 0, 0, 56) | 0;
          t = G() | 0 | c & -2130706433 | 536870912;
          b[e >> 2] = s | a;
          b[e + 4 >> 2] = t;
          e = 0;
          S = u;
          return e | 0;
        }

        function Sc(a, c, d) {
          a = a | 0;
          c = c | 0;
          d = d | 0;
          var e = 0,
              f = 0,
              g = 0;
          g = (ub(a, c) | 0) == 0;
          e = Rc(a, c, 0, d) | 0;
          f = (e | 0) == 0;

          if (g) {
            if (!f) {
              g = e;
              return g | 0;
            }

            e = Rc(a, c, 1, d + 8 | 0) | 0;

            if (e | 0) {
              g = e;
              return g | 0;
            }

            e = Rc(a, c, 2, d + 16 | 0) | 0;

            if (e | 0) {
              g = e;
              return g | 0;
            }

            e = Rc(a, c, 3, d + 24 | 0) | 0;

            if (e | 0) {
              g = e;
              return g | 0;
            }

            e = Rc(a, c, 4, d + 32 | 0) | 0;
            if (!e) { return Rc(a, c, 5, d + 40 | 0) | 0; }else {
              g = e;
              return g | 0;
            }
          }

          if (!f) {
            g = e;
            return g | 0;
          }

          e = Rc(a, c, 1, d + 8 | 0) | 0;

          if (e | 0) {
            g = e;
            return g | 0;
          }

          e = Rc(a, c, 2, d + 16 | 0) | 0;

          if (e | 0) {
            g = e;
            return g | 0;
          }

          e = Rc(a, c, 3, d + 24 | 0) | 0;

          if (e | 0) {
            g = e;
            return g | 0;
          }

          e = Rc(a, c, 4, d + 32 | 0) | 0;

          if (e | 0) {
            g = e;
            return g | 0;
          }

          g = d + 40 | 0;
          b[g >> 2] = 0;
          b[g + 4 >> 2] = 0;
          g = 0;
          return g | 0;
        }

        function Tc(a, c, d) {
          a = a | 0;
          c = c | 0;
          d = d | 0;
          var e = 0,
              f = 0,
              g = 0,
              h = 0,
              i = 0,
              j = 0;
          j = S;
          S = S + 192 | 0;
          f = j;
          g = j + 168 | 0;
          h = qd(a | 0, c | 0, 56) | 0;
          G() | 0;
          h = h & 7;
          i = c & -2130706433 | 134217728;
          e = Lb(a, i, g) | 0;

          if (e | 0) {
            i = e;
            S = j;
            return i | 0;
          }

          c = qd(a | 0, c | 0, 52) | 0;
          G() | 0;
          c = c & 15;
          if (!(ub(a, i) | 0)) { nb(g, c, h, 1, f); }else { jb(g, c, h, 1, f); }
          i = f + 8 | 0;
          b[d >> 2] = b[i >> 2];
          b[d + 4 >> 2] = b[i + 4 >> 2];
          b[d + 8 >> 2] = b[i + 8 >> 2];
          b[d + 12 >> 2] = b[i + 12 >> 2];
          i = 0;
          S = j;
          return i | 0;
        }

        function Uc(a, c) {
          a = a | 0;
          c = c | 0;
          var d = 0,
              e = 0,
              f = 0,
              g = 0;
          f = S;
          S = S + 16 | 0;
          d = f;

          if (!(0 == 0 & (c & 2013265920 | 0) == 536870912)) {
            e = 0;
            S = f;
            return e | 0;
          }

          e = c & -2130706433 | 134217728;

          if (!(rb(a, e) | 0)) {
            e = 0;
            S = f;
            return e | 0;
          }

          g = qd(a | 0, c | 0, 56) | 0;
          G() | 0;
          g = (Rc(a, e, g & 7, d) | 0) == 0;
          e = d;
          e = g & ((b[e >> 2] | 0) == (a | 0) ? (b[e + 4 >> 2] | 0) == (c | 0) : 0) & 1;
          S = f;
          return e | 0;
        }

        function Vc(a, c, d) {
          a = a | 0;
          c = c | 0;
          d = d | 0;
          var e = 0;

          if ((c | 0) > 0) {
            e = fd(c, 4) | 0;
            b[a >> 2] = e;
            if (!e) { H(23102, 23125, 40, 23139); }
          } else { b[a >> 2] = 0; }

          b[a + 4 >> 2] = c;
          b[a + 8 >> 2] = 0;
          b[a + 12 >> 2] = d;
          return;
        }

        function Wc(a) {
          a = a | 0;
          var c = 0,
              d = 0,
              f = 0,
              g = 0,
              h = 0,
              i = 0,
              j = 0;
          g = a + 4 | 0;
          h = a + 12 | 0;
          i = a + 8 | 0;

          a: while (1) {
            d = b[g >> 2] | 0;
            c = 0;

            while (1) {
              if ((c | 0) >= (d | 0)) { break a; }
              f = b[a >> 2] | 0;
              j = b[f + (c << 2) >> 2] | 0;
              if (!j) { c = c + 1 | 0; }else { break; }
            }

            c = f + (~~(+q(+(+s(10.0, + +(15 - (b[h >> 2] | 0) | 0)) * (+e[j >> 3] + +e[j + 8 >> 3]))) % +(d | 0)) >>> 0 << 2) | 0;
            d = b[c >> 2] | 0;

            b: do { if (d | 0) {
              f = j + 32 | 0;
              if ((d | 0) == (j | 0)) { b[c >> 2] = b[f >> 2]; }else {
                d = d + 32 | 0;
                c = b[d >> 2] | 0;
                if (!c) { break; }

                while (1) {
                  if ((c | 0) == (j | 0)) { break; }
                  d = c + 32 | 0;
                  c = b[d >> 2] | 0;
                  if (!c) { break b; }
                }

                b[d >> 2] = b[f >> 2];
              }
              ed(j);
              b[i >> 2] = (b[i >> 2] | 0) + -1;
            } } while (0);
          }

          ed(b[a >> 2] | 0);
          return;
        }

        function Xc(a) {
          a = a | 0;
          var c = 0,
              d = 0,
              e = 0;
          e = b[a + 4 >> 2] | 0;
          d = 0;

          while (1) {
            if ((d | 0) >= (e | 0)) {
              c = 0;
              d = 4;
              break;
            }

            c = b[(b[a >> 2] | 0) + (d << 2) >> 2] | 0;
            if (!c) { d = d + 1 | 0; }else {
              d = 4;
              break;
            }
          }

          if ((d | 0) == 4) { return c | 0; }
          return 0;
        }

        function Yc(a, c) {
          a = a | 0;
          c = c | 0;
          var d = 0,
              f = 0,
              g = 0,
              h = 0;
          d = ~~(+q(+(+s(10.0, + +(15 - (b[a + 12 >> 2] | 0) | 0)) * (+e[c >> 3] + +e[c + 8 >> 3]))) % +(b[a + 4 >> 2] | 0)) >>> 0;
          d = (b[a >> 2] | 0) + (d << 2) | 0;
          f = b[d >> 2] | 0;

          if (!f) {
            h = 1;
            return h | 0;
          }

          h = c + 32 | 0;

          do { if ((f | 0) != (c | 0)) {
            d = b[f + 32 >> 2] | 0;

            if (!d) {
              h = 1;
              return h | 0;
            }

            g = d;

            while (1) {
              if ((g | 0) == (c | 0)) {
                g = 8;
                break;
              }

              d = b[g + 32 >> 2] | 0;

              if (!d) {
                d = 1;
                g = 10;
                break;
              } else {
                f = g;
                g = d;
              }
            }

            if ((g | 0) == 8) {
              b[f + 32 >> 2] = b[h >> 2];
              break;
            } else if ((g | 0) == 10) { return d | 0; }
          } else { b[d >> 2] = b[h >> 2]; } } while (0);

          ed(c);
          h = a + 8 | 0;
          b[h >> 2] = (b[h >> 2] | 0) + -1;
          h = 0;
          return h | 0;
        }

        function Zc(a, c, d) {
          a = a | 0;
          c = c | 0;
          d = d | 0;
          var f = 0,
              g = 0,
              h = 0,
              i = 0;
          h = dd(40) | 0;
          if (!h) { H(23155, 23125, 98, 23168); }
          b[h >> 2] = b[c >> 2];
          b[h + 4 >> 2] = b[c + 4 >> 2];
          b[h + 8 >> 2] = b[c + 8 >> 2];
          b[h + 12 >> 2] = b[c + 12 >> 2];
          g = h + 16 | 0;
          b[g >> 2] = b[d >> 2];
          b[g + 4 >> 2] = b[d + 4 >> 2];
          b[g + 8 >> 2] = b[d + 8 >> 2];
          b[g + 12 >> 2] = b[d + 12 >> 2];
          b[h + 32 >> 2] = 0;
          g = ~~(+q(+(+s(10.0, + +(15 - (b[a + 12 >> 2] | 0) | 0)) * (+e[c >> 3] + +e[c + 8 >> 3]))) % +(b[a + 4 >> 2] | 0)) >>> 0;
          g = (b[a >> 2] | 0) + (g << 2) | 0;
          f = b[g >> 2] | 0;

          do { if (!f) { b[g >> 2] = h; }else {
            while (1) {
              if (Vb(f, c) | 0 ? Vb(f + 16 | 0, d) | 0 : 0) { break; }
              g = b[f + 32 >> 2] | 0;
              f = (g | 0) == 0 ? f : g;

              if (!(b[f + 32 >> 2] | 0)) {
                i = 10;
                break;
              }
            }

            if ((i | 0) == 10) {
              b[f + 32 >> 2] = h;
              break;
            }

            ed(h);
            i = f;
            return i | 0;
          } } while (0);

          i = a + 8 | 0;
          b[i >> 2] = (b[i >> 2] | 0) + 1;
          i = h;
          return i | 0;
        }

        function _c(a, c, d) {
          a = a | 0;
          c = c | 0;
          d = d | 0;
          var f = 0,
              g = 0;
          g = ~~(+q(+(+s(10.0, + +(15 - (b[a + 12 >> 2] | 0) | 0)) * (+e[c >> 3] + +e[c + 8 >> 3]))) % +(b[a + 4 >> 2] | 0)) >>> 0;
          g = b[(b[a >> 2] | 0) + (g << 2) >> 2] | 0;

          if (!g) {
            d = 0;
            return d | 0;
          }

          if (!d) {
            a = g;

            while (1) {
              if (Vb(a, c) | 0) {
                f = 10;
                break;
              }

              a = b[a + 32 >> 2] | 0;

              if (!a) {
                a = 0;
                f = 10;
                break;
              }
            }

            if ((f | 0) == 10) { return a | 0; }
          }

          a = g;

          while (1) {
            if (Vb(a, c) | 0 ? Vb(a + 16 | 0, d) | 0 : 0) {
              f = 10;
              break;
            }

            a = b[a + 32 >> 2] | 0;

            if (!a) {
              a = 0;
              f = 10;
              break;
            }
          }

          if ((f | 0) == 10) { return a | 0; }
          return 0;
        }

        function $c(a, c) {
          a = a | 0;
          c = c | 0;
          var d = 0;
          d = ~~(+q(+(+s(10.0, + +(15 - (b[a + 12 >> 2] | 0) | 0)) * (+e[c >> 3] + +e[c + 8 >> 3]))) % +(b[a + 4 >> 2] | 0)) >>> 0;
          a = b[(b[a >> 2] | 0) + (d << 2) >> 2] | 0;

          if (!a) {
            d = 0;
            return d | 0;
          }

          while (1) {
            if (Vb(a, c) | 0) {
              c = 5;
              break;
            }

            a = b[a + 32 >> 2] | 0;

            if (!a) {
              a = 0;
              c = 5;
              break;
            }
          }

          if ((c | 0) == 5) { return a | 0; }
          return 0;
        }

        function ad() {
          return 23184;
        }

        function bd(a) {
          a = +a;
          return + +wd(+a);
        }

        function cd(a) {
          a = +a;
          return ~~+bd(a) | 0;
        }

        function dd(a) {
          a = a | 0;
          var c = 0,
              d = 0,
              e = 0,
              f = 0,
              g = 0,
              h = 0,
              i = 0,
              j = 0,
              k = 0,
              l = 0,
              m = 0,
              n = 0,
              o = 0,
              p = 0,
              q = 0,
              r = 0,
              s = 0,
              t = 0,
              u = 0,
              v = 0,
              w = 0;
          w = S;
          S = S + 16 | 0;
          n = w;

          do { if (a >>> 0 < 245) {
            k = a >>> 0 < 11 ? 16 : a + 11 & -8;
            a = k >>> 3;
            m = b[5797] | 0;
            d = m >>> a;

            if (d & 3 | 0) {
              c = (d & 1 ^ 1) + a | 0;
              a = 23228 + (c << 1 << 2) | 0;
              d = a + 8 | 0;
              e = b[d >> 2] | 0;
              f = e + 8 | 0;
              g = b[f >> 2] | 0;
              if ((g | 0) == (a | 0)) { b[5797] = m & ~(1 << c); }else {
                b[g + 12 >> 2] = a;
                b[d >> 2] = g;
              }
              v = c << 3;
              b[e + 4 >> 2] = v | 3;
              v = e + v + 4 | 0;
              b[v >> 2] = b[v >> 2] | 1;
              v = f;
              S = w;
              return v | 0;
            }

            l = b[5799] | 0;

            if (k >>> 0 > l >>> 0) {
              if (d | 0) {
                c = 2 << a;
                c = d << a & (c | 0 - c);
                c = (c & 0 - c) + -1 | 0;
                i = c >>> 12 & 16;
                c = c >>> i;
                d = c >>> 5 & 8;
                c = c >>> d;
                g = c >>> 2 & 4;
                c = c >>> g;
                a = c >>> 1 & 2;
                c = c >>> a;
                e = c >>> 1 & 1;
                e = (d | i | g | a | e) + (c >>> e) | 0;
                c = 23228 + (e << 1 << 2) | 0;
                a = c + 8 | 0;
                g = b[a >> 2] | 0;
                i = g + 8 | 0;
                d = b[i >> 2] | 0;

                if ((d | 0) == (c | 0)) {
                  a = m & ~(1 << e);
                  b[5797] = a;
                } else {
                  b[d + 12 >> 2] = c;
                  b[a >> 2] = d;
                  a = m;
                }

                v = e << 3;
                h = v - k | 0;
                b[g + 4 >> 2] = k | 3;
                f = g + k | 0;
                b[f + 4 >> 2] = h | 1;
                b[g + v >> 2] = h;

                if (l | 0) {
                  e = b[5802] | 0;
                  c = l >>> 3;
                  d = 23228 + (c << 1 << 2) | 0;
                  c = 1 << c;

                  if (!(a & c)) {
                    b[5797] = a | c;
                    c = d;
                    a = d + 8 | 0;
                  } else {
                    a = d + 8 | 0;
                    c = b[a >> 2] | 0;
                  }

                  b[a >> 2] = e;
                  b[c + 12 >> 2] = e;
                  b[e + 8 >> 2] = c;
                  b[e + 12 >> 2] = d;
                }

                b[5799] = h;
                b[5802] = f;
                v = i;
                S = w;
                return v | 0;
              }

              g = b[5798] | 0;

              if (g) {
                d = (g & 0 - g) + -1 | 0;
                f = d >>> 12 & 16;
                d = d >>> f;
                e = d >>> 5 & 8;
                d = d >>> e;
                h = d >>> 2 & 4;
                d = d >>> h;
                i = d >>> 1 & 2;
                d = d >>> i;
                j = d >>> 1 & 1;
                j = b[23492 + ((e | f | h | i | j) + (d >>> j) << 2) >> 2] | 0;
                d = j;
                i = j;
                j = (b[j + 4 >> 2] & -8) - k | 0;

                while (1) {
                  a = b[d + 16 >> 2] | 0;

                  if (!a) {
                    a = b[d + 20 >> 2] | 0;
                    if (!a) { break; }
                  }

                  h = (b[a + 4 >> 2] & -8) - k | 0;
                  f = h >>> 0 < j >>> 0;
                  d = a;
                  i = f ? a : i;
                  j = f ? h : j;
                }

                h = i + k | 0;

                if (h >>> 0 > i >>> 0) {
                  f = b[i + 24 >> 2] | 0;
                  c = b[i + 12 >> 2] | 0;

                  do { if ((c | 0) == (i | 0)) {
                    a = i + 20 | 0;
                    c = b[a >> 2] | 0;

                    if (!c) {
                      a = i + 16 | 0;
                      c = b[a >> 2] | 0;

                      if (!c) {
                        d = 0;
                        break;
                      }
                    }

                    while (1) {
                      e = c + 20 | 0;
                      d = b[e >> 2] | 0;

                      if (!d) {
                        e = c + 16 | 0;
                        d = b[e >> 2] | 0;
                        if (!d) { break; }else {
                          c = d;
                          a = e;
                        }
                      } else {
                        c = d;
                        a = e;
                      }
                    }

                    b[a >> 2] = 0;
                    d = c;
                  } else {
                    d = b[i + 8 >> 2] | 0;
                    b[d + 12 >> 2] = c;
                    b[c + 8 >> 2] = d;
                    d = c;
                  } } while (0);

                  do { if (f | 0) {
                    c = b[i + 28 >> 2] | 0;
                    a = 23492 + (c << 2) | 0;

                    if ((i | 0) == (b[a >> 2] | 0)) {
                      b[a >> 2] = d;

                      if (!d) {
                        b[5798] = g & ~(1 << c);
                        break;
                      }
                    } else {
                      v = f + 16 | 0;
                      b[((b[v >> 2] | 0) == (i | 0) ? v : f + 20 | 0) >> 2] = d;
                      if (!d) { break; }
                    }

                    b[d + 24 >> 2] = f;
                    c = b[i + 16 >> 2] | 0;

                    if (c | 0) {
                      b[d + 16 >> 2] = c;
                      b[c + 24 >> 2] = d;
                    }

                    c = b[i + 20 >> 2] | 0;

                    if (c | 0) {
                      b[d + 20 >> 2] = c;
                      b[c + 24 >> 2] = d;
                    }
                  } } while (0);

                  if (j >>> 0 < 16) {
                    v = j + k | 0;
                    b[i + 4 >> 2] = v | 3;
                    v = i + v + 4 | 0;
                    b[v >> 2] = b[v >> 2] | 1;
                  } else {
                    b[i + 4 >> 2] = k | 3;
                    b[h + 4 >> 2] = j | 1;
                    b[h + j >> 2] = j;

                    if (l | 0) {
                      e = b[5802] | 0;
                      c = l >>> 3;
                      d = 23228 + (c << 1 << 2) | 0;
                      c = 1 << c;

                      if (!(c & m)) {
                        b[5797] = c | m;
                        c = d;
                        a = d + 8 | 0;
                      } else {
                        a = d + 8 | 0;
                        c = b[a >> 2] | 0;
                      }

                      b[a >> 2] = e;
                      b[c + 12 >> 2] = e;
                      b[e + 8 >> 2] = c;
                      b[e + 12 >> 2] = d;
                    }

                    b[5799] = j;
                    b[5802] = h;
                  }

                  v = i + 8 | 0;
                  S = w;
                  return v | 0;
                } else { m = k; }
              } else { m = k; }
            } else { m = k; }
          } else if (a >>> 0 <= 4294967231) {
            a = a + 11 | 0;
            k = a & -8;
            e = b[5798] | 0;

            if (e) {
              f = 0 - k | 0;
              a = a >>> 8;
              if (a) {
                if (k >>> 0 > 16777215) { j = 31; }else {
                  m = (a + 1048320 | 0) >>> 16 & 8;
                  q = a << m;
                  i = (q + 520192 | 0) >>> 16 & 4;
                  q = q << i;
                  j = (q + 245760 | 0) >>> 16 & 2;
                  j = 14 - (i | m | j) + (q << j >>> 15) | 0;
                  j = k >>> (j + 7 | 0) & 1 | j << 1;
                }
              } else { j = 0; }
              d = b[23492 + (j << 2) >> 2] | 0;

              a: do { if (!d) {
                d = 0;
                a = 0;
                q = 61;
              } else {
                a = 0;
                i = k << ((j | 0) == 31 ? 0 : 25 - (j >>> 1) | 0);
                g = 0;

                while (1) {
                  h = (b[d + 4 >> 2] & -8) - k | 0;
                  if (h >>> 0 < f >>> 0) { if (!h) {
                    a = d;
                    f = 0;
                    q = 65;
                    break a;
                  } else {
                    a = d;
                    f = h;
                  } }
                  q = b[d + 20 >> 2] | 0;
                  d = b[d + 16 + (i >>> 31 << 2) >> 2] | 0;
                  g = (q | 0) == 0 | (q | 0) == (d | 0) ? g : q;

                  if (!d) {
                    d = g;
                    q = 61;
                    break;
                  } else { i = i << 1; }
                }
              } } while (0);

              if ((q | 0) == 61) {
                if ((d | 0) == 0 & (a | 0) == 0) {
                  a = 2 << j;
                  a = (a | 0 - a) & e;

                  if (!a) {
                    m = k;
                    break;
                  }

                  m = (a & 0 - a) + -1 | 0;
                  h = m >>> 12 & 16;
                  m = m >>> h;
                  g = m >>> 5 & 8;
                  m = m >>> g;
                  i = m >>> 2 & 4;
                  m = m >>> i;
                  j = m >>> 1 & 2;
                  m = m >>> j;
                  d = m >>> 1 & 1;
                  a = 0;
                  d = b[23492 + ((g | h | i | j | d) + (m >>> d) << 2) >> 2] | 0;
                }

                if (!d) {
                  i = a;
                  h = f;
                } else { q = 65; }
              }

              if ((q | 0) == 65) {
                g = d;

                while (1) {
                  m = (b[g + 4 >> 2] & -8) - k | 0;
                  d = m >>> 0 < f >>> 0;
                  f = d ? m : f;
                  a = d ? g : a;
                  d = b[g + 16 >> 2] | 0;
                  if (!d) { d = b[g + 20 >> 2] | 0; }

                  if (!d) {
                    i = a;
                    h = f;
                    break;
                  } else { g = d; }
                }
              }

              if (((i | 0) != 0 ? h >>> 0 < ((b[5799] | 0) - k | 0) >>> 0 : 0) ? (l = i + k | 0, l >>> 0 > i >>> 0) : 0) {
                g = b[i + 24 >> 2] | 0;
                c = b[i + 12 >> 2] | 0;

                do { if ((c | 0) == (i | 0)) {
                  a = i + 20 | 0;
                  c = b[a >> 2] | 0;

                  if (!c) {
                    a = i + 16 | 0;
                    c = b[a >> 2] | 0;

                    if (!c) {
                      c = 0;
                      break;
                    }
                  }

                  while (1) {
                    f = c + 20 | 0;
                    d = b[f >> 2] | 0;

                    if (!d) {
                      f = c + 16 | 0;
                      d = b[f >> 2] | 0;
                      if (!d) { break; }else {
                        c = d;
                        a = f;
                      }
                    } else {
                      c = d;
                      a = f;
                    }
                  }

                  b[a >> 2] = 0;
                } else {
                  v = b[i + 8 >> 2] | 0;
                  b[v + 12 >> 2] = c;
                  b[c + 8 >> 2] = v;
                } } while (0);

                do { if (g) {
                  a = b[i + 28 >> 2] | 0;
                  d = 23492 + (a << 2) | 0;

                  if ((i | 0) == (b[d >> 2] | 0)) {
                    b[d >> 2] = c;

                    if (!c) {
                      e = e & ~(1 << a);
                      b[5798] = e;
                      break;
                    }
                  } else {
                    v = g + 16 | 0;
                    b[((b[v >> 2] | 0) == (i | 0) ? v : g + 20 | 0) >> 2] = c;
                    if (!c) { break; }
                  }

                  b[c + 24 >> 2] = g;
                  a = b[i + 16 >> 2] | 0;

                  if (a | 0) {
                    b[c + 16 >> 2] = a;
                    b[a + 24 >> 2] = c;
                  }

                  a = b[i + 20 >> 2] | 0;

                  if (a) {
                    b[c + 20 >> 2] = a;
                    b[a + 24 >> 2] = c;
                  }
                } } while (0);

                b: do { if (h >>> 0 < 16) {
                  v = h + k | 0;
                  b[i + 4 >> 2] = v | 3;
                  v = i + v + 4 | 0;
                  b[v >> 2] = b[v >> 2] | 1;
                } else {
                  b[i + 4 >> 2] = k | 3;
                  b[l + 4 >> 2] = h | 1;
                  b[l + h >> 2] = h;
                  c = h >>> 3;

                  if (h >>> 0 < 256) {
                    d = 23228 + (c << 1 << 2) | 0;
                    a = b[5797] | 0;
                    c = 1 << c;

                    if (!(a & c)) {
                      b[5797] = a | c;
                      c = d;
                      a = d + 8 | 0;
                    } else {
                      a = d + 8 | 0;
                      c = b[a >> 2] | 0;
                    }

                    b[a >> 2] = l;
                    b[c + 12 >> 2] = l;
                    b[l + 8 >> 2] = c;
                    b[l + 12 >> 2] = d;
                    break;
                  }

                  c = h >>> 8;
                  if (c) {
                    if (h >>> 0 > 16777215) { d = 31; }else {
                      u = (c + 1048320 | 0) >>> 16 & 8;
                      v = c << u;
                      t = (v + 520192 | 0) >>> 16 & 4;
                      v = v << t;
                      d = (v + 245760 | 0) >>> 16 & 2;
                      d = 14 - (t | u | d) + (v << d >>> 15) | 0;
                      d = h >>> (d + 7 | 0) & 1 | d << 1;
                    }
                  } else { d = 0; }
                  c = 23492 + (d << 2) | 0;
                  b[l + 28 >> 2] = d;
                  a = l + 16 | 0;
                  b[a + 4 >> 2] = 0;
                  b[a >> 2] = 0;
                  a = 1 << d;

                  if (!(e & a)) {
                    b[5798] = e | a;
                    b[c >> 2] = l;
                    b[l + 24 >> 2] = c;
                    b[l + 12 >> 2] = l;
                    b[l + 8 >> 2] = l;
                    break;
                  }

                  c = b[c >> 2] | 0;

                  c: do { if ((b[c + 4 >> 2] & -8 | 0) != (h | 0)) {
                    e = h << ((d | 0) == 31 ? 0 : 25 - (d >>> 1) | 0);

                    while (1) {
                      d = c + 16 + (e >>> 31 << 2) | 0;
                      a = b[d >> 2] | 0;
                      if (!a) { break; }

                      if ((b[a + 4 >> 2] & -8 | 0) == (h | 0)) {
                        c = a;
                        break c;
                      } else {
                        e = e << 1;
                        c = a;
                      }
                    }

                    b[d >> 2] = l;
                    b[l + 24 >> 2] = c;
                    b[l + 12 >> 2] = l;
                    b[l + 8 >> 2] = l;
                    break b;
                  } } while (0);

                  u = c + 8 | 0;
                  v = b[u >> 2] | 0;
                  b[v + 12 >> 2] = l;
                  b[u >> 2] = l;
                  b[l + 8 >> 2] = v;
                  b[l + 12 >> 2] = c;
                  b[l + 24 >> 2] = 0;
                } } while (0);

                v = i + 8 | 0;
                S = w;
                return v | 0;
              } else { m = k; }
            } else { m = k; }
          } else { m = -1; } } while (0);

          d = b[5799] | 0;

          if (d >>> 0 >= m >>> 0) {
            c = d - m | 0;
            a = b[5802] | 0;

            if (c >>> 0 > 15) {
              v = a + m | 0;
              b[5802] = v;
              b[5799] = c;
              b[v + 4 >> 2] = c | 1;
              b[a + d >> 2] = c;
              b[a + 4 >> 2] = m | 3;
            } else {
              b[5799] = 0;
              b[5802] = 0;
              b[a + 4 >> 2] = d | 3;
              v = a + d + 4 | 0;
              b[v >> 2] = b[v >> 2] | 1;
            }

            v = a + 8 | 0;
            S = w;
            return v | 0;
          }

          h = b[5800] | 0;

          if (h >>> 0 > m >>> 0) {
            t = h - m | 0;
            b[5800] = t;
            v = b[5803] | 0;
            u = v + m | 0;
            b[5803] = u;
            b[u + 4 >> 2] = t | 1;
            b[v + 4 >> 2] = m | 3;
            v = v + 8 | 0;
            S = w;
            return v | 0;
          }

          if (!(b[5915] | 0)) {
            b[5917] = 4096;
            b[5916] = 4096;
            b[5918] = -1;
            b[5919] = -1;
            b[5920] = 0;
            b[5908] = 0;
            b[5915] = n & -16 ^ 1431655768;
            a = 4096;
          } else { a = b[5917] | 0; }

          i = m + 48 | 0;
          j = m + 47 | 0;
          g = a + j | 0;
          f = 0 - a | 0;
          k = g & f;

          if (k >>> 0 <= m >>> 0) {
            v = 0;
            S = w;
            return v | 0;
          }

          a = b[5907] | 0;

          if (a | 0 ? (l = b[5905] | 0, n = l + k | 0, n >>> 0 <= l >>> 0 | n >>> 0 > a >>> 0) : 0) {
            v = 0;
            S = w;
            return v | 0;
          }

          d: do { if (!(b[5908] & 4)) {
            d = b[5803] | 0;

            e: do { if (d) {
              e = 23636;

              while (1) {
                n = b[e >> 2] | 0;
                if (n >>> 0 <= d >>> 0 ? (n + (b[e + 4 >> 2] | 0) | 0) >>> 0 > d >>> 0 : 0) { break; }
                a = b[e + 8 >> 2] | 0;

                if (!a) {
                  q = 128;
                  break e;
                } else { e = a; }
              }

              c = g - h & f;

              if (c >>> 0 < 2147483647) {
                a = xd(c | 0) | 0;

                if ((a | 0) == ((b[e >> 2] | 0) + (b[e + 4 >> 2] | 0) | 0)) {
                  if ((a | 0) != (-1 | 0)) {
                    h = c;
                    g = a;
                    q = 145;
                    break d;
                  }
                } else {
                  e = a;
                  q = 136;
                }
              } else { c = 0; }
            } else { q = 128; } } while (0);

            do { if ((q | 0) == 128) {
              d = xd(0) | 0;

              if ((d | 0) != (-1 | 0) ? (c = d, o = b[5916] | 0, p = o + -1 | 0, c = ((p & c | 0) == 0 ? 0 : (p + c & 0 - o) - c | 0) + k | 0, o = b[5905] | 0, p = c + o | 0, c >>> 0 > m >>> 0 & c >>> 0 < 2147483647) : 0) {
                n = b[5907] | 0;

                if (n | 0 ? p >>> 0 <= o >>> 0 | p >>> 0 > n >>> 0 : 0) {
                  c = 0;
                  break;
                }

                a = xd(c | 0) | 0;

                if ((a | 0) == (d | 0)) {
                  h = c;
                  g = d;
                  q = 145;
                  break d;
                } else {
                  e = a;
                  q = 136;
                }
              } else { c = 0; }
            } } while (0);

            do { if ((q | 0) == 136) {
              d = 0 - c | 0;
              if (!(i >>> 0 > c >>> 0 & (c >>> 0 < 2147483647 & (e | 0) != (-1 | 0)))) { if ((e | 0) == (-1 | 0)) {
                c = 0;
                break;
              } else {
                h = c;
                g = e;
                q = 145;
                break d;
              } }
              a = b[5917] | 0;
              a = j - c + a & 0 - a;

              if (a >>> 0 >= 2147483647) {
                h = c;
                g = e;
                q = 145;
                break d;
              }

              if ((xd(a | 0) | 0) == (-1 | 0)) {
                xd(d | 0) | 0;
                c = 0;
                break;
              } else {
                h = a + c | 0;
                g = e;
                q = 145;
                break d;
              }
            } } while (0);

            b[5908] = b[5908] | 4;
            q = 143;
          } else {
            c = 0;
            q = 143;
          } } while (0);

          if (((q | 0) == 143 ? k >>> 0 < 2147483647 : 0) ? (t = xd(k | 0) | 0, p = xd(0) | 0, r = p - t | 0, s = r >>> 0 > (m + 40 | 0) >>> 0, !((t | 0) == (-1 | 0) | s ^ 1 | t >>> 0 < p >>> 0 & ((t | 0) != (-1 | 0) & (p | 0) != (-1 | 0)) ^ 1)) : 0) {
            h = s ? r : c;
            g = t;
            q = 145;
          }

          if ((q | 0) == 145) {
            c = (b[5905] | 0) + h | 0;
            b[5905] = c;
            if (c >>> 0 > (b[5906] | 0) >>> 0) { b[5906] = c; }
            j = b[5803] | 0;

            f: do { if (j) {
              c = 23636;

              while (1) {
                a = b[c >> 2] | 0;
                d = b[c + 4 >> 2] | 0;

                if ((g | 0) == (a + d | 0)) {
                  q = 154;
                  break;
                }

                e = b[c + 8 >> 2] | 0;
                if (!e) { break; }else { c = e; }
              }

              if (((q | 0) == 154 ? (u = c + 4 | 0, (b[c + 12 >> 2] & 8 | 0) == 0) : 0) ? g >>> 0 > j >>> 0 & a >>> 0 <= j >>> 0 : 0) {
                b[u >> 2] = d + h;
                v = (b[5800] | 0) + h | 0;
                t = j + 8 | 0;
                t = (t & 7 | 0) == 0 ? 0 : 0 - t & 7;
                u = j + t | 0;
                t = v - t | 0;
                b[5803] = u;
                b[5800] = t;
                b[u + 4 >> 2] = t | 1;
                b[j + v + 4 >> 2] = 40;
                b[5804] = b[5919];
                break;
              }

              if (g >>> 0 < (b[5801] | 0) >>> 0) { b[5801] = g; }
              d = g + h | 0;
              c = 23636;

              while (1) {
                if ((b[c >> 2] | 0) == (d | 0)) {
                  q = 162;
                  break;
                }

                a = b[c + 8 >> 2] | 0;
                if (!a) { break; }else { c = a; }
              }

              if ((q | 0) == 162 ? (b[c + 12 >> 2] & 8 | 0) == 0 : 0) {
                b[c >> 2] = g;
                l = c + 4 | 0;
                b[l >> 2] = (b[l >> 2] | 0) + h;
                l = g + 8 | 0;
                l = g + ((l & 7 | 0) == 0 ? 0 : 0 - l & 7) | 0;
                c = d + 8 | 0;
                c = d + ((c & 7 | 0) == 0 ? 0 : 0 - c & 7) | 0;
                k = l + m | 0;
                i = c - l - m | 0;
                b[l + 4 >> 2] = m | 3;

                g: do { if ((j | 0) == (c | 0)) {
                  v = (b[5800] | 0) + i | 0;
                  b[5800] = v;
                  b[5803] = k;
                  b[k + 4 >> 2] = v | 1;
                } else {
                  if ((b[5802] | 0) == (c | 0)) {
                    v = (b[5799] | 0) + i | 0;
                    b[5799] = v;
                    b[5802] = k;
                    b[k + 4 >> 2] = v | 1;
                    b[k + v >> 2] = v;
                    break;
                  }

                  a = b[c + 4 >> 2] | 0;

                  if ((a & 3 | 0) == 1) {
                    h = a & -8;
                    e = a >>> 3;

                    h: do { if (a >>> 0 < 256) {
                      a = b[c + 8 >> 2] | 0;
                      d = b[c + 12 >> 2] | 0;

                      if ((d | 0) == (a | 0)) {
                        b[5797] = b[5797] & ~(1 << e);
                        break;
                      } else {
                        b[a + 12 >> 2] = d;
                        b[d + 8 >> 2] = a;
                        break;
                      }
                    } else {
                      g = b[c + 24 >> 2] | 0;
                      a = b[c + 12 >> 2] | 0;

                      do { if ((a | 0) == (c | 0)) {
                        d = c + 16 | 0;
                        e = d + 4 | 0;
                        a = b[e >> 2] | 0;

                        if (!a) {
                          a = b[d >> 2] | 0;

                          if (!a) {
                            a = 0;
                            break;
                          }
                        } else { d = e; }

                        while (1) {
                          f = a + 20 | 0;
                          e = b[f >> 2] | 0;

                          if (!e) {
                            f = a + 16 | 0;
                            e = b[f >> 2] | 0;
                            if (!e) { break; }else {
                              a = e;
                              d = f;
                            }
                          } else {
                            a = e;
                            d = f;
                          }
                        }

                        b[d >> 2] = 0;
                      } else {
                        v = b[c + 8 >> 2] | 0;
                        b[v + 12 >> 2] = a;
                        b[a + 8 >> 2] = v;
                      } } while (0);

                      if (!g) { break; }
                      d = b[c + 28 >> 2] | 0;
                      e = 23492 + (d << 2) | 0;

                      do { if ((b[e >> 2] | 0) != (c | 0)) {
                        v = g + 16 | 0;
                        b[((b[v >> 2] | 0) == (c | 0) ? v : g + 20 | 0) >> 2] = a;
                        if (!a) { break h; }
                      } else {
                        b[e >> 2] = a;
                        if (a | 0) { break; }
                        b[5798] = b[5798] & ~(1 << d);
                        break h;
                      } } while (0);

                      b[a + 24 >> 2] = g;
                      d = c + 16 | 0;
                      e = b[d >> 2] | 0;

                      if (e | 0) {
                        b[a + 16 >> 2] = e;
                        b[e + 24 >> 2] = a;
                      }

                      d = b[d + 4 >> 2] | 0;
                      if (!d) { break; }
                      b[a + 20 >> 2] = d;
                      b[d + 24 >> 2] = a;
                    } } while (0);

                    c = c + h | 0;
                    f = h + i | 0;
                  } else { f = i; }

                  c = c + 4 | 0;
                  b[c >> 2] = b[c >> 2] & -2;
                  b[k + 4 >> 2] = f | 1;
                  b[k + f >> 2] = f;
                  c = f >>> 3;

                  if (f >>> 0 < 256) {
                    d = 23228 + (c << 1 << 2) | 0;
                    a = b[5797] | 0;
                    c = 1 << c;

                    if (!(a & c)) {
                      b[5797] = a | c;
                      c = d;
                      a = d + 8 | 0;
                    } else {
                      a = d + 8 | 0;
                      c = b[a >> 2] | 0;
                    }

                    b[a >> 2] = k;
                    b[c + 12 >> 2] = k;
                    b[k + 8 >> 2] = c;
                    b[k + 12 >> 2] = d;
                    break;
                  }

                  c = f >>> 8;

                  do { if (!c) { e = 0; }else {
                    if (f >>> 0 > 16777215) {
                      e = 31;
                      break;
                    }

                    u = (c + 1048320 | 0) >>> 16 & 8;
                    v = c << u;
                    t = (v + 520192 | 0) >>> 16 & 4;
                    v = v << t;
                    e = (v + 245760 | 0) >>> 16 & 2;
                    e = 14 - (t | u | e) + (v << e >>> 15) | 0;
                    e = f >>> (e + 7 | 0) & 1 | e << 1;
                  } } while (0);

                  c = 23492 + (e << 2) | 0;
                  b[k + 28 >> 2] = e;
                  a = k + 16 | 0;
                  b[a + 4 >> 2] = 0;
                  b[a >> 2] = 0;
                  a = b[5798] | 0;
                  d = 1 << e;

                  if (!(a & d)) {
                    b[5798] = a | d;
                    b[c >> 2] = k;
                    b[k + 24 >> 2] = c;
                    b[k + 12 >> 2] = k;
                    b[k + 8 >> 2] = k;
                    break;
                  }

                  c = b[c >> 2] | 0;

                  i: do { if ((b[c + 4 >> 2] & -8 | 0) != (f | 0)) {
                    e = f << ((e | 0) == 31 ? 0 : 25 - (e >>> 1) | 0);

                    while (1) {
                      d = c + 16 + (e >>> 31 << 2) | 0;
                      a = b[d >> 2] | 0;
                      if (!a) { break; }

                      if ((b[a + 4 >> 2] & -8 | 0) == (f | 0)) {
                        c = a;
                        break i;
                      } else {
                        e = e << 1;
                        c = a;
                      }
                    }

                    b[d >> 2] = k;
                    b[k + 24 >> 2] = c;
                    b[k + 12 >> 2] = k;
                    b[k + 8 >> 2] = k;
                    break g;
                  } } while (0);

                  u = c + 8 | 0;
                  v = b[u >> 2] | 0;
                  b[v + 12 >> 2] = k;
                  b[u >> 2] = k;
                  b[k + 8 >> 2] = v;
                  b[k + 12 >> 2] = c;
                  b[k + 24 >> 2] = 0;
                } } while (0);

                v = l + 8 | 0;
                S = w;
                return v | 0;
              }

              c = 23636;

              while (1) {
                a = b[c >> 2] | 0;
                if (a >>> 0 <= j >>> 0 ? (v = a + (b[c + 4 >> 2] | 0) | 0, v >>> 0 > j >>> 0) : 0) { break; }
                c = b[c + 8 >> 2] | 0;
              }

              f = v + -47 | 0;
              a = f + 8 | 0;
              a = f + ((a & 7 | 0) == 0 ? 0 : 0 - a & 7) | 0;
              f = j + 16 | 0;
              a = a >>> 0 < f >>> 0 ? j : a;
              c = a + 8 | 0;
              d = h + -40 | 0;
              t = g + 8 | 0;
              t = (t & 7 | 0) == 0 ? 0 : 0 - t & 7;
              u = g + t | 0;
              t = d - t | 0;
              b[5803] = u;
              b[5800] = t;
              b[u + 4 >> 2] = t | 1;
              b[g + d + 4 >> 2] = 40;
              b[5804] = b[5919];
              d = a + 4 | 0;
              b[d >> 2] = 27;
              b[c >> 2] = b[5909];
              b[c + 4 >> 2] = b[5910];
              b[c + 8 >> 2] = b[5911];
              b[c + 12 >> 2] = b[5912];
              b[5909] = g;
              b[5910] = h;
              b[5912] = 0;
              b[5911] = c;
              c = a + 24 | 0;

              do {
                u = c;
                c = c + 4 | 0;
                b[c >> 2] = 7;
              } while ((u + 8 | 0) >>> 0 < v >>> 0);

              if ((a | 0) != (j | 0)) {
                g = a - j | 0;
                b[d >> 2] = b[d >> 2] & -2;
                b[j + 4 >> 2] = g | 1;
                b[a >> 2] = g;
                c = g >>> 3;

                if (g >>> 0 < 256) {
                  d = 23228 + (c << 1 << 2) | 0;
                  a = b[5797] | 0;
                  c = 1 << c;

                  if (!(a & c)) {
                    b[5797] = a | c;
                    c = d;
                    a = d + 8 | 0;
                  } else {
                    a = d + 8 | 0;
                    c = b[a >> 2] | 0;
                  }

                  b[a >> 2] = j;
                  b[c + 12 >> 2] = j;
                  b[j + 8 >> 2] = c;
                  b[j + 12 >> 2] = d;
                  break;
                }

                c = g >>> 8;
                if (c) {
                  if (g >>> 0 > 16777215) { e = 31; }else {
                    u = (c + 1048320 | 0) >>> 16 & 8;
                    v = c << u;
                    t = (v + 520192 | 0) >>> 16 & 4;
                    v = v << t;
                    e = (v + 245760 | 0) >>> 16 & 2;
                    e = 14 - (t | u | e) + (v << e >>> 15) | 0;
                    e = g >>> (e + 7 | 0) & 1 | e << 1;
                  }
                } else { e = 0; }
                d = 23492 + (e << 2) | 0;
                b[j + 28 >> 2] = e;
                b[j + 20 >> 2] = 0;
                b[f >> 2] = 0;
                c = b[5798] | 0;
                a = 1 << e;

                if (!(c & a)) {
                  b[5798] = c | a;
                  b[d >> 2] = j;
                  b[j + 24 >> 2] = d;
                  b[j + 12 >> 2] = j;
                  b[j + 8 >> 2] = j;
                  break;
                }

                c = b[d >> 2] | 0;

                j: do { if ((b[c + 4 >> 2] & -8 | 0) != (g | 0)) {
                  e = g << ((e | 0) == 31 ? 0 : 25 - (e >>> 1) | 0);

                  while (1) {
                    d = c + 16 + (e >>> 31 << 2) | 0;
                    a = b[d >> 2] | 0;
                    if (!a) { break; }

                    if ((b[a + 4 >> 2] & -8 | 0) == (g | 0)) {
                      c = a;
                      break j;
                    } else {
                      e = e << 1;
                      c = a;
                    }
                  }

                  b[d >> 2] = j;
                  b[j + 24 >> 2] = c;
                  b[j + 12 >> 2] = j;
                  b[j + 8 >> 2] = j;
                  break f;
                } } while (0);

                u = c + 8 | 0;
                v = b[u >> 2] | 0;
                b[v + 12 >> 2] = j;
                b[u >> 2] = j;
                b[j + 8 >> 2] = v;
                b[j + 12 >> 2] = c;
                b[j + 24 >> 2] = 0;
              }
            } else {
              v = b[5801] | 0;
              if ((v | 0) == 0 | g >>> 0 < v >>> 0) { b[5801] = g; }
              b[5909] = g;
              b[5910] = h;
              b[5912] = 0;
              b[5806] = b[5915];
              b[5805] = -1;
              b[5810] = 23228;
              b[5809] = 23228;
              b[5812] = 23236;
              b[5811] = 23236;
              b[5814] = 23244;
              b[5813] = 23244;
              b[5816] = 23252;
              b[5815] = 23252;
              b[5818] = 23260;
              b[5817] = 23260;
              b[5820] = 23268;
              b[5819] = 23268;
              b[5822] = 23276;
              b[5821] = 23276;
              b[5824] = 23284;
              b[5823] = 23284;
              b[5826] = 23292;
              b[5825] = 23292;
              b[5828] = 23300;
              b[5827] = 23300;
              b[5830] = 23308;
              b[5829] = 23308;
              b[5832] = 23316;
              b[5831] = 23316;
              b[5834] = 23324;
              b[5833] = 23324;
              b[5836] = 23332;
              b[5835] = 23332;
              b[5838] = 23340;
              b[5837] = 23340;
              b[5840] = 23348;
              b[5839] = 23348;
              b[5842] = 23356;
              b[5841] = 23356;
              b[5844] = 23364;
              b[5843] = 23364;
              b[5846] = 23372;
              b[5845] = 23372;
              b[5848] = 23380;
              b[5847] = 23380;
              b[5850] = 23388;
              b[5849] = 23388;
              b[5852] = 23396;
              b[5851] = 23396;
              b[5854] = 23404;
              b[5853] = 23404;
              b[5856] = 23412;
              b[5855] = 23412;
              b[5858] = 23420;
              b[5857] = 23420;
              b[5860] = 23428;
              b[5859] = 23428;
              b[5862] = 23436;
              b[5861] = 23436;
              b[5864] = 23444;
              b[5863] = 23444;
              b[5866] = 23452;
              b[5865] = 23452;
              b[5868] = 23460;
              b[5867] = 23460;
              b[5870] = 23468;
              b[5869] = 23468;
              b[5872] = 23476;
              b[5871] = 23476;
              v = h + -40 | 0;
              t = g + 8 | 0;
              t = (t & 7 | 0) == 0 ? 0 : 0 - t & 7;
              u = g + t | 0;
              t = v - t | 0;
              b[5803] = u;
              b[5800] = t;
              b[u + 4 >> 2] = t | 1;
              b[g + v + 4 >> 2] = 40;
              b[5804] = b[5919];
            } } while (0);

            c = b[5800] | 0;

            if (c >>> 0 > m >>> 0) {
              t = c - m | 0;
              b[5800] = t;
              v = b[5803] | 0;
              u = v + m | 0;
              b[5803] = u;
              b[u + 4 >> 2] = t | 1;
              b[v + 4 >> 2] = m | 3;
              v = v + 8 | 0;
              S = w;
              return v | 0;
            }
          }

          v = ad() | 0;
          b[v >> 2] = 12;
          v = 0;
          S = w;
          return v | 0;
        }

        function ed(a) {
          a = a | 0;
          var c = 0,
              d = 0,
              e = 0,
              f = 0,
              g = 0,
              h = 0,
              i = 0,
              j = 0;
          if (!a) { return; }
          d = a + -8 | 0;
          f = b[5801] | 0;
          a = b[a + -4 >> 2] | 0;
          c = a & -8;
          j = d + c | 0;

          do { if (!(a & 1)) {
            e = b[d >> 2] | 0;
            if (!(a & 3)) { return; }
            h = d + (0 - e) | 0;
            g = e + c | 0;
            if (h >>> 0 < f >>> 0) { return; }

            if ((b[5802] | 0) == (h | 0)) {
              a = j + 4 | 0;
              c = b[a >> 2] | 0;

              if ((c & 3 | 0) != 3) {
                i = h;
                c = g;
                break;
              }

              b[5799] = g;
              b[a >> 2] = c & -2;
              b[h + 4 >> 2] = g | 1;
              b[h + g >> 2] = g;
              return;
            }

            d = e >>> 3;

            if (e >>> 0 < 256) {
              a = b[h + 8 >> 2] | 0;
              c = b[h + 12 >> 2] | 0;

              if ((c | 0) == (a | 0)) {
                b[5797] = b[5797] & ~(1 << d);
                i = h;
                c = g;
                break;
              } else {
                b[a + 12 >> 2] = c;
                b[c + 8 >> 2] = a;
                i = h;
                c = g;
                break;
              }
            }

            f = b[h + 24 >> 2] | 0;
            a = b[h + 12 >> 2] | 0;

            do { if ((a | 0) == (h | 0)) {
              c = h + 16 | 0;
              d = c + 4 | 0;
              a = b[d >> 2] | 0;

              if (!a) {
                a = b[c >> 2] | 0;

                if (!a) {
                  a = 0;
                  break;
                }
              } else { c = d; }

              while (1) {
                e = a + 20 | 0;
                d = b[e >> 2] | 0;

                if (!d) {
                  e = a + 16 | 0;
                  d = b[e >> 2] | 0;
                  if (!d) { break; }else {
                    a = d;
                    c = e;
                  }
                } else {
                  a = d;
                  c = e;
                }
              }

              b[c >> 2] = 0;
            } else {
              i = b[h + 8 >> 2] | 0;
              b[i + 12 >> 2] = a;
              b[a + 8 >> 2] = i;
            } } while (0);

            if (f) {
              c = b[h + 28 >> 2] | 0;
              d = 23492 + (c << 2) | 0;

              if ((b[d >> 2] | 0) == (h | 0)) {
                b[d >> 2] = a;

                if (!a) {
                  b[5798] = b[5798] & ~(1 << c);
                  i = h;
                  c = g;
                  break;
                }
              } else {
                i = f + 16 | 0;
                b[((b[i >> 2] | 0) == (h | 0) ? i : f + 20 | 0) >> 2] = a;

                if (!a) {
                  i = h;
                  c = g;
                  break;
                }
              }

              b[a + 24 >> 2] = f;
              c = h + 16 | 0;
              d = b[c >> 2] | 0;

              if (d | 0) {
                b[a + 16 >> 2] = d;
                b[d + 24 >> 2] = a;
              }

              c = b[c + 4 >> 2] | 0;

              if (c) {
                b[a + 20 >> 2] = c;
                b[c + 24 >> 2] = a;
                i = h;
                c = g;
              } else {
                i = h;
                c = g;
              }
            } else {
              i = h;
              c = g;
            }
          } else {
            i = d;
            h = d;
          } } while (0);

          if (h >>> 0 >= j >>> 0) { return; }
          a = j + 4 | 0;
          e = b[a >> 2] | 0;
          if (!(e & 1)) { return; }

          if (!(e & 2)) {
            if ((b[5803] | 0) == (j | 0)) {
              j = (b[5800] | 0) + c | 0;
              b[5800] = j;
              b[5803] = i;
              b[i + 4 >> 2] = j | 1;
              if ((i | 0) != (b[5802] | 0)) { return; }
              b[5802] = 0;
              b[5799] = 0;
              return;
            }

            if ((b[5802] | 0) == (j | 0)) {
              j = (b[5799] | 0) + c | 0;
              b[5799] = j;
              b[5802] = h;
              b[i + 4 >> 2] = j | 1;
              b[h + j >> 2] = j;
              return;
            }

            f = (e & -8) + c | 0;
            d = e >>> 3;

            do { if (e >>> 0 < 256) {
              c = b[j + 8 >> 2] | 0;
              a = b[j + 12 >> 2] | 0;

              if ((a | 0) == (c | 0)) {
                b[5797] = b[5797] & ~(1 << d);
                break;
              } else {
                b[c + 12 >> 2] = a;
                b[a + 8 >> 2] = c;
                break;
              }
            } else {
              g = b[j + 24 >> 2] | 0;
              a = b[j + 12 >> 2] | 0;

              do { if ((a | 0) == (j | 0)) {
                c = j + 16 | 0;
                d = c + 4 | 0;
                a = b[d >> 2] | 0;

                if (!a) {
                  a = b[c >> 2] | 0;

                  if (!a) {
                    d = 0;
                    break;
                  }
                } else { c = d; }

                while (1) {
                  e = a + 20 | 0;
                  d = b[e >> 2] | 0;

                  if (!d) {
                    e = a + 16 | 0;
                    d = b[e >> 2] | 0;
                    if (!d) { break; }else {
                      a = d;
                      c = e;
                    }
                  } else {
                    a = d;
                    c = e;
                  }
                }

                b[c >> 2] = 0;
                d = a;
              } else {
                d = b[j + 8 >> 2] | 0;
                b[d + 12 >> 2] = a;
                b[a + 8 >> 2] = d;
                d = a;
              } } while (0);

              if (g | 0) {
                a = b[j + 28 >> 2] | 0;
                c = 23492 + (a << 2) | 0;

                if ((b[c >> 2] | 0) == (j | 0)) {
                  b[c >> 2] = d;

                  if (!d) {
                    b[5798] = b[5798] & ~(1 << a);
                    break;
                  }
                } else {
                  e = g + 16 | 0;
                  b[((b[e >> 2] | 0) == (j | 0) ? e : g + 20 | 0) >> 2] = d;
                  if (!d) { break; }
                }

                b[d + 24 >> 2] = g;
                a = j + 16 | 0;
                c = b[a >> 2] | 0;

                if (c | 0) {
                  b[d + 16 >> 2] = c;
                  b[c + 24 >> 2] = d;
                }

                a = b[a + 4 >> 2] | 0;

                if (a | 0) {
                  b[d + 20 >> 2] = a;
                  b[a + 24 >> 2] = d;
                }
              }
            } } while (0);

            b[i + 4 >> 2] = f | 1;
            b[h + f >> 2] = f;

            if ((i | 0) == (b[5802] | 0)) {
              b[5799] = f;
              return;
            }
          } else {
            b[a >> 2] = e & -2;
            b[i + 4 >> 2] = c | 1;
            b[h + c >> 2] = c;
            f = c;
          }

          a = f >>> 3;

          if (f >>> 0 < 256) {
            d = 23228 + (a << 1 << 2) | 0;
            c = b[5797] | 0;
            a = 1 << a;

            if (!(c & a)) {
              b[5797] = c | a;
              a = d;
              c = d + 8 | 0;
            } else {
              c = d + 8 | 0;
              a = b[c >> 2] | 0;
            }

            b[c >> 2] = i;
            b[a + 12 >> 2] = i;
            b[i + 8 >> 2] = a;
            b[i + 12 >> 2] = d;
            return;
          }

          a = f >>> 8;
          if (a) {
            if (f >>> 0 > 16777215) { e = 31; }else {
              h = (a + 1048320 | 0) >>> 16 & 8;
              j = a << h;
              g = (j + 520192 | 0) >>> 16 & 4;
              j = j << g;
              e = (j + 245760 | 0) >>> 16 & 2;
              e = 14 - (g | h | e) + (j << e >>> 15) | 0;
              e = f >>> (e + 7 | 0) & 1 | e << 1;
            }
          } else { e = 0; }
          a = 23492 + (e << 2) | 0;
          b[i + 28 >> 2] = e;
          b[i + 20 >> 2] = 0;
          b[i + 16 >> 2] = 0;
          c = b[5798] | 0;
          d = 1 << e;

          a: do { if (!(c & d)) {
            b[5798] = c | d;
            b[a >> 2] = i;
            b[i + 24 >> 2] = a;
            b[i + 12 >> 2] = i;
            b[i + 8 >> 2] = i;
          } else {
            a = b[a >> 2] | 0;

            b: do { if ((b[a + 4 >> 2] & -8 | 0) != (f | 0)) {
              e = f << ((e | 0) == 31 ? 0 : 25 - (e >>> 1) | 0);

              while (1) {
                d = a + 16 + (e >>> 31 << 2) | 0;
                c = b[d >> 2] | 0;
                if (!c) { break; }

                if ((b[c + 4 >> 2] & -8 | 0) == (f | 0)) {
                  a = c;
                  break b;
                } else {
                  e = e << 1;
                  a = c;
                }
              }

              b[d >> 2] = i;
              b[i + 24 >> 2] = a;
              b[i + 12 >> 2] = i;
              b[i + 8 >> 2] = i;
              break a;
            } } while (0);

            h = a + 8 | 0;
            j = b[h >> 2] | 0;
            b[j + 12 >> 2] = i;
            b[h >> 2] = i;
            b[i + 8 >> 2] = j;
            b[i + 12 >> 2] = a;
            b[i + 24 >> 2] = 0;
          } } while (0);

          j = (b[5805] | 0) + -1 | 0;
          b[5805] = j;
          if (j | 0) { return; }
          a = 23644;

          while (1) {
            a = b[a >> 2] | 0;
            if (!a) { break; }else { a = a + 8 | 0; }
          }

          b[5805] = -1;
          return;
        }

        function fd(a, c) {
          a = a | 0;
          c = c | 0;
          var d = 0;

          if (a) {
            d = B(c, a) | 0;
            if ((c | a) >>> 0 > 65535) { d = ((d >>> 0) / (a >>> 0) | 0 | 0) == (c | 0) ? d : -1; }
          } else { d = 0; }

          a = dd(d) | 0;
          if (!a) { return a | 0; }
          if (!(b[a + -4 >> 2] & 3)) { return a | 0; }
          vd(a | 0, 0, d | 0) | 0;
          return a | 0;
        }

        function gd(a, b, c, d) {
          a = a | 0;
          b = b | 0;
          c = c | 0;
          d = d | 0;
          c = a + c >>> 0;
          return (F(b + d + (c >>> 0 < a >>> 0 | 0) >>> 0 | 0), c | 0) | 0;
        }

        function hd(a, b, c, d) {
          a = a | 0;
          b = b | 0;
          c = c | 0;
          d = d | 0;
          d = b - d - (c >>> 0 > a >>> 0 | 0) >>> 0;
          return (F(d | 0), a - c >>> 0 | 0) | 0;
        }

        function id(a) {
          a = a | 0;
          return (a ? 31 - (D(a ^ a - 1) | 0) | 0 : 32) | 0;
        }

        function jd(a, c, d, e, f) {
          a = a | 0;
          c = c | 0;
          d = d | 0;
          e = e | 0;
          f = f | 0;
          var g = 0,
              h = 0,
              i = 0,
              j = 0,
              k = 0,
              l = 0,
              m = 0,
              n = 0,
              o = 0,
              p = 0;
          l = a;
          j = c;
          k = j;
          h = d;
          n = e;
          i = n;

          if (!k) {
            g = (f | 0) != 0;

            if (!i) {
              if (g) {
                b[f >> 2] = (l >>> 0) % (h >>> 0);
                b[f + 4 >> 2] = 0;
              }

              n = 0;
              f = (l >>> 0) / (h >>> 0) >>> 0;
              return (F(n | 0), f) | 0;
            } else {
              if (!g) {
                n = 0;
                f = 0;
                return (F(n | 0), f) | 0;
              }

              b[f >> 2] = a | 0;
              b[f + 4 >> 2] = c & 0;
              n = 0;
              f = 0;
              return (F(n | 0), f) | 0;
            }
          }

          g = (i | 0) == 0;

          do { if (h) {
            if (!g) {
              g = (D(i | 0) | 0) - (D(k | 0) | 0) | 0;

              if (g >>> 0 <= 31) {
                m = g + 1 | 0;
                i = 31 - g | 0;
                c = g - 31 >> 31;
                h = m;
                a = l >>> (m >>> 0) & c | k << i;
                c = k >>> (m >>> 0) & c;
                g = 0;
                i = l << i;
                break;
              }

              if (!f) {
                n = 0;
                f = 0;
                return (F(n | 0), f) | 0;
              }

              b[f >> 2] = a | 0;
              b[f + 4 >> 2] = j | c & 0;
              n = 0;
              f = 0;
              return (F(n | 0), f) | 0;
            }

            g = h - 1 | 0;

            if (g & h | 0) {
              i = (D(h | 0) | 0) + 33 - (D(k | 0) | 0) | 0;
              p = 64 - i | 0;
              m = 32 - i | 0;
              j = m >> 31;
              o = i - 32 | 0;
              c = o >> 31;
              h = i;
              a = m - 1 >> 31 & k >>> (o >>> 0) | (k << m | l >>> (i >>> 0)) & c;
              c = c & k >>> (i >>> 0);
              g = l << p & j;
              i = (k << p | l >>> (o >>> 0)) & j | l << m & i - 33 >> 31;
              break;
            }

            if (f | 0) {
              b[f >> 2] = g & l;
              b[f + 4 >> 2] = 0;
            }

            if ((h | 0) == 1) {
              o = j | c & 0;
              p = a | 0 | 0;
              return (F(o | 0), p) | 0;
            } else {
              p = id(h | 0) | 0;
              o = k >>> (p >>> 0) | 0;
              p = k << 32 - p | l >>> (p >>> 0) | 0;
              return (F(o | 0), p) | 0;
            }
          } else {
            if (g) {
              if (f | 0) {
                b[f >> 2] = (k >>> 0) % (h >>> 0);
                b[f + 4 >> 2] = 0;
              }

              o = 0;
              p = (k >>> 0) / (h >>> 0) >>> 0;
              return (F(o | 0), p) | 0;
            }

            if (!l) {
              if (f | 0) {
                b[f >> 2] = 0;
                b[f + 4 >> 2] = (k >>> 0) % (i >>> 0);
              }

              o = 0;
              p = (k >>> 0) / (i >>> 0) >>> 0;
              return (F(o | 0), p) | 0;
            }

            g = i - 1 | 0;

            if (!(g & i)) {
              if (f | 0) {
                b[f >> 2] = a | 0;
                b[f + 4 >> 2] = g & k | c & 0;
              }

              o = 0;
              p = k >>> ((id(i | 0) | 0) >>> 0);
              return (F(o | 0), p) | 0;
            }

            g = (D(i | 0) | 0) - (D(k | 0) | 0) | 0;

            if (g >>> 0 <= 30) {
              c = g + 1 | 0;
              i = 31 - g | 0;
              h = c;
              a = k << i | l >>> (c >>> 0);
              c = k >>> (c >>> 0);
              g = 0;
              i = l << i;
              break;
            }

            if (!f) {
              o = 0;
              p = 0;
              return (F(o | 0), p) | 0;
            }

            b[f >> 2] = a | 0;
            b[f + 4 >> 2] = j | c & 0;
            o = 0;
            p = 0;
            return (F(o | 0), p) | 0;
          } } while (0);

          if (!h) {
            k = i;
            j = 0;
            i = 0;
          } else {
            m = d | 0 | 0;
            l = n | e & 0;
            k = gd(m | 0, l | 0, -1, -1) | 0;
            d = G() | 0;
            j = i;
            i = 0;

            do {
              e = j;
              j = g >>> 31 | j << 1;
              g = i | g << 1;
              e = a << 1 | e >>> 31 | 0;
              n = a >>> 31 | c << 1 | 0;
              hd(k | 0, d | 0, e | 0, n | 0) | 0;
              p = G() | 0;
              o = p >> 31 | ((p | 0) < 0 ? -1 : 0) << 1;
              i = o & 1;
              a = hd(e | 0, n | 0, o & m | 0, (((p | 0) < 0 ? -1 : 0) >> 31 | ((p | 0) < 0 ? -1 : 0) << 1) & l | 0) | 0;
              c = G() | 0;
              h = h - 1 | 0;
            } while ((h | 0) != 0);

            k = j;
            j = 0;
          }

          h = 0;

          if (f | 0) {
            b[f >> 2] = a;
            b[f + 4 >> 2] = c;
          }

          o = (g | 0) >>> 31 | (k | h) << 1 | (h << 1 | g >>> 31) & 0 | j;
          p = (g << 1 | 0 >>> 31) & -2 | i;
          return (F(o | 0), p) | 0;
        }

        function kd(a, b, c, d) {
          a = a | 0;
          b = b | 0;
          c = c | 0;
          d = d | 0;
          var e = 0,
              f = 0,
              g = 0,
              h = 0,
              i = 0,
              j = 0;
          j = b >> 31 | ((b | 0) < 0 ? -1 : 0) << 1;
          i = ((b | 0) < 0 ? -1 : 0) >> 31 | ((b | 0) < 0 ? -1 : 0) << 1;
          f = d >> 31 | ((d | 0) < 0 ? -1 : 0) << 1;
          e = ((d | 0) < 0 ? -1 : 0) >> 31 | ((d | 0) < 0 ? -1 : 0) << 1;
          h = hd(j ^ a | 0, i ^ b | 0, j | 0, i | 0) | 0;
          g = G() | 0;
          a = f ^ j;
          b = e ^ i;
          return hd((jd(h, g, hd(f ^ c | 0, e ^ d | 0, f | 0, e | 0) | 0, G() | 0, 0) | 0) ^ a | 0, (G() | 0) ^ b | 0, a | 0, b | 0) | 0;
        }

        function ld(a, b) {
          a = a | 0;
          b = b | 0;
          var c = 0,
              d = 0,
              e = 0,
              f = 0;
          f = a & 65535;
          e = b & 65535;
          c = B(e, f) | 0;
          d = a >>> 16;
          a = (c >>> 16) + (B(e, d) | 0) | 0;
          e = b >>> 16;
          b = B(e, f) | 0;
          return (F((a >>> 16) + (B(e, d) | 0) + (((a & 65535) + b | 0) >>> 16) | 0), a + b << 16 | c & 65535 | 0) | 0;
        }

        function md(a, b, c, d) {
          a = a | 0;
          b = b | 0;
          c = c | 0;
          d = d | 0;
          var e = 0,
              f = 0;
          e = a;
          f = c;
          c = ld(e, f) | 0;
          a = G() | 0;
          return (F((B(b, f) | 0) + (B(d, e) | 0) + a | a & 0 | 0), c | 0 | 0) | 0;
        }

        function nd(a, c, d, e) {
          a = a | 0;
          c = c | 0;
          d = d | 0;
          e = e | 0;
          var f = 0,
              g = 0,
              h = 0,
              i = 0,
              j = 0,
              k = 0;
          f = S;
          S = S + 16 | 0;
          i = f | 0;
          h = c >> 31 | ((c | 0) < 0 ? -1 : 0) << 1;
          g = ((c | 0) < 0 ? -1 : 0) >> 31 | ((c | 0) < 0 ? -1 : 0) << 1;
          k = e >> 31 | ((e | 0) < 0 ? -1 : 0) << 1;
          j = ((e | 0) < 0 ? -1 : 0) >> 31 | ((e | 0) < 0 ? -1 : 0) << 1;
          a = hd(h ^ a | 0, g ^ c | 0, h | 0, g | 0) | 0;
          c = G() | 0;
          jd(a, c, hd(k ^ d | 0, j ^ e | 0, k | 0, j | 0) | 0, G() | 0, i) | 0;
          e = hd(b[i >> 2] ^ h | 0, b[i + 4 >> 2] ^ g | 0, h | 0, g | 0) | 0;
          d = G() | 0;
          S = f;
          return (F(d | 0), e) | 0;
        }

        function od(a, c, d, e) {
          a = a | 0;
          c = c | 0;
          d = d | 0;
          e = e | 0;
          var f = 0,
              g = 0;
          g = S;
          S = S + 16 | 0;
          f = g | 0;
          jd(a, c, d, e, f) | 0;
          S = g;
          return (F(b[f + 4 >> 2] | 0), b[f >> 2] | 0) | 0;
        }

        function pd(a, b, c) {
          a = a | 0;
          b = b | 0;
          c = c | 0;

          if ((c | 0) < 32) {
            F(b >> c | 0);
            return a >>> c | (b & (1 << c) - 1) << 32 - c;
          }

          F(((b | 0) < 0 ? -1 : 0) | 0);
          return b >> c - 32 | 0;
        }

        function qd(a, b, c) {
          a = a | 0;
          b = b | 0;
          c = c | 0;

          if ((c | 0) < 32) {
            F(b >>> c | 0);
            return a >>> c | (b & (1 << c) - 1) << 32 - c;
          }

          F(0);
          return b >>> c - 32 | 0;
        }

        function rd(a, b, c) {
          a = a | 0;
          b = b | 0;
          c = c | 0;

          if ((c | 0) < 32) {
            F(b << c | (a & (1 << c) - 1 << 32 - c) >>> 32 - c | 0);
            return a << c;
          }

          F(a << c - 32 | 0);
          return 0;
        }

        function sd(a, b) {
          a = +a;
          b = +b;
          if (a != a) { return +b; }
          if (b != b) { return +a; }
          return +C(+a, +b);
        }

        function td(a) {
          a = +a;
          return a >= 0.0 ? +p(a + .5) : +A(a - .5);
        }

        function ud(c, d, e) {
          c = c | 0;
          d = d | 0;
          e = e | 0;
          var f = 0,
              g = 0,
              h = 0;

          if ((e | 0) >= 8192) {
            K(c | 0, d | 0, e | 0) | 0;
            return c | 0;
          }

          h = c | 0;
          g = c + e | 0;

          if ((c & 3) == (d & 3)) {
            while (c & 3) {
              if (!e) { return h | 0; }
              a[c >> 0] = a[d >> 0] | 0;
              c = c + 1 | 0;
              d = d + 1 | 0;
              e = e - 1 | 0;
            }

            e = g & -4 | 0;
            f = e - 64 | 0;

            while ((c | 0) <= (f | 0)) {
              b[c >> 2] = b[d >> 2];
              b[c + 4 >> 2] = b[d + 4 >> 2];
              b[c + 8 >> 2] = b[d + 8 >> 2];
              b[c + 12 >> 2] = b[d + 12 >> 2];
              b[c + 16 >> 2] = b[d + 16 >> 2];
              b[c + 20 >> 2] = b[d + 20 >> 2];
              b[c + 24 >> 2] = b[d + 24 >> 2];
              b[c + 28 >> 2] = b[d + 28 >> 2];
              b[c + 32 >> 2] = b[d + 32 >> 2];
              b[c + 36 >> 2] = b[d + 36 >> 2];
              b[c + 40 >> 2] = b[d + 40 >> 2];
              b[c + 44 >> 2] = b[d + 44 >> 2];
              b[c + 48 >> 2] = b[d + 48 >> 2];
              b[c + 52 >> 2] = b[d + 52 >> 2];
              b[c + 56 >> 2] = b[d + 56 >> 2];
              b[c + 60 >> 2] = b[d + 60 >> 2];
              c = c + 64 | 0;
              d = d + 64 | 0;
            }

            while ((c | 0) < (e | 0)) {
              b[c >> 2] = b[d >> 2];
              c = c + 4 | 0;
              d = d + 4 | 0;
            }
          } else {
            e = g - 4 | 0;

            while ((c | 0) < (e | 0)) {
              a[c >> 0] = a[d >> 0] | 0;
              a[c + 1 >> 0] = a[d + 1 >> 0] | 0;
              a[c + 2 >> 0] = a[d + 2 >> 0] | 0;
              a[c + 3 >> 0] = a[d + 3 >> 0] | 0;
              c = c + 4 | 0;
              d = d + 4 | 0;
            }
          }

          while ((c | 0) < (g | 0)) {
            a[c >> 0] = a[d >> 0] | 0;
            c = c + 1 | 0;
            d = d + 1 | 0;
          }

          return h | 0;
        }

        function vd(c, d, e) {
          c = c | 0;
          d = d | 0;
          e = e | 0;
          var f = 0,
              g = 0,
              h = 0,
              i = 0;
          h = c + e | 0;
          d = d & 255;

          if ((e | 0) >= 67) {
            while (c & 3) {
              a[c >> 0] = d;
              c = c + 1 | 0;
            }

            f = h & -4 | 0;
            i = d | d << 8 | d << 16 | d << 24;
            g = f - 64 | 0;

            while ((c | 0) <= (g | 0)) {
              b[c >> 2] = i;
              b[c + 4 >> 2] = i;
              b[c + 8 >> 2] = i;
              b[c + 12 >> 2] = i;
              b[c + 16 >> 2] = i;
              b[c + 20 >> 2] = i;
              b[c + 24 >> 2] = i;
              b[c + 28 >> 2] = i;
              b[c + 32 >> 2] = i;
              b[c + 36 >> 2] = i;
              b[c + 40 >> 2] = i;
              b[c + 44 >> 2] = i;
              b[c + 48 >> 2] = i;
              b[c + 52 >> 2] = i;
              b[c + 56 >> 2] = i;
              b[c + 60 >> 2] = i;
              c = c + 64 | 0;
            }

            while ((c | 0) < (f | 0)) {
              b[c >> 2] = i;
              c = c + 4 | 0;
            }
          }

          while ((c | 0) < (h | 0)) {
            a[c >> 0] = d;
            c = c + 1 | 0;
          }

          return h - e | 0;
        }

        function wd(a) {
          a = +a;
          return a >= 0.0 ? +p(a + .5) : +A(a - .5);
        }

        function xd(a) {
          a = a | 0;
          var c = 0,
              d = 0,
              e = 0;
          e = J() | 0;
          d = b[g >> 2] | 0;
          c = d + a | 0;

          if ((a | 0) > 0 & (c | 0) < (d | 0) | (c | 0) < 0) {
            M(c | 0) | 0;
            I(12);
            return -1;
          }

          if ((c | 0) > (e | 0)) { if (!(L(c | 0) | 0)) {
            I(12);
            return -1;
          } }
          b[g >> 2] = c;
          return d | 0;
        } // EMSCRIPTEN_END_FUNCS


        return {
          ___divdi3: kd,
          ___muldi3: md,
          ___remdi3: nd,
          ___uremdi3: od,
          _areNeighborCells: Ya,
          _bitshift64Ashr: pd,
          _bitshift64Lshr: qd,
          _bitshift64Shl: rd,
          _calloc: fd,
          _cellAreaKm2: gc,
          _cellAreaM2: hc,
          _cellAreaRads2: fc,
          _cellToBoundary: Nb,
          _cellToCenterChild: xb,
          _cellToChildren: vb,
          _cellToChildrenSize: tb,
          _cellToLatLng: Mb,
          _cellToLocalIj: sc,
          _cellToParent: sb,
          _cellToVertex: Rc,
          _cellToVertexes: Sc,
          _cellsToDirectedEdge: Za,
          _cellsToLinkedMultiPolygon: ka,
          _compactCells: yb,
          _destroyLinkedMultiPolygon: nc,
          _directedEdgeToBoundary: db,
          _directedEdgeToCells: bb,
          _edgeLengthKm: jc,
          _edgeLengthM: kc,
          _edgeLengthRads: ic,
          _emscripten_replace_memory: V,
          _free: ed,
          _getBaseCellNumber: qb,
          _getDirectedEdgeDestination: $a,
          _getDirectedEdgeOrigin: _a,
          _getHexagonAreaAvgKm2: $b,
          _getHexagonAreaAvgM2: ac,
          _getHexagonEdgeLengthAvgKm: bc,
          _getHexagonEdgeLengthAvgM: cc,
          _getIcosahedronFaces: Pb,
          _getNumCells: dc,
          _getPentagons: Rb,
          _getRes0Cells: va,
          _getResolution: pb,
          _greatCircleDistanceKm: Xb,
          _greatCircleDistanceM: Yb,
          _greatCircleDistanceRads: Wb,
          _gridDisk: $,
          _gridDiskDistances: aa,
          _gridDistance: uc,
          _gridPathCells: wc,
          _gridPathCellsSize: vc,
          _gridRingUnsafe: fa,
          _i64Add: gd,
          _i64Subtract: hd,
          _isPentagon: ub,
          _isResClassIII: Bb,
          _isValidCell: rb,
          _isValidDirectedEdge: ab,
          _isValidVertex: Uc,
          _latLngToCell: Jb,
          _llvm_minnum_f64: sd,
          _llvm_round_f64: td,
          _localIjToCell: tc,
          _malloc: dd,
          _maxFaceCount: Ob,
          _maxGridDiskSize: _,
          _maxPolygonToCellsSize: ga,
          _memcpy: ud,
          _memset: vd,
          _originToDirectedEdges: cb,
          _pentagonCount: Qb,
          _polygonToCells: ia,
          _readInt64AsDoubleFromPointer: Jc,
          _res0CellCount: ua,
          _round: wd,
          _sbrk: xd,
          _sizeOfCellBoundary: Ec,
          _sizeOfCoordIJ: Ic,
          _sizeOfGeoLoop: Fc,
          _sizeOfGeoPolygon: Gc,
          _sizeOfH3Index: Cc,
          _sizeOfLatLng: Dc,
          _sizeOfLinkedGeoPolygon: Hc,
          _uncompactCells: zb,
          _uncompactCellsSize: Ab,
          _vertexToLatLng: Tc,
          establishStackSpace: Z,
          stackAlloc: W,
          stackRestore: Y,
          stackSave: X
        };
      }( // EMSCRIPTEN_END_ASM
      asmGlobalArg, asmLibraryArg, buffer);

      Module["___divdi3"] = asm["___divdi3"];

      Module["___muldi3"] = asm["___muldi3"];

      Module["___remdi3"] = asm["___remdi3"];

      Module["___uremdi3"] = asm["___uremdi3"];

      Module["_areNeighborCells"] = asm["_areNeighborCells"];

      Module["_bitshift64Ashr"] = asm["_bitshift64Ashr"];

      Module["_bitshift64Lshr"] = asm["_bitshift64Lshr"];

      Module["_bitshift64Shl"] = asm["_bitshift64Shl"];

      Module["_calloc"] = asm["_calloc"];

      Module["_cellAreaKm2"] = asm["_cellAreaKm2"];

      Module["_cellAreaM2"] = asm["_cellAreaM2"];

      Module["_cellAreaRads2"] = asm["_cellAreaRads2"];

      Module["_cellToBoundary"] = asm["_cellToBoundary"];

      Module["_cellToCenterChild"] = asm["_cellToCenterChild"];

      Module["_cellToChildren"] = asm["_cellToChildren"];

      Module["_cellToChildrenSize"] = asm["_cellToChildrenSize"];

      Module["_cellToLatLng"] = asm["_cellToLatLng"];

      Module["_cellToLocalIj"] = asm["_cellToLocalIj"];

      Module["_cellToParent"] = asm["_cellToParent"];

      Module["_cellToVertex"] = asm["_cellToVertex"];

      Module["_cellToVertexes"] = asm["_cellToVertexes"];

      Module["_cellsToDirectedEdge"] = asm["_cellsToDirectedEdge"];

      Module["_cellsToLinkedMultiPolygon"] = asm["_cellsToLinkedMultiPolygon"];

      Module["_compactCells"] = asm["_compactCells"];

      Module["_destroyLinkedMultiPolygon"] = asm["_destroyLinkedMultiPolygon"];

      Module["_directedEdgeToBoundary"] = asm["_directedEdgeToBoundary"];

      Module["_directedEdgeToCells"] = asm["_directedEdgeToCells"];

      Module["_edgeLengthKm"] = asm["_edgeLengthKm"];

      Module["_edgeLengthM"] = asm["_edgeLengthM"];

      Module["_edgeLengthRads"] = asm["_edgeLengthRads"];

      var _emscripten_replace_memory = Module["_emscripten_replace_memory"] = asm["_emscripten_replace_memory"];

      Module["_free"] = asm["_free"];

      Module["_getBaseCellNumber"] = asm["_getBaseCellNumber"];

      Module["_getDirectedEdgeDestination"] = asm["_getDirectedEdgeDestination"];

      Module["_getDirectedEdgeOrigin"] = asm["_getDirectedEdgeOrigin"];

      Module["_getHexagonAreaAvgKm2"] = asm["_getHexagonAreaAvgKm2"];

      Module["_getHexagonAreaAvgM2"] = asm["_getHexagonAreaAvgM2"];

      Module["_getHexagonEdgeLengthAvgKm"] = asm["_getHexagonEdgeLengthAvgKm"];

      Module["_getHexagonEdgeLengthAvgM"] = asm["_getHexagonEdgeLengthAvgM"];

      Module["_getIcosahedronFaces"] = asm["_getIcosahedronFaces"];

      Module["_getNumCells"] = asm["_getNumCells"];

      Module["_getPentagons"] = asm["_getPentagons"];

      Module["_getRes0Cells"] = asm["_getRes0Cells"];

      Module["_getResolution"] = asm["_getResolution"];

      Module["_greatCircleDistanceKm"] = asm["_greatCircleDistanceKm"];

      Module["_greatCircleDistanceM"] = asm["_greatCircleDistanceM"];

      Module["_greatCircleDistanceRads"] = asm["_greatCircleDistanceRads"];

      Module["_gridDisk"] = asm["_gridDisk"];

      Module["_gridDiskDistances"] = asm["_gridDiskDistances"];

      Module["_gridDistance"] = asm["_gridDistance"];

      Module["_gridPathCells"] = asm["_gridPathCells"];

      Module["_gridPathCellsSize"] = asm["_gridPathCellsSize"];

      Module["_gridRingUnsafe"] = asm["_gridRingUnsafe"];

      Module["_i64Add"] = asm["_i64Add"];

      Module["_i64Subtract"] = asm["_i64Subtract"];

      Module["_isPentagon"] = asm["_isPentagon"];

      Module["_isResClassIII"] = asm["_isResClassIII"];

      Module["_isValidCell"] = asm["_isValidCell"];

      Module["_isValidDirectedEdge"] = asm["_isValidDirectedEdge"];

      Module["_isValidVertex"] = asm["_isValidVertex"];

      Module["_latLngToCell"] = asm["_latLngToCell"];

      Module["_llvm_minnum_f64"] = asm["_llvm_minnum_f64"];

      Module["_llvm_round_f64"] = asm["_llvm_round_f64"];

      Module["_localIjToCell"] = asm["_localIjToCell"];

      Module["_malloc"] = asm["_malloc"];

      Module["_maxFaceCount"] = asm["_maxFaceCount"];

      Module["_maxGridDiskSize"] = asm["_maxGridDiskSize"];

      Module["_maxPolygonToCellsSize"] = asm["_maxPolygonToCellsSize"];

      Module["_memcpy"] = asm["_memcpy"];

      Module["_memset"] = asm["_memset"];

      Module["_originToDirectedEdges"] = asm["_originToDirectedEdges"];

      Module["_pentagonCount"] = asm["_pentagonCount"];

      Module["_polygonToCells"] = asm["_polygonToCells"];

      Module["_readInt64AsDoubleFromPointer"] = asm["_readInt64AsDoubleFromPointer"];

      Module["_res0CellCount"] = asm["_res0CellCount"];

      Module["_round"] = asm["_round"];

      Module["_sbrk"] = asm["_sbrk"];

      Module["_sizeOfCellBoundary"] = asm["_sizeOfCellBoundary"];

      Module["_sizeOfCoordIJ"] = asm["_sizeOfCoordIJ"];

      Module["_sizeOfGeoLoop"] = asm["_sizeOfGeoLoop"];

      Module["_sizeOfGeoPolygon"] = asm["_sizeOfGeoPolygon"];

      Module["_sizeOfH3Index"] = asm["_sizeOfH3Index"];

      Module["_sizeOfLatLng"] = asm["_sizeOfLatLng"];

      Module["_sizeOfLinkedGeoPolygon"] = asm["_sizeOfLinkedGeoPolygon"];

      Module["_uncompactCells"] = asm["_uncompactCells"];

      Module["_uncompactCellsSize"] = asm["_uncompactCellsSize"];

      Module["_vertexToLatLng"] = asm["_vertexToLatLng"];

      Module["establishStackSpace"] = asm["establishStackSpace"];
      var stackAlloc = Module["stackAlloc"] = asm["stackAlloc"];
      var stackRestore = Module["stackRestore"] = asm["stackRestore"];
      var stackSave = Module["stackSave"] = asm["stackSave"];
      Module["asm"] = asm;
      Module["cwrap"] = cwrap;
      Module["setValue"] = setValue;
      Module["getValue"] = getValue;

      if (memoryInitializer) {
        if (!isDataURI(memoryInitializer)) {
          memoryInitializer = locateFile(memoryInitializer);
        }

        {
          addRunDependency();

          var applyMemoryInitializer = function (data) {
            if (data.byteLength) { data = new Uint8Array(data); }
            HEAPU8.set(data, GLOBAL_BASE);
            if (Module["memoryInitializerRequest"]) { delete Module["memoryInitializerRequest"].response; }
            removeRunDependency();
          };

          var doBrowserLoad = function () {
            readAsync(memoryInitializer, applyMemoryInitializer, function () {
              throw "could not load memory initializer " + memoryInitializer;
            });
          };

          var memoryInitializerBytes = tryParseAsDataURI(memoryInitializer);

          if (memoryInitializerBytes) {
            applyMemoryInitializer(memoryInitializerBytes.buffer);
          } else if (Module["memoryInitializerRequest"]) {
            var useRequest = function () {
              var request = Module["memoryInitializerRequest"];
              var response = request.response;

              if (request.status !== 200 && request.status !== 0) {
                var data = tryParseAsDataURI(Module["memoryInitializerRequestURL"]);

                if (data) {
                  response = data.buffer;
                } else {
                  console.warn("a problem seems to have happened with Module.memoryInitializerRequest, status: " + request.status + ", retrying " + memoryInitializer);
                  doBrowserLoad();
                  return;
                }
              }

              applyMemoryInitializer(response);
            };

            if (Module["memoryInitializerRequest"].response) {
              setTimeout(useRequest, 0);
            } else {
              Module["memoryInitializerRequest"].addEventListener("load", useRequest);
            }
          } else {
            doBrowserLoad();
          }
        }
      }

      var calledRun;

      dependenciesFulfilled = function runCaller() {
        if (!calledRun) { run(); }
        if (!calledRun) { dependenciesFulfilled = runCaller; }
      };

      function run(args) {

        if (runDependencies > 0) {
          return;
        }

        preRun();
        if (runDependencies > 0) { return; }

        function doRun() {
          if (calledRun) { return; }
          calledRun = true;
          if (ABORT) { return; }
          initRuntime();
          preMain();
          if (Module["onRuntimeInitialized"]) { Module["onRuntimeInitialized"](); }
          postRun();
        }

        if (Module["setStatus"]) {
          Module["setStatus"]("Running...");
          setTimeout(function () {
            setTimeout(function () {
              Module["setStatus"]("");
            }, 1);
            doRun();
          }, 1);
        } else {
          doRun();
        }
      }

      Module["run"] = run;

      function abort(what) {
        if (Module["onAbort"]) {
          Module["onAbort"](what);
        }

        what += "";
        out(what);
        err(what);
        ABORT = true;
        throw "abort(" + what + "). Build with -s ASSERTIONS=1 for more info.";
      }

      Module["abort"] = abort;

      if (Module["preInit"]) {
        if (typeof Module["preInit"] == "function") { Module["preInit"] = [Module["preInit"]]; }

        while (Module["preInit"].length > 0) {
          Module["preInit"].pop()();
        }
      }
      run();
      return libh3;
    }(typeof libh3 === 'object' ? libh3 : {});

    /*
     * Copyright 2018-2019, 2022 Uber Technologies, Inc.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *         http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    // Define the C bindings for the h3 library
    // Add some aliases to make the function definitions more intelligible
    var NUMBER = 'number';
    var H3_ERROR = NUMBER;
    var BOOLEAN = NUMBER;
    var H3_LOWER = NUMBER;
    var H3_UPPER = NUMBER;
    var RESOLUTION = NUMBER;
    var POINTER = NUMBER; // Define the bindings to functions in the C lib. Functions are defined as
    // [name, return type, [arg types]]. You must run `npm run build-emscripten`
    // before new functions added here will be available.

    /** @type {([string, string] | [string, string | null, string[]])[]} */

    var BINDINGS = [// The size functions are inserted via build/sizes.h
    ['sizeOfH3Index', NUMBER], ['sizeOfLatLng', NUMBER], ['sizeOfCellBoundary', NUMBER], ['sizeOfGeoLoop', NUMBER], ['sizeOfGeoPolygon', NUMBER], ['sizeOfLinkedGeoPolygon', NUMBER], ['sizeOfCoordIJ', NUMBER], ['readInt64AsDoubleFromPointer', NUMBER], // The remaining functions are defined in the core lib in h3Api.h
    ['isValidCell', BOOLEAN, [H3_LOWER, H3_UPPER]], ['latLngToCell', H3_ERROR, [NUMBER, NUMBER, RESOLUTION, POINTER]], ['cellToLatLng', H3_ERROR, [H3_LOWER, H3_UPPER, POINTER]], ['cellToBoundary', H3_ERROR, [H3_LOWER, H3_UPPER, POINTER]], ['maxGridDiskSize', H3_ERROR, [NUMBER, POINTER]], ['gridDisk', H3_ERROR, [H3_LOWER, H3_UPPER, NUMBER, POINTER]], ['gridDiskDistances', H3_ERROR, [H3_LOWER, H3_UPPER, NUMBER, POINTER, POINTER]], ['gridRingUnsafe', H3_ERROR, [H3_LOWER, H3_UPPER, NUMBER, POINTER]], ['maxPolygonToCellsSize', H3_ERROR, [POINTER, RESOLUTION, NUMBER, POINTER]], ['polygonToCells', H3_ERROR, [POINTER, RESOLUTION, NUMBER, POINTER]], ['cellsToLinkedMultiPolygon', H3_ERROR, [POINTER, NUMBER, POINTER]], ['destroyLinkedMultiPolygon', null, [POINTER]], ['compactCells', H3_ERROR, [POINTER, POINTER, NUMBER, NUMBER]], ['uncompactCells', H3_ERROR, [POINTER, NUMBER, NUMBER, POINTER, NUMBER, RESOLUTION]], ['uncompactCellsSize', H3_ERROR, [POINTER, NUMBER, NUMBER, RESOLUTION, POINTER]], ['isPentagon', BOOLEAN, [H3_LOWER, H3_UPPER]], ['isResClassIII', BOOLEAN, [H3_LOWER, H3_UPPER]], ['getBaseCellNumber', NUMBER, [H3_LOWER, H3_UPPER]], ['getResolution', NUMBER, [H3_LOWER, H3_UPPER]], ['maxFaceCount', H3_ERROR, [H3_LOWER, H3_UPPER, POINTER]], ['getIcosahedronFaces', H3_ERROR, [H3_LOWER, H3_UPPER, POINTER]], ['cellToParent', H3_ERROR, [H3_LOWER, H3_UPPER, RESOLUTION, POINTER]], ['cellToChildren', H3_ERROR, [H3_LOWER, H3_UPPER, RESOLUTION, POINTER]], ['cellToCenterChild', H3_ERROR, [H3_LOWER, H3_UPPER, RESOLUTION, POINTER]], ['cellToChildrenSize', H3_ERROR, [H3_LOWER, H3_UPPER, RESOLUTION, POINTER]], ['areNeighborCells', H3_ERROR, [H3_LOWER, H3_UPPER, H3_LOWER, H3_UPPER, POINTER]], ['cellsToDirectedEdge', H3_ERROR, [H3_LOWER, H3_UPPER, H3_LOWER, H3_UPPER, POINTER]], ['getDirectedEdgeOrigin', H3_ERROR, [H3_LOWER, H3_UPPER, POINTER]], ['getDirectedEdgeDestination', H3_ERROR, [H3_LOWER, H3_UPPER, POINTER]], ['isValidDirectedEdge', BOOLEAN, [H3_LOWER, H3_UPPER]], ['directedEdgeToCells', H3_ERROR, [H3_LOWER, H3_UPPER, POINTER]], ['originToDirectedEdges', H3_ERROR, [H3_LOWER, H3_UPPER, POINTER]], ['directedEdgeToBoundary', H3_ERROR, [H3_LOWER, H3_UPPER, POINTER]], ['gridDistance', H3_ERROR, [H3_LOWER, H3_UPPER, H3_LOWER, H3_UPPER, POINTER]], ['gridPathCells', H3_ERROR, [H3_LOWER, H3_UPPER, H3_LOWER, H3_UPPER, POINTER]], ['gridPathCellsSize', H3_ERROR, [H3_LOWER, H3_UPPER, H3_LOWER, H3_UPPER, POINTER]], ['cellToLocalIj', H3_ERROR, [H3_LOWER, H3_UPPER, H3_LOWER, H3_UPPER, NUMBER, POINTER]], ['localIjToCell', H3_ERROR, [H3_LOWER, H3_UPPER, POINTER, NUMBER, POINTER]], ['getHexagonAreaAvgM2', H3_ERROR, [RESOLUTION, POINTER]], ['getHexagonAreaAvgKm2', H3_ERROR, [RESOLUTION, POINTER]], ['getHexagonEdgeLengthAvgM', H3_ERROR, [RESOLUTION, POINTER]], ['getHexagonEdgeLengthAvgKm', H3_ERROR, [RESOLUTION, POINTER]], ['greatCircleDistanceM', NUMBER, [POINTER, POINTER]], ['greatCircleDistanceKm', NUMBER, [POINTER, POINTER]], ['greatCircleDistanceRads', NUMBER, [POINTER, POINTER]], ['cellAreaM2', H3_ERROR, [H3_LOWER, H3_UPPER, POINTER]], ['cellAreaKm2', H3_ERROR, [H3_LOWER, H3_UPPER, POINTER]], ['cellAreaRads2', H3_ERROR, [H3_LOWER, H3_UPPER, POINTER]], ['edgeLengthM', H3_ERROR, [H3_LOWER, H3_UPPER, POINTER]], ['edgeLengthKm', H3_ERROR, [H3_LOWER, H3_UPPER, POINTER]], ['edgeLengthRads', H3_ERROR, [H3_LOWER, H3_UPPER, POINTER]], ['getNumCells', H3_ERROR, [RESOLUTION, POINTER]], ['getRes0Cells', H3_ERROR, [POINTER]], ['res0CellCount', NUMBER], ['getPentagons', H3_ERROR, [NUMBER, POINTER]], ['pentagonCount', NUMBER], ['cellToVertex', H3_ERROR, [H3_LOWER, H3_UPPER, NUMBER, POINTER]], ['cellToVertexes', H3_ERROR, [H3_LOWER, H3_UPPER, POINTER]], ['vertexToLatLng', H3_ERROR, [H3_LOWER, H3_UPPER, POINTER]], ['isValidVertex', BOOLEAN, [H3_LOWER, H3_UPPER]]];

    /*
     * Copyright 2018-2019, 2022 Uber Technologies, Inc.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *         http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    // Error codes from the code library, aliased here for legibility
    var E_SUCCESS = 0;
    var E_FAILED = 1;
    var E_DOMAIN = 2;
    var E_LATLNG_DOMAIN = 3;
    var E_RES_DOMAIN = 4;
    var E_CELL_INVALID = 5;
    var E_DIR_EDGE_INVALID = 6;
    var E_UNDIR_EDGE_INVALID = 7;
    var E_VERTEX_INVALID = 8;
    var E_PENTAGON = 9;
    var E_DUPLICATE_INPUT = 10;
    var E_NOT_NEIGHBORS = 11;
    var E_RES_MISMATCH = 12;
    var E_MEMORY_ALLOC = 13;
    var E_MEMORY_BOUNDS = 14;
    var E_OPTION_INVALID = 15;
    /**
     * Error messages corresponding to the core library error codes. See
     * https://h3geo.org/docs/library/errors#table-of-error-codes
     * @private
     */

    var H3_ERROR_MSGS = {};
    H3_ERROR_MSGS[E_SUCCESS] = 'Success';
    H3_ERROR_MSGS[E_FAILED] = 'The operation failed but a more specific error is not available';
    H3_ERROR_MSGS[E_DOMAIN] = 'Argument was outside of acceptable range';
    H3_ERROR_MSGS[E_LATLNG_DOMAIN] = 'Latitude or longitude arguments were outside of acceptable range';
    H3_ERROR_MSGS[E_RES_DOMAIN] = 'Resolution argument was outside of acceptable range';
    H3_ERROR_MSGS[E_CELL_INVALID] = 'Cell argument was not valid';
    H3_ERROR_MSGS[E_DIR_EDGE_INVALID] = 'Directed edge argument was not valid';
    H3_ERROR_MSGS[E_UNDIR_EDGE_INVALID] = 'Undirected edge argument was not valid';
    H3_ERROR_MSGS[E_VERTEX_INVALID] = 'Vertex argument was not valid';
    H3_ERROR_MSGS[E_PENTAGON] = 'Pentagon distortion was encountered';
    H3_ERROR_MSGS[E_DUPLICATE_INPUT] = 'Duplicate input';
    H3_ERROR_MSGS[E_NOT_NEIGHBORS] = 'Cell arguments were not neighbors';
    H3_ERROR_MSGS[E_RES_MISMATCH] = 'Cell arguments had incompatible resolutions';
    H3_ERROR_MSGS[E_MEMORY_ALLOC] = 'Memory allocation failed';
    H3_ERROR_MSGS[E_MEMORY_BOUNDS] = 'Bounds of provided memory were insufficient';
    H3_ERROR_MSGS[E_OPTION_INVALID] = 'Mode or flags argument was not valid'; // Error codes for JS errors thrown in the bindings

    var E_UNKNOWN_UNIT = 1000;
    var E_ARRAY_LENGTH = 1001;
    var E_NULL_INDEX = 1002;
    /**
     * Error messages for errors thrown in the binding code. These don't strictly
     * need error codes, but it's simpler to treat all of the errors consistently
     * @private
     */

    var JS_ERROR_MESSAGES = {};
    JS_ERROR_MESSAGES[E_UNKNOWN_UNIT] = 'Unknown unit';
    JS_ERROR_MESSAGES[E_ARRAY_LENGTH] = 'Array length out of bounds';
    JS_ERROR_MESSAGES[E_NULL_INDEX] = 'Got unexpected null value for H3 index';
    var UNKNOWN_ERROR_MSG = 'Unknown error';
    /**
     * Create an error with an attached code
     * @private
     * @param {Record<number, string>} messages  Map of code-to-messages to use
     * @param {number} errCode                   Numeric error code
     * @param {{value: unknown} | {}} [meta]     Metadata with value to associate with the error
     */

    function createError(messages, errCode, meta) {
      // The error value may be "undefined", so check if the argument was provided
      var hasValue = meta && 'value' in meta; // Throw a custom error type with the code attached

      var err = new Error(((messages[errCode] || UNKNOWN_ERROR_MSG) + " (code: " + errCode + (hasValue ? (", value: " + (meta.value)) : '') + ")")); // @ts-expect-error - TS doesn't like extending Error

      err.code = errCode;
      return err;
    }
    /**
     * Custom error for H3Error codes
     * @private
     * @param {number} errCode     Error code from the H3 library
     * @param {unknown} [value]    Value to associate with the error, if any
     * @returns {Error}
     */


    function H3LibraryError(errCode, value) {
      // The error value may be "undefined", so check if the argument was provided
      var meta = arguments.length === 2 ? {
        value: value
      } : {};
      return createError(H3_ERROR_MSGS, errCode, meta);
    }
    /**
     * Custom errors thrown from the JS bindings.
     * @private
     * @param {number} errCode     Error code from the H3 library
     * @param {unknown} [value]    Value to associate with the error, if any
     * @returns {Error}
     */

    function JSBindingError(errCode, value) {
      // The error value may be "undefined", so check if the argument was provided
      var meta = arguments.length === 2 ? {
        value: value
      } : {};
      return createError(JS_ERROR_MESSAGES, errCode, meta);
    }
    /**
     * Throw a JavaScript error if the C library return code is an error
     * @private
     * @param {number} errCode     Error code from the H3 library
     * @throws {Error} Error if err is not E_SUCCESS (0)
     */

    function throwIfError(errCode) {
      if (errCode !== 0) {
        throw H3LibraryError(errCode);
      }
    }

    /*
     * Copyright 2018-2019, 2022 Uber Technologies, Inc.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *         http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /**
     * Map of C-defined functions
     * @type {any}
     * @private
     */

    var H3 = {}; // Create the bound functions themselves

    BINDINGS.forEach(function bind(def) {
      H3[def[0]] = libh3.cwrap.apply(libh3, def);
    }); // Alias the hexidecimal base for legibility

    var BASE_16 = 16; // Alias unused bits for legibility
    // Byte size imports

    var SZ_INT = 4;
    var SZ_DBL = 8;
    var SZ_INT64 = 8;
    var SZ_H3INDEX = H3.sizeOfH3Index();
    var SZ_LATLNG = H3.sizeOfLatLng();
    var SZ_CELLBOUNDARY = H3.sizeOfCellBoundary();
    var SZ_GEOPOLYGON = H3.sizeOfGeoPolygon();
    var SZ_GEOLOOP = H3.sizeOfGeoLoop();
    H3.sizeOfLinkedGeoPolygon();
    H3.sizeOfCoordIJ(); // ----------------------------------------------------------------------------
    // Utilities and helpers

    /**
     * Validate a resolution, throwing an error if invalid
     * @private
     * @param  {unknown} res Value to validate
     * @return {number}      Valid res
     * @throws {H3Error}     If invalid
     */

    function validateRes(res) {
      if (typeof res !== 'number' || res < 0 || res > 15 || Math.floor(res) !== res) {
        throw H3LibraryError(E_RES_DOMAIN, res);
      }

      return res;
    }
    /**
     * Assert H3 index output, throwing an error if null
     * @private
     * @param {H3Index | null} h3Index    Index to validate
     * @return {H3Index}
     * @throws {H3Error}     If invalid
     */


    function validateH3Index(h3Index) {
      if (!h3Index) { throw JSBindingError(E_NULL_INDEX); }
      return h3Index;
    }

    var MAX_JS_ARRAY_LENGTH = Math.pow(2, 32) - 1;
    /**
     * Validate an array length. JS will throw its own error if you try
     * to create an array larger than 2^32 - 1, but validating beforehand
     * allows us to exit early before we try to process large amounts
     * of data that won't even fit in an output array
     * @private
     * @param  {number} length  Length to validate
     * @return {number}         Valid array length
     * @throws {H3Error}        If invalid
     */

    function validateArrayLength(length) {
      if (length > MAX_JS_ARRAY_LENGTH) {
        throw JSBindingError(E_ARRAY_LENGTH, length);
      }

      return length;
    }

    var INVALID_HEXIDECIMAL_CHAR = /[^0-9a-fA-F]/;
    /**
     * Convert an H3 index (64-bit hexidecimal string) into a "split long" - a pair of 32-bit ints
     * @param  {H3IndexInput} h3Index  H3 index to check
     * @return {SplitLong}             A two-element array with 32 lower bits and 32 upper bits
     */

    function h3IndexToSplitLong(h3Index) {
      if (Array.isArray(h3Index) && h3Index.length === 2 && Number.isInteger(h3Index[0]) && Number.isInteger(h3Index[1])) {
        return h3Index;
      }

      if (typeof h3Index !== 'string' || INVALID_HEXIDECIMAL_CHAR.test(h3Index)) {
        return [0, 0];
      }

      var upper = parseInt(h3Index.substring(0, h3Index.length - 8), BASE_16);
      var lower = parseInt(h3Index.substring(h3Index.length - 8), BASE_16);
      return [lower, upper];
    }
    /**
     * Convert a 32-bit int to a hexdecimal string
     * @private
     * @param  {number} num  Integer to convert
     * @return {H3Index}     Hexidecimal string
     */

    function hexFrom32Bit(num) {
      if (num >= 0) {
        return num.toString(BASE_16);
      } // Handle negative numbers


      num = num & 0x7fffffff;
      var tempStr = zeroPad(8, num.toString(BASE_16));
      var topNum = (parseInt(tempStr[0], BASE_16) + 8).toString(BASE_16);
      tempStr = topNum + tempStr.substring(1);
      return tempStr;
    }
    /**
     * Get a H3 index string from a split long (pair of 32-bit ints)
     * @param  {number} lower Lower 32 bits
     * @param  {number} upper Upper 32 bits
     * @return {H3Index}       H3 index
     */


    function splitLongToH3Index(lower, upper) {
      return hexFrom32Bit(upper) + zeroPad(8, hexFrom32Bit(lower));
    }
    /**
     * Zero-pad a string to a given length
     * @private
     * @param  {number} fullLen Target length
     * @param  {string} numStr  String to zero-pad
     * @return {string}         Zero-padded string
     */

    function zeroPad(fullLen, numStr) {
      var numZeroes = fullLen - numStr.length;
      var outStr = '';

      for (var i = 0; i < numZeroes; i++) {
        outStr += '0';
      }

      outStr = outStr + numStr;
      return outStr;
    }
    /**
     * Populate a C-appropriate GeoLoop struct from a polygon array
     * @private
     * @param  {number[][]} polygonArray  Polygon, as an array of coordinate pairs
     * @param  {number}  geoLoop          C pointer to a GeoLoop struct
     * @param  {boolean} isGeoJson        Whether coordinates are in [lng, lat] order per GeoJSON spec
     * @return {number}                   C pointer to populated GeoLoop struct
     */


    function polygonArrayToGeoLoop(polygonArray, geoLoop, isGeoJson) {
      var numVerts = polygonArray.length;

      var geoCoordArray = libh3._calloc(numVerts, SZ_LATLNG); // Support [lng, lat] pairs if GeoJSON is specified


      var latIndex = isGeoJson ? 1 : 0;
      var lngIndex = isGeoJson ? 0 : 1;

      for (var i = 0; i < numVerts * 2; i += 2) {
        libh3.HEAPF64.set([polygonArray[i / 2][latIndex], polygonArray[i / 2][lngIndex]].map(degsToRads), geoCoordArray / SZ_DBL + i);
      }

      libh3.HEAPU32.set([numVerts, geoCoordArray], geoLoop / SZ_INT);
      return geoLoop;
    }
    /**
     * Create a C-appropriate GeoPolygon struct from an array of polygons
     * @private
     * @param  {number[][][]} coordinates Array of polygons, each an array of coordinate pairs
     * @param  {boolean} isGeoJson        Whether coordinates are in [lng, lat] order per GeoJSON spec
     * @return {number}                   C pointer to populated GeoPolygon struct
     */


    function coordinatesToGeoPolygon(coordinates, isGeoJson) {
      // Any loops beyond the first loop are holes
      var numHoles = coordinates.length - 1;

      var geoPolygon = libh3._calloc(SZ_GEOPOLYGON); // Byte positions within the struct


      var geoLoopOffset = 0;
      var numHolesOffset = geoLoopOffset + SZ_GEOLOOP;
      var holesOffset = numHolesOffset + SZ_INT; // geoLoop is first part of struct

      polygonArrayToGeoLoop(coordinates[0], geoPolygon + geoLoopOffset, isGeoJson);
      var holes;

      if (numHoles > 0) {
        holes = libh3._calloc(numHoles, SZ_GEOLOOP);

        for (var i = 0; i < numHoles; i++) {
          polygonArrayToGeoLoop(coordinates[i + 1], holes + SZ_GEOLOOP * i, isGeoJson);
        }
      }

      libh3.setValue(geoPolygon + numHolesOffset, numHoles, 'i32');
      libh3.setValue(geoPolygon + holesOffset, holes, 'i32');
      return geoPolygon;
    }
    /**
     * Free memory allocated for a GeoPolygon struct. It is an error to access the struct
     * after passing it to this method.
     * @private
     * @param {number} geoPolygon     C pointer to GeoPolygon struct
     * @return {void}
     */


    function destroyGeoPolygon(geoPolygon) {
      // Byte positions within the struct
      var geoLoopOffset = 0;
      var numHolesOffset = geoLoopOffset + SZ_GEOLOOP;
      var holesOffset = numHolesOffset + SZ_INT; // Offset of the geoLoop vertex array pointer within the GeoLoop struct

      var geoLoopArrayOffset = SZ_INT; // Free the outer vertex array

      libh3._free(libh3.getValue(geoPolygon + geoLoopOffset + geoLoopArrayOffset, 'i8*')); // Free the vertex array for the holes, if any


      var numHoles = libh3.getValue(geoPolygon + numHolesOffset, 'i32');

      if (numHoles > 0) {
        var holes = libh3.getValue(geoPolygon + holesOffset, 'i32');

        for (var i = 0; i < numHoles; i++) {
          libh3._free(libh3.getValue(holes + SZ_GEOLOOP * i + geoLoopArrayOffset, 'i8*'));
        }

        libh3._free(holes);
      }

      libh3._free(geoPolygon);
    }
    /**
     * Read an H3 index from a pointer to C memory.
     * @private
     * @param  {number} cAddress  Pointer to allocated C memory
     * @param {number} offset     Offset, in number of H3 indexes, in case we're
     *                            reading an array
     * @return {H3Index | null}   H3 index, or null if index was invalid
     */


    function readH3IndexFromPointer(cAddress, offset) {
      if ( offset === void 0 ) offset = 0;

      var lower = libh3.getValue(cAddress + SZ_H3INDEX * offset, 'i32');
      var upper = libh3.getValue(cAddress + SZ_H3INDEX * offset + SZ_INT, 'i32'); // The lower bits are allowed to be 0s, but if the upper bits are 0
      // this represents an invalid H3 index

      return upper ? splitLongToH3Index(lower, upper) : null;
    }
    /**
     * Read a 64-bit int from a pointer to C memory into a JS 64-bit float.
     * Note that this may lose precision if larger than MAX_SAFE_INTEGER
     * @private
     * @param  {number} cAddress  Pointer to allocated C memory
     * @return {number} Double value
     */


    function readInt64AsDoubleFromPointer(cAddress) {
      return H3.readInt64AsDoubleFromPointer(cAddress);
    }
    /**
     * Read an array of 64-bit H3 indexes from C and convert to a JS array of
     * H3 index strings
     * @private
     * @param  {number} cAddress    Pointer to C ouput array
     * @param  {number} maxCount    Max number of hexagons in array. Hexagons with
     *                              the value 0 will be skipped, so this isn't
     *                              necessarily the length of the output array.
     * @return {H3Index[]}          Array of H3 indexes
     */


    function readArrayOfH3Indexes(cAddress, maxCount) {
      var out = [];

      for (var i = 0; i < maxCount; i++) {
        var h3Index = readH3IndexFromPointer(cAddress, i);

        if (h3Index !== null) {
          out.push(h3Index);
        }
      }

      return out;
    }
    /**
     * Read a single lat or lng value
     * @private
     * @param  {number} cAddress Pointer to C value
     * @return {number}
     */


    function readSingleCoord(cAddress) {
      return radsToDegs(libh3.getValue(cAddress, 'double'));
    }
    /**
     * Read a LatLng from C and return a [lat, lng] pair.
     * @private
     * @param  {number} cAddress    Pointer to C struct
     * @return {CoordPair}          [lat, lng] pair
     */


    function readLatLng(cAddress) {
      return [readSingleCoord(cAddress), readSingleCoord(cAddress + SZ_DBL)];
    }
    /**
     * Read a LatLng from C and return a GeoJSON-style [lng, lat] pair.
     * @private
     * @param  {number} cAddress    Pointer to C struct
     * @return {CoordPair}          [lng, lat] pair
     */


    function readLatLngGeoJson(cAddress) {
      return [readSingleCoord(cAddress + SZ_DBL), readSingleCoord(cAddress)];
    }
    /**
     * Read the CellBoundary structure into a list of geo coordinate pairs
     * @private
     * @param {number}  cellBoundary       C pointer to CellBoundary struct
     * @param {boolean} [geoJsonCoords]    Whether to provide GeoJSON coordinate order: [lng, lat]
     * @param {boolean} [closedLoop]       Whether to close the loop
     * @return {CoordPair[]}               Array of geo coordinate pairs
     */


    function readCellBoundary(cellBoundary, geoJsonCoords, closedLoop) {
      var numVerts = libh3.getValue(cellBoundary, 'i32'); // Note that though numVerts is an int, the coordinate doubles have to be
      // aligned to 8 bytes, hence the 8-byte offset here

      var vertsPos = cellBoundary + SZ_DBL;
      var out = []; // Support [lng, lat] pairs if GeoJSON is specified

      var readCoord = geoJsonCoords ? readLatLngGeoJson : readLatLng;

      for (var i = 0; i < numVerts * 2; i += 2) {
        out.push(readCoord(vertsPos + SZ_DBL * i));
      }

      if (closedLoop) {
        // Close loop if GeoJSON is specified
        out.push(out[0]);
      }

      return out;
    }
    /**
     * Get the hexagon containing a lat,lon point
     * @static
     * @param  {number} lat Latitude of point
     * @param  {number} lng Longtitude of point
     * @param  {number} res Resolution of hexagons to return
     * @return {H3Index}    H3 index
     * @throws {H3Error}    If input is invalid
     */

    function latLngToCell(lat, lng, res) {
      var latLng = libh3._malloc(SZ_LATLNG); // Slightly more efficient way to set the memory


      libh3.HEAPF64.set([lat, lng].map(degsToRads), latLng / SZ_DBL); // Read value as a split long

      var h3Index = libh3._malloc(SZ_H3INDEX);

      try {
        throwIfError(H3.latLngToCell(latLng, res, h3Index));
        return validateH3Index(readH3IndexFromPointer(h3Index));
      } finally {
        libh3._free(h3Index);

        libh3._free(latLng);
      }
    }
    /**
     * Get the lat,lon center of a given hexagon
     * @static
     * @param  {H3IndexInput} h3Index  H3 index
     * @return {CoordPair}             Point as a [lat, lng] pair
     * @throws {H3Error}               If input is invalid
     */

    function cellToLatLng(h3Index) {
      var latLng = libh3._malloc(SZ_LATLNG);

      var ref = h3IndexToSplitLong(h3Index);
      var lower = ref[0];
      var upper = ref[1];

      try {
        throwIfError(H3.cellToLatLng(lower, upper, latLng));
        return readLatLng(latLng);
      } finally {
        libh3._free(latLng);
      }
    }
    /**
     * Get the vertices of a given hexagon (or pentagon), as an array of [lat, lng]
     * points. For pentagons and hexagons on the edge of an icosahedron face, this
     * function may return up to 10 vertices.
     * @static
     * @param  {H3Index} h3Index          H3 index
     * @param {boolean} [formatAsGeoJson] Whether to provide GeoJSON output: [lng, lat], closed loops
     * @return {CoordPair[]}              Array of [lat, lng] pairs
     * @throws {H3Error}                  If input is invalid
     */

    function cellToBoundary(h3Index, formatAsGeoJson) {
      var cellBoundary = libh3._malloc(SZ_CELLBOUNDARY);

      var ref = h3IndexToSplitLong(h3Index);
      var lower = ref[0];
      var upper = ref[1];

      try {
        throwIfError(H3.cellToBoundary(lower, upper, cellBoundary));
        return readCellBoundary(cellBoundary, formatAsGeoJson, formatAsGeoJson);
      } finally {
        libh3._free(cellBoundary);
      }
    } // ----------------------------------------------------------------------------
    /**
     * Get all hexagons with centers contained in a given polygon. The polygon
     * is specified with GeoJson semantics as an array of loops. Each loop is
     * an array of [lat, lng] pairs (or [lng, lat] if isGeoJson is specified).
     * The first loop is the perimeter of the polygon, and subsequent loops are
     * expected to be holes.
     * @static
     * @param  {number[][] | number[][][]} coordinates
     *                                  Array of loops, or a single loop
     * @param  {number} res             Resolution of hexagons to return
     * @param  {boolean} [isGeoJson]    Whether to expect GeoJson-style [lng, lat]
     *                                  pairs instead of [lat, lng]
     * @return {H3Index[]}              H3 indexes for all hexagons in polygon
     * @throws {H3Error}                If input is invalid or output is too large for JS
     */

    function polygonToCells(coordinates, res, isGeoJson) {
      validateRes(res);
      isGeoJson = Boolean(isGeoJson); // Guard against empty input

      if (coordinates.length === 0 || coordinates[0].length === 0) {
        return [];
      } // Wrap to expected format if a single loop is provided


      var polygon = typeof coordinates[0][0] === 'number' ? [coordinates] : coordinates;
      var geoPolygon = coordinatesToGeoPolygon( // @ts-expect-error - There's no way to convince TS that polygon is now number[][][]
      polygon, isGeoJson);

      var countPtr = libh3._malloc(SZ_INT64);

      try {
        throwIfError(H3.maxPolygonToCellsSize(geoPolygon, res, 0, countPtr));
        var count = validateArrayLength(readInt64AsDoubleFromPointer(countPtr));

        var hexagons = libh3._calloc(count, SZ_H3INDEX);

        try {
          throwIfError(H3.polygonToCells(geoPolygon, res, 0, hexagons));
          return readArrayOfH3Indexes(hexagons, count);
        } finally {
          libh3._free(hexagons);
        }
      } finally {
        libh3._free(countPtr);

        destroyGeoPolygon(geoPolygon);
      }
    }
    /**
     * Convert degrees to radians
     * @static
     * @param  {number} deg Value in degrees
     * @return {number}     Value in radians
     */

    function degsToRads(deg) {
      return deg * Math.PI / 180;
    }
    /**
     * Convert radians to degrees
     * @static
     * @param  {number} rad Value in radians
     * @return {number}     Value in degrees
     */

    function radsToDegs(rad) {
      return rad * 180 / Math.PI;
    }

    const THREE$2$1 = window.THREE ? window.THREE // Prefer consumption from global THREE, if exists
    : {
      Box3,
      BufferGeometry,
      Float32BufferAttribute,
      InstancedBufferGeometry,
      InstancedInterleavedBuffer,
      InterleavedBufferAttribute,
      Sphere,
      Vector3,
      WireframeGeometry
    }; // support multiple method names for backwards threejs compatibility

    var setAttributeFn$1$1 = new THREE$2$1.BufferGeometry().setAttribute ? 'setAttribute' : 'addAttribute';

    const _box$1 = new THREE$2$1.Box3();

    const _vector = new THREE$2$1.Vector3();

    class LineSegmentsGeometry extends THREE$2$1.InstancedBufferGeometry {
      constructor() {
        super();
        this.type = 'LineSegmentsGeometry';
        const positions = [-1, 2, 0, 1, 2, 0, -1, 1, 0, 1, 1, 0, -1, 0, 0, 1, 0, 0, -1, -1, 0, 1, -1, 0];
        const uvs = [-1, 2, 1, 2, -1, 1, 1, 1, -1, -1, 1, -1, -1, -2, 1, -2];
        const index = [0, 2, 1, 2, 3, 1, 2, 4, 3, 4, 5, 3, 4, 6, 5, 6, 7, 5];
        this.setIndex(index);
        this[setAttributeFn$1$1]('position', new THREE$2$1.Float32BufferAttribute(positions, 3));
        this[setAttributeFn$1$1]('uv', new THREE$2$1.Float32BufferAttribute(uvs, 2));
      }

      applyMatrix4(matrix) {
        const start = this.attributes.instanceStart;
        const end = this.attributes.instanceEnd;

        if (start !== undefined) {
          start.applyMatrix4(matrix);
          end.applyMatrix4(matrix);
          start.needsUpdate = true;
        }

        if (this.boundingBox !== null) {
          this.computeBoundingBox();
        }

        if (this.boundingSphere !== null) {
          this.computeBoundingSphere();
        }

        return this;
      }

      setPositions(array) {
        let lineSegments;

        if (array instanceof Float32Array) {
          lineSegments = array;
        } else if (Array.isArray(array)) {
          lineSegments = new Float32Array(array);
        }

        const instanceBuffer = new THREE$2$1.InstancedInterleavedBuffer(lineSegments, 6, 1); // xyz, xyz

        this[setAttributeFn$1$1]('instanceStart', new THREE$2$1.InterleavedBufferAttribute(instanceBuffer, 3, 0)); // xyz

        this[setAttributeFn$1$1]('instanceEnd', new THREE$2$1.InterleavedBufferAttribute(instanceBuffer, 3, 3)); // xyz
        //

        this.computeBoundingBox();
        this.computeBoundingSphere();
        return this;
      }

      setColors(array) {
        let colors;

        if (array instanceof Float32Array) {
          colors = array;
        } else if (Array.isArray(array)) {
          colors = new Float32Array(array);
        }

        const instanceColorBuffer = new THREE$2$1.InstancedInterleavedBuffer(colors, 6, 1); // rgb, rgb

        this[setAttributeFn$1$1]('instanceColorStart', new THREE$2$1.InterleavedBufferAttribute(instanceColorBuffer, 3, 0)); // rgb

        this[setAttributeFn$1$1]('instanceColorEnd', new THREE$2$1.InterleavedBufferAttribute(instanceColorBuffer, 3, 3)); // rgb

        return this;
      }

      fromWireframeGeometry(geometry) {
        this.setPositions(geometry.attributes.position.array);
        return this;
      }

      fromEdgesGeometry(geometry) {
        this.setPositions(geometry.attributes.position.array);
        return this;
      }

      fromMesh(mesh) {
        this.fromWireframeGeometry(new THREE$2$1.WireframeGeometry(mesh.geometry)); // set colors, maybe

        return this;
      }

      fromLineSegments(lineSegments) {
        const geometry = lineSegments.geometry;

        if (geometry.isGeometry) {
          console.error('LineSegmentsGeometry no longer supports Geometry. Use THREE.BufferGeometry instead.');
          return;
        } else if (geometry.isBufferGeometry) {
          this.setPositions(geometry.attributes.position.array); // assumes non-indexed
        } // set colors, maybe


        return this;
      }

      computeBoundingBox() {
        if (this.boundingBox === null) {
          this.boundingBox = new THREE$2$1.Box3();
        }

        const start = this.attributes.instanceStart;
        const end = this.attributes.instanceEnd;

        if (start !== undefined && end !== undefined) {
          this.boundingBox.setFromBufferAttribute(start);

          _box$1.setFromBufferAttribute(end);

          this.boundingBox.union(_box$1);
        }
      }

      computeBoundingSphere() {
        if (this.boundingSphere === null) {
          this.boundingSphere = new THREE$2$1.Sphere();
        }

        if (this.boundingBox === null) {
          this.computeBoundingBox();
        }

        const start = this.attributes.instanceStart;
        const end = this.attributes.instanceEnd;

        if (start !== undefined && end !== undefined) {
          const center = this.boundingSphere.center;
          this.boundingBox.getCenter(center);
          let maxRadiusSq = 0;

          for (let i = 0, il = start.count; i < il; i++) {
            _vector.fromBufferAttribute(start, i);

            maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector));

            _vector.fromBufferAttribute(end, i);

            maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector));
          }

          this.boundingSphere.radius = Math.sqrt(maxRadiusSq);

          if (isNaN(this.boundingSphere.radius)) {
            console.error('THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.', this);
          }
        }
      }

      toJSON() {// todo
      }

      applyMatrix(matrix) {
        console.warn('THREE.LineSegmentsGeometry: applyMatrix() has been renamed to applyMatrix4().');
        return this.applyMatrix4(matrix);
      }

    }

    LineSegmentsGeometry.prototype.isLineSegmentsGeometry = true;

    /**
     * parameters = {
     *  color: <hex>,
     *  linewidth: <float>,
     *  dashed: <boolean>,
     *  dashScale: <float>,
     *  dashSize: <float>,
     *  dashOffset: <float>,
     *  gapSize: <float>,
     *  resolution: <Vector2>, // to be set by renderer
     * }
     */
    const THREE$1$1 = window.THREE ? window.THREE // Prefer consumption from global THREE, if exists
    : {
      ShaderLib,
      ShaderMaterial,
      UniformsLib,
      UniformsUtils,
      Vector2
    };
    THREE$1$1.UniformsLib.line = {
      worldUnits: {
        value: 1
      },
      linewidth: {
        value: 1
      },
      resolution: {
        value: new THREE$1$1.Vector2(1, 1)
      },
      dashScale: {
        value: 1
      },
      dashSize: {
        value: 1
      },
      dashOffset: {
        value: 0
      },
      gapSize: {
        value: 1
      } // todo FIX - maybe change to totalSize

    };
    THREE$1$1.ShaderLib['line'] = {
      uniforms: THREE$1$1.UniformsUtils.merge([THREE$1$1.UniformsLib.common, THREE$1$1.UniformsLib.fog, THREE$1$1.UniformsLib.line]),
      vertexShader:
      /* glsl */
      `
		#include <common>
		#include <color_pars_vertex>
		#include <fog_pars_vertex>
		#include <logdepthbuf_pars_vertex>
		#include <clipping_planes_pars_vertex>

		uniform float linewidth;
		uniform vec2 resolution;

		attribute vec3 instanceStart;
		attribute vec3 instanceEnd;

		attribute vec3 instanceColorStart;
		attribute vec3 instanceColorEnd;

		varying vec2 vUv;
		varying vec4 worldPos;
		varying vec3 worldStart;
		varying vec3 worldEnd;

		#ifdef USE_DASH

			uniform float dashScale;
			attribute float instanceDistanceStart;
			attribute float instanceDistanceEnd;
			varying float vLineDistance;

		#endif

		void trimSegment( const in vec4 start, inout vec4 end ) {

			// trim end segment so it terminates between the camera plane and the near plane

			// conservative estimate of the near plane
			float a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column
			float b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column
			float nearEstimate = - 0.5 * b / a;

			float alpha = ( nearEstimate - start.z ) / ( end.z - start.z );

			end.xyz = mix( start.xyz, end.xyz, alpha );

		}

		void main() {

			#ifdef USE_COLOR

				vColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;

			#endif

			#ifdef USE_DASH

				vLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;

			#endif

			float aspect = resolution.x / resolution.y;

			vUv = uv;

			// camera space
			vec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );
			vec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );

			worldStart = start.xyz;
			worldEnd = end.xyz;

			// special case for perspective projection, and segments that terminate either in, or behind, the camera plane
			// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space
			// but we need to perform ndc-space calculations in the shader, so we must address this issue directly
			// perhaps there is a more elegant solution -- WestLangley

			bool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column

			if ( perspective ) {

				if ( start.z < 0.0 && end.z >= 0.0 ) {

					trimSegment( start, end );

				} else if ( end.z < 0.0 && start.z >= 0.0 ) {

					trimSegment( end, start );

				}

			}

			// clip space
			vec4 clipStart = projectionMatrix * start;
			vec4 clipEnd = projectionMatrix * end;

			// ndc space
			vec3 ndcStart = clipStart.xyz / clipStart.w;
			vec3 ndcEnd = clipEnd.xyz / clipEnd.w;

			// direction
			vec2 dir = ndcEnd.xy - ndcStart.xy;

			// account for clip-space aspect ratio
			dir.x *= aspect;
			dir = normalize( dir );

			#ifdef WORLD_UNITS

				// get the offset direction as perpendicular to the view vector
				vec3 worldDir = normalize( end.xyz - start.xyz );
				vec3 offset;
				if ( position.y < 0.5 ) {

					offset = normalize( cross( start.xyz, worldDir ) );

				} else {

					offset = normalize( cross( end.xyz, worldDir ) );

				}

				// sign flip
				if ( position.x < 0.0 ) offset *= - 1.0;

				float forwardOffset = dot( worldDir, vec3( 0.0, 0.0, 1.0 ) );

				// don't extend the line if we're rendering dashes because we
				// won't be rendering the endcaps
				#ifndef USE_DASH

					// extend the line bounds to encompass  endcaps
					start.xyz += - worldDir * linewidth * 0.5;
					end.xyz += worldDir * linewidth * 0.5;

					// shift the position of the quad so it hugs the forward edge of the line
					offset.xy -= dir * forwardOffset;
					offset.z += 0.5;

				#endif

				// endcaps
				if ( position.y > 1.0 || position.y < 0.0 ) {

					offset.xy += dir * 2.0 * forwardOffset;

				}

				// adjust for linewidth
				offset *= linewidth * 0.5;

				// set the world position
				worldPos = ( position.y < 0.5 ) ? start : end;
				worldPos.xyz += offset;

				// project the worldpos
				vec4 clip = projectionMatrix * worldPos;

				// shift the depth of the projected points so the line
				// segements overlap neatly
				vec3 clipPose = ( position.y < 0.5 ) ? ndcStart : ndcEnd;
				clip.z = clipPose.z * clip.w;

			#else

			vec2 offset = vec2( dir.y, - dir.x );
			// undo aspect ratio adjustment
			dir.x /= aspect;
			offset.x /= aspect;

			// sign flip
			if ( position.x < 0.0 ) offset *= - 1.0;

			// endcaps
			if ( position.y < 0.0 ) {

				offset += - dir;

			} else if ( position.y > 1.0 ) {

				offset += dir;

			}

			// adjust for linewidth
			offset *= linewidth;

			// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...
			offset /= resolution.y;

			// select end
			vec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;

			// back to clip space
			offset *= clip.w;

			clip.xy += offset;

			#endif

			gl_Position = clip;

			vec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation

			#include <logdepthbuf_vertex>
			#include <clipping_planes_vertex>
			#include <fog_vertex>

		}
		`,
      fragmentShader:
      /* glsl */
      `
		uniform vec3 diffuse;
		uniform float opacity;
		uniform float linewidth;

		#ifdef USE_DASH

			uniform float dashOffset;
			uniform float dashSize;
			uniform float gapSize;

		#endif

		varying float vLineDistance;
		varying vec4 worldPos;
		varying vec3 worldStart;
		varying vec3 worldEnd;

		#include <common>
		#include <color_pars_fragment>
		#include <fog_pars_fragment>
		#include <logdepthbuf_pars_fragment>
		#include <clipping_planes_pars_fragment>

		varying vec2 vUv;

		vec2 closestLineToLine(vec3 p1, vec3 p2, vec3 p3, vec3 p4) {

			float mua;
			float mub;

			vec3 p13 = p1 - p3;
			vec3 p43 = p4 - p3;

			vec3 p21 = p2 - p1;

			float d1343 = dot( p13, p43 );
			float d4321 = dot( p43, p21 );
			float d1321 = dot( p13, p21 );
			float d4343 = dot( p43, p43 );
			float d2121 = dot( p21, p21 );

			float denom = d2121 * d4343 - d4321 * d4321;

			float numer = d1343 * d4321 - d1321 * d4343;

			mua = numer / denom;
			mua = clamp( mua, 0.0, 1.0 );
			mub = ( d1343 + d4321 * ( mua ) ) / d4343;
			mub = clamp( mub, 0.0, 1.0 );

			return vec2( mua, mub );

		}

		void main() {

			#include <clipping_planes_fragment>

			#ifdef USE_DASH

				if ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps

				if ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX

			#endif

			float alpha = opacity;

			#ifdef WORLD_UNITS

				// Find the closest points on the view ray and the line segment
				vec3 rayEnd = normalize( worldPos.xyz ) * 1e5;
				vec3 lineDir = worldEnd - worldStart;
				vec2 params = closestLineToLine( worldStart, worldEnd, vec3( 0.0, 0.0, 0.0 ), rayEnd );

				vec3 p1 = worldStart + lineDir * params.x;
				vec3 p2 = rayEnd * params.y;
				vec3 delta = p1 - p2;
				float len = length( delta );
				float norm = len / linewidth;

				#ifndef USE_DASH

					#ifdef ALPHA_TO_COVERAGE

						float dnorm = fwidth( norm );
						alpha = 1.0 - smoothstep( 0.5 - dnorm, 0.5 + dnorm, norm );

					#else

						if ( norm > 0.5 ) {

							discard;

						}

					#endif

			#endif

			#else

				#ifdef ALPHA_TO_COVERAGE

					// artifacts appear on some hardware if a derivative is taken within a conditional
					float a = vUv.x;
					float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
					float len2 = a * a + b * b;
					float dlen = fwidth( len2 );

					if ( abs( vUv.y ) > 1.0 ) {

						alpha = 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );

					}

				#else

			if ( abs( vUv.y ) > 1.0 ) {

				float a = vUv.x;
				float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
				float len2 = a * a + b * b;

				if ( len2 > 1.0 ) discard;

			}

				#endif

			#endif

			vec4 diffuseColor = vec4( diffuse, alpha );

			#include <logdepthbuf_fragment>
			#include <color_fragment>

			gl_FragColor = vec4( diffuseColor.rgb, alpha );

			#include <tonemapping_fragment>
			#include <encodings_fragment>
			#include <fog_fragment>
			#include <premultiplied_alpha_fragment>

		}
		`
    };

    class LineMaterial extends THREE$1$1.ShaderMaterial {
      constructor(parameters) {
        super({
          type: 'LineMaterial',
          uniforms: THREE$1$1.UniformsUtils.clone(THREE$1$1.ShaderLib['line'].uniforms),
          vertexShader: THREE$1$1.ShaderLib['line'].vertexShader,
          fragmentShader: THREE$1$1.ShaderLib['line'].fragmentShader,
          clipping: true // required for clipping support

        });
        Object.defineProperties(this, {
          color: {
            enumerable: true,
            get: function () {
              return this.uniforms.diffuse.value;
            },
            set: function (value) {
              this.uniforms.diffuse.value = value;
            }
          },
          worldUnits: {
            enumerable: true,
            get: function () {
              return 'WORLD_UNITS' in this.defines;
            },
            set: function (value) {
              if (value === true) {
                this.defines.WORLD_UNITS = '';
              } else {
                delete this.defines.WORLD_UNITS;
              }
            }
          },
          linewidth: {
            enumerable: true,
            get: function () {
              return this.uniforms.linewidth.value;
            },
            set: function (value) {
              this.uniforms.linewidth.value = value;
            }
          },
          dashed: {
            enumerable: true,
            get: function () {
              return Boolean('USE_DASH' in this.defines);
            },

            set(value) {
              if (Boolean(value) !== Boolean('USE_DASH' in this.defines)) {
                this.needsUpdate = true;
              }

              if (value === true) {
                this.defines.USE_DASH = '';
              } else {
                delete this.defines.USE_DASH;
              }
            }

          },
          dashScale: {
            enumerable: true,
            get: function () {
              return this.uniforms.dashScale.value;
            },
            set: function (value) {
              this.uniforms.dashScale.value = value;
            }
          },
          dashSize: {
            enumerable: true,
            get: function () {
              return this.uniforms.dashSize.value;
            },
            set: function (value) {
              this.uniforms.dashSize.value = value;
            }
          },
          dashOffset: {
            enumerable: true,
            get: function () {
              return this.uniforms.dashOffset.value;
            },
            set: function (value) {
              this.uniforms.dashOffset.value = value;
            }
          },
          gapSize: {
            enumerable: true,
            get: function () {
              return this.uniforms.gapSize.value;
            },
            set: function (value) {
              this.uniforms.gapSize.value = value;
            }
          },
          opacity: {
            enumerable: true,
            get: function () {
              return this.uniforms.opacity.value;
            },
            set: function (value) {
              this.uniforms.opacity.value = value;
            }
          },
          resolution: {
            enumerable: true,
            get: function () {
              return this.uniforms.resolution.value;
            },
            set: function (value) {
              this.uniforms.resolution.value.copy(value);
            }
          },
          alphaToCoverage: {
            enumerable: true,
            get: function () {
              return Boolean('ALPHA_TO_COVERAGE' in this.defines);
            },
            set: function (value) {
              if (Boolean(value) !== Boolean('ALPHA_TO_COVERAGE' in this.defines)) {
                this.needsUpdate = true;
              }

              if (value === true) {
                this.defines.ALPHA_TO_COVERAGE = '';
                this.extensions.derivatives = true;
              } else {
                delete this.defines.ALPHA_TO_COVERAGE;
                this.extensions.derivatives = false;
              }
            }
          }
        });
        this.setValues(parameters);
      }

    }

    LineMaterial.prototype.isLineMaterial = true;

    const THREE$h = window.THREE ? window.THREE // Prefer consumption from global THREE, if exists
    : {
      Box3,
      BufferGeometry,
      InstancedInterleavedBuffer,
      InterleavedBufferAttribute,
      Line3,
      MathUtils,
      Matrix4,
      Mesh,
      Sphere,
      Vector3,
      Vector4
    };

    var setAttributeFn$2 = new THREE$h.BufferGeometry().setAttribute ? 'setAttribute' : 'addAttribute';

    const _start = new THREE$h.Vector3();

    const _end = new THREE$h.Vector3();

    const _start4 = new THREE$h.Vector4();

    const _end4 = new THREE$h.Vector4();

    const _ssOrigin = new THREE$h.Vector4();

    const _ssOrigin3 = new THREE$h.Vector3();

    const _mvMatrix = new THREE$h.Matrix4();

    const _line = new THREE$h.Line3();

    const _closestPoint = new THREE$h.Vector3();

    const _box = new THREE$h.Box3();

    const _sphere = new THREE$h.Sphere();

    const _clipToWorldVector = new THREE$h.Vector4();

    class LineSegments2 extends THREE$h.Mesh {
      constructor(geometry = new LineSegmentsGeometry(), material = new LineMaterial({
        color: Math.random() * 0xffffff
      })) {
        super(geometry, material);
        this.type = 'LineSegments2';
      } // for backwards-compatability, but could be a method of LineSegmentsGeometry...


      computeLineDistances() {
        const geometry = this.geometry;
        const instanceStart = geometry.attributes.instanceStart;
        const instanceEnd = geometry.attributes.instanceEnd;
        const lineDistances = new Float32Array(2 * instanceStart.count);

        for (let i = 0, j = 0, l = instanceStart.count; i < l; i++, j += 2) {
          _start.fromBufferAttribute(instanceStart, i);

          _end.fromBufferAttribute(instanceEnd, i);

          lineDistances[j] = j === 0 ? 0 : lineDistances[j - 1];
          lineDistances[j + 1] = lineDistances[j] + _start.distanceTo(_end);
        }

        const instanceDistanceBuffer = new THREE$h.InstancedInterleavedBuffer(lineDistances, 2, 1); // d0, d1

        geometry[setAttributeFn$2]('instanceDistanceStart', new THREE$h.InterleavedBufferAttribute(instanceDistanceBuffer, 1, 0)); // d0

        geometry[setAttributeFn$2]('instanceDistanceEnd', new THREE$h.InterleavedBufferAttribute(instanceDistanceBuffer, 1, 1)); // d1

        return this;
      }

      raycast(raycaster, intersects) {
        if (raycaster.camera === null) {
          console.error('LineSegments2: "Raycaster.camera" needs to be set in order to raycast against LineSegments2.');
        }

        const threshold = raycaster.params.Line2 !== undefined ? raycaster.params.Line2.threshold || 0 : 0;
        const ray = raycaster.ray;
        const camera = raycaster.camera;
        const projectionMatrix = camera.projectionMatrix;
        const matrixWorld = this.matrixWorld;
        const geometry = this.geometry;
        const material = this.material;
        const resolution = material.resolution;
        const lineWidth = material.linewidth + threshold;
        const instanceStart = geometry.attributes.instanceStart;
        const instanceEnd = geometry.attributes.instanceEnd; // camera forward is negative

        const near = -camera.near; // clip space is [ - 1, 1 ] so multiply by two to get the full
        // width in clip space

        const ssMaxWidth = 2.0 * Math.max(lineWidth / resolution.width, lineWidth / resolution.height); //
        // check if we intersect the sphere bounds

        if (geometry.boundingSphere === null) {
          geometry.computeBoundingSphere();
        }

        _sphere.copy(geometry.boundingSphere).applyMatrix4(matrixWorld);

        const distanceToSphere = Math.max(camera.near, _sphere.distanceToPoint(ray.origin)); // get the w component to scale the world space line width

        _clipToWorldVector.set(0, 0, -distanceToSphere, 1.0).applyMatrix4(camera.projectionMatrix);

        _clipToWorldVector.multiplyScalar(1.0 / _clipToWorldVector.w);

        _clipToWorldVector.applyMatrix4(camera.projectionMatrixInverse); // increase the sphere bounds by the worst case line screen space width


        const sphereMargin = Math.abs(ssMaxWidth / _clipToWorldVector.w) * 0.5;
        _sphere.radius += sphereMargin;

        if (raycaster.ray.intersectsSphere(_sphere) === false) {
          return;
        } //
        // check if we intersect the box bounds


        if (geometry.boundingBox === null) {
          geometry.computeBoundingBox();
        }

        _box.copy(geometry.boundingBox).applyMatrix4(matrixWorld);

        const distanceToBox = Math.max(camera.near, _box.distanceToPoint(ray.origin)); // get the w component to scale the world space line width

        _clipToWorldVector.set(0, 0, -distanceToBox, 1.0).applyMatrix4(camera.projectionMatrix);

        _clipToWorldVector.multiplyScalar(1.0 / _clipToWorldVector.w);

        _clipToWorldVector.applyMatrix4(camera.projectionMatrixInverse); // increase the sphere bounds by the worst case line screen space width


        const boxMargin = Math.abs(ssMaxWidth / _clipToWorldVector.w) * 0.5;
        _box.max.x += boxMargin;
        _box.max.y += boxMargin;
        _box.max.z += boxMargin;
        _box.min.x -= boxMargin;
        _box.min.y -= boxMargin;
        _box.min.z -= boxMargin;

        if (raycaster.ray.intersectsBox(_box) === false) {
          return;
        } //
        // pick a point 1 unit out along the ray to avoid the ray origin
        // sitting at the camera origin which will cause "w" to be 0 when
        // applying the projection matrix.


        ray.at(1, _ssOrigin); // ndc space [ - 1.0, 1.0 ]

        _ssOrigin.w = 1;

        _ssOrigin.applyMatrix4(camera.matrixWorldInverse);

        _ssOrigin.applyMatrix4(projectionMatrix);

        _ssOrigin.multiplyScalar(1 / _ssOrigin.w); // screen space


        _ssOrigin.x *= resolution.x / 2;
        _ssOrigin.y *= resolution.y / 2;
        _ssOrigin.z = 0;

        _ssOrigin3.copy(_ssOrigin);

        _mvMatrix.multiplyMatrices(camera.matrixWorldInverse, matrixWorld);

        for (let i = 0, l = instanceStart.count; i < l; i++) {
          _start4.fromBufferAttribute(instanceStart, i);

          _end4.fromBufferAttribute(instanceEnd, i);

          _start4.w = 1;
          _end4.w = 1; // camera space

          _start4.applyMatrix4(_mvMatrix);

          _end4.applyMatrix4(_mvMatrix); // skip the segment if it's entirely behind the camera


          var isBehindCameraNear = _start4.z > near && _end4.z > near;

          if (isBehindCameraNear) {
            continue;
          } // trim the segment if it extends behind camera near


          if (_start4.z > near) {
            const deltaDist = _start4.z - _end4.z;
            const t = (_start4.z - near) / deltaDist;

            _start4.lerp(_end4, t);
          } else if (_end4.z > near) {
            const deltaDist = _end4.z - _start4.z;
            const t = (_end4.z - near) / deltaDist;

            _end4.lerp(_start4, t);
          } // clip space


          _start4.applyMatrix4(projectionMatrix);

          _end4.applyMatrix4(projectionMatrix); // ndc space [ - 1.0, 1.0 ]


          _start4.multiplyScalar(1 / _start4.w);

          _end4.multiplyScalar(1 / _end4.w); // screen space


          _start4.x *= resolution.x / 2;
          _start4.y *= resolution.y / 2;
          _end4.x *= resolution.x / 2;
          _end4.y *= resolution.y / 2; // create 2d segment

          _line.start.copy(_start4);

          _line.start.z = 0;

          _line.end.copy(_end4);

          _line.end.z = 0; // get closest point on ray to segment

          const param = _line.closestPointToPointParameter(_ssOrigin3, true);

          _line.at(param, _closestPoint); // check if the intersection point is within clip space


          const zPos = THREE$h.MathUtils.lerp(_start4.z, _end4.z, param);
          const isInClipSpace = zPos >= -1 && zPos <= 1;
          const isInside = _ssOrigin3.distanceTo(_closestPoint) < lineWidth * 0.5;

          if (isInClipSpace && isInside) {
            _line.start.fromBufferAttribute(instanceStart, i);

            _line.end.fromBufferAttribute(instanceEnd, i);

            _line.start.applyMatrix4(matrixWorld);

            _line.end.applyMatrix4(matrixWorld);

            const pointOnLine = new THREE$h.Vector3();
            const point = new THREE$h.Vector3();
            ray.distanceSqToSegment(_line.start, _line.end, point, pointOnLine);
            intersects.push({
              point: point,
              pointOnLine: pointOnLine,
              distance: ray.origin.distanceTo(point),
              object: this,
              face: null,
              faceIndex: i,
              uv: null,
              uv2: null
            });
          }
        }
      }

    }

    LineSegments2.prototype.LineSegments2 = true;

    class LineGeometry extends LineSegmentsGeometry {
      constructor() {
        super();
        this.type = 'LineGeometry';
      }

      setPositions(array) {
        // converts [ x1, y1, z1,  x2, y2, z2, ... ] to pairs format
        var length = array.length - 3;
        var points = new Float32Array(2 * length);

        for (var i = 0; i < length; i += 3) {
          points[2 * i] = array[i];
          points[2 * i + 1] = array[i + 1];
          points[2 * i + 2] = array[i + 2];
          points[2 * i + 3] = array[i + 3];
          points[2 * i + 4] = array[i + 4];
          points[2 * i + 5] = array[i + 5];
        }

        super.setPositions(points);
        return this;
      }

      setColors(array) {
        // converts [ r1, g1, b1,  r2, g2, b2, ... ] to pairs format
        var length = array.length - 3;
        var colors = new Float32Array(2 * length);

        for (var i = 0; i < length; i += 3) {
          colors[2 * i] = array[i];
          colors[2 * i + 1] = array[i + 1];
          colors[2 * i + 2] = array[i + 2];
          colors[2 * i + 3] = array[i + 3];
          colors[2 * i + 4] = array[i + 4];
          colors[2 * i + 5] = array[i + 5];
        }

        super.setColors(colors);
        return this;
      }

      fromLine(line) {
        var geometry = line.geometry;

        if (geometry.isGeometry) {
          console.error('THREE.LineGeometry no longer supports Geometry. Use THREE.BufferGeometry instead.');
          return;
        } else if (geometry.isBufferGeometry) {
          this.setPositions(geometry.attributes.position.array); // assumes non-indexed
        } // set colors, maybe


        return this;
      }

    }

    LineGeometry.prototype.isLineGeometry = true;

    class Line2 extends LineSegments2 {
      constructor(geometry = new LineGeometry(), material = new LineMaterial({
        color: Math.random() * 0xffffff
      })) {
        super(geometry, material);
        this.type = 'Line2';
      }

    }

    Line2.prototype.isLine2 = true;

    /**
     * Text = 3D Text
     *
     * parameters = {
     *  font: <THREE.Font>, // font
     *
     *  size: <float>, // size of the text
     *  height: <float>, // thickness to extrude text
     *  curveSegments: <int>, // number of points on the curves
     *
     *  bevelEnabled: <bool>, // turn on bevel
     *  bevelThickness: <float>, // how deep into text bevel goes
     *  bevelSize: <float>, // how far from text outline (including bevelOffset) is bevel
     *  bevelOffset: <float> // how far from text outline does bevel start
     * }
     */

    class TextGeometry extends ExtrudeGeometry {

    	constructor( text, parameters = {} ) {

    		const font = parameters.font;

    		if ( font === undefined ) {

    			super(); // generate default extrude geometry

    		} else {

    			const shapes = font.generateShapes( text, parameters.size );

    			// translate parameters to ExtrudeGeometry API

    			parameters.depth = parameters.height !== undefined ? parameters.height : 50;

    			// defaults

    			if ( parameters.bevelThickness === undefined ) parameters.bevelThickness = 10;
    			if ( parameters.bevelSize === undefined ) parameters.bevelSize = 8;
    			if ( parameters.bevelEnabled === undefined ) parameters.bevelEnabled = false;

    			super( shapes, parameters );

    		}

    		this.type = 'TextGeometry';

    	}

    }

    //

    class Font {

    	constructor( data ) {

    		this.isFont = true;

    		this.type = 'Font';

    		this.data = data;

    	}

    	generateShapes( text, size = 100 ) {

    		const shapes = [];
    		const paths = createPaths( text, size, this.data );

    		for ( let p = 0, pl = paths.length; p < pl; p ++ ) {

    			shapes.push( ...paths[ p ].toShapes() );

    		}

    		return shapes;

    	}

    }

    function createPaths( text, size, data ) {

    	const chars = Array.from( text );
    	const scale = size / data.resolution;
    	const line_height = ( data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness ) * scale;

    	const paths = [];

    	let offsetX = 0, offsetY = 0;

    	for ( let i = 0; i < chars.length; i ++ ) {

    		const char = chars[ i ];

    		if ( char === '\n' ) {

    			offsetX = 0;
    			offsetY -= line_height;

    		} else {

    			const ret = createPath( char, scale, offsetX, offsetY, data );
    			offsetX += ret.offsetX;
    			paths.push( ret.path );

    		}

    	}

    	return paths;

    }

    function createPath( char, scale, offsetX, offsetY, data ) {

    	const glyph = data.glyphs[ char ] || data.glyphs[ '?' ];

    	if ( ! glyph ) {

    		console.error( 'THREE.Font: character "' + char + '" does not exists in font family ' + data.familyName + '.' );

    		return;

    	}

    	const path = new ShapePath();

    	let x, y, cpx, cpy, cpx1, cpy1, cpx2, cpy2;

    	if ( glyph.o ) {

    		const outline = glyph._cachedOutline || ( glyph._cachedOutline = glyph.o.split( ' ' ) );

    		for ( let i = 0, l = outline.length; i < l; ) {

    			const action = outline[ i ++ ];

    			switch ( action ) {

    				case 'm': // moveTo

    					x = outline[ i ++ ] * scale + offsetX;
    					y = outline[ i ++ ] * scale + offsetY;

    					path.moveTo( x, y );

    					break;

    				case 'l': // lineTo

    					x = outline[ i ++ ] * scale + offsetX;
    					y = outline[ i ++ ] * scale + offsetY;

    					path.lineTo( x, y );

    					break;

    				case 'q': // quadraticCurveTo

    					cpx = outline[ i ++ ] * scale + offsetX;
    					cpy = outline[ i ++ ] * scale + offsetY;
    					cpx1 = outline[ i ++ ] * scale + offsetX;
    					cpy1 = outline[ i ++ ] * scale + offsetY;

    					path.quadraticCurveTo( cpx1, cpy1, cpx, cpy );

    					break;

    				case 'b': // bezierCurveTo

    					cpx = outline[ i ++ ] * scale + offsetX;
    					cpy = outline[ i ++ ] * scale + offsetY;
    					cpx1 = outline[ i ++ ] * scale + offsetX;
    					cpy1 = outline[ i ++ ] * scale + offsetY;
    					cpx2 = outline[ i ++ ] * scale + offsetX;
    					cpy2 = outline[ i ++ ] * scale + offsetY;

    					path.bezierCurveTo( cpx1, cpy1, cpx2, cpy2, cpx, cpy );

    					break;

    			}

    		}

    	}

    	return { offsetX: glyph.ha * scale, path: path };

    }

    function ownKeys$2(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function (sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread2$1(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys$2(Object(source), !0).forEach(function (key) {
          _defineProperty$2(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$2(Object(source)).forEach(function (key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties$1(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass$1(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties$1(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties$1(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", {
        writable: false
      });
      return Constructor;
    }
    function _defineProperty$2(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      Object.defineProperty(subClass, "prototype", {
        writable: false
      });
      if (superClass) _setPrototypeOf$1(subClass, superClass);
    }
    function _getPrototypeOf$1(o) {
      _getPrototypeOf$1 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
      };
      return _getPrototypeOf$1(o);
    }
    function _setPrototypeOf$1(o, p) {
      _setPrototypeOf$1 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };
      return _setPrototypeOf$1(o, p);
    }
    function _isNativeReflectConstruct$1() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _construct$1(Parent, args, Class) {
      if (_isNativeReflectConstruct$1()) {
        _construct$1 = Reflect.construct.bind();
      } else {
        _construct$1 = function _construct(Parent, args, Class) {
          var a = [null];
          a.push.apply(a, args);
          var Constructor = Function.bind.apply(Parent, a);
          var instance = new Constructor();
          if (Class) _setPrototypeOf$1(instance, Class.prototype);
          return instance;
        };
      }
      return _construct$1.apply(null, arguments);
    }
    function _objectWithoutPropertiesLoose$1(source, excluded) {
      if (source == null) return {};
      var target = {};
      var sourceKeys = Object.keys(source);
      var key, i;
      for (i = 0; i < sourceKeys.length; i++) {
        key = sourceKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        target[key] = source[key];
      }
      return target;
    }
    function _objectWithoutProperties$1(source, excluded) {
      if (source == null) return {};
      var target = _objectWithoutPropertiesLoose$1(source, excluded);
      var key, i;
      if (Object.getOwnPropertySymbols) {
        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
        for (i = 0; i < sourceSymbolKeys.length; i++) {
          key = sourceSymbolKeys[i];
          if (excluded.indexOf(key) >= 0) continue;
          if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
          target[key] = source[key];
        }
      }
      return target;
    }
    function _assertThisInitialized$1(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (typeof call === "object" || typeof call === "function")) {
        return call;
      } else if (call !== void 0) {
        throw new TypeError("Derived constructors may only return object or undefined");
      }
      return _assertThisInitialized$1(self);
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct$1();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf$1(Derived),
          result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf$1(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    function _slicedToArray$1(arr, i) {
      return _arrayWithHoles$1(arr) || _iterableToArrayLimit$1(arr, i) || _unsupportedIterableToArray$2(arr, i) || _nonIterableRest$1();
    }
    function _toConsumableArray$2(arr) {
      return _arrayWithoutHoles$2(arr) || _iterableToArray$2(arr) || _unsupportedIterableToArray$2(arr) || _nonIterableSpread$2();
    }
    function _arrayWithoutHoles$2(arr) {
      if (Array.isArray(arr)) return _arrayLikeToArray$2(arr);
    }
    function _arrayWithHoles$1(arr) {
      if (Array.isArray(arr)) return arr;
    }
    function _iterableToArray$2(iter) {
      if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
    }
    function _iterableToArrayLimit$1(arr, i) {
      var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
      if (_i == null) return;
      var _arr = [];
      var _n = true;
      var _d = false;
      var _s, _e;
      try {
        for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);
          if (i && _arr.length === i) break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"] != null) _i["return"]();
        } finally {
          if (_d) throw _e;
        }
      }
      return _arr;
    }
    function _unsupportedIterableToArray$2(o, minLen) {
      if (!o) return;
      if (typeof o === "string") return _arrayLikeToArray$2(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor) n = o.constructor.name;
      if (n === "Map" || n === "Set") return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$2(o, minLen);
    }
    function _arrayLikeToArray$2(arr, len) {
      if (len == null || len > arr.length) len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
      return arr2;
    }
    function _nonIterableSpread$2() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _nonIterableRest$1() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }

    var materialDispose = function materialDispose(material) {
      if (material instanceof Array) {
        material.forEach(materialDispose);
      } else {
        if (material.map) {
          material.map.dispose();
        }
        material.dispose();
      }
    };
    var deallocate = function deallocate(obj) {
      if (obj.geometry) {
        obj.geometry.dispose();
      }
      if (obj.material) {
        materialDispose(obj.material);
      }
      if (obj.texture) {
        obj.texture.dispose();
      }
      if (obj.children) {
        obj.children.forEach(deallocate);
      }
    };
    var emptyObject = function emptyObject(obj) {
      if (obj && obj.children) while (obj.children.length) {
        var childObj = obj.children[0];
        obj.remove(childObj);
        deallocate(childObj);
      }
    };

    function linkKapsule$1 (kapsulePropName, kapsuleType) {
      var dummyK = new kapsuleType(); // To extract defaults

      return {
        linkProp: function linkProp(prop) {
          // link property config
          return {
            "default": dummyK[prop](),
            onChange: function onChange(v, state) {
              state[kapsulePropName][prop](v);
            },
            triggerUpdate: false
          };
        },
        linkMethod: function linkMethod(method) {
          // link method pass-through
          return function (state) {
            var kapsuleInstance = state[kapsulePropName];
            for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
              args[_key - 1] = arguments[_key];
            }
            var returnVal = kapsuleInstance[method].apply(kapsuleInstance, args);
            return returnVal === kapsuleInstance ? this // chain based on the parent object, not the inner kapsule
            : returnVal;
          };
        }
      };
    }

    var GLOBE_RADIUS = 100;

    function getGlobeRadius() {
      return GLOBE_RADIUS;
    }
    function polar2Cartesian(lat, lng) {
      var relAltitude = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var phi = (90 - lat) * Math.PI / 180;
      var theta = (90 - lng) * Math.PI / 180;
      var r = GLOBE_RADIUS * (1 + relAltitude);
      return {
        x: r * Math.sin(phi) * Math.cos(theta),
        y: r * Math.cos(phi),
        z: r * Math.sin(phi) * Math.sin(theta)
      };
    }
    function cartesian2Polar(_ref) {
      var x = _ref.x,
        y = _ref.y,
        z = _ref.z;
      var r = Math.sqrt(x * x + y * y + z * z);
      var phi = Math.acos(y / r);
      var theta = Math.atan2(z, x);
      return {
        lat: 90 - phi * 180 / Math.PI,
        lng: 90 - theta * 180 / Math.PI - (theta < -Math.PI / 2 ? 360 : 0),
        // keep within [-180, 180] boundaries
        altitude: r / GLOBE_RADIUS - 1
      };
    }

    var THREE$f = window.THREE ? window.THREE // Prefer consumption from global THREE, if exists
    : {
      BackSide: BackSide,
      BufferAttribute: BufferAttribute,
      Color: Color$1,
      Mesh: Mesh,
      ShaderMaterial: ShaderMaterial
    };
    var fragmentShader = "\nuniform vec3 color;\nuniform float coefficient;\nuniform float power;\nvarying vec3 vVertexNormal;\nvarying vec3 vVertexWorldPosition;\nvoid main() {\n  vec3 worldCameraToVertex = vVertexWorldPosition - cameraPosition;\n  vec3 viewCameraToVertex\t= (viewMatrix * vec4(worldCameraToVertex, 0.0)).xyz;\n  viewCameraToVertex = normalize(viewCameraToVertex);\n  float intensity\t= pow(\n    coefficient + dot(vVertexNormal, viewCameraToVertex),\n    power\n  );\n  gl_FragColor = vec4(color, intensity);\n}";
    var vertexShader = "\nvarying vec3 vVertexWorldPosition;\nvarying vec3 vVertexNormal;\nvoid main() {\n  vVertexNormal\t= normalize(normalMatrix * normal);\n  vVertexWorldPosition = (modelMatrix * vec4(position, 1.0)).xyz;\n  gl_Position\t= projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n";
    var defaultOptions = {
      backside: true,
      coefficient: 0.5,
      color: 'gold',
      size: 2,
      power: 1
    };

    // Based off: http://stemkoski.blogspot.fr/2013/07/shaders-in-threejs-glow-and-halo.html
    function createGlowMaterial(coefficient, color, power) {
      return new THREE$f.ShaderMaterial({
        depthWrite: false,
        fragmentShader: fragmentShader,
        transparent: true,
        uniforms: {
          coefficient: {
            value: coefficient
          },
          color: {
            value: new THREE$f.Color(color)
          },
          power: {
            value: power
          }
        },
        vertexShader: vertexShader
      });
    }
    function createGlowGeometry(geometry, size) {
      // expect BufferGeometry
      var glowGeometry = geometry.clone();

      // Resize vertex positions according to normals
      var position = new Float32Array(geometry.attributes.position.count * 3);
      for (var idx = 0, len = position.length; idx < len; idx++) {
        var normal = geometry.attributes.normal.array[idx];
        var curPos = geometry.attributes.position.array[idx];
        position[idx] = curPos + normal * size;
      }
      glowGeometry.setAttribute('position', new THREE$f.BufferAttribute(position, 3));
      return glowGeometry;
    }
    function createGlowMesh(geometry) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultOptions;
      var backside = options.backside,
        coefficient = options.coefficient,
        color = options.color,
        size = options.size,
        power = options.power;
      var glowGeometry = createGlowGeometry(geometry, size);
      var glowMaterial = createGlowMaterial(coefficient, color, power);
      if (backside) {
        glowMaterial.side = THREE$f.BackSide;
      }
      return new THREE$f.Mesh(glowGeometry, glowMaterial);
    }

    var THREE$e = window.THREE ? window.THREE // Prefer consumption from global THREE, if exists
    : {
      Color: Color$1,
      LineBasicMaterial: LineBasicMaterial,
      LineSegments: LineSegments,
      Mesh: Mesh,
      MeshPhongMaterial: MeshPhongMaterial,
      SphereGeometry: SphereGeometry,
      TextureLoader: TextureLoader
    };

    //

    var GlobeLayerKapsule = index$2({
      props: {
        globeImageUrl: {},
        bumpImageUrl: {},
        showGlobe: {
          "default": true,
          onChange: function onChange(showGlobe, state) {
            state.globeObj.visible = !!showGlobe;
          },
          triggerUpdate: false
        },
        showGraticules: {
          "default": false,
          onChange: function onChange(showGraticules, state) {
            state.graticulesObj.visible = !!showGraticules;
          },
          triggerUpdate: false
        },
        showAtmosphere: {
          "default": true,
          onChange: function onChange(showAtmosphere, state) {
            state.atmosphereObj && (state.atmosphereObj.visible = !!showAtmosphere);
          },
          triggerUpdate: false
        },
        atmosphereColor: {
          "default": 'lightskyblue'
        },
        atmosphereAltitude: {
          "default": 0.15
        },
        onReady: {
          "default": function _default() {},
          triggerUpdate: false
        }
      },
      methods: {
        globeMaterial: function globeMaterial(state, _globeMaterial) {
          if (_globeMaterial !== undefined) {
            state.globeObj.material = _globeMaterial || state.defaultGlobeMaterial;
            return this;
          }
          return state.globeObj.material;
        }
      },
      stateInit: function stateInit() {
        // create globe
        var globeGeometry = new THREE$e.SphereGeometry(GLOBE_RADIUS, 75, 75);
        var defaultGlobeMaterial = new THREE$e.MeshPhongMaterial({
          color: 0x000000,
          transparent: true
        });
        var globeObj = new THREE$e.Mesh(globeGeometry, defaultGlobeMaterial);
        globeObj.rotation.y = -Math.PI / 2; // face prime meridian along Z axis
        globeObj.__globeObjType = 'globe'; // Add object type

        // create graticules
        var graticulesObj = new THREE$e.LineSegments(new GeoJsonGeometry(graticule10(), GLOBE_RADIUS, 2), new THREE$e.LineBasicMaterial({
          color: 'lightgrey',
          transparent: true,
          opacity: 0.1
        }));
        return {
          globeObj: globeObj,
          graticulesObj: graticulesObj,
          defaultGlobeMaterial: defaultGlobeMaterial
        };
      },
      init: function init(threeObj, state) {
        // Clear the scene
        emptyObject(threeObj);

        // Main three object to manipulate
        state.scene = threeObj;
        state.scene.add(state.globeObj); // add globe
        state.scene.add(state.graticulesObj); // add graticules

        state.ready = false;
      },
      update: function update(state, changedProps) {
        var globeMaterial = state.globeObj.material;
        if (changedProps.hasOwnProperty('globeImageUrl')) {
          if (!state.globeImageUrl) {
            // Black globe if no image
            !globeMaterial.color && (globeMaterial.color = new THREE$e.Color(0x000000));
          } else {
            new THREE$e.TextureLoader().load(state.globeImageUrl, function (texture) {
              globeMaterial.map = texture;
              globeMaterial.color = null;
              globeMaterial.needsUpdate = true;

              // ready when first globe image finishes loading (asynchronously to allow 1 frame to load texture)
              !state.ready && (state.ready = true) && setTimeout(state.onReady);
            });
          }
        }
        if (changedProps.hasOwnProperty('bumpImageUrl')) {
          if (!state.bumpImageUrl) {
            globeMaterial.bumpMap = null;
            globeMaterial.needsUpdate = true;
          } else {
            state.bumpImageUrl && new THREE$e.TextureLoader().load(state.bumpImageUrl, function (texture) {
              globeMaterial.bumpMap = texture;
              globeMaterial.needsUpdate = true;
            });
          }
        }
        if (changedProps.hasOwnProperty('atmosphereColor') || changedProps.hasOwnProperty('atmosphereAltitude')) {
          if (state.atmosphereObj) {
            // recycle previous atmosphere object
            state.scene.remove(state.atmosphereObj);
            emptyObject(state.atmosphereObj);
          }
          if (state.atmosphereColor && state.atmosphereAltitude) {
            var obj = state.atmosphereObj = createGlowMesh(state.globeObj.geometry, {
              backside: true,
              color: state.atmosphereColor,
              size: GLOBE_RADIUS * state.atmosphereAltitude,
              power: 3.5,
              // dispersion
              coefficient: 0.1
            });
            obj.visible = !!state.showAtmosphere;
            obj.__globeObjType = 'atmosphere'; // Add object type
            state.scene.add(obj);
          }
        }
        if (!state.ready && !state.globeImageUrl) {
          // ready immediately if there's no globe image
          state.ready = true;
          state.onReady();
        }
      }
    });

    var colorStr2Hex = function colorStr2Hex(str) {
      return isNaN(str) ? parseInt(tinycolor(str).toHex(), 16) : str;
    };
    var colorAlpha = function colorAlpha(str) {
      return isNaN(str) ? tinycolor(str).getAlpha() : 1;
    };
    var color2ShaderArr = function color2ShaderArr(str) {
      var includeAlpha = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      var rgba = tinycolor(str).toRgb();
      var rgbArr = ['r', 'g', 'b'].map(function (d) {
        return rgba[d] / 255;
      });
      return includeAlpha ? [].concat(_toConsumableArray$2(rgbArr), [rgba.a]) : rgbArr;
    };
    function setMaterialOpacity(material, opacity, depthWrite) {
      material.opacity = opacity;
      material.transparent = opacity < 1;
      material.depthWrite = depthWrite === undefined ? opacity >= 1 : depthWrite; // depthWrite=false recommended for transparent materials, to prevent transparency issues https://discourse.threejs.org/t/threejs-and-the-transparent-problem/11553/31

      return material;
    }

    function threeDigest(data, scene) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var _ref = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {},
        _ref$removeDelay = _ref.removeDelay,
        removeDelay = _ref$removeDelay === void 0 ? 0 : _ref$removeDelay;
      return viewDigest(data, scene.children, function (obj) {
        return scene.add(obj);
      }, function (obj) {
        var removeFn = function removeFn() {
          scene.remove(obj);
          emptyObject(obj);
          obj && obj.hasOwnProperty('__data') && delete obj.__data.__currentTargetD;
        };
        removeDelay ? setTimeout(removeFn, removeDelay) : removeFn();
      }, _objectSpread2$1({
        objBindAttr: '__threeObj'
      }, options));
    }

    var THREE$d = window.THREE ? window.THREE // Prefer consumption from global THREE, if exists
    : {
      BufferAttribute: BufferAttribute,
      BufferGeometry: BufferGeometry,
      Color: Color$1,
      CylinderGeometry: CylinderGeometry,
      Matrix4: Matrix4,
      Mesh: Mesh,
      MeshBasicMaterial: MeshBasicMaterial,
      MeshLambertMaterial: MeshLambertMaterial,
      Object3D: Object3D,
      Vector3: Vector3
    };
    var bfg$2 = Object.assign({}, _bfg);
    var BufferGeometryUtils$2 = bfg$2.BufferGeometryUtils || bfg$2;

    //

    // support multiple method names for backwards threejs compatibility
    var applyMatrix4Fn$1 = new THREE$d.BufferGeometry().applyMatrix4 ? 'applyMatrix4' : 'applyMatrix';
    var PointsLayerKapsule = index$2({
      props: {
        pointsData: {
          "default": []
        },
        pointLat: {
          "default": 'lat'
        },
        pointLng: {
          "default": 'lng'
        },
        pointColor: {
          "default": function _default() {
            return '#ffffaa';
          }
        },
        pointAltitude: {
          "default": 0.1
        },
        // in units of globe radius
        pointRadius: {
          "default": 0.25
        },
        // in deg
        pointResolution: {
          "default": 12,
          triggerUpdate: false
        },
        // how many slice segments in the cylinder's circumference
        pointsMerge: {
          "default": false
        },
        // boolean. Whether to merge all points into a single mesh for rendering performance
        pointsTransitionDuration: {
          "default": 1000,
          triggerUpdate: false
        } // ms
      },
      init: function init(threeObj, state) {
        // Clear the scene
        emptyObject(threeObj);

        // Main three object to manipulate
        state.scene = threeObj;
      },
      update: function update(state) {
        // Data accessors
        var latAccessor = index$1(state.pointLat);
        var lngAccessor = index$1(state.pointLng);
        var altitudeAccessor = index$1(state.pointAltitude);
        var radiusAccessor = index$1(state.pointRadius);
        var colorAccessor = index$1(state.pointColor);

        // shared geometry
        var pointGeometry = new THREE$d.CylinderGeometry(1, 1, 1, state.pointResolution);
        pointGeometry[applyMatrix4Fn$1](new THREE$d.Matrix4().makeRotationX(Math.PI / 2));
        pointGeometry[applyMatrix4Fn$1](new THREE$d.Matrix4().makeTranslation(0, 0, -0.5));
        var pxPerDeg = 2 * Math.PI * GLOBE_RADIUS / 360;
        var pointMaterials = {}; // indexed by color

        var scene = state.pointsMerge ? new THREE$d.Object3D() : state.scene; // use fake scene if merging points

        threeDigest(state.pointsData, scene, {
          createObj: createObj,
          updateObj: updateObj
        });
        if (state.pointsMerge) {
          // merge points into a single mesh
          var pointsGeometry = !state.pointsData.length ? new THREE$d.BufferGeometry() : BufferGeometryUtils$2.mergeBufferGeometries(state.pointsData.map(function (d) {
            var obj = d.__threeObj;
            d.__threeObj = undefined; // unbind merged points

            var geom = obj.geometry.clone();

            // apply mesh world transform to vertices
            obj.updateMatrix();
            geom[applyMatrix4Fn$1](obj.matrix);

            // color vertices
            var color = new THREE$d.Color(colorAccessor(d));
            var nVertices = geom.attributes.position.count;
            var colors = new Float32Array(nVertices * 3);
            for (var i = 0, len = nVertices; i < len; i++) {
              var idx = i * 3;
              colors[idx] = color.r;
              colors[idx + 1] = color.g;
              colors[idx + 2] = color.b;
            }
            geom.setAttribute('color', new THREE$d.BufferAttribute(colors, 3));
            return geom;
          }));
          var points = new THREE$d.Mesh(pointsGeometry, new THREE$d.MeshBasicMaterial({
            color: 0xffffff,
            vertexColors: true
          }));
          points.__globeObjType = 'points'; // Add object type
          points.__data = state.pointsData; // Attach obj data

          emptyObject(state.scene);
          state.scene.add(points);
        }

        //

        function createObj() {
          var obj = new THREE$d.Mesh(pointGeometry);
          obj.__globeObjType = 'point'; // Add object type
          return obj;
        }
        function updateObj(obj, d) {
          var applyUpdate = function applyUpdate(td) {
            var _obj$__currentTargetD = obj.__currentTargetD = td,
              r = _obj$__currentTargetD.r,
              alt = _obj$__currentTargetD.alt,
              lat = _obj$__currentTargetD.lat,
              lng = _obj$__currentTargetD.lng;

            // position cylinder ground
            Object.assign(obj.position, polar2Cartesian(lat, lng));

            // orientate outwards
            var globeCenter = state.pointsMerge ? new THREE$d.Vector3(0, 0, 0) : state.scene.localToWorld(new THREE$d.Vector3(0, 0, 0)); // translate from local to world coords
            obj.lookAt(globeCenter);

            // scale radius and altitude
            obj.scale.x = obj.scale.y = Math.min(30, r) * pxPerDeg;
            obj.scale.z = Math.max(alt * GLOBE_RADIUS, 0.1); // avoid non-invertible matrix
          };

          var targetD = {
            alt: +altitudeAccessor(d),
            r: +radiusAccessor(d),
            lat: +latAccessor(d),
            lng: +lngAccessor(d)
          };
          var currentTargetD = obj.__currentTargetD || Object.assign({}, targetD, {
            alt: -1e-3
          });
          if (Object.keys(targetD).some(function (k) {
            return currentTargetD[k] !== targetD[k];
          })) {
            if (state.pointsMerge || !state.pointsTransitionDuration || state.pointsTransitionDuration < 0) {
              // set final position
              applyUpdate(targetD);
            } else {
              // animate
              new exports$1.Tween(currentTargetD).to(targetD, state.pointsTransitionDuration).easing(exports$1.Easing.Quadratic.InOut).onUpdate(applyUpdate).start();
            }
          }
          if (!state.pointsMerge) {
            // Update materials on individual points
            var color = colorAccessor(d);
            var opacity = color ? colorAlpha(color) : 0;
            var showCyl = !!opacity;
            obj.visible = showCyl;
            if (showCyl) {
              if (!pointMaterials.hasOwnProperty(color)) {
                pointMaterials[color] = new THREE$d.MeshLambertMaterial({
                  color: colorStr2Hex(color),
                  transparent: opacity < 1,
                  opacity: opacity
                });
              }
              obj.material = pointMaterials[color];
            }
          }
        }
      }
    });

    var _excluded$1 = ["stroke"];
    var THREE$c = window.THREE ? window.THREE // Prefer consumption from global THREE, if exists
    : {
      BufferGeometry: BufferGeometry,
      CubicBezierCurve3: CubicBezierCurve3,
      Curve: Curve,
      Float32BufferAttribute: Float32BufferAttribute,
      Group: Group$1,
      Line: Line,
      Mesh: Mesh,
      NormalBlending: NormalBlending,
      QuadraticBezierCurve3: QuadraticBezierCurve3,
      ShaderMaterial: ShaderMaterial,
      TubeGeometry: TubeGeometry,
      Vector3: Vector3
    };
    var FrameTicker$2 = _FrameTicker["default"] || _FrameTicker;

    //

    // support both modes for backwards threejs compatibility
    var setAttributeFn$1 = new THREE$c.BufferGeometry().setAttribute ? 'setAttribute' : 'addAttribute';
    var gradientShaders$1 = {
      uniforms: {
        // dash param defaults, all relative to full length
        dashOffset: {
          value: 0
        },
        dashSize: {
          value: 1
        },
        gapSize: {
          value: 0
        },
        dashTranslate: {
          value: 0
        } // used for animating the dash
      },

      vertexShader: "\n    uniform float dashTranslate; \n\n    attribute vec4 vertexColor;\n    varying vec4 vColor;\n    \n    attribute float vertexRelDistance;\n    varying float vRelDistance;\n\n    void main() {\n      // pass through colors and distances\n      vColor = vertexColor;\n      vRelDistance = vertexRelDistance + dashTranslate;\n      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n    }\n  ",
      fragmentShader: "\n    uniform float dashOffset; \n    uniform float dashSize;\n    uniform float gapSize; \n    \n    varying vec4 vColor;\n    varying float vRelDistance;\n    \n    void main() {\n      // ignore pixels in the gap\n      if (vRelDistance < dashOffset) discard;\n      if (mod(vRelDistance - dashOffset, dashSize + gapSize) > dashSize) discard;\n    \n      // set px color: [r, g, b, a], interpolated between vertices \n      gl_FragColor = vColor; \n    }\n  "
    };
    var ArcsLayerKapsule = index$2({
      props: {
        arcsData: {
          "default": []
        },
        arcStartLat: {
          "default": 'startLat'
        },
        arcStartLng: {
          "default": 'startLng'
        },
        arcEndLat: {
          "default": 'endLat'
        },
        arcEndLng: {
          "default": 'endLng'
        },
        arcColor: {
          "default": function _default() {
            return '#ffffaa';
          }
        },
        // single color, array of colors or color interpolation fn
        arcAltitude: {},
        // in units of globe radius
        arcAltitudeAutoScale: {
          "default": 0.5
        },
        // scale altitude proportional to great-arc distance between the two points
        arcStroke: {},
        // in deg
        arcCurveResolution: {
          "default": 64,
          triggerUpdate: false
        },
        // how many straight segments in the curve
        arcCircularResolution: {
          "default": 6,
          triggerUpdate: false
        },
        // how many slice segments in the tube's circumference
        arcDashLength: {
          "default": 1
        },
        // in units of line length
        arcDashGap: {
          "default": 0
        },
        arcDashInitialGap: {
          "default": 0
        },
        arcDashAnimateTime: {
          "default": 0
        },
        // ms
        arcsTransitionDuration: {
          "default": 1000,
          triggerUpdate: false
        } // ms
      },
      init: function init(threeObj, state) {
        // Clear the scene
        emptyObject(threeObj);

        // Main three object to manipulate
        state.scene = threeObj;

        // Kick-off dash animations
        new FrameTicker$2().onTick.add(function (_, timeDelta) {
          state.arcsData.filter(function (d) {
            return d.__threeObj && d.__threeObj.children.length && d.__threeObj.children[0].material && d.__threeObj.children[0].__dashAnimateStep;
          }).forEach(function (d) {
            var obj = d.__threeObj.children[0];
            var step = obj.__dashAnimateStep * timeDelta;
            var curTranslate = obj.material.uniforms.dashTranslate.value % 1e9; // reset after 1B loops
            obj.material.uniforms.dashTranslate.value = curTranslate + step;
          });
        });
      },
      update: function update(state) {
        // Data accessors
        var startLatAccessor = index$1(state.arcStartLat);
        var startLngAccessor = index$1(state.arcStartLng);
        var endLatAccessor = index$1(state.arcEndLat);
        var endLngAccessor = index$1(state.arcEndLng);
        var altitudeAccessor = index$1(state.arcAltitude);
        var altitudeAutoScaleAccessor = index$1(state.arcAltitudeAutoScale);
        var strokeAccessor = index$1(state.arcStroke);
        var colorAccessor = index$1(state.arcColor);
        var dashLengthAccessor = index$1(state.arcDashLength);
        var dashGapAccessor = index$1(state.arcDashGap);
        var dashInitialGapAccessor = index$1(state.arcDashInitialGap);
        var dashAnimateTimeAccessor = index$1(state.arcDashAnimateTime);
        var sharedMaterial = new THREE$c.ShaderMaterial(_objectSpread2$1(_objectSpread2$1({}, gradientShaders$1), {}, {
          transparent: true,
          blending: THREE$c.NormalBlending
        }));
        threeDigest(state.arcsData, state.scene, {
          createObj: function createObj() {
            var obj = new THREE$c.Group(); // populated in updateObj

            obj.__globeObjType = 'arc'; // Add object type
            return obj;
          },
          updateObj: function updateObj(group, arc) {
            var stroke = strokeAccessor(arc);
            var useTube = stroke !== null && stroke !== undefined;
            if (!group.children.length || useTube !== (group.children[0].type === 'Mesh')) {
              // create or swap object types
              emptyObject(group);
              var _obj = useTube ? new THREE$c.Mesh() : new THREE$c.Line(new THREE$c.BufferGeometry());
              _obj.material = sharedMaterial.clone(); // Separate material instance per object to have dedicated uniforms (but shared shaders)

              group.add(_obj);
            }
            var obj = group.children[0];

            // set dash uniforms
            Object.assign(obj.material.uniforms, {
              dashSize: {
                value: dashLengthAccessor(arc)
              },
              gapSize: {
                value: dashGapAccessor(arc)
              },
              dashOffset: {
                value: dashInitialGapAccessor(arc)
              }
            });

            // set dash animation step
            var dashAnimateTime = dashAnimateTimeAccessor(arc);
            obj.__dashAnimateStep = dashAnimateTime > 0 ? 1000 / dashAnimateTime : 0; // per second

            // calculate vertex colors (to create gradient)
            var vertexColorArray = calcColorVertexArray(colorAccessor(arc),
            // single, array of colors or interpolator
            state.arcCurveResolution,
            // numSegments
            useTube ? state.arcCircularResolution + 1 : 1 // num vertices per segment
            );

            // calculate vertex relative distances (for dashed lines)
            var vertexRelDistanceArray = calcVertexRelDistances(state.arcCurveResolution,
            // numSegments
            useTube ? state.arcCircularResolution + 1 : 1,
            // num vertices per segment
            true // run from end to start, to animate in the correct direction
            );

            obj.geometry[setAttributeFn$1]('vertexColor', vertexColorArray);
            obj.geometry[setAttributeFn$1]('vertexRelDistance', vertexRelDistanceArray);
            var applyUpdate = function applyUpdate(td) {
              var _arc$__currentTargetD = arc.__currentTargetD = td,
                stroke = _arc$__currentTargetD.stroke,
                curveD = _objectWithoutProperties$1(_arc$__currentTargetD, _excluded$1);
              var curve = calcCurve(curveD);
              if (useTube) {
                obj.geometry && obj.geometry.dispose();
                obj.geometry = new THREE$c.TubeGeometry(curve, state.arcCurveResolution, stroke / 2, state.arcCircularResolution);
                obj.geometry[setAttributeFn$1]('vertexColor', vertexColorArray);
                obj.geometry[setAttributeFn$1]('vertexRelDistance', vertexRelDistanceArray);
              } else {
                obj.geometry.setFromPoints(curve.getPoints(state.arcCurveResolution));
              }
            };
            var targetD = {
              stroke: stroke,
              alt: altitudeAccessor(arc),
              altAutoScale: +altitudeAutoScaleAccessor(arc),
              startLat: +startLatAccessor(arc),
              startLng: +startLngAccessor(arc),
              endLat: +endLatAccessor(arc),
              endLng: +endLngAccessor(arc)
            };
            var currentTargetD = arc.__currentTargetD || Object.assign({}, targetD, {
              altAutoScale: -1e-3
            });
            if (Object.keys(targetD).some(function (k) {
              return currentTargetD[k] !== targetD[k];
            })) {
              if (!state.arcsTransitionDuration || state.arcsTransitionDuration < 0) {
                // set final position
                applyUpdate(targetD);
              } else {
                // animate
                new exports$1.Tween(currentTargetD).to(targetD, state.arcsTransitionDuration).easing(exports$1.Easing.Quadratic.InOut).onUpdate(applyUpdate).start();
              }
            }
          }
        });

        //

        function calcCurve(_ref) {
          var alt = _ref.alt,
            altAutoScale = _ref.altAutoScale,
            startLat = _ref.startLat,
            startLng = _ref.startLng,
            endLat = _ref.endLat,
            endLng = _ref.endLng;
          var getVec = function getVec(_ref2) {
            var _ref3 = _slicedToArray$1(_ref2, 3),
              lng = _ref3[0],
              lat = _ref3[1],
              alt = _ref3[2];
            var _polar2Cartesian = polar2Cartesian(lat, lng, alt),
              x = _polar2Cartesian.x,
              y = _polar2Cartesian.y,
              z = _polar2Cartesian.z;
            return new THREE$c.Vector3(x, y, z);
          };

          //calculate curve
          var startPnt = [startLng, startLat];
          var endPnt = [endLng, endLat];
          var altitude = alt;
          (altitude === null || altitude === undefined) && (
          // by default set altitude proportional to the great-arc distance
          altitude = geoDistance(startPnt, endPnt) / 2 * altAutoScale);
          if (altitude) {
            var interpolate = geoInterpolate(startPnt, endPnt);
            var _map = [0.25, 0.75].map(function (t) {
                return [].concat(_toConsumableArray$2(interpolate(t)), [altitude * 1.5]);
              }),
              _map2 = _slicedToArray$1(_map, 2),
              m1Pnt = _map2[0],
              m2Pnt = _map2[1];
            var curve = _construct$1(THREE$c.CubicBezierCurve3, _toConsumableArray$2([startPnt, m1Pnt, m2Pnt, endPnt].map(getVec)));

            //const mPnt = [...interpolate(0.5), altitude * 2];
            //curve = new THREE.QuadraticBezierCurve3(...[startPnt, mPnt, endPnt].map(getVec));

            return curve;
          } else {
            // ground line
            var _alt = 0.001; // slightly above the ground to prevent occlusion
            return calcSphereArc.apply(void 0, _toConsumableArray$2([[].concat(startPnt, [_alt]), [].concat(endPnt, [_alt])].map(getVec)));
          }

          //

          function calcSphereArc(startVec, endVec) {
            var angle = startVec.angleTo(endVec);
            var getGreatCirclePoint = angle === 0 ? function () {
              return startVec.clone();
            } // points exactly overlap
            : function (t) {
              return new THREE$c.Vector3().addVectors(startVec.clone().multiplyScalar(Math.sin((1 - t) * angle)), endVec.clone().multiplyScalar(Math.sin(t * angle))).divideScalar(Math.sin(angle));
            };
            var sphereArc = new THREE$c.Curve();
            sphereArc.getPoint = getGreatCirclePoint;
            return sphereArc;
          }
        }
        function calcColorVertexArray(colors, numSegments) {
          var numVerticesPerSegment = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
          var numVerticesGroup = numSegments + 1; // one between every two segments and two at the ends

          var getVertexColor;
          if (colors instanceof Array || colors instanceof Function) {
            var colorInterpolator = colors instanceof Array ? linear() // array of colors, interpolate at each step
            .domain(colors.map(function (_, idx) {
              return idx / (colors.length - 1);
            })) // same number of stops as colors
            .range(colors) : colors; // already interpolator fn

            getVertexColor = function getVertexColor(t) {
              return color2ShaderArr(colorInterpolator(t));
            };
          } else {
            // single color, use constant
            var vertexColor = color2ShaderArr(colors);
            getVertexColor = function getVertexColor() {
              return vertexColor;
            };
          }
          var vertexColorArray = new THREE$c.Float32BufferAttribute(numVerticesGroup * 4 * numVerticesPerSegment, 4);
          for (var v = 0, l = numVerticesGroup; v < l; v++) {
            var _vertexColor = getVertexColor(v / (l - 1));
            for (var s = 0; s < numVerticesPerSegment; s++) {
              vertexColorArray.set(_vertexColor, (v * numVerticesPerSegment + s) * 4);
            }
          }
          return vertexColorArray;
        }
        function calcVertexRelDistances(numSegments) {
          var numVerticesPerSegment = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
          var invert = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
          var numVerticesGroup = numSegments + 1; // one between every two segments and two at the ends
          var arrLen = numVerticesGroup * numVerticesPerSegment;
          var vertexDistanceArray = new THREE$c.Float32BufferAttribute(arrLen, 1);
          for (var v = 0, l = numVerticesGroup; v < l; v++) {
            var relDistance = v / (l - 1);
            for (var s = 0; s < numVerticesPerSegment; s++) {
              var idx = v * numVerticesPerSegment + s;
              var pos = invert ? arrLen - 1 - idx : idx;
              vertexDistanceArray.setX(pos, relDistance);
            }
          }
          return vertexDistanceArray;
        }
      }
    });

    var THREE$b = window.THREE ? window.THREE // Prefer consumption from global THREE, if exists
    : {
      BufferAttribute: BufferAttribute,
      BufferGeometry: BufferGeometry,
      Color: Color$1,
      DoubleSide: DoubleSide,
      Mesh: Mesh,
      MeshBasicMaterial: MeshBasicMaterial,
      MeshLambertMaterial: MeshLambertMaterial,
      Object3D: Object3D
    };
    var bfg$1 = Object.assign({}, _bfg);
    var BufferGeometryUtils$1 = bfg$1.BufferGeometryUtils || bfg$1;

    //

    // support multiple method names for backwards threejs compatibility
    var applyMatrix4Fn = new THREE$b.BufferGeometry().applyMatrix4 ? 'applyMatrix4' : 'applyMatrix';
    var HexBinLayerKapsule = index$2({
      props: {
        hexBinPointsData: {
          "default": []
        },
        hexBinPointLat: {
          "default": 'lat'
        },
        hexBinPointLng: {
          "default": 'lng'
        },
        hexBinPointWeight: {
          "default": 1
        },
        hexBinResolution: {
          "default": 4
        },
        // 0-15. Level 0 partitions the earth in 122 (mostly) hexagonal cells. Each subsequent level sub-divides the previous in roughly 7 hexagons.
        hexMargin: {
          "default": 0.2
        },
        // in fraction of diameter
        hexTopCurvatureResolution: {
          "default": 5
        },
        // in angular degrees
        hexTopColor: {
          "default": function _default() {
            return '#ffffaa';
          }
        },
        hexSideColor: {
          "default": function _default() {
            return '#ffffaa';
          }
        },
        hexAltitude: {
          "default": function _default(_ref) {
            var sumWeight = _ref.sumWeight;
            return sumWeight * 0.01;
          }
        },
        // in units of globe radius
        hexBinMerge: {
          "default": false
        },
        // boolean. Whether to merge all hex geometries into a single mesh for rendering performance
        hexTransitionDuration: {
          "default": 1000,
          triggerUpdate: false
        } // ms
      },
      init: function init(threeObj, state) {
        // Clear the scene
        emptyObject(threeObj);

        // Main three object to manipulate
        state.scene = threeObj;
      },
      update: function update(state) {
        // Accessors
        var latAccessor = index$1(state.hexBinPointLat);
        var lngAccessor = index$1(state.hexBinPointLng);
        var weightAccessor = index$1(state.hexBinPointWeight);
        var altitudeAccessor = index$1(state.hexAltitude);
        var topColorAccessor = index$1(state.hexTopColor);
        var sideColorAccessor = index$1(state.hexSideColor);
        var marginAccessor = index$1(state.hexMargin);
        var byH3Idx = index(state.hexBinPointsData.map(function (d) {
          return _objectSpread2$1(_objectSpread2$1({}, d), {}, {
            h3Idx: latLngToCell(latAccessor(d), lngAccessor(d), state.hexBinResolution)
          });
        }), 'h3Idx');
        var hexBins = Object.entries(byH3Idx).map(function (_ref2) {
          var _ref3 = _slicedToArray$1(_ref2, 2),
            h3Idx = _ref3[0],
            points = _ref3[1];
          return {
            h3Idx: h3Idx,
            points: points,
            sumWeight: points.reduce(function (agg, d) {
              return agg + +weightAccessor(d);
            }, 0)
          };
        });
        var hexMaterials = {}; // indexed by color

        var scene = state.hexBinMerge ? new THREE$b.Object3D() : state.scene; // use fake scene if merging hex points

        threeDigest(hexBins, scene, {
          createObj: createObj,
          updateObj: updateObj,
          idAccessor: function idAccessor(d) {
            return d.h3Idx;
          }
        });
        if (state.hexBinMerge) {
          // merge points into a single mesh
          var hexPointsGeometry = !hexBins.length ? new THREE$b.BufferGeometry() : BufferGeometryUtils$1.mergeBufferGeometries(hexBins.map(function (d) {
            var obj = d.__threeObj;
            d.__threeObj = undefined; // unbind merged points

            // use non-indexed geometry so that groups can be colored separately, otherwise different groups share vertices
            var geom = obj.geometry.toNonIndexed();

            // apply mesh world transform to vertices
            obj.updateMatrix();
            geom[applyMatrix4Fn](obj.matrix);

            // color vertices
            var topColor = new THREE$b.Color(topColorAccessor(d));
            var sideColor = new THREE$b.Color(sideColorAccessor(d));
            var nVertices = geom.attributes.position.count;
            var topFaceIdx = geom.groups[0].count; // starting vertex index of top group
            var colors = new Float32Array(nVertices * 3);
            for (var i = 0, len = nVertices; i < len; i++) {
              var idx = i * 3;
              var c = i >= topFaceIdx ? topColor : sideColor;
              colors[idx] = c.r;
              colors[idx + 1] = c.g;
              colors[idx + 2] = c.b;
            }
            geom.setAttribute('color', new THREE$b.BufferAttribute(colors, 3));
            return geom;
          }));
          var hexPoints = new THREE$b.Mesh(hexPointsGeometry, new THREE$b.MeshBasicMaterial({
            color: 0xffffff,
            vertexColors: true,
            side: THREE$b.DoubleSide
          }));
          hexPoints.__globeObjType = 'hexBinPoints'; // Add object type
          hexPoints.__data = hexBins; // Attach obj data

          emptyObject(state.scene);
          state.scene.add(hexPoints);
        }

        //

        function createObj(d) {
          var obj = new THREE$b.Mesh();
          obj.__hexCenter = cellToLatLng(d.h3Idx);
          obj.__hexGeoJson = cellToBoundary(d.h3Idx, true).reverse(); // correct polygon winding

          // stitch longitudes at the anti-meridian
          var centerLng = obj.__hexCenter[1];
          obj.__hexGeoJson.forEach(function (d) {
            var edgeLng = d[0];
            if (Math.abs(centerLng - edgeLng) > 170) {
              // normalize large lng distances
              d[0] += centerLng > edgeLng ? 360 : -360;
            }
          });
          obj.__globeObjType = 'hexbin'; // Add object type
          return obj;
        }
        function updateObj(obj, d) {
          // compute new geojson with relative margin
          var relNum = function relNum(st, end, rat) {
            return st - (st - end) * rat;
          };
          var margin = Math.max(0, Math.min(1, +marginAccessor(d)));
          var _obj$__hexCenter = _slicedToArray$1(obj.__hexCenter, 2),
            clat = _obj$__hexCenter[0],
            clng = _obj$__hexCenter[1];
          var geoJson = margin === 0 ? obj.__hexGeoJson : obj.__hexGeoJson.map(function (_ref4) {
            var _ref5 = _slicedToArray$1(_ref4, 2),
              elng = _ref5[0],
              elat = _ref5[1];
            return [[elng, clng], [elat, clat]].map(function (_ref6) {
              var _ref7 = _slicedToArray$1(_ref6, 2),
                st = _ref7[0],
                end = _ref7[1];
              return relNum(st, end, margin);
            });
          });
          var topCurvatureResolution = state.hexTopCurvatureResolution;
          obj.geometry = new ConicPolygonBufferGeometry([geoJson], 0, GLOBE_RADIUS, false, true, true, topCurvatureResolution);
          var targetD = {
            alt: +altitudeAccessor(d)
          };
          var applyUpdate = function applyUpdate(td) {
            var _obj$__currentTargetD = obj.__currentTargetD = td,
              alt = _obj$__currentTargetD.alt;
            obj.scale.x = obj.scale.y = obj.scale.z = 1 + alt; // scale according to altitude
          };

          var currentTargetD = obj.__currentTargetD || Object.assign({}, targetD, {
            alt: -1e-3
          });
          if (Object.keys(targetD).some(function (k) {
            return currentTargetD[k] !== targetD[k];
          })) {
            if (state.hexBinMerge || !state.hexTransitionDuration || state.hexTransitionDuration < 0) {
              // set final position
              applyUpdate(targetD);
            } else {
              // animate
              new exports$1.Tween(currentTargetD).to(targetD, state.hexTransitionDuration).easing(exports$1.Easing.Quadratic.InOut).onUpdate(applyUpdate).start();
            }
          }
          if (!state.hexBinMerge) {
            // Update materials on individual hex points
            var sideColor = sideColorAccessor(d);
            var topColor = topColorAccessor(d);
            [sideColor, topColor].forEach(function (color) {
              if (!hexMaterials.hasOwnProperty(color)) {
                var opacity = colorAlpha(color);
                hexMaterials[color] = new THREE$b.MeshLambertMaterial({
                  color: colorStr2Hex(color),
                  transparent: opacity < 1,
                  opacity: opacity,
                  side: THREE$b.DoubleSide
                });
              }
            });
            obj.material = [sideColor, topColor].map(function (color) {
              return hexMaterials[color];
            });
          }
        }
      }
    });

    var THREE$a = window.THREE ? window.THREE // Prefer consumption from global THREE, if exists
    : {
      DoubleSide: DoubleSide,
      Group: Group$1,
      LineBasicMaterial: LineBasicMaterial,
      LineSegments: LineSegments,
      Mesh: Mesh,
      MeshBasicMaterial: MeshBasicMaterial
    };

    //

    var PolygonsLayerKapsule = index$2({
      props: {
        polygonsData: {
          "default": []
        },
        polygonGeoJsonGeometry: {
          "default": 'geometry'
        },
        polygonSideColor: {
          "default": function _default() {
            return '#ffffaa';
          }
        },
        polygonSideMaterial: {},
        polygonCapColor: {
          "default": function _default() {
            return '#ffffaa';
          }
        },
        polygonCapMaterial: {},
        polygonStrokeColor: {},
        polygonAltitude: {
          "default": 0.01
        },
        // in units of globe radius
        polygonCapCurvatureResolution: {
          "default": 5
        },
        // in angular degrees
        polygonsTransitionDuration: {
          "default": 1000,
          triggerUpdate: false
        } // ms
      },
      init: function init(threeObj, state) {
        // Clear the scene
        emptyObject(threeObj);

        // Main three object to manipulate
        state.scene = threeObj;
      },
      update: function update(state) {
        // Data accessors
        var geoJsonAccessor = index$1(state.polygonGeoJsonGeometry);
        var altitudeAccessor = index$1(state.polygonAltitude);
        var capCurvatureResolutionAccessor = index$1(state.polygonCapCurvatureResolution);
        var capColorAccessor = index$1(state.polygonCapColor);
        var capMaterialAccessor = index$1(state.polygonCapMaterial);
        var sideColorAccessor = index$1(state.polygonSideColor);
        var sideMaterialAccessor = index$1(state.polygonSideMaterial);
        var strokeColorAccessor = index$1(state.polygonStrokeColor);
        var singlePolygons = [];
        state.polygonsData.forEach(function (polygon) {
          var objAttrs = {
            data: polygon,
            capColor: capColorAccessor(polygon),
            capMaterial: capMaterialAccessor(polygon),
            sideColor: sideColorAccessor(polygon),
            sideMaterial: sideMaterialAccessor(polygon),
            strokeColor: strokeColorAccessor(polygon),
            altitude: +altitudeAccessor(polygon),
            capCurvatureResolution: +capCurvatureResolutionAccessor(polygon)
          };
          var geoJson = geoJsonAccessor(polygon);
          var geoId = polygon.__id || "".concat(Math.round(Math.random() * 1e9)); // generate and stamp polygon ids to keep track in digest
          polygon.__id = geoId;
          if (geoJson.type === 'Polygon') {
            singlePolygons.push(_objectSpread2$1({
              id: "".concat(geoId, "_0"),
              coords: geoJson.coordinates
            }, objAttrs));
          } else if (geoJson.type === 'MultiPolygon') {
            singlePolygons.push.apply(singlePolygons, _toConsumableArray$2(geoJson.coordinates.map(function (coords, idx) {
              return _objectSpread2$1({
                id: "".concat(geoId, "_").concat(idx),
                coords: coords
              }, objAttrs);
            })));
          } else {
            console.warn("Unsupported GeoJson geometry type: ".concat(geoJson.type, ". Skipping geometry..."));
          }
        });
        threeDigest(singlePolygons, state.scene, {
          idAccessor: function idAccessor(d) {
            return d.id;
          },
          createObj: function createObj() {
            var obj = new THREE$a.Group();
            obj.__defaultSideMaterial = new THREE$a.MeshBasicMaterial({
              side: THREE$a.DoubleSide,
              depthWrite: true
            });
            obj.__defaultCapMaterial = new THREE$a.MeshBasicMaterial({
              side: THREE$a.DoubleSide,
              depthWrite: true
            });

            // conic geometry
            obj.add(new THREE$a.Mesh(undefined, [obj.__defaultSideMaterial,
            // side material
            obj.__defaultCapMaterial // cap material
            ]));

            // polygon stroke
            obj.add(new THREE$a.LineSegments(undefined, new THREE$a.LineBasicMaterial()));
            obj.__globeObjType = 'polygon'; // Add object type

            return obj;
          },
          updateObj: function updateObj(obj, _ref) {
            var coords = _ref.coords,
              capColor = _ref.capColor,
              capMaterial = _ref.capMaterial,
              sideColor = _ref.sideColor,
              sideMaterial = _ref.sideMaterial,
              strokeColor = _ref.strokeColor,
              altitude = _ref.altitude,
              capCurvatureResolution = _ref.capCurvatureResolution;
            var _obj$children = _slicedToArray$1(obj.children, 2),
              conicObj = _obj$children[0],
              strokeObj = _obj$children[1];

            // hide stroke if no color set
            var addStroke = !!strokeColor;
            strokeObj.visible = addStroke;

            // regenerate geometries if needed
            !objMatch(conicObj.geometry.parameters || {}, {
              polygonGeoJson: coords,
              curvatureResolution: capCurvatureResolution
            }) && (conicObj.geometry = new ConicPolygonBufferGeometry(coords, 0, GLOBE_RADIUS, false, true, true, capCurvatureResolution));
            addStroke && (!strokeObj.geometry.parameters || strokeObj.geometry.parameters.geoJson.coordinates !== coords || strokeObj.geometry.parameters.resolution !== capCurvatureResolution) && (strokeObj.geometry = new GeoJsonGeometry({
              type: 'Polygon',
              coordinates: coords
            }, GLOBE_RADIUS, capCurvatureResolution));

            // replace side/cap materials if defined
            conicObj.material[0] = sideMaterial || obj.__defaultSideMaterial;
            conicObj.material[1] = capMaterial || obj.__defaultCapMaterial;

            // update default material colors
            [!sideMaterial && sideColor, !capMaterial && capColor].forEach(function (color, materialIdx) {
              if (!color) return; // skip custom materials

              // conic object
              var material = conicObj.material[materialIdx];
              var opacity = colorAlpha(color);
              material.color.set(colorStr2Hex(color));
              material.transparent = opacity < 1;
              material.opacity = opacity;
            });
            if (addStroke) {
              // stroke object
              var material = strokeObj.material;
              var opacity = colorAlpha(strokeColor);
              material.color.set(colorStr2Hex(strokeColor));
              material.transparent = opacity < 1;
              material.opacity = opacity;
            }
            var targetD = {
              alt: altitude
            };
            var applyUpdate = function applyUpdate(td) {
              var _obj$__currentTargetD = obj.__currentTargetD = td,
                alt = _obj$__currentTargetD.alt;
              conicObj.scale.x = conicObj.scale.y = conicObj.scale.z = 1 + alt;
              addStroke && (strokeObj.scale.x = strokeObj.scale.y = strokeObj.scale.z = 1 + alt + 1e-4); // stroke slightly above the conic mesh
            };

            var currentTargetD = obj.__currentTargetD || Object.assign({}, targetD, {
              alt: -1e-3
            });
            if (Object.keys(targetD).some(function (k) {
              return currentTargetD[k] !== targetD[k];
            })) {
              if (!state.polygonsTransitionDuration || state.polygonsTransitionDuration < 0 || currentTargetD.alt === targetD.alt) {
                // set final position
                applyUpdate(targetD);
              } else {
                // animate
                new exports$1.Tween(currentTargetD).to(targetD, state.polygonsTransitionDuration).easing(exports$1.Easing.Quadratic.InOut).onUpdate(applyUpdate).start();
              }
            }
          }
        });
      }
    });
    function objMatch(obj, attrs) {
      var compFn = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function () {
        return function (a, b) {
          return a === b;
        };
      };
      return Object.entries(attrs).every(function (_ref2) {
        var _ref3 = _slicedToArray$1(_ref2, 2),
          k = _ref3[0],
          v = _ref3[1];
        return obj.hasOwnProperty(k) && compFn(k)(obj[k], v);
      });
    }

    var THREE$9 = window.THREE ? window.THREE // Prefer consumption from global THREE, if exists
    : {
      BufferGeometry: BufferGeometry,
      DoubleSide: DoubleSide,
      Mesh: Mesh,
      MeshLambertMaterial: MeshLambertMaterial
    };
    var bfg = Object.assign({}, _bfg);
    var BufferGeometryUtils = bfg.BufferGeometryUtils || bfg;

    //

    var HexedPolygonsLayerKapsule = index$2({
      props: {
        hexPolygonsData: {
          "default": []
        },
        hexPolygonGeoJsonGeometry: {
          "default": 'geometry'
        },
        hexPolygonColor: {
          "default": function _default() {
            return '#ffffaa';
          }
        },
        hexPolygonAltitude: {
          "default": 0.001
        },
        // in units of globe radius
        hexPolygonResolution: {
          "default": 3
        },
        // 0-15. Level 0 partitions the earth in 122 (mostly) hexagonal cells. Each subsequent level sub-divides the previous in roughly 7 hexagons.
        hexPolygonMargin: {
          "default": 0.2
        },
        // in fraction of hex diameter
        hexPolygonCurvatureResolution: {
          "default": 5
        },
        // in angular degrees
        hexPolygonsTransitionDuration: {
          "default": 0,
          triggerUpdate: false
        } // ms
      },
      init: function init(threeObj, state) {
        // Clear the scene
        emptyObject(threeObj);

        // Main three object to manipulate
        state.scene = threeObj;
      },
      update: function update(state) {
        // Accessors
        var geoJsonAccessor = index$1(state.hexPolygonGeoJsonGeometry);
        var colorAccessor = index$1(state.hexPolygonColor);
        var altitudeAccessor = index$1(state.hexPolygonAltitude);
        var resolutionAccessor = index$1(state.hexPolygonResolution);
        var marginAccessor = index$1(state.hexPolygonMargin);
        var curvatureResolutionAccessor = index$1(state.hexPolygonCurvatureResolution);
        threeDigest(state.hexPolygonsData, state.scene, {
          createObj: function createObj(d) {
            var obj = new THREE$9.Mesh(undefined, new THREE$9.MeshLambertMaterial({
              side: THREE$9.DoubleSide
            }));
            obj.__globeObjType = 'hexPolygon'; // Add object type

            return obj;
          },
          updateObj: function updateObj(obj, d) {
            var geoJson = geoJsonAccessor(d);
            var h3Res = resolutionAccessor(d);
            var alt = altitudeAccessor(d);
            var margin = Math.max(0, Math.min(1, +marginAccessor(d)));
            var curvatureResolution = curvatureResolutionAccessor(d);

            // update material
            var color = colorAccessor(d);
            var opacity = colorAlpha(color);
            obj.material.color.set(colorStr2Hex(color));
            obj.material.transparent = opacity < 1;
            obj.material.opacity = opacity;
            var targetD = {
              alt: alt,
              margin: margin,
              curvatureResolution: curvatureResolution
            };
            var currentTargetD = obj.__currentTargetD || Object.assign({}, targetD, {
              alt: -1e-3
            });
            if (Object.keys(targetD).some(function (k) {
              return currentTargetD[k] !== targetD[k];
            })) {
              var h3Idxs = [];
              if (geoJson.type === 'Polygon') {
                polygonToCells(geoJson.coordinates, h3Res, true).forEach(function (idx) {
                  return h3Idxs.push(idx);
                });
              } else if (geoJson.type === 'MultiPolygon') {
                geoJson.coordinates.forEach(function (coords) {
                  return polygonToCells(coords, h3Res, true).forEach(function (idx) {
                    return h3Idxs.push(idx);
                  });
                });
              } else {
                console.warn("Unsupported GeoJson geometry type: ".concat(geoJson.type, ". Skipping geometry..."));
              }
              var hexBins = h3Idxs.map(function (h3Idx) {
                var hexCenter = cellToLatLng(h3Idx);
                var hexGeoJson = cellToBoundary(h3Idx, true).reverse(); // correct polygon winding

                // stitch longitudes at the anti-meridian
                var centerLng = hexCenter[1];
                hexGeoJson.forEach(function (d) {
                  var edgeLng = d[0];
                  if (Math.abs(centerLng - edgeLng) > 170) {
                    // normalize large lng distances
                    d[0] += centerLng > edgeLng ? 360 : -360;
                  }
                });
                return {
                  h3Idx: h3Idx,
                  hexCenter: hexCenter,
                  hexGeoJson: hexGeoJson
                };
              });
              var applyUpdate = function applyUpdate(td) {
                var _obj$__currentTargetD = obj.__currentTargetD = td,
                  alt = _obj$__currentTargetD.alt,
                  margin = _obj$__currentTargetD.margin,
                  curvatureResolution = _obj$__currentTargetD.curvatureResolution;
                obj.geometry && obj.geometry.dispose();
                obj.geometry = !hexBins.length ? new THREE$9.BufferGeometry() : BufferGeometryUtils.mergeBufferGeometries(hexBins.map(function (h) {
                  // compute new geojson with relative margin
                  var relNum = function relNum(st, end, rat) {
                    return st - (st - end) * rat;
                  };
                  var _h$hexCenter = _slicedToArray$1(h.hexCenter, 2),
                    clat = _h$hexCenter[0],
                    clng = _h$hexCenter[1];
                  var geoJson = margin === 0 ? h.hexGeoJson : h.hexGeoJson.map(function (_ref) {
                    var _ref2 = _slicedToArray$1(_ref, 2),
                      elng = _ref2[0],
                      elat = _ref2[1];
                    return [[elng, clng], [elat, clat]].map(function (_ref3) {
                      var _ref4 = _slicedToArray$1(_ref3, 2),
                        st = _ref4[0],
                        end = _ref4[1];
                      return relNum(st, end, margin);
                    });
                  });
                  return new ConicPolygonBufferGeometry([geoJson], GLOBE_RADIUS, GLOBE_RADIUS * (1 + alt), false, true, false, curvatureResolution);
                }));
              };
              if (!state.hexPolygonsTransitionDuration || state.hexPolygonsTransitionDuration < 0) {
                // set final position
                applyUpdate(targetD);
              } else {
                // animate
                new exports$1.Tween(currentTargetD).to(targetD, state.hexPolygonsTransitionDuration).easing(exports$1.Easing.Quadratic.InOut).onUpdate(applyUpdate).start();
              }
            }
          }
        });
      }
    });

    var THREE$8 = window.THREE ? window.THREE // Prefer consumption from global THREE, if exists
    : {
      Vector3: Vector3
    };
    function interpolateVectors(fromPnts, toPnts) {
      var extendArr = function extendArr(arr, length) {
        var repeatItem = arr[arr.length - 1];
        return [].concat(_toConsumableArray$2(arr), _toConsumableArray$2(_toConsumableArray$2(new Array(length - arr.length)).map(function () {
          return repeatItem;
        })));
      };
      var arrLength = Math.max(fromPnts.length, toPnts.length);
      var interpolator = interpolateArray.apply(void 0, _toConsumableArray$2([fromPnts, toPnts].map(function (pnts) {
        return pnts.map(function (_ref) {
          var x = _ref.x,
            y = _ref.y,
            z = _ref.z;
          return [x, y, z];
        });
      }).map(function (arr) {
        return extendArr(arr, arrLength);
      })));
      return function (k) {
        return k === 0 ? fromPnts : k === 1 ? toPnts : interpolator(k).map(function (_ref2) {
          var _ref3 = _slicedToArray$1(_ref2, 3),
            x = _ref3[0],
            y = _ref3[1],
            z = _ref3[2];
          return new THREE$8.Vector3(x, y, z);
        });
      };
    }

    var THREE$7 = window.THREE ? window.THREE // Prefer consumption from global THREE, if exists
    : {
      BufferGeometry: BufferGeometry,
      Color: Color$1,
      Float32BufferAttribute: Float32BufferAttribute,
      Group: Group$1,
      Line: Line,
      NormalBlending: NormalBlending,
      ShaderMaterial: ShaderMaterial,
      Vector3: Vector3
    };
    var FrameTicker$1 = _FrameTicker["default"] || _FrameTicker;

    //

    // support both modes for backwards threejs compatibility
    var setAttributeFn = new THREE$7.BufferGeometry().setAttribute ? 'setAttribute' : 'addAttribute';
    var gradientShaders = {
      uniforms: {
        // dash param defaults, all relative to full length
        dashOffset: {
          value: 0
        },
        dashSize: {
          value: 1
        },
        gapSize: {
          value: 0
        },
        dashTranslate: {
          value: 0
        } // used for animating the dash
      },

      vertexShader: "\n    uniform float dashTranslate;\n\n    attribute vec4 vertexColor;\n    varying vec4 vColor;\n\n    attribute float vertexRelDistance;\n    varying float vRelDistance;\n\n    void main() {\n      // pass through colors and distances\n      vColor = vertexColor;\n      vRelDistance = vertexRelDistance + dashTranslate;\n      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n    }\n  ",
      fragmentShader: "\n    uniform float dashOffset;\n    uniform float dashSize;\n    uniform float gapSize;\n\n    varying vec4 vColor;\n    varying float vRelDistance;\n\n    void main() {\n      // ignore pixels in the gap\n      if (vRelDistance < dashOffset) discard;\n      if (mod(vRelDistance - dashOffset, dashSize + gapSize) > dashSize) discard;\n\n      // set px color: [r, g, b, a], interpolated between vertices\n      gl_FragColor = vColor;\n    }\n  "
    };
    var PathsLayerKapsule = index$2({
      props: {
        pathsData: {
          "default": []
        },
        pathPoints: {
          "default": function _default(pnts) {
            return pnts;
          }
        },
        pathPointLat: {
          "default": function _default(arr) {
            return arr[0];
          }
        },
        pathPointLng: {
          "default": function _default(arr) {
            return arr[1];
          }
        },
        pathPointAlt: {
          "default": 1e-3
        },
        pathResolution: {
          "default": 2
        },
        // in deg
        pathColor: {
          "default": function _default() {
            return '#ffffaa';
          }
        },
        // single color, array of colors or color interpolation fn
        pathStroke: {},
        // in deg
        pathDashLength: {
          "default": 1
        },
        // in units of line length
        pathDashGap: {
          "default": 0
        },
        pathDashInitialGap: {
          "default": 0
        },
        pathDashAnimateTime: {
          "default": 0
        },
        // ms
        pathTransitionDuration: {
          "default": 1000,
          triggerUpdate: false
        },
        // ms
        rendererSize: {} // necessary to set correct fatline proportions
      },
      init: function init(threeObj, state) {
        // Clear the scene
        emptyObject(threeObj);

        // Main three object to manipulate
        state.scene = threeObj;

        // Kick-off dash animations
        new FrameTicker$1().onTick.add(function (_, timeDelta) {
          state.pathsData.filter(function (d) {
            return d.__threeObj && d.__threeObj.children.length && d.__threeObj.children[0].material && d.__threeObj.children[0].__dashAnimateStep;
          }).forEach(function (d) {
            var obj = d.__threeObj.children[0];
            var step = obj.__dashAnimateStep * timeDelta;
            if (obj.type === 'Line') {
              var curTranslate = obj.material.uniforms.dashTranslate.value % 1e9; // reset after 1B loops
              obj.material.uniforms.dashTranslate.value = curTranslate + step;
            } else if (obj.type === 'Line2') {
              // fatline
              var offset = obj.material.dashOffset - step;
              var dashLength = obj.material.dashSize + obj.material.gapSize;
              while (offset <= -dashLength) {
                offset += dashLength;
              } // cycle within dash length
              obj.material.dashOffset = offset;
            }
          });
        });
      },
      update: function update(state) {
        // Data accessors
        var pointsAccessor = index$1(state.pathPoints);
        var pointLatAccessor = index$1(state.pathPointLat);
        var pointLngAccessor = index$1(state.pathPointLng);
        var pointAltAccessor = index$1(state.pathPointAlt);
        var strokeAccessor = index$1(state.pathStroke);
        var colorAccessor = index$1(state.pathColor);
        var dashLengthAccessor = index$1(state.pathDashLength);
        var dashGapAccessor = index$1(state.pathDashGap);
        var dashInitialGapAccessor = index$1(state.pathDashInitialGap);
        var dashAnimateTimeAccessor = index$1(state.pathDashAnimateTime);
        var sharedShaderMaterial = new THREE$7.ShaderMaterial(_objectSpread2$1(_objectSpread2$1({}, gradientShaders), {}, {
          transparent: true,
          blending: THREE$7.NormalBlending
        }));
        threeDigest(state.pathsData, state.scene, {
          createObj: function createObj() {
            var obj = new THREE$7.Group(); // populated in updateObj

            obj.__globeObjType = 'path'; // Add object type
            return obj;
          },
          updateObj: function updateObj(group, path) {
            var stroke = strokeAccessor(path);
            var useFatLine = stroke !== null && stroke !== undefined;
            if (!group.children.length || useFatLine === (group.children[0].type === 'Line')) {
              // create or swap object types
              emptyObject(group);
              var _obj = useFatLine ? new Line2(new LineGeometry(), new LineMaterial()) : new THREE$7.Line(new THREE$7.BufferGeometry(), sharedShaderMaterial.clone() // Separate material instance per object to have dedicated uniforms (but shared shaders)
              );

              group.add(_obj);
            }
            var obj = group.children[0];
            var points = calcPath(pointsAccessor(path), pointLatAccessor, pointLngAccessor, pointAltAccessor, state.pathResolution);

            // set dash animation step
            var dashAnimateTime = dashAnimateTimeAccessor(path);
            obj.__dashAnimateStep = dashAnimateTime > 0 ? 1000 / dashAnimateTime : 0; // per second

            if (!useFatLine) {
              // set dash uniforms
              Object.assign(obj.material.uniforms, {
                dashSize: {
                  value: dashLengthAccessor(path)
                },
                gapSize: {
                  value: dashGapAccessor(path)
                },
                dashOffset: {
                  value: dashInitialGapAccessor(path)
                }
              });

              // calculate vertex colors (to create gradient)
              var vertexColorArray = calcColorVertexArray(colorAccessor(path),
              // single, array of colors or interpolator
              points.length // numSegments
              );

              // calculate vertex relative distances (for dashed lines)
              var vertexRelDistanceArray = calcVertexRelDistances(points.length,
              // numSegments
              1,
              // num vertices per segment
              true // run from end to start, to animate in the correct direction
              );

              obj.geometry[setAttributeFn]('vertexColor', vertexColorArray);
              obj.geometry[setAttributeFn]('vertexRelDistance', vertexRelDistanceArray);
            } else {
              // fat lines
              obj.material.resolution = state.rendererSize;
              {
                // set dash styling
                var dashLength = dashLengthAccessor(path);
                var dashGap = dashGapAccessor(path);
                var dashInitialGap = dashInitialGapAccessor(path);
                obj.material.dashed = dashGap > 0;

                // temp hack to activate line dashes
                obj.material.dashed ? obj.material.defines.USE_DASH = "" : delete obj.material.defines.USE_DASH;
                if (obj.material.dashed) {
                  obj.material.dashScale = 1 / calcLineDistance(points); // dash sizes relative to full line length

                  obj.material.dashSize = dashLength;
                  obj.material.gapSize = dashGap;
                  obj.material.dashOffset = -dashInitialGap;
                }
              }
              {
                // set line colors
                var colors = colorAccessor(path);
                if (colors instanceof Array) {
                  // calculate vertex colors (to create gradient)
                  var _vertexColorArray = calcColorVertexArray(colorAccessor(path),
                  // single, array of colors or interpolator
                  points.length - 1,
                  // numSegments
                  1,
                  // num vertices per segment
                  false);
                  obj.geometry.setColors(_vertexColorArray.array);
                  obj.material.vertexColors = true;
                } else {
                  // single color
                  var color = colors;
                  var opacity = colorAlpha(color);
                  obj.material.color = new THREE$7.Color(colorStr2Hex(color));
                  obj.material.transparent = opacity < 1;
                  obj.material.opacity = opacity;
                  obj.material.vertexColors = false;
                }
              }
              obj.material.needsUpdate = true;
            }

            // animate from start to finish by default
            var pointsInterpolator = interpolateVectors(path.__currentTargetD && path.__currentTargetD.points || [points[0]], points);
            var applyUpdate = function applyUpdate(td) {
              var _path$__currentTarget = path.__currentTargetD = td,
                stroke = _path$__currentTarget.stroke,
                interpolK = _path$__currentTarget.interpolK;
              var kPoints = path.__currentTargetD.points = pointsInterpolator(interpolK);
              if (useFatLine) {
                var _ref;
                obj.geometry.setPositions((_ref = []).concat.apply(_ref, _toConsumableArray$2(kPoints.map(function (_ref2) {
                  var x = _ref2.x,
                    y = _ref2.y,
                    z = _ref2.z;
                  return [x, y, z];
                }))));
                obj.material.linewidth = stroke;

                // necessary for dashed lines
                obj.material.dashed && obj.computeLineDistances();
              } else {
                obj.geometry.setFromPoints(kPoints);
                obj.geometry.computeBoundingSphere();
              }
            };
            var targetD = {
              stroke: stroke,
              interpolK: 1
            };
            var currentTargetD = Object.assign({}, path.__currentTargetD || targetD, {
              interpolK: 0
            });
            if (Object.keys(targetD).some(function (k) {
              return currentTargetD[k] !== targetD[k];
            })) {
              if (!state.pathTransitionDuration || state.pathTransitionDuration < 0) {
                // set final position
                applyUpdate(targetD);
              } else {
                // animate
                new exports$1.Tween(currentTargetD).to(targetD, state.pathTransitionDuration).easing(exports$1.Easing.Quadratic.InOut).onUpdate(applyUpdate).start();
              }
            }
          }
        });

        //

        function calcLineDistance(pnts) {
          var totalDist = 0;
          var prevPnt;
          pnts.forEach(function (pnt) {
            prevPnt && (totalDist += prevPnt.distanceTo(pnt));
            prevPnt = pnt;
          });
          return totalDist;
        }
        function calcPath(points, latAccessor, lngAccessor, altAccessor, angularResolution) {
          var getInterpolatedVals = function getInterpolatedVals(start, end, numPnts) {
            var result = [];
            for (var i = 1; i <= numPnts; i++) {
              result.push(start + (end - start) * i / (numPnts + 1));
            }
            return result;
          };
          var interpolateLine = function interpolateLine() {
            var lineCoords = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
            var maxDegDistance = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
            var result = [];
            var prevPnt = null;
            lineCoords.forEach(function (pnt) {
              if (prevPnt) {
                // cross the anti-meridian if that's the closest distance between points
                while (Math.abs(prevPnt[1] - pnt[1]) > 180) {
                  prevPnt[1] += 360 * (prevPnt[1] < pnt[1] ? 1 : -1);
                }
                var dist = Math.sqrt(Math.pow(pnt[0] - prevPnt[0], 2) + Math.pow(pnt[1] - prevPnt[1], 2));
                if (dist > maxDegDistance) {
                  var numAdditionalPnts = Math.floor(dist / maxDegDistance);
                  var lats = getInterpolatedVals(prevPnt[0], pnt[0], numAdditionalPnts);
                  var lngs = getInterpolatedVals(prevPnt[1], pnt[1], numAdditionalPnts);
                  var alts = getInterpolatedVals(prevPnt[2], pnt[2], numAdditionalPnts);
                  for (var i = 0, len = lats.length; i < len; i++) {
                    result.push([lats[i], lngs[i], alts[i]]);
                  }
                }
              }
              result.push(prevPnt = pnt);
            });
            return result;
          };
          var getVec = function getVec(_ref3) {
            var _ref4 = _slicedToArray$1(_ref3, 3),
              lat = _ref4[0],
              lng = _ref4[1],
              alt = _ref4[2];
            var _polar2Cartesian = polar2Cartesian(lat, lng, alt),
              x = _polar2Cartesian.x,
              y = _polar2Cartesian.y,
              z = _polar2Cartesian.z;
            return new THREE$7.Vector3(x, y, z);
          };
          return interpolateLine(points.map(function (pnt) {
            return [latAccessor(pnt), lngAccessor(pnt), altAccessor(pnt)];
          }), angularResolution).map(getVec);
        }
        function calcColorVertexArray(colors, numSegments) {
          var numVerticesPerSegment = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
          var includeAlpha = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
          var numVerticesGroup = numSegments + 1; // one between every two segments and two at the ends

          var getVertexColor;
          if (colors instanceof Array || colors instanceof Function) {
            var colorInterpolator = colors instanceof Array ? linear() // array of colors, interpolate at each step
            .domain(colors.map(function (_, idx) {
              return idx / (colors.length - 1);
            })) // same number of stops as colors
            .range(colors) : colors; // already interpolator fn

            getVertexColor = function getVertexColor(t) {
              return color2ShaderArr(colorInterpolator(t), includeAlpha);
            };
          } else {
            // single color, use constant
            var vertexColor = color2ShaderArr(colors, includeAlpha);
            getVertexColor = function getVertexColor() {
              return vertexColor;
            };
          }
          var numArgs = includeAlpha ? 4 : 3;
          var vertexColorArray = new THREE$7.Float32BufferAttribute(numVerticesGroup * numArgs * numVerticesPerSegment, numArgs);
          for (var v = 0, l = numVerticesGroup; v < l; v++) {
            var _vertexColor = getVertexColor(v / (l - 1));
            for (var s = 0; s < numVerticesPerSegment; s++) {
              vertexColorArray.set(_vertexColor, (v * numVerticesPerSegment + s) * numArgs);
            }
          }
          return vertexColorArray;
        }
        function calcVertexRelDistances(numSegments) {
          var numVerticesPerSegment = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
          var invert = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
          var numVerticesGroup = numSegments + 1; // one between every two segments and two at the ends
          var arrLen = numVerticesGroup * numVerticesPerSegment;
          var vertexDistanceArray = new THREE$7.Float32BufferAttribute(arrLen, 1);
          for (var v = 0, l = numVerticesGroup; v < l; v++) {
            var relDistance = v / (l - 1);
            for (var s = 0; s < numVerticesPerSegment; s++) {
              var idx = v * numVerticesPerSegment + s;
              var pos = invert ? arrLen - 1 - idx : idx;
              vertexDistanceArray.setX(pos, relDistance);
            }
          }
          return vertexDistanceArray;
        }
      }
    });

    var THREE$6 = window.THREE ? window.THREE // Prefer consumption from global THREE, if exists
    : {
      Euler: Euler,
      Mesh: Mesh,
      MeshLambertMaterial: MeshLambertMaterial,
      SphereGeometry: SphereGeometry
    };

    //

    var TilesLayerKapsule = index$2({
      props: {
        tilesData: {
          "default": []
        },
        tileLat: {
          "default": 'lat'
        },
        // tile centroid
        tileLng: {
          "default": 'lng'
        },
        tileAltitude: {
          "default": 0.01
        },
        // in units of globe radius
        tileWidth: {
          "default": 1
        },
        // in lng degrees
        tileHeight: {
          "default": 1
        },
        // in lat degrees
        tileUseGlobeProjection: {
          "default": true
        },
        // whether to size tiles relative to the globe coordinate system, or independently
        tileMaterial: {
          "default": function _default() {
            return new THREE$6.MeshLambertMaterial({
              color: '#ffbb88',
              opacity: 0.4,
              transparent: true
            });
          }
        },
        tileCurvatureResolution: {
          "default": 5
        },
        // in angular degrees
        tilesTransitionDuration: {
          "default": 1000,
          triggerUpdate: false
        } // ms
      },
      init: function init(threeObj, state) {
        // Clear the scene
        emptyObject(threeObj);

        // Main three object to manipulate
        state.scene = threeObj;
      },
      update: function update(state) {
        // Data accessors
        var latAccessor = index$1(state.tileLat);
        var lngAccessor = index$1(state.tileLng);
        var altitudeAccessor = index$1(state.tileAltitude);
        var widthAccessor = index$1(state.tileWidth);
        var heightAccessor = index$1(state.tileHeight);
        var useGlobeProjectionAccessor = index$1(state.tileUseGlobeProjection);
        var materialAccessor = index$1(state.tileMaterial);
        var curvatureResolutionAccessor = index$1(state.tileCurvatureResolution);
        threeDigest(state.tilesData, state.scene, {
          createObj: function createObj() {
            var obj = new THREE$6.Mesh();
            obj.__globeObjType = 'tile'; // Add object type

            return obj;
          },
          updateObj: function updateObj(obj, d) {
            obj.material = materialAccessor(d); // set material

            var useGlobeProjection = useGlobeProjectionAccessor(d);
            var curvatureResolution = curvatureResolutionAccessor(d);

            // animations
            var applyPosition = function applyPosition(td) {
              var _obj$__currentTargetD = obj.__currentTargetD = td,
                lat = _obj$__currentTargetD.lat,
                lng = _obj$__currentTargetD.lng,
                alt = _obj$__currentTargetD.alt,
                width = _obj$__currentTargetD.width,
                height = _obj$__currentTargetD.height;
              var rotLng = deg2Rad(lng);
              var rotLat = deg2Rad(-lat);
              obj.geometry && obj.geometry.dispose();
              obj.geometry = new THREE$6.SphereGeometry(GLOBE_RADIUS * (1 + alt), Math.ceil(width / (curvatureResolution || -1)), Math.ceil(height / (curvatureResolution || -1)), deg2Rad(90 - width / 2) + (useGlobeProjection ? rotLng : 0), deg2Rad(width), deg2Rad(90 - height / 2) + (useGlobeProjection ? rotLat : 0), deg2Rad(height));
              if (!useGlobeProjection) {
                // rotate obj instead. order matters, rotate longitudinally first.
                obj.setRotationFromEuler(new THREE$6.Euler(rotLat, rotLng, 0, 'YXZ'));
              }
            };
            var targetD = {
              lat: +latAccessor(d),
              lng: +lngAccessor(d),
              alt: +altitudeAccessor(d),
              width: +widthAccessor(d),
              height: +heightAccessor(d)
            };
            var currentTargetD = obj.__currentTargetD || Object.assign({}, targetD, {
              width: 0,
              height: 0
            });
            if (Object.keys(targetD).some(function (k) {
              return currentTargetD[k] !== targetD[k];
            })) {
              if (!state.tilesTransitionDuration || state.tilesTransitionDuration < 0) {
                // set final position
                applyPosition(targetD);
              } else {
                // animate
                new exports$1.Tween(currentTargetD).to(targetD, state.tilesTransitionDuration).easing(exports$1.Easing.Quadratic.InOut).onUpdate(applyPosition).start();
              }
            }
          }
        });
      }
    });
    var deg2Rad = function deg2Rad(deg) {
      return deg * Math.PI / 180;
    };

    var glyphs={"0":{x_min:73,x_max:715,ha:792,o:"m 394 -29 q 153 129 242 -29 q 73 479 73 272 q 152 829 73 687 q 394 989 241 989 q 634 829 545 989 q 715 479 715 684 q 635 129 715 270 q 394 -29 546 -29 m 394 89 q 546 211 489 89 q 598 479 598 322 q 548 748 598 640 q 394 871 491 871 q 241 748 298 871 q 190 479 190 637 q 239 211 190 319 q 394 89 296 89 "},"1":{x_min:215.671875,x_max:574,ha:792,o:"m 574 0 l 442 0 l 442 697 l 215 697 l 215 796 q 386 833 330 796 q 475 986 447 875 l 574 986 l 574 0 "},"2":{x_min:59,x_max:731,ha:792,o:"m 731 0 l 59 0 q 197 314 59 188 q 457 487 199 315 q 598 691 598 580 q 543 819 598 772 q 411 867 488 867 q 272 811 328 867 q 209 630 209 747 l 81 630 q 182 901 81 805 q 408 986 271 986 q 629 909 536 986 q 731 694 731 826 q 613 449 731 541 q 378 316 495 383 q 201 122 235 234 l 731 122 l 731 0 "},"3":{x_min:54,x_max:737,ha:792,o:"m 737 284 q 635 55 737 141 q 399 -25 541 -25 q 156 52 248 -25 q 54 308 54 140 l 185 308 q 245 147 185 202 q 395 96 302 96 q 539 140 484 96 q 602 280 602 190 q 510 429 602 390 q 324 454 451 454 l 324 565 q 487 584 441 565 q 565 719 565 617 q 515 835 565 791 q 395 879 466 879 q 255 824 307 879 q 203 661 203 769 l 78 661 q 166 909 78 822 q 387 992 250 992 q 603 921 513 992 q 701 723 701 844 q 669 607 701 656 q 578 524 637 558 q 696 434 655 499 q 737 284 737 369 "},"4":{x_min:48,x_max:742.453125,ha:792,o:"m 742 243 l 602 243 l 602 0 l 476 0 l 476 243 l 48 243 l 48 368 l 476 958 l 602 958 l 602 354 l 742 354 l 742 243 m 476 354 l 476 792 l 162 354 l 476 354 "},"5":{x_min:54.171875,x_max:738,ha:792,o:"m 738 314 q 626 60 738 153 q 382 -23 526 -23 q 155 47 248 -23 q 54 256 54 125 l 183 256 q 259 132 204 174 q 382 91 314 91 q 533 149 471 91 q 602 314 602 213 q 538 469 602 411 q 386 528 475 528 q 284 506 332 528 q 197 439 237 484 l 81 439 l 159 958 l 684 958 l 684 840 l 254 840 l 214 579 q 306 627 258 612 q 407 643 354 643 q 636 552 540 643 q 738 314 738 457 "},"6":{x_min:53,x_max:739,ha:792,o:"m 739 312 q 633 62 739 162 q 400 -31 534 -31 q 162 78 257 -31 q 53 439 53 206 q 178 859 53 712 q 441 986 284 986 q 643 912 559 986 q 732 713 732 833 l 601 713 q 544 830 594 786 q 426 875 494 875 q 268 793 331 875 q 193 517 193 697 q 301 597 240 570 q 427 624 362 624 q 643 540 552 624 q 739 312 739 451 m 603 298 q 540 461 603 400 q 404 516 484 516 q 268 461 323 516 q 207 300 207 401 q 269 137 207 198 q 405 83 325 83 q 541 137 486 83 q 603 298 603 197 "},"7":{x_min:58.71875,x_max:730.953125,ha:792,o:"m 730 839 q 469 448 560 641 q 335 0 378 255 l 192 0 q 328 441 235 252 q 593 830 421 630 l 58 830 l 58 958 l 730 958 l 730 839 "},"8":{x_min:55,x_max:736,ha:792,o:"m 571 527 q 694 424 652 491 q 736 280 736 358 q 648 71 736 158 q 395 -26 551 -26 q 142 69 238 -26 q 55 279 55 157 q 96 425 55 359 q 220 527 138 491 q 120 615 153 562 q 88 726 88 668 q 171 904 88 827 q 395 986 261 986 q 618 905 529 986 q 702 727 702 830 q 670 616 702 667 q 571 527 638 565 m 394 565 q 519 610 475 565 q 563 717 563 655 q 521 823 563 781 q 392 872 474 872 q 265 824 312 872 q 224 720 224 783 q 265 613 224 656 q 394 565 312 565 m 395 91 q 545 150 488 91 q 597 280 597 204 q 546 408 597 355 q 395 465 492 465 q 244 408 299 465 q 194 280 194 356 q 244 150 194 203 q 395 91 299 91 "},"9":{x_min:53,x_max:739,ha:792,o:"m 739 524 q 619 94 739 241 q 362 -32 516 -32 q 150 47 242 -32 q 59 244 59 126 l 191 244 q 246 129 191 176 q 373 82 301 82 q 526 161 466 82 q 597 440 597 255 q 363 334 501 334 q 130 432 216 334 q 53 650 53 521 q 134 880 53 786 q 383 986 226 986 q 659 841 566 986 q 739 524 739 719 m 388 449 q 535 514 480 449 q 585 658 585 573 q 535 805 585 744 q 388 873 480 873 q 242 809 294 873 q 191 658 191 745 q 239 514 191 572 q 388 449 292 449 "},"ο":{x_min:0,x_max:712,ha:815,o:"m 356 -25 q 96 88 192 -25 q 0 368 0 201 q 92 642 0 533 q 356 761 192 761 q 617 644 517 761 q 712 368 712 533 q 619 91 712 201 q 356 -25 520 -25 m 356 85 q 527 175 465 85 q 583 369 583 255 q 528 562 583 484 q 356 651 466 651 q 189 560 250 651 q 135 369 135 481 q 187 177 135 257 q 356 85 250 85 "},S:{x_min:0,x_max:788,ha:890,o:"m 788 291 q 662 54 788 144 q 397 -26 550 -26 q 116 68 226 -26 q 0 337 0 168 l 131 337 q 200 152 131 220 q 384 85 269 85 q 557 129 479 85 q 650 270 650 183 q 490 429 650 379 q 194 513 341 470 q 33 739 33 584 q 142 964 33 881 q 388 1041 242 1041 q 644 957 543 1041 q 756 716 756 867 l 625 716 q 561 874 625 816 q 395 933 497 933 q 243 891 309 933 q 164 759 164 841 q 325 609 164 656 q 625 526 475 568 q 788 291 788 454 "},"¦":{x_min:343,x_max:449,ha:792,o:"m 449 462 l 343 462 l 343 986 l 449 986 l 449 462 m 449 -242 l 343 -242 l 343 280 l 449 280 l 449 -242 "},"/":{x_min:183.25,x_max:608.328125,ha:792,o:"m 608 1041 l 266 -129 l 183 -129 l 520 1041 l 608 1041 "},"Τ":{x_min:-0.4375,x_max:777.453125,ha:839,o:"m 777 893 l 458 893 l 458 0 l 319 0 l 319 892 l 0 892 l 0 1013 l 777 1013 l 777 893 "},y:{x_min:0,x_max:684.78125,ha:771,o:"m 684 738 l 388 -83 q 311 -216 356 -167 q 173 -279 252 -279 q 97 -266 133 -279 l 97 -149 q 132 -155 109 -151 q 168 -160 155 -160 q 240 -114 213 -160 q 274 -26 248 -98 l 0 738 l 137 737 l 341 139 l 548 737 l 684 738 "},"Π":{x_min:0,x_max:803,ha:917,o:"m 803 0 l 667 0 l 667 886 l 140 886 l 140 0 l 0 0 l 0 1012 l 803 1012 l 803 0 "},"ΐ":{x_min:-111,x_max:339,ha:361,o:"m 339 800 l 229 800 l 229 925 l 339 925 l 339 800 m -1 800 l -111 800 l -111 925 l -1 925 l -1 800 m 284 3 q 233 -10 258 -5 q 182 -15 207 -15 q 85 26 119 -15 q 42 200 42 79 l 42 737 l 167 737 l 168 215 q 172 141 168 157 q 226 101 183 101 q 248 103 239 101 q 284 112 257 104 l 284 3 m 302 1040 l 113 819 l 30 819 l 165 1040 l 302 1040 "},g:{x_min:0,x_max:686,ha:838,o:"m 686 34 q 586 -213 686 -121 q 331 -306 487 -306 q 131 -252 216 -306 q 31 -84 31 -190 l 155 -84 q 228 -174 166 -138 q 345 -207 284 -207 q 514 -109 454 -207 q 564 89 564 -27 q 461 6 521 36 q 335 -23 401 -23 q 88 100 184 -23 q 0 370 0 215 q 87 634 0 522 q 330 758 183 758 q 457 728 398 758 q 564 644 515 699 l 564 737 l 686 737 l 686 34 m 582 367 q 529 560 582 481 q 358 652 468 652 q 189 561 250 652 q 135 369 135 482 q 189 176 135 255 q 361 85 251 85 q 529 176 468 85 q 582 367 582 255 "},"²":{x_min:0,x_max:442,ha:539,o:"m 442 383 l 0 383 q 91 566 0 492 q 260 668 176 617 q 354 798 354 727 q 315 875 354 845 q 227 905 277 905 q 136 869 173 905 q 99 761 99 833 l 14 761 q 82 922 14 864 q 232 974 141 974 q 379 926 316 974 q 442 797 442 878 q 351 635 442 704 q 183 539 321 611 q 92 455 92 491 l 442 455 l 442 383 "},"–":{x_min:0,x_max:705.5625,ha:803,o:"m 705 334 l 0 334 l 0 410 l 705 410 l 705 334 "},"Κ":{x_min:0,x_max:819.5625,ha:893,o:"m 819 0 l 650 0 l 294 509 l 139 356 l 139 0 l 0 0 l 0 1013 l 139 1013 l 139 526 l 626 1013 l 809 1013 l 395 600 l 819 0 "},"ƒ":{x_min:-46.265625,x_max:392,ha:513,o:"m 392 651 l 259 651 l 79 -279 l -46 -278 l 134 651 l 14 651 l 14 751 l 135 751 q 151 948 135 900 q 304 1041 185 1041 q 334 1040 319 1041 q 392 1034 348 1039 l 392 922 q 337 931 360 931 q 271 883 287 931 q 260 793 260 853 l 260 751 l 392 751 l 392 651 "},e:{x_min:0,x_max:714,ha:813,o:"m 714 326 l 140 326 q 200 157 140 227 q 359 87 260 87 q 488 130 431 87 q 561 245 545 174 l 697 245 q 577 48 670 123 q 358 -26 484 -26 q 97 85 195 -26 q 0 363 0 197 q 94 642 0 529 q 358 765 195 765 q 626 627 529 765 q 714 326 714 503 m 576 429 q 507 583 564 522 q 355 650 445 650 q 206 583 266 650 q 140 429 152 522 l 576 429 "},"ό":{x_min:0,x_max:712,ha:815,o:"m 356 -25 q 94 91 194 -25 q 0 368 0 202 q 92 642 0 533 q 356 761 192 761 q 617 644 517 761 q 712 368 712 533 q 619 91 712 201 q 356 -25 520 -25 m 356 85 q 527 175 465 85 q 583 369 583 255 q 528 562 583 484 q 356 651 466 651 q 189 560 250 651 q 135 369 135 481 q 187 177 135 257 q 356 85 250 85 m 576 1040 l 387 819 l 303 819 l 438 1040 l 576 1040 "},J:{x_min:0,x_max:588,ha:699,o:"m 588 279 q 287 -26 588 -26 q 58 73 126 -26 q 0 327 0 158 l 133 327 q 160 172 133 227 q 288 96 198 96 q 426 171 391 96 q 449 336 449 219 l 449 1013 l 588 1013 l 588 279 "},"»":{x_min:-1,x_max:503,ha:601,o:"m 503 302 l 280 136 l 281 256 l 429 373 l 281 486 l 280 608 l 503 440 l 503 302 m 221 302 l 0 136 l 0 255 l 145 372 l 0 486 l -1 608 l 221 440 l 221 302 "},"©":{x_min:-3,x_max:1008,ha:1106,o:"m 502 -7 q 123 151 263 -7 q -3 501 -3 294 q 123 851 -3 706 q 502 1011 263 1011 q 881 851 739 1011 q 1008 501 1008 708 q 883 151 1008 292 q 502 -7 744 -7 m 502 60 q 830 197 709 60 q 940 501 940 322 q 831 805 940 681 q 502 944 709 944 q 174 805 296 944 q 65 501 65 680 q 173 197 65 320 q 502 60 294 60 m 741 394 q 661 246 731 302 q 496 190 591 190 q 294 285 369 190 q 228 497 228 370 q 295 714 228 625 q 499 813 370 813 q 656 762 588 813 q 733 625 724 711 l 634 625 q 589 704 629 673 q 498 735 550 735 q 377 666 421 735 q 334 504 334 597 q 374 340 334 408 q 490 272 415 272 q 589 304 549 272 q 638 394 628 337 l 741 394 "},"ώ":{x_min:0,x_max:922,ha:1030,o:"m 687 1040 l 498 819 l 415 819 l 549 1040 l 687 1040 m 922 339 q 856 97 922 203 q 650 -26 780 -26 q 538 9 587 -26 q 461 103 489 44 q 387 12 436 46 q 277 -22 339 -22 q 69 97 147 -22 q 0 338 0 202 q 45 551 0 444 q 161 737 84 643 l 302 737 q 175 552 219 647 q 124 336 124 446 q 155 179 124 248 q 275 88 197 88 q 375 163 341 88 q 400 294 400 219 l 400 572 l 524 572 l 524 294 q 561 135 524 192 q 643 88 591 88 q 762 182 719 88 q 797 341 797 257 q 745 555 797 450 q 619 737 705 637 l 760 737 q 874 551 835 640 q 922 339 922 444 "},"^":{x_min:193.0625,x_max:598.609375,ha:792,o:"m 598 772 l 515 772 l 395 931 l 277 772 l 193 772 l 326 1013 l 462 1013 l 598 772 "},"«":{x_min:0,x_max:507.203125,ha:604,o:"m 506 136 l 284 302 l 284 440 l 506 608 l 507 485 l 360 371 l 506 255 l 506 136 m 222 136 l 0 302 l 0 440 l 222 608 l 221 486 l 73 373 l 222 256 l 222 136 "},D:{x_min:0,x_max:828,ha:935,o:"m 389 1013 q 714 867 593 1013 q 828 521 828 729 q 712 161 828 309 q 382 0 587 0 l 0 0 l 0 1013 l 389 1013 m 376 124 q 607 247 523 124 q 681 510 681 355 q 607 771 681 662 q 376 896 522 896 l 139 896 l 139 124 l 376 124 "},"∙":{x_min:0,x_max:142,ha:239,o:"m 142 585 l 0 585 l 0 738 l 142 738 l 142 585 "},"ÿ":{x_min:0,x_max:47,ha:125,o:"m 47 3 q 37 -7 47 -7 q 28 0 30 -7 q 39 -4 32 -4 q 45 3 45 -1 l 37 0 q 28 9 28 0 q 39 19 28 19 l 47 16 l 47 19 l 47 3 m 37 1 q 44 8 44 1 q 37 16 44 16 q 30 8 30 16 q 37 1 30 1 m 26 1 l 23 22 l 14 0 l 3 22 l 3 3 l 0 25 l 13 1 l 22 25 l 26 1 "},w:{x_min:0,x_max:1009.71875,ha:1100,o:"m 1009 738 l 783 0 l 658 0 l 501 567 l 345 0 l 222 0 l 0 738 l 130 738 l 284 174 l 432 737 l 576 738 l 721 173 l 881 737 l 1009 738 "},$:{x_min:0,x_max:700,ha:793,o:"m 664 717 l 542 717 q 490 825 531 785 q 381 872 450 865 l 381 551 q 620 446 540 522 q 700 241 700 370 q 618 45 700 116 q 381 -25 536 -25 l 381 -152 l 307 -152 l 307 -25 q 81 62 162 -25 q 0 297 0 149 l 124 297 q 169 146 124 204 q 307 81 215 89 l 307 441 q 80 536 148 469 q 13 725 13 603 q 96 910 13 839 q 307 982 180 982 l 307 1077 l 381 1077 l 381 982 q 574 917 494 982 q 664 717 664 845 m 307 565 l 307 872 q 187 831 233 872 q 142 724 142 791 q 180 618 142 656 q 307 565 218 580 m 381 76 q 562 237 562 96 q 517 361 562 313 q 381 423 472 409 l 381 76 "},"\\":{x_min:-0.015625,x_max:425.0625,ha:522,o:"m 425 -129 l 337 -129 l 0 1041 l 83 1041 l 425 -129 "},"µ":{x_min:0,x_max:697.21875,ha:747,o:"m 697 -4 q 629 -14 658 -14 q 498 97 513 -14 q 422 9 470 41 q 313 -23 374 -23 q 207 4 258 -23 q 119 81 156 32 l 119 -278 l 0 -278 l 0 738 l 124 738 l 124 343 q 165 173 124 246 q 308 83 216 83 q 452 178 402 83 q 493 359 493 255 l 493 738 l 617 738 l 617 214 q 623 136 617 160 q 673 92 637 92 q 697 96 684 92 l 697 -4 "},"Ι":{x_min:42,x_max:181,ha:297,o:"m 181 0 l 42 0 l 42 1013 l 181 1013 l 181 0 "},"Ύ":{x_min:0,x_max:1144.5,ha:1214,o:"m 1144 1012 l 807 416 l 807 0 l 667 0 l 667 416 l 325 1012 l 465 1012 l 736 533 l 1004 1012 l 1144 1012 m 277 1040 l 83 799 l 0 799 l 140 1040 l 277 1040 "},"’":{x_min:0,x_max:139,ha:236,o:"m 139 851 q 102 737 139 784 q 0 669 65 690 l 0 734 q 59 787 42 741 q 72 873 72 821 l 0 873 l 0 1013 l 139 1013 l 139 851 "},"Ν":{x_min:0,x_max:801,ha:915,o:"m 801 0 l 651 0 l 131 822 l 131 0 l 0 0 l 0 1013 l 151 1013 l 670 191 l 670 1013 l 801 1013 l 801 0 "},"-":{x_min:8.71875,x_max:350.390625,ha:478,o:"m 350 317 l 8 317 l 8 428 l 350 428 l 350 317 "},Q:{x_min:0,x_max:968,ha:1072,o:"m 954 5 l 887 -79 l 744 35 q 622 -11 687 2 q 483 -26 556 -26 q 127 130 262 -26 q 0 504 0 279 q 127 880 0 728 q 484 1041 262 1041 q 841 884 708 1041 q 968 507 968 735 q 933 293 968 398 q 832 104 899 188 l 954 5 m 723 191 q 802 330 777 248 q 828 499 828 412 q 744 790 828 673 q 483 922 650 922 q 228 791 322 922 q 142 505 142 673 q 227 221 142 337 q 487 91 323 91 q 632 123 566 91 l 520 215 l 587 301 l 723 191 "},"ς":{x_min:1,x_max:676.28125,ha:740,o:"m 676 460 l 551 460 q 498 595 542 546 q 365 651 448 651 q 199 578 263 651 q 136 401 136 505 q 266 178 136 241 q 508 106 387 142 q 640 -50 640 62 q 625 -158 640 -105 q 583 -278 611 -211 l 465 -278 q 498 -182 490 -211 q 515 -80 515 -126 q 381 12 515 -15 q 134 91 197 51 q 1 388 1 179 q 100 651 1 542 q 354 761 199 761 q 587 680 498 761 q 676 460 676 599 "},M:{x_min:0,x_max:954,ha:1067,o:"m 954 0 l 819 0 l 819 869 l 537 0 l 405 0 l 128 866 l 128 0 l 0 0 l 0 1013 l 200 1013 l 472 160 l 757 1013 l 954 1013 l 954 0 "},"Ψ":{x_min:0,x_max:1006,ha:1094,o:"m 1006 678 q 914 319 1006 429 q 571 200 814 200 l 571 0 l 433 0 l 433 200 q 92 319 194 200 q 0 678 0 429 l 0 1013 l 139 1013 l 139 679 q 191 417 139 492 q 433 326 255 326 l 433 1013 l 571 1013 l 571 326 l 580 326 q 813 423 747 326 q 868 679 868 502 l 868 1013 l 1006 1013 l 1006 678 "},C:{x_min:0,x_max:886,ha:944,o:"m 886 379 q 760 87 886 201 q 455 -26 634 -26 q 112 136 236 -26 q 0 509 0 283 q 118 882 0 737 q 469 1041 245 1041 q 748 955 630 1041 q 879 708 879 859 l 745 708 q 649 862 724 805 q 473 920 573 920 q 219 791 312 920 q 136 509 136 675 q 217 229 136 344 q 470 99 311 99 q 672 179 591 99 q 753 379 753 259 l 886 379 "},"!":{x_min:0,x_max:138,ha:236,o:"m 138 684 q 116 409 138 629 q 105 244 105 299 l 33 244 q 16 465 33 313 q 0 684 0 616 l 0 1013 l 138 1013 l 138 684 m 138 0 l 0 0 l 0 151 l 138 151 l 138 0 "},"{":{x_min:0,x_max:480.5625,ha:578,o:"m 480 -286 q 237 -213 303 -286 q 187 -45 187 -159 q 194 48 187 -15 q 201 141 201 112 q 164 264 201 225 q 0 314 118 314 l 0 417 q 164 471 119 417 q 201 605 201 514 q 199 665 201 644 q 193 772 193 769 q 241 941 193 887 q 480 1015 308 1015 l 480 915 q 336 866 375 915 q 306 742 306 828 q 310 662 306 717 q 314 577 314 606 q 288 452 314 500 q 176 365 256 391 q 289 275 257 337 q 314 143 314 226 q 313 84 314 107 q 310 -11 310 -5 q 339 -131 310 -94 q 480 -182 377 -182 l 480 -286 "},X:{x_min:-0.015625,x_max:854.15625,ha:940,o:"m 854 0 l 683 0 l 423 409 l 166 0 l 0 0 l 347 519 l 18 1013 l 186 1013 l 428 637 l 675 1013 l 836 1013 l 504 520 l 854 0 "},"#":{x_min:0,x_max:963.890625,ha:1061,o:"m 963 690 l 927 590 l 719 590 l 655 410 l 876 410 l 840 310 l 618 310 l 508 -3 l 393 -2 l 506 309 l 329 310 l 215 -2 l 102 -3 l 212 310 l 0 310 l 36 410 l 248 409 l 312 590 l 86 590 l 120 690 l 347 690 l 459 1006 l 573 1006 l 462 690 l 640 690 l 751 1006 l 865 1006 l 754 690 l 963 690 m 606 590 l 425 590 l 362 410 l 543 410 l 606 590 "},"ι":{x_min:42,x_max:284,ha:361,o:"m 284 3 q 233 -10 258 -5 q 182 -15 207 -15 q 85 26 119 -15 q 42 200 42 79 l 42 738 l 167 738 l 168 215 q 172 141 168 157 q 226 101 183 101 q 248 103 239 101 q 284 112 257 104 l 284 3 "},"Ά":{x_min:0,x_max:906.953125,ha:982,o:"m 283 1040 l 88 799 l 5 799 l 145 1040 l 283 1040 m 906 0 l 756 0 l 650 303 l 251 303 l 143 0 l 0 0 l 376 1012 l 529 1012 l 906 0 m 609 421 l 452 866 l 293 421 l 609 421 "},")":{x_min:0,x_max:318,ha:415,o:"m 318 365 q 257 25 318 191 q 87 -290 197 -141 l 0 -290 q 140 21 93 -128 q 193 360 193 189 q 141 704 193 537 q 0 1024 97 850 l 87 1024 q 257 706 197 871 q 318 365 318 542 "},"ε":{x_min:0,x_max:634.71875,ha:714,o:"m 634 234 q 527 38 634 110 q 300 -25 433 -25 q 98 29 183 -25 q 0 204 0 93 q 37 314 0 265 q 128 390 67 353 q 56 460 82 419 q 26 555 26 505 q 114 712 26 654 q 295 763 191 763 q 499 700 416 763 q 589 515 589 631 l 478 515 q 419 618 464 580 q 307 657 374 657 q 207 630 253 657 q 151 547 151 598 q 238 445 151 469 q 389 434 280 434 l 389 331 l 349 331 q 206 315 255 331 q 125 210 125 287 q 183 107 125 145 q 302 76 233 76 q 436 117 379 76 q 509 234 493 159 l 634 234 "},"Δ":{x_min:0,x_max:952.78125,ha:1028,o:"m 952 0 l 0 0 l 400 1013 l 551 1013 l 952 0 m 762 124 l 476 867 l 187 124 l 762 124 "},"}":{x_min:0,x_max:481,ha:578,o:"m 481 314 q 318 262 364 314 q 282 136 282 222 q 284 65 282 97 q 293 -58 293 -48 q 241 -217 293 -166 q 0 -286 174 -286 l 0 -182 q 143 -130 105 -182 q 171 -2 171 -93 q 168 81 171 22 q 165 144 165 140 q 188 275 165 229 q 306 365 220 339 q 191 455 224 391 q 165 588 165 505 q 168 681 165 624 q 171 742 171 737 q 141 865 171 827 q 0 915 102 915 l 0 1015 q 243 942 176 1015 q 293 773 293 888 q 287 675 293 741 q 282 590 282 608 q 318 466 282 505 q 481 417 364 417 l 481 314 "},"‰":{x_min:-3,x_max:1672,ha:1821,o:"m 846 0 q 664 76 732 0 q 603 244 603 145 q 662 412 603 344 q 846 489 729 489 q 1027 412 959 489 q 1089 244 1089 343 q 1029 76 1089 144 q 846 0 962 0 m 845 103 q 945 143 910 103 q 981 243 981 184 q 947 340 981 301 q 845 385 910 385 q 745 342 782 385 q 709 243 709 300 q 742 147 709 186 q 845 103 781 103 m 888 986 l 284 -25 l 199 -25 l 803 986 l 888 986 m 241 468 q 58 545 126 468 q -3 715 -3 615 q 56 881 -3 813 q 238 958 124 958 q 421 881 353 958 q 483 712 483 813 q 423 544 483 612 q 241 468 356 468 m 241 855 q 137 811 175 855 q 100 710 100 768 q 136 612 100 653 q 240 572 172 572 q 344 614 306 572 q 382 713 382 656 q 347 810 382 771 q 241 855 308 855 m 1428 0 q 1246 76 1314 0 q 1185 244 1185 145 q 1244 412 1185 344 q 1428 489 1311 489 q 1610 412 1542 489 q 1672 244 1672 343 q 1612 76 1672 144 q 1428 0 1545 0 m 1427 103 q 1528 143 1492 103 q 1564 243 1564 184 q 1530 340 1564 301 q 1427 385 1492 385 q 1327 342 1364 385 q 1291 243 1291 300 q 1324 147 1291 186 q 1427 103 1363 103 "},a:{x_min:0,x_max:698.609375,ha:794,o:"m 698 0 q 661 -12 679 -7 q 615 -17 643 -17 q 536 12 564 -17 q 500 96 508 41 q 384 6 456 37 q 236 -25 312 -25 q 65 31 130 -25 q 0 194 0 88 q 118 390 0 334 q 328 435 180 420 q 488 483 476 451 q 495 523 495 504 q 442 619 495 584 q 325 654 389 654 q 209 617 257 654 q 152 513 161 580 l 33 513 q 123 705 33 633 q 332 772 207 772 q 528 712 448 772 q 617 531 617 645 l 617 163 q 624 108 617 126 q 664 90 632 90 l 698 94 l 698 0 m 491 262 l 491 372 q 272 329 350 347 q 128 201 128 294 q 166 113 128 144 q 264 83 205 83 q 414 130 346 83 q 491 262 491 183 "},"—":{x_min:0,x_max:941.671875,ha:1039,o:"m 941 334 l 0 334 l 0 410 l 941 410 l 941 334 "},"=":{x_min:8.71875,x_max:780.953125,ha:792,o:"m 780 510 l 8 510 l 8 606 l 780 606 l 780 510 m 780 235 l 8 235 l 8 332 l 780 332 l 780 235 "},N:{x_min:0,x_max:801,ha:914,o:"m 801 0 l 651 0 l 131 823 l 131 0 l 0 0 l 0 1013 l 151 1013 l 670 193 l 670 1013 l 801 1013 l 801 0 "},"ρ":{x_min:0,x_max:712,ha:797,o:"m 712 369 q 620 94 712 207 q 362 -26 521 -26 q 230 2 292 -26 q 119 83 167 30 l 119 -278 l 0 -278 l 0 362 q 91 643 0 531 q 355 764 190 764 q 617 647 517 764 q 712 369 712 536 m 583 366 q 530 559 583 480 q 359 651 469 651 q 190 562 252 651 q 135 370 135 483 q 189 176 135 257 q 359 85 250 85 q 528 175 466 85 q 583 366 583 254 "},"¯":{x_min:0,x_max:941.671875,ha:938,o:"m 941 1033 l 0 1033 l 0 1109 l 941 1109 l 941 1033 "},Z:{x_min:0,x_max:779,ha:849,o:"m 779 0 l 0 0 l 0 113 l 621 896 l 40 896 l 40 1013 l 779 1013 l 778 887 l 171 124 l 779 124 l 779 0 "},u:{x_min:0,x_max:617,ha:729,o:"m 617 0 l 499 0 l 499 110 q 391 10 460 45 q 246 -25 322 -25 q 61 58 127 -25 q 0 258 0 136 l 0 738 l 125 738 l 125 284 q 156 148 125 202 q 273 82 197 82 q 433 165 369 82 q 493 340 493 243 l 493 738 l 617 738 l 617 0 "},k:{x_min:0,x_max:612.484375,ha:697,o:"m 612 738 l 338 465 l 608 0 l 469 0 l 251 382 l 121 251 l 121 0 l 0 0 l 0 1013 l 121 1013 l 121 402 l 456 738 l 612 738 "},"Η":{x_min:0,x_max:803,ha:917,o:"m 803 0 l 667 0 l 667 475 l 140 475 l 140 0 l 0 0 l 0 1013 l 140 1013 l 140 599 l 667 599 l 667 1013 l 803 1013 l 803 0 "},"Α":{x_min:0,x_max:906.953125,ha:985,o:"m 906 0 l 756 0 l 650 303 l 251 303 l 143 0 l 0 0 l 376 1013 l 529 1013 l 906 0 m 609 421 l 452 866 l 293 421 l 609 421 "},s:{x_min:0,x_max:604,ha:697,o:"m 604 217 q 501 36 604 104 q 292 -23 411 -23 q 86 43 166 -23 q 0 238 0 114 l 121 237 q 175 122 121 164 q 300 85 223 85 q 415 112 363 85 q 479 207 479 147 q 361 309 479 276 q 140 372 141 370 q 21 544 21 426 q 111 708 21 647 q 298 761 190 761 q 492 705 413 761 q 583 531 583 643 l 462 531 q 412 625 462 594 q 298 657 363 657 q 199 636 242 657 q 143 558 143 608 q 262 454 143 486 q 484 394 479 397 q 604 217 604 341 "},B:{x_min:0,x_max:778,ha:876,o:"m 580 546 q 724 469 670 535 q 778 311 778 403 q 673 83 778 171 q 432 0 575 0 l 0 0 l 0 1013 l 411 1013 q 629 957 541 1013 q 732 768 732 892 q 691 633 732 693 q 580 546 650 572 m 393 899 l 139 899 l 139 588 l 379 588 q 521 624 462 588 q 592 744 592 667 q 531 859 592 819 q 393 899 471 899 m 419 124 q 566 169 504 124 q 635 303 635 219 q 559 436 635 389 q 402 477 494 477 l 139 477 l 139 124 l 419 124 "},"…":{x_min:0,x_max:614,ha:708,o:"m 142 0 l 0 0 l 0 151 l 142 151 l 142 0 m 378 0 l 236 0 l 236 151 l 378 151 l 378 0 m 614 0 l 472 0 l 472 151 l 614 151 l 614 0 "},"?":{x_min:0,x_max:607,ha:704,o:"m 607 777 q 543 599 607 674 q 422 474 482 537 q 357 272 357 391 l 236 272 q 297 487 236 395 q 411 619 298 490 q 474 762 474 691 q 422 885 474 838 q 301 933 371 933 q 179 880 228 933 q 124 706 124 819 l 0 706 q 94 963 0 872 q 302 1044 177 1044 q 511 973 423 1044 q 607 777 607 895 m 370 0 l 230 0 l 230 151 l 370 151 l 370 0 "},H:{x_min:0,x_max:803,ha:915,o:"m 803 0 l 667 0 l 667 475 l 140 475 l 140 0 l 0 0 l 0 1013 l 140 1013 l 140 599 l 667 599 l 667 1013 l 803 1013 l 803 0 "},"ν":{x_min:0,x_max:675,ha:761,o:"m 675 738 l 404 0 l 272 0 l 0 738 l 133 738 l 340 147 l 541 738 l 675 738 "},c:{x_min:1,x_max:701.390625,ha:775,o:"m 701 264 q 584 53 681 133 q 353 -26 487 -26 q 91 91 188 -26 q 1 370 1 201 q 92 645 1 537 q 353 761 190 761 q 572 688 479 761 q 690 493 666 615 l 556 493 q 487 606 545 562 q 356 650 428 650 q 186 563 246 650 q 134 372 134 487 q 188 179 134 258 q 359 88 250 88 q 492 136 437 88 q 566 264 548 185 l 701 264 "},"¶":{x_min:0,x_max:566.671875,ha:678,o:"m 21 892 l 52 892 l 98 761 l 145 892 l 176 892 l 178 741 l 157 741 l 157 867 l 108 741 l 88 741 l 40 871 l 40 741 l 21 741 l 21 892 m 308 854 l 308 731 q 252 691 308 691 q 227 691 240 691 q 207 696 213 695 l 207 712 l 253 706 q 288 733 288 706 l 288 763 q 244 741 279 741 q 193 797 193 741 q 261 860 193 860 q 287 860 273 860 q 308 854 302 855 m 288 842 l 263 843 q 213 796 213 843 q 248 756 213 756 q 288 796 288 756 l 288 842 m 566 988 l 502 988 l 502 -1 l 439 -1 l 439 988 l 317 988 l 317 -1 l 252 -1 l 252 602 q 81 653 155 602 q 0 805 0 711 q 101 989 0 918 q 309 1053 194 1053 l 566 1053 l 566 988 "},"β":{x_min:0,x_max:660,ha:745,o:"m 471 550 q 610 450 561 522 q 660 280 660 378 q 578 64 660 151 q 367 -22 497 -22 q 239 5 299 -22 q 126 82 178 32 l 126 -278 l 0 -278 l 0 593 q 54 903 0 801 q 318 1042 127 1042 q 519 964 436 1042 q 603 771 603 887 q 567 644 603 701 q 471 550 532 586 m 337 79 q 476 138 418 79 q 535 279 535 198 q 427 437 535 386 q 226 477 344 477 l 226 583 q 398 620 329 583 q 486 762 486 668 q 435 884 486 833 q 312 935 384 935 q 169 861 219 935 q 126 698 126 797 l 126 362 q 170 169 126 242 q 337 79 224 79 "},"Μ":{x_min:0,x_max:954,ha:1068,o:"m 954 0 l 819 0 l 819 868 l 537 0 l 405 0 l 128 865 l 128 0 l 0 0 l 0 1013 l 199 1013 l 472 158 l 758 1013 l 954 1013 l 954 0 "},"Ό":{x_min:0.109375,x_max:1120,ha:1217,o:"m 1120 505 q 994 132 1120 282 q 642 -29 861 -29 q 290 130 422 -29 q 167 505 167 280 q 294 883 167 730 q 650 1046 430 1046 q 999 882 868 1046 q 1120 505 1120 730 m 977 504 q 896 784 977 669 q 644 915 804 915 q 391 785 484 915 q 307 504 307 669 q 391 224 307 339 q 644 95 486 95 q 894 224 803 95 q 977 504 977 339 m 277 1040 l 83 799 l 0 799 l 140 1040 l 277 1040 "},"Ή":{x_min:0,x_max:1158,ha:1275,o:"m 1158 0 l 1022 0 l 1022 475 l 496 475 l 496 0 l 356 0 l 356 1012 l 496 1012 l 496 599 l 1022 599 l 1022 1012 l 1158 1012 l 1158 0 m 277 1040 l 83 799 l 0 799 l 140 1040 l 277 1040 "},"•":{x_min:0,x_max:663.890625,ha:775,o:"m 663 529 q 566 293 663 391 q 331 196 469 196 q 97 294 194 196 q 0 529 0 393 q 96 763 0 665 q 331 861 193 861 q 566 763 469 861 q 663 529 663 665 "},"¥":{x_min:0.1875,x_max:819.546875,ha:886,o:"m 563 561 l 697 561 l 696 487 l 520 487 l 482 416 l 482 380 l 697 380 l 695 308 l 482 308 l 482 0 l 342 0 l 342 308 l 125 308 l 125 380 l 342 380 l 342 417 l 303 487 l 125 487 l 125 561 l 258 561 l 0 1013 l 140 1013 l 411 533 l 679 1013 l 819 1013 l 563 561 "},"(":{x_min:0,x_max:318.0625,ha:415,o:"m 318 -290 l 230 -290 q 61 23 122 -142 q 0 365 0 190 q 62 712 0 540 q 230 1024 119 869 l 318 1024 q 175 705 219 853 q 125 360 125 542 q 176 22 125 187 q 318 -290 223 -127 "},U:{x_min:0,x_max:796,ha:904,o:"m 796 393 q 681 93 796 212 q 386 -25 566 -25 q 101 95 208 -25 q 0 393 0 211 l 0 1013 l 138 1013 l 138 391 q 204 191 138 270 q 394 107 276 107 q 586 191 512 107 q 656 391 656 270 l 656 1013 l 796 1013 l 796 393 "},"γ":{x_min:0.5,x_max:744.953125,ha:822,o:"m 744 737 l 463 54 l 463 -278 l 338 -278 l 338 54 l 154 495 q 104 597 124 569 q 13 651 67 651 l 0 651 l 0 751 l 39 753 q 168 711 121 753 q 242 594 207 676 l 403 208 l 617 737 l 744 737 "},"α":{x_min:0,x_max:765.5625,ha:809,o:"m 765 -4 q 698 -14 726 -14 q 564 97 586 -14 q 466 7 525 40 q 337 -26 407 -26 q 88 98 186 -26 q 0 369 0 212 q 88 637 0 525 q 337 760 184 760 q 465 728 407 760 q 563 637 524 696 l 563 739 l 685 739 l 685 222 q 693 141 685 168 q 748 94 708 94 q 765 96 760 94 l 765 -4 m 584 371 q 531 562 584 485 q 360 653 470 653 q 192 566 254 653 q 135 379 135 489 q 186 181 135 261 q 358 84 247 84 q 528 176 465 84 q 584 371 584 260 "},F:{x_min:0,x_max:683.328125,ha:717,o:"m 683 888 l 140 888 l 140 583 l 613 583 l 613 458 l 140 458 l 140 0 l 0 0 l 0 1013 l 683 1013 l 683 888 "},"­":{x_min:0,x_max:705.5625,ha:803,o:"m 705 334 l 0 334 l 0 410 l 705 410 l 705 334 "},":":{x_min:0,x_max:142,ha:239,o:"m 142 585 l 0 585 l 0 738 l 142 738 l 142 585 m 142 0 l 0 0 l 0 151 l 142 151 l 142 0 "},"Χ":{x_min:0,x_max:854.171875,ha:935,o:"m 854 0 l 683 0 l 423 409 l 166 0 l 0 0 l 347 519 l 18 1013 l 186 1013 l 427 637 l 675 1013 l 836 1013 l 504 521 l 854 0 "},"*":{x_min:116,x_max:674,ha:792,o:"m 674 768 l 475 713 l 610 544 l 517 477 l 394 652 l 272 478 l 178 544 l 314 713 l 116 766 l 153 876 l 341 812 l 342 1013 l 446 1013 l 446 811 l 635 874 l 674 768 "},"†":{x_min:0,x_max:777,ha:835,o:"m 458 804 l 777 804 l 777 683 l 458 683 l 458 0 l 319 0 l 319 681 l 0 683 l 0 804 l 319 804 l 319 1015 l 458 1013 l 458 804 "},"°":{x_min:0,x_max:347,ha:444,o:"m 173 802 q 43 856 91 802 q 0 977 0 905 q 45 1101 0 1049 q 173 1153 90 1153 q 303 1098 255 1153 q 347 977 347 1049 q 303 856 347 905 q 173 802 256 802 m 173 884 q 238 910 214 884 q 262 973 262 937 q 239 1038 262 1012 q 173 1064 217 1064 q 108 1037 132 1064 q 85 973 85 1010 q 108 910 85 937 q 173 884 132 884 "},V:{x_min:0,x_max:862.71875,ha:940,o:"m 862 1013 l 505 0 l 361 0 l 0 1013 l 143 1013 l 434 165 l 718 1012 l 862 1013 "},"Ξ":{x_min:0,x_max:734.71875,ha:763,o:"m 723 889 l 9 889 l 9 1013 l 723 1013 l 723 889 m 673 463 l 61 463 l 61 589 l 673 589 l 673 463 m 734 0 l 0 0 l 0 124 l 734 124 l 734 0 "}," ":{x_min:0,x_max:0,ha:853},"Ϋ":{x_min:0.328125,x_max:819.515625,ha:889,o:"m 588 1046 l 460 1046 l 460 1189 l 588 1189 l 588 1046 m 360 1046 l 232 1046 l 232 1189 l 360 1189 l 360 1046 m 819 1012 l 482 416 l 482 0 l 342 0 l 342 416 l 0 1012 l 140 1012 l 411 533 l 679 1012 l 819 1012 "},"”":{x_min:0,x_max:347,ha:454,o:"m 139 851 q 102 737 139 784 q 0 669 65 690 l 0 734 q 59 787 42 741 q 72 873 72 821 l 0 873 l 0 1013 l 139 1013 l 139 851 m 347 851 q 310 737 347 784 q 208 669 273 690 l 208 734 q 267 787 250 741 q 280 873 280 821 l 208 873 l 208 1013 l 347 1013 l 347 851 "},"@":{x_min:0,x_max:1260,ha:1357,o:"m 1098 -45 q 877 -160 1001 -117 q 633 -203 752 -203 q 155 -29 327 -203 q 0 360 0 127 q 176 802 0 616 q 687 1008 372 1008 q 1123 854 969 1008 q 1260 517 1260 718 q 1155 216 1260 341 q 868 82 1044 82 q 772 106 801 82 q 737 202 737 135 q 647 113 700 144 q 527 82 594 82 q 367 147 420 82 q 314 312 314 212 q 401 565 314 452 q 639 690 498 690 q 810 588 760 690 l 849 668 l 938 668 q 877 441 900 532 q 833 226 833 268 q 853 182 833 198 q 902 167 873 167 q 1088 272 1012 167 q 1159 512 1159 372 q 1051 793 1159 681 q 687 925 925 925 q 248 747 415 925 q 97 361 97 586 q 226 26 97 159 q 627 -122 370 -122 q 856 -87 737 -122 q 1061 8 976 -53 l 1098 -45 m 786 488 q 738 580 777 545 q 643 615 700 615 q 483 517 548 615 q 425 322 425 430 q 457 203 425 250 q 552 156 490 156 q 722 273 665 156 q 786 488 738 309 "},"Ί":{x_min:0,x_max:499,ha:613,o:"m 277 1040 l 83 799 l 0 799 l 140 1040 l 277 1040 m 499 0 l 360 0 l 360 1012 l 499 1012 l 499 0 "},i:{x_min:14,x_max:136,ha:275,o:"m 136 873 l 14 873 l 14 1013 l 136 1013 l 136 873 m 136 0 l 14 0 l 14 737 l 136 737 l 136 0 "},"Β":{x_min:0,x_max:778,ha:877,o:"m 580 545 q 724 468 671 534 q 778 310 778 402 q 673 83 778 170 q 432 0 575 0 l 0 0 l 0 1013 l 411 1013 q 629 957 541 1013 q 732 768 732 891 q 691 632 732 692 q 580 545 650 571 m 393 899 l 139 899 l 139 587 l 379 587 q 521 623 462 587 q 592 744 592 666 q 531 859 592 819 q 393 899 471 899 m 419 124 q 566 169 504 124 q 635 302 635 219 q 559 435 635 388 q 402 476 494 476 l 139 476 l 139 124 l 419 124 "},"υ":{x_min:0,x_max:617,ha:725,o:"m 617 352 q 540 94 617 199 q 308 -24 455 -24 q 76 94 161 -24 q 0 352 0 199 l 0 739 l 126 739 l 126 355 q 169 185 126 257 q 312 98 220 98 q 451 185 402 98 q 492 355 492 257 l 492 739 l 617 739 l 617 352 "},"]":{x_min:0,x_max:275,ha:372,o:"m 275 -281 l 0 -281 l 0 -187 l 151 -187 l 151 920 l 0 920 l 0 1013 l 275 1013 l 275 -281 "},m:{x_min:0,x_max:1019,ha:1128,o:"m 1019 0 l 897 0 l 897 454 q 860 591 897 536 q 739 660 816 660 q 613 586 659 660 q 573 436 573 522 l 573 0 l 447 0 l 447 455 q 412 591 447 535 q 294 657 372 657 q 165 586 213 657 q 122 437 122 521 l 122 0 l 0 0 l 0 738 l 117 738 l 117 640 q 202 730 150 697 q 316 763 254 763 q 437 730 381 763 q 525 642 494 697 q 621 731 559 700 q 753 763 682 763 q 943 694 867 763 q 1019 512 1019 625 l 1019 0 "},"χ":{x_min:8.328125,x_max:780.5625,ha:815,o:"m 780 -278 q 715 -294 747 -294 q 616 -257 663 -294 q 548 -175 576 -227 l 379 133 l 143 -277 l 9 -277 l 313 254 l 163 522 q 127 586 131 580 q 36 640 91 640 q 8 637 27 640 l 8 752 l 52 757 q 162 719 113 757 q 236 627 200 690 l 383 372 l 594 737 l 726 737 l 448 250 l 625 -69 q 670 -153 647 -110 q 743 -188 695 -188 q 780 -184 759 -188 l 780 -278 "},"ί":{x_min:42,x_max:326.71875,ha:361,o:"m 284 3 q 233 -10 258 -5 q 182 -15 207 -15 q 85 26 119 -15 q 42 200 42 79 l 42 737 l 167 737 l 168 215 q 172 141 168 157 q 226 101 183 101 q 248 102 239 101 q 284 112 257 104 l 284 3 m 326 1040 l 137 819 l 54 819 l 189 1040 l 326 1040 "},"Ζ":{x_min:0,x_max:779.171875,ha:850,o:"m 779 0 l 0 0 l 0 113 l 620 896 l 40 896 l 40 1013 l 779 1013 l 779 887 l 170 124 l 779 124 l 779 0 "},R:{x_min:0,x_max:781.953125,ha:907,o:"m 781 0 l 623 0 q 587 242 590 52 q 407 433 585 433 l 138 433 l 138 0 l 0 0 l 0 1013 l 396 1013 q 636 946 539 1013 q 749 731 749 868 q 711 597 749 659 q 608 502 674 534 q 718 370 696 474 q 729 207 722 352 q 781 26 736 62 l 781 0 m 373 551 q 533 594 465 551 q 614 731 614 645 q 532 859 614 815 q 373 896 465 896 l 138 896 l 138 551 l 373 551 "},o:{x_min:0,x_max:713,ha:821,o:"m 357 -25 q 94 91 194 -25 q 0 368 0 202 q 93 642 0 533 q 357 761 193 761 q 618 644 518 761 q 713 368 713 533 q 619 91 713 201 q 357 -25 521 -25 m 357 85 q 528 175 465 85 q 584 369 584 255 q 529 562 584 484 q 357 651 467 651 q 189 560 250 651 q 135 369 135 481 q 187 177 135 257 q 357 85 250 85 "},K:{x_min:0,x_max:819.46875,ha:906,o:"m 819 0 l 649 0 l 294 509 l 139 355 l 139 0 l 0 0 l 0 1013 l 139 1013 l 139 526 l 626 1013 l 809 1013 l 395 600 l 819 0 "},",":{x_min:0,x_max:142,ha:239,o:"m 142 -12 q 105 -132 142 -82 q 0 -205 68 -182 l 0 -138 q 57 -82 40 -124 q 70 0 70 -51 l 0 0 l 0 151 l 142 151 l 142 -12 "},d:{x_min:0,x_max:683,ha:796,o:"m 683 0 l 564 0 l 564 93 q 456 6 516 38 q 327 -25 395 -25 q 87 100 181 -25 q 0 365 0 215 q 90 639 0 525 q 343 763 187 763 q 564 647 486 763 l 564 1013 l 683 1013 l 683 0 m 582 373 q 529 562 582 484 q 361 653 468 653 q 190 561 253 653 q 135 365 135 479 q 189 175 135 254 q 358 85 251 85 q 529 178 468 85 q 582 373 582 258 "},"¨":{x_min:-109,x_max:247,ha:232,o:"m 247 1046 l 119 1046 l 119 1189 l 247 1189 l 247 1046 m 19 1046 l -109 1046 l -109 1189 l 19 1189 l 19 1046 "},E:{x_min:0,x_max:736.109375,ha:789,o:"m 736 0 l 0 0 l 0 1013 l 725 1013 l 725 889 l 139 889 l 139 585 l 677 585 l 677 467 l 139 467 l 139 125 l 736 125 l 736 0 "},Y:{x_min:0,x_max:820,ha:886,o:"m 820 1013 l 482 416 l 482 0 l 342 0 l 342 416 l 0 1013 l 140 1013 l 411 534 l 679 1012 l 820 1013 "},"\"":{x_min:0,x_max:299,ha:396,o:"m 299 606 l 203 606 l 203 988 l 299 988 l 299 606 m 96 606 l 0 606 l 0 988 l 96 988 l 96 606 "},"‹":{x_min:17.984375,x_max:773.609375,ha:792,o:"m 773 40 l 18 376 l 17 465 l 773 799 l 773 692 l 159 420 l 773 149 l 773 40 "},"„":{x_min:0,x_max:364,ha:467,o:"m 141 -12 q 104 -132 141 -82 q 0 -205 67 -182 l 0 -138 q 56 -82 40 -124 q 69 0 69 -51 l 0 0 l 0 151 l 141 151 l 141 -12 m 364 -12 q 327 -132 364 -82 q 222 -205 290 -182 l 222 -138 q 279 -82 262 -124 q 292 0 292 -51 l 222 0 l 222 151 l 364 151 l 364 -12 "},"δ":{x_min:1,x_max:710,ha:810,o:"m 710 360 q 616 87 710 196 q 356 -28 518 -28 q 99 82 197 -28 q 1 356 1 192 q 100 606 1 509 q 355 703 199 703 q 180 829 288 754 q 70 903 124 866 l 70 1012 l 643 1012 l 643 901 l 258 901 q 462 763 422 794 q 636 592 577 677 q 710 360 710 485 m 584 365 q 552 501 584 447 q 451 602 521 555 q 372 611 411 611 q 197 541 258 611 q 136 355 136 472 q 190 171 136 245 q 358 85 252 85 q 528 173 465 85 q 584 365 584 252 "},"έ":{x_min:0,x_max:634.71875,ha:714,o:"m 634 234 q 527 38 634 110 q 300 -25 433 -25 q 98 29 183 -25 q 0 204 0 93 q 37 313 0 265 q 128 390 67 352 q 56 459 82 419 q 26 555 26 505 q 114 712 26 654 q 295 763 191 763 q 499 700 416 763 q 589 515 589 631 l 478 515 q 419 618 464 580 q 307 657 374 657 q 207 630 253 657 q 151 547 151 598 q 238 445 151 469 q 389 434 280 434 l 389 331 l 349 331 q 206 315 255 331 q 125 210 125 287 q 183 107 125 145 q 302 76 233 76 q 436 117 379 76 q 509 234 493 159 l 634 234 m 520 1040 l 331 819 l 248 819 l 383 1040 l 520 1040 "},"ω":{x_min:0,x_max:922,ha:1031,o:"m 922 339 q 856 97 922 203 q 650 -26 780 -26 q 538 9 587 -26 q 461 103 489 44 q 387 12 436 46 q 277 -22 339 -22 q 69 97 147 -22 q 0 339 0 203 q 45 551 0 444 q 161 738 84 643 l 302 738 q 175 553 219 647 q 124 336 124 446 q 155 179 124 249 q 275 88 197 88 q 375 163 341 88 q 400 294 400 219 l 400 572 l 524 572 l 524 294 q 561 135 524 192 q 643 88 591 88 q 762 182 719 88 q 797 342 797 257 q 745 556 797 450 q 619 738 705 638 l 760 738 q 874 551 835 640 q 922 339 922 444 "},"´":{x_min:0,x_max:96,ha:251,o:"m 96 606 l 0 606 l 0 988 l 96 988 l 96 606 "},"±":{x_min:11,x_max:781,ha:792,o:"m 781 490 l 446 490 l 446 255 l 349 255 l 349 490 l 11 490 l 11 586 l 349 586 l 349 819 l 446 819 l 446 586 l 781 586 l 781 490 m 781 21 l 11 21 l 11 115 l 781 115 l 781 21 "},"|":{x_min:343,x_max:449,ha:792,o:"m 449 462 l 343 462 l 343 986 l 449 986 l 449 462 m 449 -242 l 343 -242 l 343 280 l 449 280 l 449 -242 "},"ϋ":{x_min:0,x_max:617,ha:725,o:"m 482 800 l 372 800 l 372 925 l 482 925 l 482 800 m 239 800 l 129 800 l 129 925 l 239 925 l 239 800 m 617 352 q 540 93 617 199 q 308 -24 455 -24 q 76 93 161 -24 q 0 352 0 199 l 0 738 l 126 738 l 126 354 q 169 185 126 257 q 312 98 220 98 q 451 185 402 98 q 492 354 492 257 l 492 738 l 617 738 l 617 352 "},"§":{x_min:0,x_max:593,ha:690,o:"m 593 425 q 554 312 593 369 q 467 233 516 254 q 537 83 537 172 q 459 -74 537 -12 q 288 -133 387 -133 q 115 -69 184 -133 q 47 96 47 -6 l 166 96 q 199 7 166 40 q 288 -26 232 -26 q 371 -5 332 -26 q 420 60 420 21 q 311 201 420 139 q 108 309 210 255 q 0 490 0 383 q 33 602 0 551 q 124 687 66 654 q 75 743 93 712 q 58 812 58 773 q 133 984 58 920 q 300 1043 201 1043 q 458 987 394 1043 q 529 814 529 925 l 411 814 q 370 908 404 877 q 289 939 336 939 q 213 911 246 939 q 180 841 180 883 q 286 720 180 779 q 484 612 480 615 q 593 425 593 534 m 467 409 q 355 544 467 473 q 196 630 228 612 q 146 587 162 609 q 124 525 124 558 q 239 387 124 462 q 398 298 369 315 q 448 345 429 316 q 467 409 467 375 "},b:{x_min:0,x_max:685,ha:783,o:"m 685 372 q 597 99 685 213 q 347 -25 501 -25 q 219 5 277 -25 q 121 93 161 36 l 121 0 l 0 0 l 0 1013 l 121 1013 l 121 634 q 214 723 157 692 q 341 754 272 754 q 591 637 493 754 q 685 372 685 526 m 554 356 q 499 550 554 470 q 328 644 437 644 q 162 556 223 644 q 108 369 108 478 q 160 176 108 256 q 330 83 221 83 q 498 169 435 83 q 554 356 554 245 "},q:{x_min:0,x_max:683,ha:876,o:"m 683 -278 l 564 -278 l 564 97 q 474 8 533 39 q 345 -23 415 -23 q 91 93 188 -23 q 0 364 0 203 q 87 635 0 522 q 337 760 184 760 q 466 727 408 760 q 564 637 523 695 l 564 737 l 683 737 l 683 -278 m 582 375 q 527 564 582 488 q 358 652 466 652 q 190 565 253 652 q 135 377 135 488 q 189 179 135 261 q 361 84 251 84 q 530 179 469 84 q 582 375 582 260 "},"Ω":{x_min:-0.171875,x_max:969.5625,ha:1068,o:"m 969 0 l 555 0 l 555 123 q 744 308 675 194 q 814 558 814 423 q 726 812 814 709 q 484 922 633 922 q 244 820 334 922 q 154 567 154 719 q 223 316 154 433 q 412 123 292 199 l 412 0 l 0 0 l 0 124 l 217 124 q 68 327 122 210 q 15 572 15 444 q 144 911 15 781 q 484 1041 274 1041 q 822 909 691 1041 q 953 569 953 777 q 899 326 953 443 q 750 124 846 210 l 969 124 l 969 0 "},"ύ":{x_min:0,x_max:617,ha:725,o:"m 617 352 q 540 93 617 199 q 308 -24 455 -24 q 76 93 161 -24 q 0 352 0 199 l 0 738 l 126 738 l 126 354 q 169 185 126 257 q 312 98 220 98 q 451 185 402 98 q 492 354 492 257 l 492 738 l 617 738 l 617 352 m 535 1040 l 346 819 l 262 819 l 397 1040 l 535 1040 "},z:{x_min:-0.015625,x_max:613.890625,ha:697,o:"m 613 0 l 0 0 l 0 100 l 433 630 l 20 630 l 20 738 l 594 738 l 593 636 l 163 110 l 613 110 l 613 0 "},"™":{x_min:0,x_max:894,ha:1000,o:"m 389 951 l 229 951 l 229 503 l 160 503 l 160 951 l 0 951 l 0 1011 l 389 1011 l 389 951 m 894 503 l 827 503 l 827 939 l 685 503 l 620 503 l 481 937 l 481 503 l 417 503 l 417 1011 l 517 1011 l 653 580 l 796 1010 l 894 1011 l 894 503 "},"ή":{x_min:0.78125,x_max:697,ha:810,o:"m 697 -278 l 572 -278 l 572 454 q 540 587 572 536 q 425 650 501 650 q 271 579 337 650 q 206 420 206 509 l 206 0 l 81 0 l 81 489 q 73 588 81 562 q 0 644 56 644 l 0 741 q 68 755 38 755 q 158 721 124 755 q 200 630 193 687 q 297 726 234 692 q 434 761 359 761 q 620 692 544 761 q 697 516 697 624 l 697 -278 m 479 1040 l 290 819 l 207 819 l 341 1040 l 479 1040 "},"Θ":{x_min:0,x_max:960,ha:1056,o:"m 960 507 q 833 129 960 280 q 476 -32 698 -32 q 123 129 255 -32 q 0 507 0 280 q 123 883 0 732 q 476 1045 255 1045 q 832 883 696 1045 q 960 507 960 732 m 817 500 q 733 789 817 669 q 476 924 639 924 q 223 792 317 924 q 142 507 142 675 q 222 222 142 339 q 476 89 315 89 q 730 218 636 89 q 817 500 817 334 m 716 449 l 243 449 l 243 571 l 716 571 l 716 449 "},"®":{x_min:-3,x_max:1008,ha:1106,o:"m 503 532 q 614 562 566 532 q 672 658 672 598 q 614 747 672 716 q 503 772 569 772 l 338 772 l 338 532 l 503 532 m 502 -7 q 123 151 263 -7 q -3 501 -3 294 q 123 851 -3 706 q 502 1011 263 1011 q 881 851 739 1011 q 1008 501 1008 708 q 883 151 1008 292 q 502 -7 744 -7 m 502 60 q 830 197 709 60 q 940 501 940 322 q 831 805 940 681 q 502 944 709 944 q 174 805 296 944 q 65 501 65 680 q 173 197 65 320 q 502 60 294 60 m 788 146 l 678 146 q 653 316 655 183 q 527 449 652 449 l 338 449 l 338 146 l 241 146 l 241 854 l 518 854 q 688 808 621 854 q 766 658 766 755 q 739 563 766 607 q 668 497 713 519 q 751 331 747 472 q 788 164 756 190 l 788 146 "},"~":{x_min:0,x_max:833,ha:931,o:"m 833 958 q 778 753 833 831 q 594 665 716 665 q 402 761 502 665 q 240 857 302 857 q 131 795 166 857 q 104 665 104 745 l 0 665 q 54 867 0 789 q 237 958 116 958 q 429 861 331 958 q 594 765 527 765 q 704 827 670 765 q 729 958 729 874 l 833 958 "},"Ε":{x_min:0,x_max:736.21875,ha:778,o:"m 736 0 l 0 0 l 0 1013 l 725 1013 l 725 889 l 139 889 l 139 585 l 677 585 l 677 467 l 139 467 l 139 125 l 736 125 l 736 0 "},"³":{x_min:0,x_max:450,ha:547,o:"m 450 552 q 379 413 450 464 q 220 366 313 366 q 69 414 130 366 q 0 567 0 470 l 85 567 q 126 470 85 504 q 225 437 168 437 q 320 467 280 437 q 360 552 360 498 q 318 632 360 608 q 213 657 276 657 q 195 657 203 657 q 176 657 181 657 l 176 722 q 279 733 249 722 q 334 815 334 752 q 300 881 334 856 q 220 907 267 907 q 133 875 169 907 q 97 781 97 844 l 15 781 q 78 926 15 875 q 220 972 135 972 q 364 930 303 972 q 426 817 426 888 q 344 697 426 733 q 421 642 392 681 q 450 552 450 603 "},"[":{x_min:0,x_max:273.609375,ha:371,o:"m 273 -281 l 0 -281 l 0 1013 l 273 1013 l 273 920 l 124 920 l 124 -187 l 273 -187 l 273 -281 "},L:{x_min:0,x_max:645.828125,ha:696,o:"m 645 0 l 0 0 l 0 1013 l 140 1013 l 140 126 l 645 126 l 645 0 "},"σ":{x_min:0,x_max:803.390625,ha:894,o:"m 803 628 l 633 628 q 713 368 713 512 q 618 93 713 204 q 357 -25 518 -25 q 94 91 194 -25 q 0 368 0 201 q 94 644 0 533 q 356 761 194 761 q 481 750 398 761 q 608 739 564 739 l 803 739 l 803 628 m 360 85 q 529 180 467 85 q 584 374 584 262 q 527 566 584 490 q 352 651 463 651 q 187 559 247 651 q 135 368 135 478 q 189 175 135 254 q 360 85 251 85 "},"ζ":{x_min:0,x_max:573,ha:642,o:"m 573 -40 q 553 -162 573 -97 q 510 -278 543 -193 l 400 -278 q 441 -187 428 -219 q 462 -90 462 -132 q 378 -14 462 -14 q 108 45 197 -14 q 0 290 0 117 q 108 631 0 462 q 353 901 194 767 l 55 901 l 55 1012 l 561 1012 l 561 924 q 261 669 382 831 q 128 301 128 489 q 243 117 128 149 q 458 98 350 108 q 573 -40 573 80 "},"θ":{x_min:0,x_max:674,ha:778,o:"m 674 496 q 601 160 674 304 q 336 -26 508 -26 q 73 153 165 -26 q 0 485 0 296 q 72 840 0 683 q 343 1045 166 1045 q 605 844 516 1045 q 674 496 674 692 m 546 579 q 498 798 546 691 q 336 935 437 935 q 178 798 237 935 q 126 579 137 701 l 546 579 m 546 475 l 126 475 q 170 233 126 348 q 338 80 230 80 q 504 233 447 80 q 546 475 546 346 "},"Ο":{x_min:0,x_max:958,ha:1054,o:"m 485 1042 q 834 883 703 1042 q 958 511 958 735 q 834 136 958 287 q 481 -26 701 -26 q 126 130 261 -26 q 0 504 0 279 q 127 880 0 729 q 485 1042 263 1042 m 480 98 q 731 225 638 98 q 815 504 815 340 q 733 783 815 670 q 480 913 640 913 q 226 785 321 913 q 142 504 142 671 q 226 224 142 339 q 480 98 319 98 "},"Γ":{x_min:0,x_max:705.28125,ha:749,o:"m 705 886 l 140 886 l 140 0 l 0 0 l 0 1012 l 705 1012 l 705 886 "}," ":{x_min:0,x_max:0,ha:375},"%":{x_min:-3,x_max:1089,ha:1186,o:"m 845 0 q 663 76 731 0 q 602 244 602 145 q 661 412 602 344 q 845 489 728 489 q 1027 412 959 489 q 1089 244 1089 343 q 1029 76 1089 144 q 845 0 962 0 m 844 103 q 945 143 909 103 q 981 243 981 184 q 947 340 981 301 q 844 385 909 385 q 744 342 781 385 q 708 243 708 300 q 741 147 708 186 q 844 103 780 103 m 888 986 l 284 -25 l 199 -25 l 803 986 l 888 986 m 241 468 q 58 545 126 468 q -3 715 -3 615 q 56 881 -3 813 q 238 958 124 958 q 421 881 353 958 q 483 712 483 813 q 423 544 483 612 q 241 468 356 468 m 241 855 q 137 811 175 855 q 100 710 100 768 q 136 612 100 653 q 240 572 172 572 q 344 614 306 572 q 382 713 382 656 q 347 810 382 771 q 241 855 308 855 "},P:{x_min:0,x_max:726,ha:806,o:"m 424 1013 q 640 931 555 1013 q 726 719 726 850 q 637 506 726 587 q 413 426 548 426 l 140 426 l 140 0 l 0 0 l 0 1013 l 424 1013 m 379 889 l 140 889 l 140 548 l 372 548 q 522 589 459 548 q 593 720 593 637 q 528 845 593 801 q 379 889 463 889 "},"Έ":{x_min:0,x_max:1078.21875,ha:1118,o:"m 1078 0 l 342 0 l 342 1013 l 1067 1013 l 1067 889 l 481 889 l 481 585 l 1019 585 l 1019 467 l 481 467 l 481 125 l 1078 125 l 1078 0 m 277 1040 l 83 799 l 0 799 l 140 1040 l 277 1040 "},"Ώ":{x_min:0.125,x_max:1136.546875,ha:1235,o:"m 1136 0 l 722 0 l 722 123 q 911 309 842 194 q 981 558 981 423 q 893 813 981 710 q 651 923 800 923 q 411 821 501 923 q 321 568 321 720 q 390 316 321 433 q 579 123 459 200 l 579 0 l 166 0 l 166 124 l 384 124 q 235 327 289 210 q 182 572 182 444 q 311 912 182 782 q 651 1042 441 1042 q 989 910 858 1042 q 1120 569 1120 778 q 1066 326 1120 443 q 917 124 1013 210 l 1136 124 l 1136 0 m 277 1040 l 83 800 l 0 800 l 140 1041 l 277 1040 "},_:{x_min:0,x_max:705.5625,ha:803,o:"m 705 -334 l 0 -334 l 0 -234 l 705 -234 l 705 -334 "},"Ϊ":{x_min:-110,x_max:246,ha:275,o:"m 246 1046 l 118 1046 l 118 1189 l 246 1189 l 246 1046 m 18 1046 l -110 1046 l -110 1189 l 18 1189 l 18 1046 m 136 0 l 0 0 l 0 1012 l 136 1012 l 136 0 "},"+":{x_min:23,x_max:768,ha:792,o:"m 768 372 l 444 372 l 444 0 l 347 0 l 347 372 l 23 372 l 23 468 l 347 468 l 347 840 l 444 840 l 444 468 l 768 468 l 768 372 "},"½":{x_min:0,x_max:1050,ha:1149,o:"m 1050 0 l 625 0 q 712 178 625 108 q 878 277 722 187 q 967 385 967 328 q 932 456 967 429 q 850 484 897 484 q 759 450 798 484 q 721 352 721 416 l 640 352 q 706 502 640 448 q 851 551 766 551 q 987 509 931 551 q 1050 385 1050 462 q 976 251 1050 301 q 829 179 902 215 q 717 68 740 133 l 1050 68 l 1050 0 m 834 985 l 215 -28 l 130 -28 l 750 984 l 834 985 m 224 422 l 142 422 l 142 811 l 0 811 l 0 867 q 104 889 62 867 q 164 973 157 916 l 224 973 l 224 422 "},"Ρ":{x_min:0,x_max:720,ha:783,o:"m 424 1013 q 637 933 554 1013 q 720 723 720 853 q 633 508 720 591 q 413 426 546 426 l 140 426 l 140 0 l 0 0 l 0 1013 l 424 1013 m 378 889 l 140 889 l 140 548 l 371 548 q 521 589 458 548 q 592 720 592 637 q 527 845 592 801 q 378 889 463 889 "},"'":{x_min:0,x_max:139,ha:236,o:"m 139 851 q 102 737 139 784 q 0 669 65 690 l 0 734 q 59 787 42 741 q 72 873 72 821 l 0 873 l 0 1013 l 139 1013 l 139 851 "},"ª":{x_min:0,x_max:350,ha:397,o:"m 350 625 q 307 616 328 616 q 266 631 281 616 q 247 673 251 645 q 190 628 225 644 q 116 613 156 613 q 32 641 64 613 q 0 722 0 669 q 72 826 0 800 q 247 866 159 846 l 247 887 q 220 934 247 916 q 162 953 194 953 q 104 934 129 953 q 76 882 80 915 l 16 882 q 60 976 16 941 q 166 1011 104 1011 q 266 979 224 1011 q 308 891 308 948 l 308 706 q 311 679 308 688 q 331 670 315 670 l 350 672 l 350 625 m 247 757 l 247 811 q 136 790 175 798 q 64 726 64 773 q 83 682 64 697 q 132 667 103 667 q 207 690 174 667 q 247 757 247 718 "},"΅":{x_min:0,x_max:450,ha:553,o:"m 450 800 l 340 800 l 340 925 l 450 925 l 450 800 m 406 1040 l 212 800 l 129 800 l 269 1040 l 406 1040 m 110 800 l 0 800 l 0 925 l 110 925 l 110 800 "},T:{x_min:0,x_max:777,ha:835,o:"m 777 894 l 458 894 l 458 0 l 319 0 l 319 894 l 0 894 l 0 1013 l 777 1013 l 777 894 "},"Φ":{x_min:0,x_max:915,ha:997,o:"m 527 0 l 389 0 l 389 122 q 110 231 220 122 q 0 509 0 340 q 110 785 0 677 q 389 893 220 893 l 389 1013 l 527 1013 l 527 893 q 804 786 693 893 q 915 509 915 679 q 805 231 915 341 q 527 122 696 122 l 527 0 m 527 226 q 712 310 641 226 q 779 507 779 389 q 712 705 779 627 q 527 787 641 787 l 527 226 m 389 226 l 389 787 q 205 698 275 775 q 136 505 136 620 q 206 308 136 391 q 389 226 276 226 "},"⁋":{x_min:0,x_max:0,ha:694},j:{x_min:-77.78125,x_max:167,ha:349,o:"m 167 871 l 42 871 l 42 1013 l 167 1013 l 167 871 m 167 -80 q 121 -231 167 -184 q -26 -278 76 -278 l -77 -278 l -77 -164 l -41 -164 q 26 -143 11 -164 q 42 -65 42 -122 l 42 737 l 167 737 l 167 -80 "},"Σ":{x_min:0,x_max:756.953125,ha:819,o:"m 756 0 l 0 0 l 0 107 l 395 523 l 22 904 l 22 1013 l 745 1013 l 745 889 l 209 889 l 566 523 l 187 125 l 756 125 l 756 0 "},"›":{x_min:18.0625,x_max:774,ha:792,o:"m 774 376 l 18 40 l 18 149 l 631 421 l 18 692 l 18 799 l 774 465 l 774 376 "},"<":{x_min:17.984375,x_max:773.609375,ha:792,o:"m 773 40 l 18 376 l 17 465 l 773 799 l 773 692 l 159 420 l 773 149 l 773 40 "},"£":{x_min:0,x_max:704.484375,ha:801,o:"m 704 41 q 623 -10 664 5 q 543 -26 583 -26 q 359 15 501 -26 q 243 36 288 36 q 158 23 197 36 q 73 -21 119 10 l 6 76 q 125 195 90 150 q 175 331 175 262 q 147 443 175 383 l 0 443 l 0 512 l 108 512 q 43 734 43 623 q 120 929 43 854 q 358 1010 204 1010 q 579 936 487 1010 q 678 729 678 857 l 678 684 l 552 684 q 504 838 552 780 q 362 896 457 896 q 216 852 263 896 q 176 747 176 815 q 199 627 176 697 q 248 512 217 574 l 468 512 l 468 443 l 279 443 q 297 356 297 398 q 230 194 297 279 q 153 107 211 170 q 227 133 190 125 q 293 142 264 142 q 410 119 339 142 q 516 96 482 96 q 579 105 550 96 q 648 142 608 115 l 704 41 "},t:{x_min:0,x_max:367,ha:458,o:"m 367 0 q 312 -5 339 -2 q 262 -8 284 -8 q 145 28 183 -8 q 108 143 108 64 l 108 638 l 0 638 l 0 738 l 108 738 l 108 944 l 232 944 l 232 738 l 367 738 l 367 638 l 232 638 l 232 185 q 248 121 232 140 q 307 102 264 102 q 345 104 330 102 q 367 107 360 107 l 367 0 "},"¬":{x_min:0,x_max:706,ha:803,o:"m 706 411 l 706 158 l 630 158 l 630 335 l 0 335 l 0 411 l 706 411 "},"λ":{x_min:0,x_max:750,ha:803,o:"m 750 -7 q 679 -15 716 -15 q 538 59 591 -15 q 466 214 512 97 l 336 551 l 126 0 l 0 0 l 270 705 q 223 837 247 770 q 116 899 190 899 q 90 898 100 899 l 90 1004 q 152 1011 125 1011 q 298 938 244 1011 q 373 783 326 901 l 605 192 q 649 115 629 136 q 716 95 669 95 l 736 95 q 750 97 745 97 l 750 -7 "},W:{x_min:0,x_max:1263.890625,ha:1351,o:"m 1263 1013 l 995 0 l 859 0 l 627 837 l 405 0 l 265 0 l 0 1013 l 136 1013 l 342 202 l 556 1013 l 701 1013 l 921 207 l 1133 1012 l 1263 1013 "},">":{x_min:18.0625,x_max:774,ha:792,o:"m 774 376 l 18 40 l 18 149 l 631 421 l 18 692 l 18 799 l 774 465 l 774 376 "},v:{x_min:0,x_max:675.15625,ha:761,o:"m 675 738 l 404 0 l 272 0 l 0 738 l 133 737 l 340 147 l 541 737 l 675 738 "},"τ":{x_min:0.28125,x_max:644.5,ha:703,o:"m 644 628 l 382 628 l 382 179 q 388 120 382 137 q 436 91 401 91 q 474 94 447 91 q 504 97 501 97 l 504 0 q 454 -9 482 -5 q 401 -14 426 -14 q 278 67 308 -14 q 260 233 260 118 l 260 628 l 0 628 l 0 739 l 644 739 l 644 628 "},"ξ":{x_min:0,x_max:624.9375,ha:699,o:"m 624 -37 q 608 -153 624 -96 q 563 -278 593 -211 l 454 -278 q 491 -183 486 -200 q 511 -83 511 -126 q 484 -23 511 -44 q 370 1 452 1 q 323 0 354 1 q 283 -1 293 -1 q 84 76 169 -1 q 0 266 0 154 q 56 431 0 358 q 197 538 108 498 q 94 613 134 562 q 54 730 54 665 q 77 823 54 780 q 143 901 101 867 l 27 901 l 27 1012 l 576 1012 l 576 901 l 380 901 q 244 863 303 901 q 178 745 178 820 q 312 600 178 636 q 532 582 380 582 l 532 479 q 276 455 361 479 q 118 281 118 410 q 165 173 118 217 q 274 120 208 133 q 494 101 384 110 q 624 -37 624 76 "},"&":{x_min:-3,x_max:894.25,ha:992,o:"m 894 0 l 725 0 l 624 123 q 471 0 553 40 q 306 -41 390 -41 q 168 -7 231 -41 q 62 92 105 26 q 14 187 31 139 q -3 276 -3 235 q 55 433 -3 358 q 248 581 114 508 q 170 689 196 640 q 137 817 137 751 q 214 985 137 922 q 384 1041 284 1041 q 548 988 483 1041 q 622 824 622 928 q 563 666 622 739 q 431 556 516 608 l 621 326 q 649 407 639 361 q 663 493 653 426 l 781 493 q 703 229 781 352 l 894 0 m 504 818 q 468 908 504 877 q 384 940 433 940 q 293 907 331 940 q 255 818 255 875 q 289 714 255 767 q 363 628 313 678 q 477 729 446 682 q 504 818 504 771 m 556 209 l 314 499 q 179 395 223 449 q 135 283 135 341 q 146 222 135 253 q 183 158 158 192 q 333 80 241 80 q 556 209 448 80 "},"Λ":{x_min:0,x_max:862.5,ha:942,o:"m 862 0 l 719 0 l 426 847 l 143 0 l 0 0 l 356 1013 l 501 1013 l 862 0 "},I:{x_min:41,x_max:180,ha:293,o:"m 180 0 l 41 0 l 41 1013 l 180 1013 l 180 0 "},G:{x_min:0,x_max:921,ha:1011,o:"m 921 0 l 832 0 l 801 136 q 655 15 741 58 q 470 -28 568 -28 q 126 133 259 -28 q 0 499 0 284 q 125 881 0 731 q 486 1043 259 1043 q 763 957 647 1043 q 905 709 890 864 l 772 709 q 668 866 747 807 q 486 926 589 926 q 228 795 322 926 q 142 507 142 677 q 228 224 142 342 q 483 94 323 94 q 712 195 625 94 q 796 435 796 291 l 477 435 l 477 549 l 921 549 l 921 0 "},"ΰ":{x_min:0,x_max:617,ha:725,o:"m 524 800 l 414 800 l 414 925 l 524 925 l 524 800 m 183 800 l 73 800 l 73 925 l 183 925 l 183 800 m 617 352 q 540 93 617 199 q 308 -24 455 -24 q 76 93 161 -24 q 0 352 0 199 l 0 738 l 126 738 l 126 354 q 169 185 126 257 q 312 98 220 98 q 451 185 402 98 q 492 354 492 257 l 492 738 l 617 738 l 617 352 m 489 1040 l 300 819 l 216 819 l 351 1040 l 489 1040 "},"`":{x_min:0,x_max:138.890625,ha:236,o:"m 138 699 l 0 699 l 0 861 q 36 974 0 929 q 138 1041 72 1020 l 138 977 q 82 931 95 969 q 69 839 69 893 l 138 839 l 138 699 "},"·":{x_min:0,x_max:142,ha:239,o:"m 142 585 l 0 585 l 0 738 l 142 738 l 142 585 "},"Υ":{x_min:0.328125,x_max:819.515625,ha:889,o:"m 819 1013 l 482 416 l 482 0 l 342 0 l 342 416 l 0 1013 l 140 1013 l 411 533 l 679 1013 l 819 1013 "},r:{x_min:0,x_max:355.5625,ha:432,o:"m 355 621 l 343 621 q 179 569 236 621 q 122 411 122 518 l 122 0 l 0 0 l 0 737 l 117 737 l 117 604 q 204 719 146 686 q 355 753 262 753 l 355 621 "},x:{x_min:0,x_max:675,ha:764,o:"m 675 0 l 525 0 l 331 286 l 144 0 l 0 0 l 256 379 l 12 738 l 157 737 l 336 473 l 516 738 l 661 738 l 412 380 l 675 0 "},"μ":{x_min:0,x_max:696.609375,ha:747,o:"m 696 -4 q 628 -14 657 -14 q 498 97 513 -14 q 422 8 470 41 q 313 -24 374 -24 q 207 3 258 -24 q 120 80 157 31 l 120 -278 l 0 -278 l 0 738 l 124 738 l 124 343 q 165 172 124 246 q 308 82 216 82 q 451 177 402 82 q 492 358 492 254 l 492 738 l 616 738 l 616 214 q 623 136 616 160 q 673 92 636 92 q 696 95 684 92 l 696 -4 "},h:{x_min:0,x_max:615,ha:724,o:"m 615 472 l 615 0 l 490 0 l 490 454 q 456 590 490 535 q 338 654 416 654 q 186 588 251 654 q 122 436 122 522 l 122 0 l 0 0 l 0 1013 l 122 1013 l 122 633 q 218 727 149 694 q 362 760 287 760 q 552 676 484 760 q 615 472 615 600 "},".":{x_min:0,x_max:142,ha:239,o:"m 142 0 l 0 0 l 0 151 l 142 151 l 142 0 "},"φ":{x_min:-2,x_max:878,ha:974,o:"m 496 -279 l 378 -279 l 378 -17 q 101 88 204 -17 q -2 367 -2 194 q 68 626 -2 510 q 283 758 151 758 l 283 646 q 167 537 209 626 q 133 373 133 462 q 192 177 133 254 q 378 93 259 93 l 378 758 q 445 764 426 763 q 476 765 464 765 q 765 659 653 765 q 878 377 878 553 q 771 96 878 209 q 496 -17 665 -17 l 496 -279 m 496 93 l 514 93 q 687 183 623 93 q 746 380 746 265 q 691 569 746 491 q 522 658 629 658 l 496 656 l 496 93 "},";":{x_min:0,x_max:142,ha:239,o:"m 142 585 l 0 585 l 0 738 l 142 738 l 142 585 m 142 -12 q 105 -132 142 -82 q 0 -206 68 -182 l 0 -138 q 58 -82 43 -123 q 68 0 68 -56 l 0 0 l 0 151 l 142 151 l 142 -12 "},f:{x_min:0,x_max:378,ha:472,o:"m 378 638 l 246 638 l 246 0 l 121 0 l 121 638 l 0 638 l 0 738 l 121 738 q 137 935 121 887 q 290 1028 171 1028 q 320 1027 305 1028 q 378 1021 334 1026 l 378 908 q 323 918 346 918 q 257 870 273 918 q 246 780 246 840 l 246 738 l 378 738 l 378 638 "},"“":{x_min:1,x_max:348.21875,ha:454,o:"m 140 670 l 1 670 l 1 830 q 37 943 1 897 q 140 1011 74 990 l 140 947 q 82 900 97 940 q 68 810 68 861 l 140 810 l 140 670 m 348 670 l 209 670 l 209 830 q 245 943 209 897 q 348 1011 282 990 l 348 947 q 290 900 305 940 q 276 810 276 861 l 348 810 l 348 670 "},A:{x_min:0.03125,x_max:906.953125,ha:1008,o:"m 906 0 l 756 0 l 648 303 l 251 303 l 142 0 l 0 0 l 376 1013 l 529 1013 l 906 0 m 610 421 l 452 867 l 293 421 l 610 421 "},"‘":{x_min:1,x_max:139.890625,ha:236,o:"m 139 670 l 1 670 l 1 830 q 37 943 1 897 q 139 1011 74 990 l 139 947 q 82 900 97 940 q 68 810 68 861 l 139 810 l 139 670 "},"ϊ":{x_min:-70,x_max:283,ha:361,o:"m 283 800 l 173 800 l 173 925 l 283 925 l 283 800 m 40 800 l -70 800 l -70 925 l 40 925 l 40 800 m 283 3 q 232 -10 257 -5 q 181 -15 206 -15 q 84 26 118 -15 q 41 200 41 79 l 41 737 l 166 737 l 167 215 q 171 141 167 157 q 225 101 182 101 q 247 103 238 101 q 283 112 256 104 l 283 3 "},"π":{x_min:-0.21875,x_max:773.21875,ha:857,o:"m 773 -7 l 707 -11 q 575 40 607 -11 q 552 174 552 77 l 552 226 l 552 626 l 222 626 l 222 0 l 97 0 l 97 626 l 0 626 l 0 737 l 773 737 l 773 626 l 676 626 l 676 171 q 695 103 676 117 q 773 90 714 90 l 773 -7 "},"ά":{x_min:0,x_max:765.5625,ha:809,o:"m 765 -4 q 698 -14 726 -14 q 564 97 586 -14 q 466 7 525 40 q 337 -26 407 -26 q 88 98 186 -26 q 0 369 0 212 q 88 637 0 525 q 337 760 184 760 q 465 727 407 760 q 563 637 524 695 l 563 738 l 685 738 l 685 222 q 693 141 685 168 q 748 94 708 94 q 765 95 760 94 l 765 -4 m 584 371 q 531 562 584 485 q 360 653 470 653 q 192 566 254 653 q 135 379 135 489 q 186 181 135 261 q 358 84 247 84 q 528 176 465 84 q 584 371 584 260 m 604 1040 l 415 819 l 332 819 l 466 1040 l 604 1040 "},O:{x_min:0,x_max:958,ha:1057,o:"m 485 1041 q 834 882 702 1041 q 958 512 958 734 q 834 136 958 287 q 481 -26 702 -26 q 126 130 261 -26 q 0 504 0 279 q 127 880 0 728 q 485 1041 263 1041 m 480 98 q 731 225 638 98 q 815 504 815 340 q 733 783 815 669 q 480 912 640 912 q 226 784 321 912 q 142 504 142 670 q 226 224 142 339 q 480 98 319 98 "},n:{x_min:0,x_max:615,ha:724,o:"m 615 463 l 615 0 l 490 0 l 490 454 q 453 592 490 537 q 331 656 410 656 q 178 585 240 656 q 117 421 117 514 l 117 0 l 0 0 l 0 738 l 117 738 l 117 630 q 218 728 150 693 q 359 764 286 764 q 552 675 484 764 q 615 463 615 593 "},l:{x_min:41,x_max:166,ha:279,o:"m 166 0 l 41 0 l 41 1013 l 166 1013 l 166 0 "},"¤":{x_min:40.09375,x_max:728.796875,ha:825,o:"m 728 304 l 649 224 l 512 363 q 383 331 458 331 q 256 363 310 331 l 119 224 l 40 304 l 177 441 q 150 553 150 493 q 184 673 150 621 l 40 818 l 119 898 l 267 749 q 321 766 291 759 q 384 773 351 773 q 447 766 417 773 q 501 749 477 759 l 649 898 l 728 818 l 585 675 q 612 618 604 648 q 621 553 621 587 q 591 441 621 491 l 728 304 m 384 682 q 280 643 318 682 q 243 551 243 604 q 279 461 243 499 q 383 423 316 423 q 487 461 449 423 q 525 553 525 500 q 490 641 525 605 q 384 682 451 682 "},"κ":{x_min:0,x_max:632.328125,ha:679,o:"m 632 0 l 482 0 l 225 384 l 124 288 l 124 0 l 0 0 l 0 738 l 124 738 l 124 446 l 433 738 l 596 738 l 312 466 l 632 0 "},p:{x_min:0,x_max:685,ha:786,o:"m 685 364 q 598 96 685 205 q 350 -23 504 -23 q 121 89 205 -23 l 121 -278 l 0 -278 l 0 738 l 121 738 l 121 633 q 220 726 159 691 q 351 761 280 761 q 598 636 504 761 q 685 364 685 522 m 557 371 q 501 560 557 481 q 330 651 437 651 q 162 559 223 651 q 108 366 108 479 q 162 177 108 254 q 333 87 224 87 q 502 178 441 87 q 557 371 557 258 "},"‡":{x_min:0,x_max:777,ha:835,o:"m 458 238 l 458 0 l 319 0 l 319 238 l 0 238 l 0 360 l 319 360 l 319 681 l 0 683 l 0 804 l 319 804 l 319 1015 l 458 1013 l 458 804 l 777 804 l 777 683 l 458 683 l 458 360 l 777 360 l 777 238 l 458 238 "},"ψ":{x_min:0,x_max:808,ha:907,o:"m 465 -278 l 341 -278 l 341 -15 q 87 102 180 -15 q 0 378 0 210 l 0 739 l 133 739 l 133 379 q 182 195 133 275 q 341 98 242 98 l 341 922 l 465 922 l 465 98 q 623 195 563 98 q 675 382 675 278 l 675 742 l 808 742 l 808 381 q 720 104 808 213 q 466 -13 627 -13 l 465 -278 "},"η":{x_min:0.78125,x_max:697,ha:810,o:"m 697 -278 l 572 -278 l 572 454 q 540 587 572 536 q 425 650 501 650 q 271 579 337 650 q 206 420 206 509 l 206 0 l 81 0 l 81 489 q 73 588 81 562 q 0 644 56 644 l 0 741 q 68 755 38 755 q 158 720 124 755 q 200 630 193 686 q 297 726 234 692 q 434 761 359 761 q 620 692 544 761 q 697 516 697 624 l 697 -278 "}};var cssFontWeight="normal";var ascender=1189;var underlinePosition=-100;var cssFontStyle="normal";var boundingBox={yMin:-334,xMin:-111,yMax:1189,xMax:1672};var resolution=1000;var original_font_information={postscript_name:"Helvetiker-Regular",version_string:"Version 1.00 2004 initial release",vendor_url:"http://www.magenta.gr/",full_font_name:"Helvetiker",font_family_name:"Helvetiker",copyright:"Copyright (c) Μagenta ltd, 2004",description:"",trademark:"",designer:"",designer_url:"",unique_font_identifier:"Μagenta ltd:Helvetiker:22-10-104",license_url:"http://www.ellak.gr/fonts/MgOpen/license.html",license_description:"Copyright (c) 2004 by MAGENTA Ltd. All Rights Reserved.\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy of the fonts accompanying this license (\"Fonts\") and associated documentation files (the \"Font Software\"), to reproduce and distribute the Font Software, including without limitation the rights to use, copy, merge, publish, distribute, and/or sell copies of the Font Software, and to permit persons to whom the Font Software is furnished to do so, subject to the following conditions: \r\n\r\nThe above copyright and this permission notice shall be included in all copies of one or more of the Font Software typefaces.\r\n\r\nThe Font Software may be modified, altered, or added to, and in particular the designs of glyphs or characters in the Fonts may be modified and additional glyphs or characters may be added to the Fonts, only if the fonts are renamed to names not containing the word \"MgOpen\", or if the modifications are accepted for inclusion in the Font Software itself by the each appointed Administrator.\r\n\r\nThis License becomes null and void to the extent applicable to Fonts or Font Software that has been modified and is distributed under the \"MgOpen\" name.\r\n\r\nThe Font Software may be sold as part of a larger software package but no copy of one or more of the Font Software typefaces may be sold by itself. \r\n\r\nTHE FONT SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF COPYRIGHT, PATENT, TRADEMARK, OR OTHER RIGHT. IN NO EVENT SHALL MAGENTA OR PERSONS OR BODIES IN CHARGE OF ADMINISTRATION AND MAINTENANCE OF THE FONT SOFTWARE BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, INCLUDING ANY GENERAL, SPECIAL, INDIRECT, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF THE USE OR INABILITY TO USE THE FONT SOFTWARE OR FROM OTHER DEALINGS IN THE FONT SOFTWARE.",manufacturer_name:"Μagenta ltd",font_sub_family_name:"Regular"};var descender=-334;var familyName="Helvetiker";var lineHeight=1522;var underlineThickness=50;var defaultTypeFace = {glyphs:glyphs,cssFontWeight:cssFontWeight,ascender:ascender,underlinePosition:underlinePosition,cssFontStyle:cssFontStyle,boundingBox:boundingBox,resolution:resolution,original_font_information:original_font_information,descender:descender,familyName:familyName,lineHeight:lineHeight,underlineThickness:underlineThickness};

    var THREE$5 = _objectSpread2$1(_objectSpread2$1({}, window.THREE ? window.THREE // Prefer consumption from global THREE, if exists
    : {
      CircleGeometry: CircleGeometry,
      Group: Group$1,
      Mesh: Mesh,
      MeshLambertMaterial: MeshLambertMaterial,
      TextGeometry: TextGeometry,
      Vector3: Vector3
    }), {}, {
      Font: Font,
      TextGeometry: TextGeometry
    });

    //

    var LabelsLayerKapsule = index$2({
      props: {
        labelsData: {
          "default": []
        },
        labelLat: {
          "default": 'lat'
        },
        labelLng: {
          "default": 'lng'
        },
        labelAltitude: {
          "default": 0
        },
        // in units of globe radius
        labelText: {
          "default": 'text'
        },
        labelSize: {
          "default": 0.5
        },
        // text height in deg
        labelTypeFace: {
          "default": defaultTypeFace,
          onChange: function onChange(tf, state) {
            state.font = new THREE$5.Font(tf);
          }
        },
        labelColor: {
          "default": function _default() {
            return 'lightgrey';
          }
        },
        labelRotation: {
          "default": 0
        },
        // clockwise degrees, relative to the latitute parallel plane
        labelResolution: {
          "default": 3
        },
        // how many segments in the text's curves
        labelIncludeDot: {
          "default": true
        },
        labelDotRadius: {
          "default": 0.1
        },
        // in deg
        labelDotOrientation: {
          "default": function _default() {
            return 'bottom';
          }
        },
        // right, top, bottom
        labelsTransitionDuration: {
          "default": 1000,
          triggerUpdate: false
        } // ms
      },
      init: function init(threeObj, state) {
        // Clear the scene
        emptyObject(threeObj);

        // Main three object to manipulate
        state.scene = threeObj;
      },
      update: function update(state) {
        // Data accessors
        var latAccessor = index$1(state.labelLat);
        var lngAccessor = index$1(state.labelLng);
        var altitudeAccessor = index$1(state.labelAltitude);
        var textAccessor = index$1(state.labelText);
        var sizeAccessor = index$1(state.labelSize);
        var rotationAccessor = index$1(state.labelRotation);
        var colorAccessor = index$1(state.labelColor);
        var includeDotAccessor = index$1(state.labelIncludeDot);
        var dotRadiusAccessor = index$1(state.labelDotRadius);
        var dotOrientationAccessor = index$1(state.labelDotOrientation);
        var orientations = new Set(['right', 'top', 'bottom']);
        var pxPerDeg = 2 * Math.PI * GLOBE_RADIUS / 360;
        var circleGeometry = new THREE$5.CircleGeometry(1, 16);
        threeDigest(state.labelsData, state.scene, {
          createObj: function createObj() {
            var material = new THREE$5.MeshLambertMaterial();
            var obj = new THREE$5.Group(); // container

            obj.add(new THREE$5.Mesh(circleGeometry, material)); // dot
            obj.add(new THREE$5.Mesh(undefined, material)); // text

            obj.__globeObjType = 'label'; // Add object type

            return obj;
          },
          updateObj: function updateObj(obj, d) {
            var _obj$children = _slicedToArray$1(obj.children, 2),
              dotObj = _obj$children[0],
              textObj = _obj$children[1];

            // update color
            var color = colorAccessor(d);
            var opacity = colorAlpha(color);
            textObj.material.color.set(colorStr2Hex(color));
            textObj.material.transparent = opacity < 1;
            textObj.material.opacity = opacity;

            // update dot
            var includeDot = includeDotAccessor(d);
            var dotOrient = dotOrientationAccessor(d);
            !includeDot || !orientations.has(dotOrient) && (dotOrient = 'bottom');

            // size dot
            var dotR = includeDot ? +dotRadiusAccessor(d) * pxPerDeg : 1e-12;
            dotObj.scale.x = dotObj.scale.y = dotR;

            // create text geometry
            var textHeight = +sizeAccessor(d) * pxPerDeg;
            textObj.geometry = new THREE$5.TextGeometry(textAccessor(d), {
              font: state.font,
              size: textHeight,
              height: 0,
              curveSegments: state.labelResolution
            });

            // center text (otherwise anchor is on bottom-left)
            dotOrient !== 'right' && textObj.geometry.center();
            if (includeDot) {
              // translate text
              var padding = dotR + textHeight / 2;
              dotOrient === 'right' && (textObj.position.x = padding);
              textObj.position.y = {
                right: -textHeight / 2,
                // center vertically
                top: padding + textHeight / 2,
                bottom: -padding - textHeight / 2
              }[dotOrient];
            }

            // animations
            var applyPosition = function applyPosition(td) {
              var _obj$__currentTargetD = obj.__currentTargetD = td,
                lat = _obj$__currentTargetD.lat,
                lng = _obj$__currentTargetD.lng,
                alt = _obj$__currentTargetD.alt,
                rot = _obj$__currentTargetD.rot,
                scale = _obj$__currentTargetD.scale;

              // position center
              Object.assign(obj.position, polar2Cartesian(lat, lng, alt));

              // rotate
              obj.lookAt(state.scene.localToWorld(new THREE$5.Vector3(0, 0, 0))); // face globe (local) center
              obj.rotateY(Math.PI); // face outwards

              // rotate clockwise relative to lat parallel
              obj.rotateZ(-rot * Math.PI / 180);

              // scale it
              obj.scale.x = obj.scale.y = obj.scale.z = scale;
            };
            var targetD = {
              lat: +latAccessor(d),
              lng: +lngAccessor(d),
              alt: +altitudeAccessor(d),
              rot: +rotationAccessor(d),
              scale: 1
            };
            var currentTargetD = obj.__currentTargetD || Object.assign({}, targetD, {
              scale: 1e-12
            });
            if (Object.keys(targetD).some(function (k) {
              return currentTargetD[k] !== targetD[k];
            })) {
              if (!state.labelsTransitionDuration || state.labelsTransitionDuration < 0) {
                // set final position
                applyPosition(targetD);
              } else {
                // animate
                new exports$1.Tween(currentTargetD).to(targetD, state.labelsTransitionDuration).easing(exports$1.Easing.Quadratic.InOut).onUpdate(applyPosition).start();
              }
            }
          }
        });
      }
    });

    var THREE$4 = window.THREE ? window.THREE // Prefer consumption from global THREE, if exists
    : {
      BufferGeometry: BufferGeometry
    };
    var CircleLineGeometry = /*#__PURE__*/function (_THREE$BufferGeometry) {
      _inherits(CircleLineGeometry, _THREE$BufferGeometry);
      var _super = _createSuper(CircleLineGeometry);
      function CircleLineGeometry() {
        var _this;
        var radius = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
        var segmentCount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 32;
        _classCallCheck(this, CircleLineGeometry);
        _this = _super.call(this);
        _this.type = 'CircleLineGeometry';
        _this.parameters = {
          radius: radius,
          segmentCount: segmentCount
        };
        var points = [];
        for (var i = 0; i <= segmentCount; i++) {
          var theta = (i / segmentCount - 0.25) * Math.PI * 2;
          points.push({
            x: Math.cos(theta) * radius,
            y: Math.sin(theta) * radius,
            z: 0
          });
        }
        _this.setFromPoints(points);
        return _this;
      }
      return _createClass$1(CircleLineGeometry);
    }(THREE$4.BufferGeometry);

    var THREE$3 = window.THREE ? window.THREE // Prefer consumption from global THREE, if exists
    : {
      Color: Color$1,
      Group: Group$1,
      Line: Line,
      LineBasicMaterial: LineBasicMaterial,
      Vector3: Vector3
    };
    var FrameTicker = _FrameTicker["default"] || _FrameTicker;
    var RingsLayerKapsule = index$2({
      props: {
        ringsData: {
          "default": []
        },
        ringLat: {
          "default": 'lat'
        },
        ringLng: {
          "default": 'lng'
        },
        ringAltitude: {
          "default": 1.5e-3
        },
        ringColor: {
          "default": function _default() {
            return '#ffffaa';
          },
          triggerUpdate: false
        },
        // single color, array of colors or color interpolation fn
        ringResolution: {
          "default": 64,
          triggerUpdate: false
        },
        // how many slice segments in each circle's circumference
        ringMaxRadius: {
          "default": 2,
          triggerUpdate: false
        },
        // degrees
        ringPropagationSpeed: {
          "default": 1,
          triggerUpdate: false
        },
        // degrees/s
        ringRepeatPeriod: {
          "default": 700,
          triggerUpdate: false
        } // ms
      },
      init: function init(threeObj, state) {
        // Clear the scene
        emptyObject(threeObj);

        // Main three object to manipulate
        state.scene = threeObj;
        new FrameTicker().onTick.add(function (time) {
          if (!state.ringsData.length) return;

          // Data accessors
          var colorAccessor = index$1(state.ringColor);
          var altitudeAccessor = index$1(state.ringAltitude);
          var maxRadiusAccessor = index$1(state.ringMaxRadius);
          var propagationSpeedAccessor = index$1(state.ringPropagationSpeed);
          var repeatPeriodAccessor = index$1(state.ringRepeatPeriod);
          state.ringsData.filter(function (d) {
            return d.__threeObj;
          }).forEach(function (d) {
            var obj = d.__threeObj;
            if ((obj.__nextRingTime || 0) <= time) {
              // time to add a new ring
              var periodSecs = repeatPeriodAccessor(d) / 1000;
              obj.__nextRingTime = time + (periodSecs <= 0 ? Infinity : periodSecs);
              var circleObj = new THREE$3.Line(new CircleLineGeometry(1, state.ringResolution), new THREE$3.LineBasicMaterial());
              var colors = colorAccessor(d);
              var isMultiColor = colors instanceof Array || colors instanceof Function;
              var colorInterpolator;
              if (!isMultiColor) {
                // set only once
                circleObj.material.color = new THREE$3.Color(colorStr2Hex(colors));
                setMaterialOpacity(circleObj.material, colorAlpha(colors));
              } else {
                if (colors instanceof Array) {
                  colorInterpolator = linear().domain(colors.map(function (_, idx) {
                    return idx / (colors.length - 1);
                  })) // same number of stops as colors
                  .range(colors);
                  circleObj.material.transparent = colors.some(function (c) {
                    return colorAlpha(c) < 1;
                  });
                } else {
                  colorInterpolator = colors;
                  circleObj.material.transparent = true;
                }
              }
              var curveR = GLOBE_RADIUS * (1 + altitudeAccessor(d));
              var maxRadius = maxRadiusAccessor(d); // in degrees
              var maxAngle = maxRadius * Math.PI / 180; // in radians
              var propagationSpeed = propagationSpeedAccessor(d);
              var isReverse = propagationSpeed <= 0;
              var updateFn = function updateFn(_ref) {
                var t = _ref.t;
                var ang = (isReverse ? 1 - t : t) * maxAngle;
                circleObj.scale.x = circleObj.scale.y = curveR * Math.sin(ang);
                circleObj.position.z = curveR * (1 - Math.cos(ang));
                if (isMultiColor) {
                  var color = colorInterpolator(t);
                  circleObj.material.color = new THREE$3.Color(colorStr2Hex(color));
                  circleObj.material.transparent && (circleObj.material.opacity = colorAlpha(color));
                }
              };
              if (propagationSpeed === 0) {
                updateFn({
                  t: 0
                });
                obj.add(circleObj);
              } else {
                var transitionTime = Math.abs(maxRadius / propagationSpeed) * 1000;
                new exports$1.Tween({
                  t: 0
                }).to({
                  t: 1
                }, transitionTime).onUpdate(updateFn).onStart(function () {
                  return obj.add(circleObj);
                }).onComplete(function () {
                  obj.remove(circleObj);
                  deallocate(circleObj);
                }).start();
              }
            }
          });
        });
      },
      update: function update(state) {
        // Data accessors
        var latAccessor = index$1(state.ringLat);
        var lngAccessor = index$1(state.ringLng);
        var altitudeAccessor = index$1(state.ringAltitude);
        var globeCenter = state.scene.localToWorld(new THREE$3.Vector3(0, 0, 0)); // translate from local to world coords

        threeDigest(state.ringsData, state.scene, {
          createObj: function createObj() {
            var obj = new THREE$3.Group();
            obj.__globeObjType = 'ring'; // Add object type
            return obj;
          },
          updateObj: function updateObj(obj, d) {
            var lat = latAccessor(d);
            var lng = lngAccessor(d);
            var alt = altitudeAccessor(d);

            // position & orientate inwards
            Object.assign(obj.position, polar2Cartesian(lat, lng, alt));
            obj.lookAt(globeCenter);
          }
        }, {
          removeDelay: 30000
        } // wait until all rings are gone
        );
      }
    });

    var THREE$2 = _objectSpread2$1(_objectSpread2$1({}, window.THREE ? window.THREE // Prefer consumption from global THREE, if exists
    : {}), {}, {
      CSS2DObject: CSS2DObject
    });

    //

    var HtmlElementsLayerKapsule = index$2({
      props: {
        htmlElementsData: {
          "default": []
        },
        htmlLat: {
          "default": 'lat'
        },
        htmlLng: {
          "default": 'lng'
        },
        htmlAltitude: {
          "default": 0
        },
        // in units of globe radius
        htmlElement: {},
        htmlTransitionDuration: {
          "default": 1000,
          triggerUpdate: false
        },
        // ms
        isBehindGlobe: {
          onChange: function onChange() {
            this.updateObjVisibility();
          },
          triggerUpdate: false
        }
      },
      methods: {
        updateObjVisibility: function updateObjVisibility(state, obj) {
          // default to all if no obj specified
          var objs = obj ? [obj] : state.htmlElementsData.map(function (d) {
            return d.__threeObj;
          }).filter(function (d) {
            return d;
          });
          // Hide elements on the far side of the globe
          objs.forEach(function (obj) {
            return obj.visible = !state.isBehindGlobe || !state.isBehindGlobe(obj.position);
          });
        }
      },
      init: function init(threeObj, state) {
        // Clear the scene
        emptyObject(threeObj);

        // Main three object to manipulate
        state.scene = threeObj;
      },
      update: function update(state, changedProps) {
        var _this = this;
        // Data accessors
        var latAccessor = index$1(state.htmlLat);
        var lngAccessor = index$1(state.htmlLng);
        var altitudeAccessor = index$1(state.htmlAltitude);
        var elemAccessor = index$1(state.htmlElement);
        threeDigest(state.htmlElementsData, state.scene, {
          // objs need to be recreated if this prop has changed
          purge: changedProps.hasOwnProperty('htmlElement'),
          createObj: function createObj(d) {
            var elem = elemAccessor(d);
            var obj = new THREE$2.CSS2DObject(elem);
            obj.__globeObjType = 'html'; // Add object type

            return obj;
          },
          updateObj: function updateObj(obj, d) {
            var applyUpdate = function applyUpdate(td) {
              var _obj$__currentTargetD = obj.__currentTargetD = td,
                alt = _obj$__currentTargetD.alt,
                lat = _obj$__currentTargetD.lat,
                lng = _obj$__currentTargetD.lng;
              Object.assign(obj.position, polar2Cartesian(lat, lng, alt));
              _this.updateObjVisibility(obj);
            };
            var targetD = {
              lat: +latAccessor(d),
              lng: +lngAccessor(d),
              alt: +altitudeAccessor(d)
            };
            if (!state.htmlTransitionDuration || state.htmlTransitionDuration < 0 || !obj.__currentTargetD) {
              // set final position
              applyUpdate(targetD);
            } else {
              // animate
              new exports$1.Tween(obj.__currentTargetD).to(targetD, state.pointsTransitionDuration).easing(exports$1.Easing.Quadratic.InOut).onUpdate(applyUpdate).start();
            }
          }
        });
      }
    });

    var THREE$1 = window.THREE ? window.THREE // Prefer consumption from global THREE, if exists
    : {
      Mesh: Mesh,
      MeshLambertMaterial: MeshLambertMaterial,
      SphereGeometry: SphereGeometry
    };

    //

    var ObjectsLayerKapsule = index$2({
      props: {
        objectsData: {
          "default": []
        },
        objectLat: {
          "default": 'lat'
        },
        objectLng: {
          "default": 'lng'
        },
        objectAltitude: {
          "default": 0.01
        },
        // in units of globe radius
        objectThreeObject: {
          "default": new THREE$1.Mesh(
          // default object: yellow sphere
          new THREE$1.SphereGeometry(1, 16, 8), new THREE$1.MeshLambertMaterial({
            color: '#ffffaa',
            transparent: true,
            opacity: 0.7
          }))
        }
      },
      init: function init(threeObj, state) {
        // Clear the scene
        emptyObject(threeObj);

        // Main three object to manipulate
        state.scene = threeObj;
      },
      update: function update(state, changedProps) {
        // Data accessors
        var latAccessor = index$1(state.objectLat);
        var lngAccessor = index$1(state.objectLng);
        var altitudeAccessor = index$1(state.objectAltitude);
        var threeObjAccessor = index$1(state.objectThreeObject);
        threeDigest(state.objectsData, state.scene, {
          // objs need to be recreated if this prop has changed
          purge: changedProps.hasOwnProperty('objectThreeObject'),
          createObj: function createObj(d) {
            var obj = threeObjAccessor(d);
            if (state.objectThreeObject === obj) {
              // clone object if it's a shared object among all points
              obj = obj.clone();
            }
            obj.__globeObjType = 'object'; // Add object type

            return obj;
          },
          updateObj: function updateObj(obj, d) {
            var lat = +latAccessor(d);
            var lng = +lngAccessor(d);
            var alt = +altitudeAccessor(d);
            Object.assign(obj.position, polar2Cartesian(lat, lng, alt));
          }
        });
      }
    });

    //

    var CustomLayerKapsule = index$2({
      props: {
        customLayerData: {
          "default": []
        },
        customThreeObject: {},
        customThreeObjectUpdate: {
          triggerUpdate: false
        }
      },
      init: function init(threeObj, state) {
        // Clear the scene
        emptyObject(threeObj);

        // Main three object to manipulate
        state.scene = threeObj;
      },
      update: function update(state, changedProps) {
        if (!state.customThreeObjectUpdate) {
          emptyObject(state.scene);
        } // Clear the existing objects to create all new, if there's no update method (brute-force)

        var customObjectAccessor = index$1(state.customThreeObject);
        var customObjectUpdateAccessor = index$1(state.customThreeObjectUpdate);
        threeDigest(state.customLayerData, state.scene, {
          // objs need to be recreated if this prop has changed
          purge: changedProps.hasOwnProperty('customThreeObject'),
          createObj: function createObj(d) {
            var obj = customObjectAccessor(d, GLOBE_RADIUS);
            if (obj) {
              if (state.customThreeObject === obj) {
                // clone object if it's a shared object among all points
                obj = obj.clone();
              }
              obj.__globeObjType = 'custom'; // Add object type
            }

            return obj;
          },
          updateObj: function updateObj(obj, d) {
            return customObjectUpdateAccessor(obj, d, GLOBE_RADIUS);
          }
        });
      }
    });

    var THREE$g = window.THREE ? window.THREE // Prefer consumption from global THREE, if exists
    : {
      Group: Group$1,
      Vector2: Vector2,
      Vector3: Vector3
    };

    //

    var layers = ['globeLayer', 'pointsLayer', 'arcsLayer', 'hexBinLayer', 'polygonsLayer', 'hexedPolygonsLayer', 'pathsLayer', 'tilesLayer', 'labelsLayer', 'ringsLayer', 'htmlElementsLayer', 'objectsLayer', 'customLayer'];

    // Expose config from layers
    var bindGlobeLayer = linkKapsule$1('globeLayer', GlobeLayerKapsule);
    var linkedGlobeLayerProps = Object.assign.apply(Object, _toConsumableArray$2(['globeImageUrl', 'bumpImageUrl', 'showGlobe', 'showGraticules', 'showAtmosphere', 'atmosphereColor', 'atmosphereAltitude'].map(function (p) {
      return _defineProperty$2({}, p, bindGlobeLayer.linkProp(p));
    })));
    var linkedGlobeLayerMethods = Object.assign.apply(Object, _toConsumableArray$2(['globeMaterial'].map(function (p) {
      return _defineProperty$2({}, p, bindGlobeLayer.linkMethod(p));
    })));
    var bindPointsLayer = linkKapsule$1('pointsLayer', PointsLayerKapsule);
    var linkedPointsLayerProps = Object.assign.apply(Object, _toConsumableArray$2(['pointsData', 'pointLat', 'pointLng', 'pointColor', 'pointAltitude', 'pointRadius', 'pointResolution', 'pointsMerge', 'pointsTransitionDuration'].map(function (p) {
      return _defineProperty$2({}, p, bindPointsLayer.linkProp(p));
    })));
    var bindArcsLayer = linkKapsule$1('arcsLayer', ArcsLayerKapsule);
    var linkedArcsLayerProps = Object.assign.apply(Object, _toConsumableArray$2(['arcsData', 'arcStartLat', 'arcStartLng', 'arcEndLat', 'arcEndLng', 'arcColor', 'arcAltitude', 'arcAltitudeAutoScale', 'arcStroke', 'arcCurveResolution', 'arcCircularResolution', 'arcDashLength', 'arcDashGap', 'arcDashInitialGap', 'arcDashAnimateTime', 'arcsTransitionDuration'].map(function (p) {
      return _defineProperty$2({}, p, bindArcsLayer.linkProp(p));
    })));
    var bindHexBinLayer = linkKapsule$1('hexBinLayer', HexBinLayerKapsule);
    var linkedHexBinLayerProps = Object.assign.apply(Object, _toConsumableArray$2(['hexBinPointsData', 'hexBinPointLat', 'hexBinPointLng', 'hexBinPointWeight', 'hexBinResolution', 'hexMargin', 'hexTopCurvatureResolution', 'hexTopColor', 'hexSideColor', 'hexAltitude', 'hexBinMerge', 'hexTransitionDuration'].map(function (p) {
      return _defineProperty$2({}, p, bindHexBinLayer.linkProp(p));
    })));
    var bindHexedPolygonsLayer = linkKapsule$1('hexedPolygonsLayer', HexedPolygonsLayerKapsule);
    var linkedHexedPolygonsLayerProps = Object.assign.apply(Object, _toConsumableArray$2(['hexPolygonsData', 'hexPolygonGeoJsonGeometry', 'hexPolygonColor', 'hexPolygonAltitude', 'hexPolygonResolution', 'hexPolygonMargin', 'hexPolygonCurvatureResolution', 'hexPolygonsTransitionDuration'].map(function (p) {
      return _defineProperty$2({}, p, bindHexedPolygonsLayer.linkProp(p));
    })));
    var bindPolygonsLayer = linkKapsule$1('polygonsLayer', PolygonsLayerKapsule);
    var linkedPolygonsLayerProps = Object.assign.apply(Object, _toConsumableArray$2(['polygonsData', 'polygonGeoJsonGeometry', 'polygonCapColor', 'polygonCapMaterial', 'polygonSideColor', 'polygonSideMaterial', 'polygonStrokeColor', 'polygonAltitude', 'polygonCapCurvatureResolution', 'polygonsTransitionDuration'].map(function (p) {
      return _defineProperty$2({}, p, bindPolygonsLayer.linkProp(p));
    })));
    var bindPathsLayer = linkKapsule$1('pathsLayer', PathsLayerKapsule);
    var linkedPathsLayerProps = Object.assign.apply(Object, _toConsumableArray$2(['pathsData', 'pathPoints', 'pathPointLat', 'pathPointLng', 'pathPointAlt', 'pathResolution', 'pathColor', 'pathStroke', 'pathDashLength', 'pathDashGap', 'pathDashInitialGap', 'pathDashAnimateTime', 'pathTransitionDuration'].map(function (p) {
      return _defineProperty$2({}, p, bindPathsLayer.linkProp(p));
    })));
    var bindTilesLayer = linkKapsule$1('tilesLayer', TilesLayerKapsule);
    var linkedTilesLayerProps = Object.assign.apply(Object, _toConsumableArray$2(['tilesData', 'tileLat', 'tileLng', 'tileAltitude', 'tileWidth', 'tileHeight', 'tileUseGlobeProjection', 'tileMaterial', 'tileCurvatureResolution', 'tilesTransitionDuration'].map(function (p) {
      return _defineProperty$2({}, p, bindTilesLayer.linkProp(p));
    })));
    var bindLabelsLayer = linkKapsule$1('labelsLayer', LabelsLayerKapsule);
    var linkedLabelsLayerProps = Object.assign.apply(Object, _toConsumableArray$2(['labelsData', 'labelLat', 'labelLng', 'labelAltitude', 'labelRotation', 'labelText', 'labelSize', 'labelTypeFace', 'labelColor', 'labelResolution', 'labelIncludeDot', 'labelDotRadius', 'labelDotOrientation', 'labelsTransitionDuration'].map(function (p) {
      return _defineProperty$2({}, p, bindLabelsLayer.linkProp(p));
    })));
    var bindRingsLayer = linkKapsule$1('ringsLayer', RingsLayerKapsule);
    var linkedRingsLayerProps = Object.assign.apply(Object, _toConsumableArray$2(['ringsData', 'ringLat', 'ringLng', 'ringAltitude', 'ringColor', 'ringResolution', 'ringMaxRadius', 'ringPropagationSpeed', 'ringRepeatPeriod'].map(function (p) {
      return _defineProperty$2({}, p, bindRingsLayer.linkProp(p));
    })));
    var bindHtmlElementsLayer = linkKapsule$1('htmlElementsLayer', HtmlElementsLayerKapsule);
    var linkedHtmlElementsLayerProps = Object.assign.apply(Object, _toConsumableArray$2(['htmlElementsData', 'htmlLat', 'htmlLng', 'htmlAltitude', 'htmlElement', 'htmlTransitionDuration'].map(function (p) {
      return _defineProperty$2({}, p, bindHtmlElementsLayer.linkProp(p));
    })));
    var bindObjectsLayer = linkKapsule$1('objectsLayer', ObjectsLayerKapsule);
    var linkedObjectsLayerProps = Object.assign.apply(Object, _toConsumableArray$2(['objectsData', 'objectLat', 'objectLng', 'objectAltitude', 'objectThreeObject'].map(function (p) {
      return _defineProperty$2({}, p, bindObjectsLayer.linkProp(p));
    })));
    var bindCustomLayer = linkKapsule$1('customLayer', CustomLayerKapsule);
    var linkedCustomLayerProps = Object.assign.apply(Object, _toConsumableArray$2(['customLayerData', 'customThreeObject', 'customThreeObjectUpdate'].map(function (p) {
      return _defineProperty$2({}, p, bindCustomLayer.linkProp(p));
    })));

    //

    var Globe = index$2({
      props: _objectSpread2$1(_objectSpread2$1(_objectSpread2$1(_objectSpread2$1(_objectSpread2$1(_objectSpread2$1(_objectSpread2$1(_objectSpread2$1(_objectSpread2$1(_objectSpread2$1(_objectSpread2$1(_objectSpread2$1(_objectSpread2$1({
        onGlobeReady: {
          triggerUpdate: false
        },
        rendererSize: {
          "default": new THREE$g.Vector2(window.innerWidth, window.innerHeight),
          onChange: function onChange(rendererSize, state) {
            state.pathsLayer.rendererSize(rendererSize);
          },
          triggerUpdate: false
        }
      }, linkedGlobeLayerProps), linkedPointsLayerProps), linkedArcsLayerProps), linkedHexBinLayerProps), linkedPolygonsLayerProps), linkedHexedPolygonsLayerProps), linkedPathsLayerProps), linkedTilesLayerProps), linkedLabelsLayerProps), linkedRingsLayerProps), linkedHtmlElementsLayerProps), linkedObjectsLayerProps), linkedCustomLayerProps),
      methods: _objectSpread2$1({
        getGlobeRadius: getGlobeRadius,
        getCoords: function getCoords(state) {
          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            args[_key - 1] = arguments[_key];
          }
          return polar2Cartesian.apply(void 0, args);
        },
        toGeoCoords: function toGeoCoords(state) {
          for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
            args[_key2 - 1] = arguments[_key2];
          }
          return cartesian2Polar.apply(void 0, args);
        },
        setPointOfView: function setPointOfView(state, globalPov, globePos) {
          var isBehindGlobe = undefined;
          if (globalPov) {
            var globeRadius = getGlobeRadius();
            var pov = globePos ? globalPov.clone().sub(globePos) : globalPov; // convert to local vector

            var povDist, povEdgeDist, povEdgeAngle;
            isBehindGlobe = function isBehindGlobe(pos) {
              povDist === undefined && (povDist = pov.length());

              // check if it's behind plane of globe's visible area
              // maxSurfacePosAngle === undefined && (maxSurfacePosAngle = Math.acos(globeRadius / povDist));
              // return pov.angleTo(pos) > maxSurfacePosAngle;

              // more sophisticated method that checks also pos altitude
              povEdgeDist === undefined && (povEdgeDist = Math.sqrt(Math.pow(povDist, 2) - Math.pow(globeRadius, 2)));
              povEdgeAngle === undefined && (povEdgeAngle = Math.acos(povEdgeDist / povDist));
              var povPosDist = pov.distanceTo(pos);
              if (povPosDist < povEdgeDist) return false; // pos is closer than visible edge of globe

              var posDist = pos.length();
              var povPosAngle = Math.acos((Math.pow(povDist, 2) + Math.pow(povPosDist, 2) - Math.pow(posDist, 2)) / (2 * povDist * povPosDist)); // triangle solver
              return povPosAngle < povEdgeAngle; // pos is within globe's visible area cone
            };
          }

          // pass behind globe checker for layers that need it
          state.layersThatNeedBehindGlobeChecker.forEach(function (l) {
            return l.isBehindGlobe(isBehindGlobe);
          });
        }
      }, linkedGlobeLayerMethods),
      stateInit: function stateInit() {
        var layers = {
          globeLayer: GlobeLayerKapsule(),
          pointsLayer: PointsLayerKapsule(),
          arcsLayer: ArcsLayerKapsule(),
          hexBinLayer: HexBinLayerKapsule(),
          polygonsLayer: PolygonsLayerKapsule(),
          hexedPolygonsLayer: HexedPolygonsLayerKapsule(),
          pathsLayer: PathsLayerKapsule(),
          tilesLayer: TilesLayerKapsule(),
          labelsLayer: LabelsLayerKapsule(),
          ringsLayer: RingsLayerKapsule(),
          htmlElementsLayer: HtmlElementsLayerKapsule(),
          objectsLayer: ObjectsLayerKapsule(),
          customLayer: CustomLayerKapsule()
        };
        return _objectSpread2$1(_objectSpread2$1({}, layers), {}, {
          layersThatNeedBehindGlobeChecker: Object.values(layers).filter(function (l) {
            return l.hasOwnProperty('isBehindGlobe');
          })
        });
      },
      init: function init(threeObj, state, _ref15) {
        var _ref15$animateIn = _ref15.animateIn,
          animateIn = _ref15$animateIn === void 0 ? true : _ref15$animateIn,
          _ref15$waitForGlobeRe = _ref15.waitForGlobeReady,
          waitForGlobeReady = _ref15$waitForGlobeRe === void 0 ? true : _ref15$waitForGlobeRe;
        // Clear the scene
        emptyObject(threeObj);

        // Main three object to manipulate
        threeObj.add(state.scene = new THREE$g.Group());
        state.scene.visible = false; // hide scene before globe initialization

        // Add all layers groups
        layers.forEach(function (layer) {
          var g = new THREE$g.Group();
          state.scene.add(g);
          state[layer](g);
        });
        var initGlobe = function initGlobe() {
          if (animateIn) {
            // Animate build-in just once
            state.scene.scale.set(1e-6, 1e-6, 1e-6);
            new exports$1.Tween({
              k: 1e-6
            }).to({
              k: 1
            }, 600).easing(exports$1.Easing.Quadratic.Out).onUpdate(function (_ref16) {
              var k = _ref16.k;
              return state.scene.scale.set(k, k, k);
            }).start();
            var rotAxis = new THREE$g.Vector3(0, 1, 0);
            new exports$1.Tween({
              rot: Math.PI * 2
            }).to({
              rot: 0
            }, 1200).easing(exports$1.Easing.Quintic.Out).onUpdate(function (_ref17) {
              var rot = _ref17.rot;
              return state.scene.setRotationFromAxisAngle(rotAxis, rot);
            }).start();
          }
          state.scene.visible = true;
          state.onGlobeReady && state.onGlobeReady();
        };
        waitForGlobeReady ? state.globeLayer.onReady(initGlobe) : initGlobe();

        // run tween updates
        (function onFrame() {
          requestAnimationFrame(onFrame);
          exports$1.update();
        })(); // IIFE
      },
      update: function update(state) {}
    });

    function fromKapsule (kapsule) {
      var baseClass = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Object;
      var initKapsuleWithSelf = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var FromKapsule = /*#__PURE__*/function (_baseClass) {
        _inherits(FromKapsule, _baseClass);
        var _super = _createSuper(FromKapsule);
        function FromKapsule() {
          var _this;
          _classCallCheck(this, FromKapsule);
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _super.call.apply(_super, [this].concat(args));
          _this.__kapsuleInstance = kapsule.apply(void 0, args).apply(void 0, [].concat(_toConsumableArray$2(initKapsuleWithSelf ? [_assertThisInitialized$1(_this)] : []), args));
          return _this;
        }
        return _createClass$1(FromKapsule);
      }(baseClass); // attach kapsule props/methods to class prototype
      Object.keys(kapsule()).forEach(function (m) {
        return FromKapsule.prototype[m] = function () {
          var _this$__kapsuleInstan;
          var returnVal = (_this$__kapsuleInstan = this.__kapsuleInstance)[m].apply(_this$__kapsuleInstan, arguments);
          return returnVal === this.__kapsuleInstance ? this // chain based on this class, not the kapsule obj
          : returnVal;
        };
      });
      return FromKapsule;
    }

    var three$1 = window.THREE ? window.THREE : {
      Group: Group$1
    }; // Prefer consumption from global THREE, if exists
    var threeGlobe = fromKapsule(Globe, three$1.Group, true);

    const _changeEvent$2 = { type: 'change' };
    const _startEvent$1 = { type: 'start' };
    const _endEvent$1 = { type: 'end' };

    class TrackballControls extends EventDispatcher {

    	constructor( object, domElement ) {

    		super();

    		const scope = this;
    		const STATE = { NONE: - 1, ROTATE: 0, ZOOM: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_ZOOM_PAN: 4 };

    		this.object = object;
    		this.domElement = domElement;
    		this.domElement.style.touchAction = 'none'; // disable touch scroll

    		// API

    		this.enabled = true;

    		this.screen = { left: 0, top: 0, width: 0, height: 0 };

    		this.rotateSpeed = 1.0;
    		this.zoomSpeed = 1.2;
    		this.panSpeed = 0.3;

    		this.noRotate = false;
    		this.noZoom = false;
    		this.noPan = false;

    		this.staticMoving = false;
    		this.dynamicDampingFactor = 0.2;

    		this.minDistance = 0;
    		this.maxDistance = Infinity;

    		this.keys = [ 'KeyA' /*A*/, 'KeyS' /*S*/, 'KeyD' /*D*/ ];

    		this.mouseButtons = { LEFT: MOUSE.ROTATE, MIDDLE: MOUSE.DOLLY, RIGHT: MOUSE.PAN };

    		// internals

    		this.target = new Vector3();

    		const EPS = 0.000001;

    		const lastPosition = new Vector3();
    		let lastZoom = 1;

    		let _state = STATE.NONE,
    			_keyState = STATE.NONE,

    			_touchZoomDistanceStart = 0,
    			_touchZoomDistanceEnd = 0,

    			_lastAngle = 0;

    		const _eye = new Vector3(),

    			_movePrev = new Vector2(),
    			_moveCurr = new Vector2(),

    			_lastAxis = new Vector3(),

    			_zoomStart = new Vector2(),
    			_zoomEnd = new Vector2(),

    			_panStart = new Vector2(),
    			_panEnd = new Vector2(),

    			_pointers = [],
    			_pointerPositions = {};

    		// for reset

    		this.target0 = this.target.clone();
    		this.position0 = this.object.position.clone();
    		this.up0 = this.object.up.clone();
    		this.zoom0 = this.object.zoom;

    		// methods

    		this.handleResize = function () {

    			const box = scope.domElement.getBoundingClientRect();
    			// adjustments come from similar code in the jquery offset() function
    			const d = scope.domElement.ownerDocument.documentElement;
    			scope.screen.left = box.left + window.pageXOffset - d.clientLeft;
    			scope.screen.top = box.top + window.pageYOffset - d.clientTop;
    			scope.screen.width = box.width;
    			scope.screen.height = box.height;

    		};

    		const getMouseOnScreen = ( function () {

    			const vector = new Vector2();

    			return function getMouseOnScreen( pageX, pageY ) {

    				vector.set(
    					( pageX - scope.screen.left ) / scope.screen.width,
    					( pageY - scope.screen.top ) / scope.screen.height
    				);

    				return vector;

    			};

    		}() );

    		const getMouseOnCircle = ( function () {

    			const vector = new Vector2();

    			return function getMouseOnCircle( pageX, pageY ) {

    				vector.set(
    					( ( pageX - scope.screen.width * 0.5 - scope.screen.left ) / ( scope.screen.width * 0.5 ) ),
    					( ( scope.screen.height + 2 * ( scope.screen.top - pageY ) ) / scope.screen.width ) // screen.width intentional
    				);

    				return vector;

    			};

    		}() );

    		this.rotateCamera = ( function () {

    			const axis = new Vector3(),
    				quaternion = new Quaternion(),
    				eyeDirection = new Vector3(),
    				objectUpDirection = new Vector3(),
    				objectSidewaysDirection = new Vector3(),
    				moveDirection = new Vector3();

    			return function rotateCamera() {

    				moveDirection.set( _moveCurr.x - _movePrev.x, _moveCurr.y - _movePrev.y, 0 );
    				let angle = moveDirection.length();

    				if ( angle ) {

    					_eye.copy( scope.object.position ).sub( scope.target );

    					eyeDirection.copy( _eye ).normalize();
    					objectUpDirection.copy( scope.object.up ).normalize();
    					objectSidewaysDirection.crossVectors( objectUpDirection, eyeDirection ).normalize();

    					objectUpDirection.setLength( _moveCurr.y - _movePrev.y );
    					objectSidewaysDirection.setLength( _moveCurr.x - _movePrev.x );

    					moveDirection.copy( objectUpDirection.add( objectSidewaysDirection ) );

    					axis.crossVectors( moveDirection, _eye ).normalize();

    					angle *= scope.rotateSpeed;
    					quaternion.setFromAxisAngle( axis, angle );

    					_eye.applyQuaternion( quaternion );
    					scope.object.up.applyQuaternion( quaternion );

    					_lastAxis.copy( axis );
    					_lastAngle = angle;

    				} else if ( ! scope.staticMoving && _lastAngle ) {

    					_lastAngle *= Math.sqrt( 1.0 - scope.dynamicDampingFactor );
    					_eye.copy( scope.object.position ).sub( scope.target );
    					quaternion.setFromAxisAngle( _lastAxis, _lastAngle );
    					_eye.applyQuaternion( quaternion );
    					scope.object.up.applyQuaternion( quaternion );

    				}

    				_movePrev.copy( _moveCurr );

    			};

    		}() );


    		this.zoomCamera = function () {

    			let factor;

    			if ( _state === STATE.TOUCH_ZOOM_PAN ) {

    				factor = _touchZoomDistanceStart / _touchZoomDistanceEnd;
    				_touchZoomDistanceStart = _touchZoomDistanceEnd;

    				if ( scope.object.isPerspectiveCamera ) {

    					_eye.multiplyScalar( factor );

    				} else if ( scope.object.isOrthographicCamera ) {

    					scope.object.zoom /= factor;
    					scope.object.updateProjectionMatrix();

    				} else {

    					console.warn( 'THREE.TrackballControls: Unsupported camera type' );

    				}

    			} else {

    				factor = 1.0 + ( _zoomEnd.y - _zoomStart.y ) * scope.zoomSpeed;

    				if ( factor !== 1.0 && factor > 0.0 ) {

    					if ( scope.object.isPerspectiveCamera ) {

    						_eye.multiplyScalar( factor );

    					} else if ( scope.object.isOrthographicCamera ) {

    						scope.object.zoom /= factor;
    						scope.object.updateProjectionMatrix();

    					} else {

    						console.warn( 'THREE.TrackballControls: Unsupported camera type' );

    					}

    				}

    				if ( scope.staticMoving ) {

    					_zoomStart.copy( _zoomEnd );

    				} else {

    					_zoomStart.y += ( _zoomEnd.y - _zoomStart.y ) * this.dynamicDampingFactor;

    				}

    			}

    		};

    		this.panCamera = ( function () {

    			const mouseChange = new Vector2(),
    				objectUp = new Vector3(),
    				pan = new Vector3();

    			return function panCamera() {

    				mouseChange.copy( _panEnd ).sub( _panStart );

    				if ( mouseChange.lengthSq() ) {

    					if ( scope.object.isOrthographicCamera ) {

    						const scale_x = ( scope.object.right - scope.object.left ) / scope.object.zoom / scope.domElement.clientWidth;
    						const scale_y = ( scope.object.top - scope.object.bottom ) / scope.object.zoom / scope.domElement.clientWidth;

    						mouseChange.x *= scale_x;
    						mouseChange.y *= scale_y;

    					}

    					mouseChange.multiplyScalar( _eye.length() * scope.panSpeed );

    					pan.copy( _eye ).cross( scope.object.up ).setLength( mouseChange.x );
    					pan.add( objectUp.copy( scope.object.up ).setLength( mouseChange.y ) );

    					scope.object.position.add( pan );
    					scope.target.add( pan );

    					if ( scope.staticMoving ) {

    						_panStart.copy( _panEnd );

    					} else {

    						_panStart.add( mouseChange.subVectors( _panEnd, _panStart ).multiplyScalar( scope.dynamicDampingFactor ) );

    					}

    				}

    			};

    		}() );

    		this.checkDistances = function () {

    			if ( ! scope.noZoom || ! scope.noPan ) {

    				if ( _eye.lengthSq() > scope.maxDistance * scope.maxDistance ) {

    					scope.object.position.addVectors( scope.target, _eye.setLength( scope.maxDistance ) );
    					_zoomStart.copy( _zoomEnd );

    				}

    				if ( _eye.lengthSq() < scope.minDistance * scope.minDistance ) {

    					scope.object.position.addVectors( scope.target, _eye.setLength( scope.minDistance ) );
    					_zoomStart.copy( _zoomEnd );

    				}

    			}

    		};

    		this.update = function () {

    			_eye.subVectors( scope.object.position, scope.target );

    			if ( ! scope.noRotate ) {

    				scope.rotateCamera();

    			}

    			if ( ! scope.noZoom ) {

    				scope.zoomCamera();

    			}

    			if ( ! scope.noPan ) {

    				scope.panCamera();

    			}

    			scope.object.position.addVectors( scope.target, _eye );

    			if ( scope.object.isPerspectiveCamera ) {

    				scope.checkDistances();

    				scope.object.lookAt( scope.target );

    				if ( lastPosition.distanceToSquared( scope.object.position ) > EPS ) {

    					scope.dispatchEvent( _changeEvent$2 );

    					lastPosition.copy( scope.object.position );

    				}

    			} else if ( scope.object.isOrthographicCamera ) {

    				scope.object.lookAt( scope.target );

    				if ( lastPosition.distanceToSquared( scope.object.position ) > EPS || lastZoom !== scope.object.zoom ) {

    					scope.dispatchEvent( _changeEvent$2 );

    					lastPosition.copy( scope.object.position );
    					lastZoom = scope.object.zoom;

    				}

    			} else {

    				console.warn( 'THREE.TrackballControls: Unsupported camera type' );

    			}

    		};

    		this.reset = function () {

    			_state = STATE.NONE;
    			_keyState = STATE.NONE;

    			scope.target.copy( scope.target0 );
    			scope.object.position.copy( scope.position0 );
    			scope.object.up.copy( scope.up0 );
    			scope.object.zoom = scope.zoom0;

    			scope.object.updateProjectionMatrix();

    			_eye.subVectors( scope.object.position, scope.target );

    			scope.object.lookAt( scope.target );

    			scope.dispatchEvent( _changeEvent$2 );

    			lastPosition.copy( scope.object.position );
    			lastZoom = scope.object.zoom;

    		};

    		// listeners

    		function onPointerDown( event ) {

    			if ( scope.enabled === false ) return;

    			if ( _pointers.length === 0 ) {

    				scope.domElement.setPointerCapture( event.pointerId );

    				scope.domElement.addEventListener( 'pointermove', onPointerMove );
    				scope.domElement.addEventListener( 'pointerup', onPointerUp );

    			}

    			//

    			addPointer( event );

    			if ( event.pointerType === 'touch' ) {

    				onTouchStart( event );

    			} else {

    				onMouseDown( event );

    			}

    		}

    		function onPointerMove( event ) {

    			if ( scope.enabled === false ) return;

    			if ( event.pointerType === 'touch' ) {

    				onTouchMove( event );

    			} else {

    				onMouseMove( event );

    			}

    		}

    		function onPointerUp( event ) {

    			if ( scope.enabled === false ) return;

    			if ( event.pointerType === 'touch' ) {

    				onTouchEnd( event );

    			} else {

    				onMouseUp();

    			}

    			//

    			removePointer( event );

    			if ( _pointers.length === 0 ) {

    				scope.domElement.releasePointerCapture( event.pointerId );

    				scope.domElement.removeEventListener( 'pointermove', onPointerMove );
    				scope.domElement.removeEventListener( 'pointerup', onPointerUp );

    			}


    		}

    		function onPointerCancel( event ) {

    			removePointer( event );

    		}

    		function keydown( event ) {

    			if ( scope.enabled === false ) return;

    			window.removeEventListener( 'keydown', keydown );

    			if ( _keyState !== STATE.NONE ) {

    				return;

    			} else if ( event.code === scope.keys[ STATE.ROTATE ] && ! scope.noRotate ) {

    				_keyState = STATE.ROTATE;

    			} else if ( event.code === scope.keys[ STATE.ZOOM ] && ! scope.noZoom ) {

    				_keyState = STATE.ZOOM;

    			} else if ( event.code === scope.keys[ STATE.PAN ] && ! scope.noPan ) {

    				_keyState = STATE.PAN;

    			}

    		}

    		function keyup() {

    			if ( scope.enabled === false ) return;

    			_keyState = STATE.NONE;

    			window.addEventListener( 'keydown', keydown );

    		}

    		function onMouseDown( event ) {

    			if ( _state === STATE.NONE ) {

    				switch ( event.button ) {

    					case scope.mouseButtons.LEFT:
    						_state = STATE.ROTATE;
    						break;

    					case scope.mouseButtons.MIDDLE:
    						_state = STATE.ZOOM;
    						break;

    					case scope.mouseButtons.RIGHT:
    						_state = STATE.PAN;
    						break;

    				}

    			}

    			const state = ( _keyState !== STATE.NONE ) ? _keyState : _state;

    			if ( state === STATE.ROTATE && ! scope.noRotate ) {

    				_moveCurr.copy( getMouseOnCircle( event.pageX, event.pageY ) );
    				_movePrev.copy( _moveCurr );

    			} else if ( state === STATE.ZOOM && ! scope.noZoom ) {

    				_zoomStart.copy( getMouseOnScreen( event.pageX, event.pageY ) );
    				_zoomEnd.copy( _zoomStart );

    			} else if ( state === STATE.PAN && ! scope.noPan ) {

    				_panStart.copy( getMouseOnScreen( event.pageX, event.pageY ) );
    				_panEnd.copy( _panStart );

    			}

    			scope.dispatchEvent( _startEvent$1 );

    		}

    		function onMouseMove( event ) {

    			const state = ( _keyState !== STATE.NONE ) ? _keyState : _state;

    			if ( state === STATE.ROTATE && ! scope.noRotate ) {

    				_movePrev.copy( _moveCurr );
    				_moveCurr.copy( getMouseOnCircle( event.pageX, event.pageY ) );

    			} else if ( state === STATE.ZOOM && ! scope.noZoom ) {

    				_zoomEnd.copy( getMouseOnScreen( event.pageX, event.pageY ) );

    			} else if ( state === STATE.PAN && ! scope.noPan ) {

    				_panEnd.copy( getMouseOnScreen( event.pageX, event.pageY ) );

    			}

    		}

    		function onMouseUp() {

    			_state = STATE.NONE;

    			scope.dispatchEvent( _endEvent$1 );

    		}

    		function onMouseWheel( event ) {

    			if ( scope.enabled === false ) return;

    			if ( scope.noZoom === true ) return;

    			event.preventDefault();

    			switch ( event.deltaMode ) {

    				case 2:
    					// Zoom in pages
    					_zoomStart.y -= event.deltaY * 0.025;
    					break;

    				case 1:
    					// Zoom in lines
    					_zoomStart.y -= event.deltaY * 0.01;
    					break;

    				default:
    					// undefined, 0, assume pixels
    					_zoomStart.y -= event.deltaY * 0.00025;
    					break;

    			}

    			scope.dispatchEvent( _startEvent$1 );
    			scope.dispatchEvent( _endEvent$1 );

    		}

    		function onTouchStart( event ) {

    			trackPointer( event );

    			switch ( _pointers.length ) {

    				case 1:
    					_state = STATE.TOUCH_ROTATE;
    					_moveCurr.copy( getMouseOnCircle( _pointers[ 0 ].pageX, _pointers[ 0 ].pageY ) );
    					_movePrev.copy( _moveCurr );
    					break;

    				default: // 2 or more
    					_state = STATE.TOUCH_ZOOM_PAN;
    					const dx = _pointers[ 0 ].pageX - _pointers[ 1 ].pageX;
    					const dy = _pointers[ 0 ].pageY - _pointers[ 1 ].pageY;
    					_touchZoomDistanceEnd = _touchZoomDistanceStart = Math.sqrt( dx * dx + dy * dy );

    					const x = ( _pointers[ 0 ].pageX + _pointers[ 1 ].pageX ) / 2;
    					const y = ( _pointers[ 0 ].pageY + _pointers[ 1 ].pageY ) / 2;
    					_panStart.copy( getMouseOnScreen( x, y ) );
    					_panEnd.copy( _panStart );
    					break;

    			}

    			scope.dispatchEvent( _startEvent$1 );

    		}

    		function onTouchMove( event ) {

    			trackPointer( event );

    			switch ( _pointers.length ) {

    				case 1:
    					_movePrev.copy( _moveCurr );
    					_moveCurr.copy( getMouseOnCircle( event.pageX, event.pageY ) );
    					break;

    				default: // 2 or more

    					const position = getSecondPointerPosition( event );

    					const dx = event.pageX - position.x;
    					const dy = event.pageY - position.y;
    					_touchZoomDistanceEnd = Math.sqrt( dx * dx + dy * dy );

    					const x = ( event.pageX + position.x ) / 2;
    					const y = ( event.pageY + position.y ) / 2;
    					_panEnd.copy( getMouseOnScreen( x, y ) );
    					break;

    			}

    		}

    		function onTouchEnd( event ) {

    			switch ( _pointers.length ) {

    				case 0:
    					_state = STATE.NONE;
    					break;

    				case 1:
    					_state = STATE.TOUCH_ROTATE;
    					_moveCurr.copy( getMouseOnCircle( event.pageX, event.pageY ) );
    					_movePrev.copy( _moveCurr );
    					break;

    				case 2:
    					_state = STATE.TOUCH_ZOOM_PAN;

    					for ( let i = 0; i < _pointers.length; i ++ ) {

    						if ( _pointers[ i ].pointerId !== event.pointerId ) {

    							const position = _pointerPositions[ _pointers[ i ].pointerId ];
    							_moveCurr.copy( getMouseOnCircle( position.x, position.y ) );
    							_movePrev.copy( _moveCurr );
    							break;

    						}

    					}

    					break;

    			}

    			scope.dispatchEvent( _endEvent$1 );

    		}

    		function contextmenu( event ) {

    			if ( scope.enabled === false ) return;

    			event.preventDefault();

    		}

    		function addPointer( event ) {

    			_pointers.push( event );

    		}

    		function removePointer( event ) {

    			delete _pointerPositions[ event.pointerId ];

    			for ( let i = 0; i < _pointers.length; i ++ ) {

    				if ( _pointers[ i ].pointerId == event.pointerId ) {

    					_pointers.splice( i, 1 );
    					return;

    				}

    			}

    		}

    		function trackPointer( event ) {

    			let position = _pointerPositions[ event.pointerId ];

    			if ( position === undefined ) {

    				position = new Vector2();
    				_pointerPositions[ event.pointerId ] = position;

    			}

    			position.set( event.pageX, event.pageY );

    		}

    		function getSecondPointerPosition( event ) {

    			const pointer = ( event.pointerId === _pointers[ 0 ].pointerId ) ? _pointers[ 1 ] : _pointers[ 0 ];

    			return _pointerPositions[ pointer.pointerId ];

    		}

    		this.dispose = function () {

    			scope.domElement.removeEventListener( 'contextmenu', contextmenu );

    			scope.domElement.removeEventListener( 'pointerdown', onPointerDown );
    			scope.domElement.removeEventListener( 'pointercancel', onPointerCancel );
    			scope.domElement.removeEventListener( 'wheel', onMouseWheel );

    			scope.domElement.removeEventListener( 'pointermove', onPointerMove );
    			scope.domElement.removeEventListener( 'pointerup', onPointerUp );

    			window.removeEventListener( 'keydown', keydown );
    			window.removeEventListener( 'keyup', keyup );

    		};

    		this.domElement.addEventListener( 'contextmenu', contextmenu );

    		this.domElement.addEventListener( 'pointerdown', onPointerDown );
    		this.domElement.addEventListener( 'pointercancel', onPointerCancel );
    		this.domElement.addEventListener( 'wheel', onMouseWheel, { passive: false } );


    		window.addEventListener( 'keydown', keydown );
    		window.addEventListener( 'keyup', keyup );

    		this.handleResize();

    		// force an update at start
    		this.update();

    	}

    }

    // This set of controls performs orbiting, dollying (zooming), and panning.
    // Unlike TrackballControls, it maintains the "up" direction object.up (+Y by default).
    //
    //    Orbit - left mouse / touch: one-finger move
    //    Zoom - middle mouse, or mousewheel / touch: two-finger spread or squish
    //    Pan - right mouse, or left mouse + ctrl/meta/shiftKey, or arrow keys / touch: two-finger move

    const _changeEvent$1 = { type: 'change' };
    const _startEvent = { type: 'start' };
    const _endEvent = { type: 'end' };

    class OrbitControls extends EventDispatcher {

    	constructor( object, domElement ) {

    		super();

    		this.object = object;
    		this.domElement = domElement;
    		this.domElement.style.touchAction = 'none'; // disable touch scroll

    		// Set to false to disable this control
    		this.enabled = true;

    		// "target" sets the location of focus, where the object orbits around
    		this.target = new Vector3();

    		// How far you can dolly in and out ( PerspectiveCamera only )
    		this.minDistance = 0;
    		this.maxDistance = Infinity;

    		// How far you can zoom in and out ( OrthographicCamera only )
    		this.minZoom = 0;
    		this.maxZoom = Infinity;

    		// How far you can orbit vertically, upper and lower limits.
    		// Range is 0 to Math.PI radians.
    		this.minPolarAngle = 0; // radians
    		this.maxPolarAngle = Math.PI; // radians

    		// How far you can orbit horizontally, upper and lower limits.
    		// If set, the interval [ min, max ] must be a sub-interval of [ - 2 PI, 2 PI ], with ( max - min < 2 PI )
    		this.minAzimuthAngle = - Infinity; // radians
    		this.maxAzimuthAngle = Infinity; // radians

    		// Set to true to enable damping (inertia)
    		// If damping is enabled, you must call controls.update() in your animation loop
    		this.enableDamping = false;
    		this.dampingFactor = 0.05;

    		// This option actually enables dollying in and out; left as "zoom" for backwards compatibility.
    		// Set to false to disable zooming
    		this.enableZoom = true;
    		this.zoomSpeed = 1.0;

    		// Set to false to disable rotating
    		this.enableRotate = true;
    		this.rotateSpeed = 1.0;

    		// Set to false to disable panning
    		this.enablePan = true;
    		this.panSpeed = 1.0;
    		this.screenSpacePanning = true; // if false, pan orthogonal to world-space direction camera.up
    		this.keyPanSpeed = 7.0;	// pixels moved per arrow key push

    		// Set to true to automatically rotate around the target
    		// If auto-rotate is enabled, you must call controls.update() in your animation loop
    		this.autoRotate = false;
    		this.autoRotateSpeed = 2.0; // 30 seconds per orbit when fps is 60

    		// The four arrow keys
    		this.keys = { LEFT: 'ArrowLeft', UP: 'ArrowUp', RIGHT: 'ArrowRight', BOTTOM: 'ArrowDown' };

    		// Mouse buttons
    		this.mouseButtons = { LEFT: MOUSE.ROTATE, MIDDLE: MOUSE.DOLLY, RIGHT: MOUSE.PAN };

    		// Touch fingers
    		this.touches = { ONE: TOUCH.ROTATE, TWO: TOUCH.DOLLY_PAN };

    		// for reset
    		this.target0 = this.target.clone();
    		this.position0 = this.object.position.clone();
    		this.zoom0 = this.object.zoom;

    		// the target DOM element for key events
    		this._domElementKeyEvents = null;

    		//
    		// public methods
    		//

    		this.getPolarAngle = function () {

    			return spherical.phi;

    		};

    		this.getAzimuthalAngle = function () {

    			return spherical.theta;

    		};

    		this.getDistance = function () {

    			return this.object.position.distanceTo( this.target );

    		};

    		this.listenToKeyEvents = function ( domElement ) {

    			domElement.addEventListener( 'keydown', onKeyDown );
    			this._domElementKeyEvents = domElement;

    		};

    		this.saveState = function () {

    			scope.target0.copy( scope.target );
    			scope.position0.copy( scope.object.position );
    			scope.zoom0 = scope.object.zoom;

    		};

    		this.reset = function () {

    			scope.target.copy( scope.target0 );
    			scope.object.position.copy( scope.position0 );
    			scope.object.zoom = scope.zoom0;

    			scope.object.updateProjectionMatrix();
    			scope.dispatchEvent( _changeEvent$1 );

    			scope.update();

    			state = STATE.NONE;

    		};

    		// this method is exposed, but perhaps it would be better if we can make it private...
    		this.update = function () {

    			const offset = new Vector3();

    			// so camera.up is the orbit axis
    			const quat = new Quaternion().setFromUnitVectors( object.up, new Vector3( 0, 1, 0 ) );
    			const quatInverse = quat.clone().invert();

    			const lastPosition = new Vector3();
    			const lastQuaternion = new Quaternion();

    			const twoPI = 2 * Math.PI;

    			return function update() {

    				const position = scope.object.position;

    				offset.copy( position ).sub( scope.target );

    				// rotate offset to "y-axis-is-up" space
    				offset.applyQuaternion( quat );

    				// angle from z-axis around y-axis
    				spherical.setFromVector3( offset );

    				if ( scope.autoRotate && state === STATE.NONE ) {

    					rotateLeft( getAutoRotationAngle() );

    				}

    				if ( scope.enableDamping ) {

    					spherical.theta += sphericalDelta.theta * scope.dampingFactor;
    					spherical.phi += sphericalDelta.phi * scope.dampingFactor;

    				} else {

    					spherical.theta += sphericalDelta.theta;
    					spherical.phi += sphericalDelta.phi;

    				}

    				// restrict theta to be between desired limits

    				let min = scope.minAzimuthAngle;
    				let max = scope.maxAzimuthAngle;

    				if ( isFinite( min ) && isFinite( max ) ) {

    					if ( min < - Math.PI ) min += twoPI; else if ( min > Math.PI ) min -= twoPI;

    					if ( max < - Math.PI ) max += twoPI; else if ( max > Math.PI ) max -= twoPI;

    					if ( min <= max ) {

    						spherical.theta = Math.max( min, Math.min( max, spherical.theta ) );

    					} else {

    						spherical.theta = ( spherical.theta > ( min + max ) / 2 ) ?
    							Math.max( min, spherical.theta ) :
    							Math.min( max, spherical.theta );

    					}

    				}

    				// restrict phi to be between desired limits
    				spherical.phi = Math.max( scope.minPolarAngle, Math.min( scope.maxPolarAngle, spherical.phi ) );

    				spherical.makeSafe();


    				spherical.radius *= scale;

    				// restrict radius to be between desired limits
    				spherical.radius = Math.max( scope.minDistance, Math.min( scope.maxDistance, spherical.radius ) );

    				// move target to panned location

    				if ( scope.enableDamping === true ) {

    					scope.target.addScaledVector( panOffset, scope.dampingFactor );

    				} else {

    					scope.target.add( panOffset );

    				}

    				offset.setFromSpherical( spherical );

    				// rotate offset back to "camera-up-vector-is-up" space
    				offset.applyQuaternion( quatInverse );

    				position.copy( scope.target ).add( offset );

    				scope.object.lookAt( scope.target );

    				if ( scope.enableDamping === true ) {

    					sphericalDelta.theta *= ( 1 - scope.dampingFactor );
    					sphericalDelta.phi *= ( 1 - scope.dampingFactor );

    					panOffset.multiplyScalar( 1 - scope.dampingFactor );

    				} else {

    					sphericalDelta.set( 0, 0, 0 );

    					panOffset.set( 0, 0, 0 );

    				}

    				scale = 1;

    				// update condition is:
    				// min(camera displacement, camera rotation in radians)^2 > EPS
    				// using small-angle approximation cos(x/2) = 1 - x^2 / 8

    				if ( zoomChanged ||
    					lastPosition.distanceToSquared( scope.object.position ) > EPS ||
    					8 * ( 1 - lastQuaternion.dot( scope.object.quaternion ) ) > EPS ) {

    					scope.dispatchEvent( _changeEvent$1 );

    					lastPosition.copy( scope.object.position );
    					lastQuaternion.copy( scope.object.quaternion );
    					zoomChanged = false;

    					return true;

    				}

    				return false;

    			};

    		}();

    		this.dispose = function () {

    			scope.domElement.removeEventListener( 'contextmenu', onContextMenu );

    			scope.domElement.removeEventListener( 'pointerdown', onPointerDown );
    			scope.domElement.removeEventListener( 'pointercancel', onPointerCancel );
    			scope.domElement.removeEventListener( 'wheel', onMouseWheel );

    			scope.domElement.removeEventListener( 'pointermove', onPointerMove );
    			scope.domElement.removeEventListener( 'pointerup', onPointerUp );


    			if ( scope._domElementKeyEvents !== null ) {

    				scope._domElementKeyEvents.removeEventListener( 'keydown', onKeyDown );

    			}

    			//scope.dispatchEvent( { type: 'dispose' } ); // should this be added here?

    		};

    		//
    		// internals
    		//

    		const scope = this;

    		const STATE = {
    			NONE: - 1,
    			ROTATE: 0,
    			DOLLY: 1,
    			PAN: 2,
    			TOUCH_ROTATE: 3,
    			TOUCH_PAN: 4,
    			TOUCH_DOLLY_PAN: 5,
    			TOUCH_DOLLY_ROTATE: 6
    		};

    		let state = STATE.NONE;

    		const EPS = 0.000001;

    		// current position in spherical coordinates
    		const spherical = new Spherical();
    		const sphericalDelta = new Spherical();

    		let scale = 1;
    		const panOffset = new Vector3();
    		let zoomChanged = false;

    		const rotateStart = new Vector2();
    		const rotateEnd = new Vector2();
    		const rotateDelta = new Vector2();

    		const panStart = new Vector2();
    		const panEnd = new Vector2();
    		const panDelta = new Vector2();

    		const dollyStart = new Vector2();
    		const dollyEnd = new Vector2();
    		const dollyDelta = new Vector2();

    		const pointers = [];
    		const pointerPositions = {};

    		function getAutoRotationAngle() {

    			return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;

    		}

    		function getZoomScale() {

    			return Math.pow( 0.95, scope.zoomSpeed );

    		}

    		function rotateLeft( angle ) {

    			sphericalDelta.theta -= angle;

    		}

    		function rotateUp( angle ) {

    			sphericalDelta.phi -= angle;

    		}

    		const panLeft = function () {

    			const v = new Vector3();

    			return function panLeft( distance, objectMatrix ) {

    				v.setFromMatrixColumn( objectMatrix, 0 ); // get X column of objectMatrix
    				v.multiplyScalar( - distance );

    				panOffset.add( v );

    			};

    		}();

    		const panUp = function () {

    			const v = new Vector3();

    			return function panUp( distance, objectMatrix ) {

    				if ( scope.screenSpacePanning === true ) {

    					v.setFromMatrixColumn( objectMatrix, 1 );

    				} else {

    					v.setFromMatrixColumn( objectMatrix, 0 );
    					v.crossVectors( scope.object.up, v );

    				}

    				v.multiplyScalar( distance );

    				panOffset.add( v );

    			};

    		}();

    		// deltaX and deltaY are in pixels; right and down are positive
    		const pan = function () {

    			const offset = new Vector3();

    			return function pan( deltaX, deltaY ) {

    				const element = scope.domElement;

    				if ( scope.object.isPerspectiveCamera ) {

    					// perspective
    					const position = scope.object.position;
    					offset.copy( position ).sub( scope.target );
    					let targetDistance = offset.length();

    					// half of the fov is center to top of screen
    					targetDistance *= Math.tan( ( scope.object.fov / 2 ) * Math.PI / 180.0 );

    					// we use only clientHeight here so aspect ratio does not distort speed
    					panLeft( 2 * deltaX * targetDistance / element.clientHeight, scope.object.matrix );
    					panUp( 2 * deltaY * targetDistance / element.clientHeight, scope.object.matrix );

    				} else if ( scope.object.isOrthographicCamera ) {

    					// orthographic
    					panLeft( deltaX * ( scope.object.right - scope.object.left ) / scope.object.zoom / element.clientWidth, scope.object.matrix );
    					panUp( deltaY * ( scope.object.top - scope.object.bottom ) / scope.object.zoom / element.clientHeight, scope.object.matrix );

    				} else {

    					// camera neither orthographic nor perspective
    					console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.' );
    					scope.enablePan = false;

    				}

    			};

    		}();

    		function dollyOut( dollyScale ) {

    			if ( scope.object.isPerspectiveCamera ) {

    				scale /= dollyScale;

    			} else if ( scope.object.isOrthographicCamera ) {

    				scope.object.zoom = Math.max( scope.minZoom, Math.min( scope.maxZoom, scope.object.zoom * dollyScale ) );
    				scope.object.updateProjectionMatrix();
    				zoomChanged = true;

    			} else {

    				console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );
    				scope.enableZoom = false;

    			}

    		}

    		function dollyIn( dollyScale ) {

    			if ( scope.object.isPerspectiveCamera ) {

    				scale *= dollyScale;

    			} else if ( scope.object.isOrthographicCamera ) {

    				scope.object.zoom = Math.max( scope.minZoom, Math.min( scope.maxZoom, scope.object.zoom / dollyScale ) );
    				scope.object.updateProjectionMatrix();
    				zoomChanged = true;

    			} else {

    				console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );
    				scope.enableZoom = false;

    			}

    		}

    		//
    		// event callbacks - update the object state
    		//

    		function handleMouseDownRotate( event ) {

    			rotateStart.set( event.clientX, event.clientY );

    		}

    		function handleMouseDownDolly( event ) {

    			dollyStart.set( event.clientX, event.clientY );

    		}

    		function handleMouseDownPan( event ) {

    			panStart.set( event.clientX, event.clientY );

    		}

    		function handleMouseMoveRotate( event ) {

    			rotateEnd.set( event.clientX, event.clientY );

    			rotateDelta.subVectors( rotateEnd, rotateStart ).multiplyScalar( scope.rotateSpeed );

    			const element = scope.domElement;

    			rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientHeight ); // yes, height

    			rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight );

    			rotateStart.copy( rotateEnd );

    			scope.update();

    		}

    		function handleMouseMoveDolly( event ) {

    			dollyEnd.set( event.clientX, event.clientY );

    			dollyDelta.subVectors( dollyEnd, dollyStart );

    			if ( dollyDelta.y > 0 ) {

    				dollyOut( getZoomScale() );

    			} else if ( dollyDelta.y < 0 ) {

    				dollyIn( getZoomScale() );

    			}

    			dollyStart.copy( dollyEnd );

    			scope.update();

    		}

    		function handleMouseMovePan( event ) {

    			panEnd.set( event.clientX, event.clientY );

    			panDelta.subVectors( panEnd, panStart ).multiplyScalar( scope.panSpeed );

    			pan( panDelta.x, panDelta.y );

    			panStart.copy( panEnd );

    			scope.update();

    		}

    		function handleMouseWheel( event ) {

    			if ( event.deltaY < 0 ) {

    				dollyIn( getZoomScale() );

    			} else if ( event.deltaY > 0 ) {

    				dollyOut( getZoomScale() );

    			}

    			scope.update();

    		}

    		function handleKeyDown( event ) {

    			let needsUpdate = false;

    			switch ( event.code ) {

    				case scope.keys.UP:

    					if ( event.ctrlKey || event.metaKey || event.shiftKey ) {

    						rotateUp( 2 * Math.PI * scope.rotateSpeed / scope.domElement.clientHeight );

    					} else {

    						pan( 0, scope.keyPanSpeed );

    					}

    					needsUpdate = true;
    					break;

    				case scope.keys.BOTTOM:

    					if ( event.ctrlKey || event.metaKey || event.shiftKey ) {

    						rotateUp( - 2 * Math.PI * scope.rotateSpeed / scope.domElement.clientHeight );

    					} else {

    						pan( 0, - scope.keyPanSpeed );

    					}

    					needsUpdate = true;
    					break;

    				case scope.keys.LEFT:

    					if ( event.ctrlKey || event.metaKey || event.shiftKey ) {

    						rotateLeft( 2 * Math.PI * scope.rotateSpeed / scope.domElement.clientHeight );

    					} else {

    						pan( scope.keyPanSpeed, 0 );

    					}

    					needsUpdate = true;
    					break;

    				case scope.keys.RIGHT:

    					if ( event.ctrlKey || event.metaKey || event.shiftKey ) {

    						rotateLeft( - 2 * Math.PI * scope.rotateSpeed / scope.domElement.clientHeight );

    					} else {

    						pan( - scope.keyPanSpeed, 0 );

    					}

    					needsUpdate = true;
    					break;

    			}

    			if ( needsUpdate ) {

    				// prevent the browser from scrolling on cursor keys
    				event.preventDefault();

    				scope.update();

    			}


    		}

    		function handleTouchStartRotate() {

    			if ( pointers.length === 1 ) {

    				rotateStart.set( pointers[ 0 ].pageX, pointers[ 0 ].pageY );

    			} else {

    				const x = 0.5 * ( pointers[ 0 ].pageX + pointers[ 1 ].pageX );
    				const y = 0.5 * ( pointers[ 0 ].pageY + pointers[ 1 ].pageY );

    				rotateStart.set( x, y );

    			}

    		}

    		function handleTouchStartPan() {

    			if ( pointers.length === 1 ) {

    				panStart.set( pointers[ 0 ].pageX, pointers[ 0 ].pageY );

    			} else {

    				const x = 0.5 * ( pointers[ 0 ].pageX + pointers[ 1 ].pageX );
    				const y = 0.5 * ( pointers[ 0 ].pageY + pointers[ 1 ].pageY );

    				panStart.set( x, y );

    			}

    		}

    		function handleTouchStartDolly() {

    			const dx = pointers[ 0 ].pageX - pointers[ 1 ].pageX;
    			const dy = pointers[ 0 ].pageY - pointers[ 1 ].pageY;

    			const distance = Math.sqrt( dx * dx + dy * dy );

    			dollyStart.set( 0, distance );

    		}

    		function handleTouchStartDollyPan() {

    			if ( scope.enableZoom ) handleTouchStartDolly();

    			if ( scope.enablePan ) handleTouchStartPan();

    		}

    		function handleTouchStartDollyRotate() {

    			if ( scope.enableZoom ) handleTouchStartDolly();

    			if ( scope.enableRotate ) handleTouchStartRotate();

    		}

    		function handleTouchMoveRotate( event ) {

    			if ( pointers.length == 1 ) {

    				rotateEnd.set( event.pageX, event.pageY );

    			} else {

    				const position = getSecondPointerPosition( event );

    				const x = 0.5 * ( event.pageX + position.x );
    				const y = 0.5 * ( event.pageY + position.y );

    				rotateEnd.set( x, y );

    			}

    			rotateDelta.subVectors( rotateEnd, rotateStart ).multiplyScalar( scope.rotateSpeed );

    			const element = scope.domElement;

    			rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientHeight ); // yes, height

    			rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight );

    			rotateStart.copy( rotateEnd );

    		}

    		function handleTouchMovePan( event ) {

    			if ( pointers.length === 1 ) {

    				panEnd.set( event.pageX, event.pageY );

    			} else {

    				const position = getSecondPointerPosition( event );

    				const x = 0.5 * ( event.pageX + position.x );
    				const y = 0.5 * ( event.pageY + position.y );

    				panEnd.set( x, y );

    			}

    			panDelta.subVectors( panEnd, panStart ).multiplyScalar( scope.panSpeed );

    			pan( panDelta.x, panDelta.y );

    			panStart.copy( panEnd );

    		}

    		function handleTouchMoveDolly( event ) {

    			const position = getSecondPointerPosition( event );

    			const dx = event.pageX - position.x;
    			const dy = event.pageY - position.y;

    			const distance = Math.sqrt( dx * dx + dy * dy );

    			dollyEnd.set( 0, distance );

    			dollyDelta.set( 0, Math.pow( dollyEnd.y / dollyStart.y, scope.zoomSpeed ) );

    			dollyOut( dollyDelta.y );

    			dollyStart.copy( dollyEnd );

    		}

    		function handleTouchMoveDollyPan( event ) {

    			if ( scope.enableZoom ) handleTouchMoveDolly( event );

    			if ( scope.enablePan ) handleTouchMovePan( event );

    		}

    		function handleTouchMoveDollyRotate( event ) {

    			if ( scope.enableZoom ) handleTouchMoveDolly( event );

    			if ( scope.enableRotate ) handleTouchMoveRotate( event );

    		}

    		//
    		// event handlers - FSM: listen for events and reset state
    		//

    		function onPointerDown( event ) {

    			if ( scope.enabled === false ) return;

    			if ( pointers.length === 0 ) {

    				scope.domElement.setPointerCapture( event.pointerId );

    				scope.domElement.addEventListener( 'pointermove', onPointerMove );
    				scope.domElement.addEventListener( 'pointerup', onPointerUp );

    			}

    			//

    			addPointer( event );

    			if ( event.pointerType === 'touch' ) {

    				onTouchStart( event );

    			} else {

    				onMouseDown( event );

    			}

    		}

    		function onPointerMove( event ) {

    			if ( scope.enabled === false ) return;

    			if ( event.pointerType === 'touch' ) {

    				onTouchMove( event );

    			} else {

    				onMouseMove( event );

    			}

    		}

    		function onPointerUp( event ) {

    		    removePointer( event );

    		    if ( pointers.length === 0 ) {

    		        scope.domElement.releasePointerCapture( event.pointerId );

    		        scope.domElement.removeEventListener( 'pointermove', onPointerMove );
    		        scope.domElement.removeEventListener( 'pointerup', onPointerUp );

    		    }

    		    scope.dispatchEvent( _endEvent );

    		    state = STATE.NONE;

    		}

    		function onPointerCancel( event ) {

    			removePointer( event );

    		}

    		function onMouseDown( event ) {

    			let mouseAction;

    			switch ( event.button ) {

    				case 0:

    					mouseAction = scope.mouseButtons.LEFT;
    					break;

    				case 1:

    					mouseAction = scope.mouseButtons.MIDDLE;
    					break;

    				case 2:

    					mouseAction = scope.mouseButtons.RIGHT;
    					break;

    				default:

    					mouseAction = - 1;

    			}

    			switch ( mouseAction ) {

    				case MOUSE.DOLLY:

    					if ( scope.enableZoom === false ) return;

    					handleMouseDownDolly( event );

    					state = STATE.DOLLY;

    					break;

    				case MOUSE.ROTATE:

    					if ( event.ctrlKey || event.metaKey || event.shiftKey ) {

    						if ( scope.enablePan === false ) return;

    						handleMouseDownPan( event );

    						state = STATE.PAN;

    					} else {

    						if ( scope.enableRotate === false ) return;

    						handleMouseDownRotate( event );

    						state = STATE.ROTATE;

    					}

    					break;

    				case MOUSE.PAN:

    					if ( event.ctrlKey || event.metaKey || event.shiftKey ) {

    						if ( scope.enableRotate === false ) return;

    						handleMouseDownRotate( event );

    						state = STATE.ROTATE;

    					} else {

    						if ( scope.enablePan === false ) return;

    						handleMouseDownPan( event );

    						state = STATE.PAN;

    					}

    					break;

    				default:

    					state = STATE.NONE;

    			}

    			if ( state !== STATE.NONE ) {

    				scope.dispatchEvent( _startEvent );

    			}

    		}

    		function onMouseMove( event ) {

    			switch ( state ) {

    				case STATE.ROTATE:

    					if ( scope.enableRotate === false ) return;

    					handleMouseMoveRotate( event );

    					break;

    				case STATE.DOLLY:

    					if ( scope.enableZoom === false ) return;

    					handleMouseMoveDolly( event );

    					break;

    				case STATE.PAN:

    					if ( scope.enablePan === false ) return;

    					handleMouseMovePan( event );

    					break;

    			}

    		}

    		function onMouseWheel( event ) {

    			if ( scope.enabled === false || scope.enableZoom === false || state !== STATE.NONE ) return;

    			event.preventDefault();

    			scope.dispatchEvent( _startEvent );

    			handleMouseWheel( event );

    			scope.dispatchEvent( _endEvent );

    		}

    		function onKeyDown( event ) {

    			if ( scope.enabled === false || scope.enablePan === false ) return;

    			handleKeyDown( event );

    		}

    		function onTouchStart( event ) {

    			trackPointer( event );

    			switch ( pointers.length ) {

    				case 1:

    					switch ( scope.touches.ONE ) {

    						case TOUCH.ROTATE:

    							if ( scope.enableRotate === false ) return;

    							handleTouchStartRotate();

    							state = STATE.TOUCH_ROTATE;

    							break;

    						case TOUCH.PAN:

    							if ( scope.enablePan === false ) return;

    							handleTouchStartPan();

    							state = STATE.TOUCH_PAN;

    							break;

    						default:

    							state = STATE.NONE;

    					}

    					break;

    				case 2:

    					switch ( scope.touches.TWO ) {

    						case TOUCH.DOLLY_PAN:

    							if ( scope.enableZoom === false && scope.enablePan === false ) return;

    							handleTouchStartDollyPan();

    							state = STATE.TOUCH_DOLLY_PAN;

    							break;

    						case TOUCH.DOLLY_ROTATE:

    							if ( scope.enableZoom === false && scope.enableRotate === false ) return;

    							handleTouchStartDollyRotate();

    							state = STATE.TOUCH_DOLLY_ROTATE;

    							break;

    						default:

    							state = STATE.NONE;

    					}

    					break;

    				default:

    					state = STATE.NONE;

    			}

    			if ( state !== STATE.NONE ) {

    				scope.dispatchEvent( _startEvent );

    			}

    		}

    		function onTouchMove( event ) {

    			trackPointer( event );

    			switch ( state ) {

    				case STATE.TOUCH_ROTATE:

    					if ( scope.enableRotate === false ) return;

    					handleTouchMoveRotate( event );

    					scope.update();

    					break;

    				case STATE.TOUCH_PAN:

    					if ( scope.enablePan === false ) return;

    					handleTouchMovePan( event );

    					scope.update();

    					break;

    				case STATE.TOUCH_DOLLY_PAN:

    					if ( scope.enableZoom === false && scope.enablePan === false ) return;

    					handleTouchMoveDollyPan( event );

    					scope.update();

    					break;

    				case STATE.TOUCH_DOLLY_ROTATE:

    					if ( scope.enableZoom === false && scope.enableRotate === false ) return;

    					handleTouchMoveDollyRotate( event );

    					scope.update();

    					break;

    				default:

    					state = STATE.NONE;

    			}

    		}

    		function onContextMenu( event ) {

    			if ( scope.enabled === false ) return;

    			event.preventDefault();

    		}

    		function addPointer( event ) {

    			pointers.push( event );

    		}

    		function removePointer( event ) {

    			delete pointerPositions[ event.pointerId ];

    			for ( let i = 0; i < pointers.length; i ++ ) {

    				if ( pointers[ i ].pointerId == event.pointerId ) {

    					pointers.splice( i, 1 );
    					return;

    				}

    			}

    		}

    		function trackPointer( event ) {

    			let position = pointerPositions[ event.pointerId ];

    			if ( position === undefined ) {

    				position = new Vector2();
    				pointerPositions[ event.pointerId ] = position;

    			}

    			position.set( event.pageX, event.pageY );

    		}

    		function getSecondPointerPosition( event ) {

    			const pointer = ( event.pointerId === pointers[ 0 ].pointerId ) ? pointers[ 1 ] : pointers[ 0 ];

    			return pointerPositions[ pointer.pointerId ];

    		}

    		//

    		scope.domElement.addEventListener( 'contextmenu', onContextMenu );

    		scope.domElement.addEventListener( 'pointerdown', onPointerDown );
    		scope.domElement.addEventListener( 'pointercancel', onPointerCancel );
    		scope.domElement.addEventListener( 'wheel', onMouseWheel, { passive: false } );

    		// force an update at start

    		this.update();

    	}

    }

    const _changeEvent = { type: 'change' };

    class FlyControls extends EventDispatcher {

    	constructor( object, domElement ) {

    		super();

    		this.object = object;
    		this.domElement = domElement;

    		// API

    		this.movementSpeed = 1.0;
    		this.rollSpeed = 0.005;

    		this.dragToLook = false;
    		this.autoForward = false;

    		// disable default target object behavior

    		// internals

    		const scope = this;

    		const EPS = 0.000001;

    		const lastQuaternion = new Quaternion();
    		const lastPosition = new Vector3();

    		this.tmpQuaternion = new Quaternion();

    		this.status = 0;

    		this.moveState = { up: 0, down: 0, left: 0, right: 0, forward: 0, back: 0, pitchUp: 0, pitchDown: 0, yawLeft: 0, yawRight: 0, rollLeft: 0, rollRight: 0 };
    		this.moveVector = new Vector3( 0, 0, 0 );
    		this.rotationVector = new Vector3( 0, 0, 0 );

    		this.keydown = function ( event ) {

    			if ( event.altKey ) {

    				return;

    			}

    			switch ( event.code ) {

    				case 'ShiftLeft':
    				case 'ShiftRight': this.movementSpeedMultiplier = .1; break;

    				case 'KeyW': this.moveState.forward = 1; break;
    				case 'KeyS': this.moveState.back = 1; break;

    				case 'KeyA': this.moveState.left = 1; break;
    				case 'KeyD': this.moveState.right = 1; break;

    				case 'KeyR': this.moveState.up = 1; break;
    				case 'KeyF': this.moveState.down = 1; break;

    				case 'ArrowUp': this.moveState.pitchUp = 1; break;
    				case 'ArrowDown': this.moveState.pitchDown = 1; break;

    				case 'ArrowLeft': this.moveState.yawLeft = 1; break;
    				case 'ArrowRight': this.moveState.yawRight = 1; break;

    				case 'KeyQ': this.moveState.rollLeft = 1; break;
    				case 'KeyE': this.moveState.rollRight = 1; break;

    			}

    			this.updateMovementVector();
    			this.updateRotationVector();

    		};

    		this.keyup = function ( event ) {

    			switch ( event.code ) {

    				case 'ShiftLeft':
    				case 'ShiftRight': this.movementSpeedMultiplier = 1; break;

    				case 'KeyW': this.moveState.forward = 0; break;
    				case 'KeyS': this.moveState.back = 0; break;

    				case 'KeyA': this.moveState.left = 0; break;
    				case 'KeyD': this.moveState.right = 0; break;

    				case 'KeyR': this.moveState.up = 0; break;
    				case 'KeyF': this.moveState.down = 0; break;

    				case 'ArrowUp': this.moveState.pitchUp = 0; break;
    				case 'ArrowDown': this.moveState.pitchDown = 0; break;

    				case 'ArrowLeft': this.moveState.yawLeft = 0; break;
    				case 'ArrowRight': this.moveState.yawRight = 0; break;

    				case 'KeyQ': this.moveState.rollLeft = 0; break;
    				case 'KeyE': this.moveState.rollRight = 0; break;

    			}

    			this.updateMovementVector();
    			this.updateRotationVector();

    		};

    		this.pointerdown = function ( event ) {

    			if ( this.dragToLook ) {

    				this.status ++;

    			} else {

    				switch ( event.button ) {

    					case 0: this.moveState.forward = 1; break;
    					case 2: this.moveState.back = 1; break;

    				}

    				this.updateMovementVector();

    			}

    		};

    		this.pointermove = function ( event ) {

    			if ( ! this.dragToLook || this.status > 0 ) {

    				const container = this.getContainerDimensions();
    				const halfWidth = container.size[ 0 ] / 2;
    				const halfHeight = container.size[ 1 ] / 2;

    				this.moveState.yawLeft = - ( ( event.pageX - container.offset[ 0 ] ) - halfWidth ) / halfWidth;
    				this.moveState.pitchDown = ( ( event.pageY - container.offset[ 1 ] ) - halfHeight ) / halfHeight;

    				this.updateRotationVector();

    			}

    		};

    		this.pointerup = function ( event ) {

    			if ( this.dragToLook ) {

    				this.status --;

    				this.moveState.yawLeft = this.moveState.pitchDown = 0;

    			} else {

    				switch ( event.button ) {

    					case 0: this.moveState.forward = 0; break;
    					case 2: this.moveState.back = 0; break;

    				}

    				this.updateMovementVector();

    			}

    			this.updateRotationVector();

    		};

    		this.update = function ( delta ) {

    			const moveMult = delta * scope.movementSpeed;
    			const rotMult = delta * scope.rollSpeed;

    			scope.object.translateX( scope.moveVector.x * moveMult );
    			scope.object.translateY( scope.moveVector.y * moveMult );
    			scope.object.translateZ( scope.moveVector.z * moveMult );

    			scope.tmpQuaternion.set( scope.rotationVector.x * rotMult, scope.rotationVector.y * rotMult, scope.rotationVector.z * rotMult, 1 ).normalize();
    			scope.object.quaternion.multiply( scope.tmpQuaternion );

    			if (
    				lastPosition.distanceToSquared( scope.object.position ) > EPS ||
    				8 * ( 1 - lastQuaternion.dot( scope.object.quaternion ) ) > EPS
    			) {

    				scope.dispatchEvent( _changeEvent );
    				lastQuaternion.copy( scope.object.quaternion );
    				lastPosition.copy( scope.object.position );

    			}

    		};

    		this.updateMovementVector = function () {

    			const forward = ( this.moveState.forward || ( this.autoForward && ! this.moveState.back ) ) ? 1 : 0;

    			this.moveVector.x = ( - this.moveState.left + this.moveState.right );
    			this.moveVector.y = ( - this.moveState.down + this.moveState.up );
    			this.moveVector.z = ( - forward + this.moveState.back );

    			//console.log( 'move:', [ this.moveVector.x, this.moveVector.y, this.moveVector.z ] );

    		};

    		this.updateRotationVector = function () {

    			this.rotationVector.x = ( - this.moveState.pitchDown + this.moveState.pitchUp );
    			this.rotationVector.y = ( - this.moveState.yawRight + this.moveState.yawLeft );
    			this.rotationVector.z = ( - this.moveState.rollRight + this.moveState.rollLeft );

    			//console.log( 'rotate:', [ this.rotationVector.x, this.rotationVector.y, this.rotationVector.z ] );

    		};

    		this.getContainerDimensions = function () {

    			if ( this.domElement != document ) {

    				return {
    					size: [ this.domElement.offsetWidth, this.domElement.offsetHeight ],
    					offset: [ this.domElement.offsetLeft, this.domElement.offsetTop ]
    				};

    			} else {

    				return {
    					size: [ window.innerWidth, window.innerHeight ],
    					offset: [ 0, 0 ]
    				};

    			}

    		};

    		this.dispose = function () {

    			this.domElement.removeEventListener( 'contextmenu', contextmenu );
    			this.domElement.removeEventListener( 'pointerdown', _pointerdown );
    			this.domElement.removeEventListener( 'pointermove', _pointermove );
    			this.domElement.removeEventListener( 'pointerup', _pointerup );

    			window.removeEventListener( 'keydown', _keydown );
    			window.removeEventListener( 'keyup', _keyup );

    		};

    		const _pointermove = this.pointermove.bind( this );
    		const _pointerdown = this.pointerdown.bind( this );
    		const _pointerup = this.pointerup.bind( this );
    		const _keydown = this.keydown.bind( this );
    		const _keyup = this.keyup.bind( this );

    		this.domElement.addEventListener( 'contextmenu', contextmenu );
    		this.domElement.addEventListener( 'pointerdown', _pointerdown );
    		this.domElement.addEventListener( 'pointermove', _pointermove );
    		this.domElement.addEventListener( 'pointerup', _pointerup );

    		window.addEventListener( 'keydown', _keydown );
    		window.addEventListener( 'keyup', _keyup );

    		this.updateMovementVector();
    		this.updateRotationVector();

    	}

    }

    function contextmenu( event ) {

    	event.preventDefault();

    }

    /**
     * Full-screen textured quad shader
     */

    const CopyShader = {

    	uniforms: {

    		'tDiffuse': { value: null },
    		'opacity': { value: 1.0 }

    	},

    	vertexShader: /* glsl */`

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,

    	fragmentShader: /* glsl */`

		uniform float opacity;

		uniform sampler2D tDiffuse;

		varying vec2 vUv;

		void main() {

			gl_FragColor = texture2D( tDiffuse, vUv );
			gl_FragColor.a *= opacity;


		}`

    };

    class Pass {

    	constructor() {

    		// if set to true, the pass is processed by the composer
    		this.enabled = true;

    		// if set to true, the pass indicates to swap read and write buffer after rendering
    		this.needsSwap = true;

    		// if set to true, the pass clears its buffer before rendering
    		this.clear = false;

    		// if set to true, the result of the pass is rendered to screen. This is set automatically by EffectComposer.
    		this.renderToScreen = false;

    	}

    	setSize( /* width, height */ ) {}

    	render( /* renderer, writeBuffer, readBuffer, deltaTime, maskActive */ ) {

    		console.error( 'THREE.Pass: .render() must be implemented in derived pass.' );

    	}

    	dispose() {}

    }

    // Helper for passes that need to fill the viewport with a single quad.

    const _camera = new OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );

    // https://github.com/mrdoob/three.js/pull/21358

    const _geometry$1 = new BufferGeometry();
    _geometry$1.setAttribute( 'position', new Float32BufferAttribute( [ - 1, 3, 0, - 1, - 1, 0, 3, - 1, 0 ], 3 ) );
    _geometry$1.setAttribute( 'uv', new Float32BufferAttribute( [ 0, 2, 0, 0, 2, 0 ], 2 ) );

    class FullScreenQuad {

    	constructor( material ) {

    		this._mesh = new Mesh( _geometry$1, material );

    	}

    	dispose() {

    		this._mesh.geometry.dispose();

    	}

    	render( renderer ) {

    		renderer.render( this._mesh, _camera );

    	}

    	get material() {

    		return this._mesh.material;

    	}

    	set material( value ) {

    		this._mesh.material = value;

    	}

    }

    class ShaderPass extends Pass {

    	constructor( shader, textureID ) {

    		super();

    		this.textureID = ( textureID !== undefined ) ? textureID : 'tDiffuse';

    		if ( shader instanceof ShaderMaterial ) {

    			this.uniforms = shader.uniforms;

    			this.material = shader;

    		} else if ( shader ) {

    			this.uniforms = UniformsUtils.clone( shader.uniforms );

    			this.material = new ShaderMaterial( {

    				defines: Object.assign( {}, shader.defines ),
    				uniforms: this.uniforms,
    				vertexShader: shader.vertexShader,
    				fragmentShader: shader.fragmentShader

    			} );

    		}

    		this.fsQuad = new FullScreenQuad( this.material );

    	}

    	render( renderer, writeBuffer, readBuffer /*, deltaTime, maskActive */ ) {

    		if ( this.uniforms[ this.textureID ] ) {

    			this.uniforms[ this.textureID ].value = readBuffer.texture;

    		}

    		this.fsQuad.material = this.material;

    		if ( this.renderToScreen ) {

    			renderer.setRenderTarget( null );
    			this.fsQuad.render( renderer );

    		} else {

    			renderer.setRenderTarget( writeBuffer );
    			// TODO: Avoid using autoClear properties, see https://github.com/mrdoob/three.js/pull/15571#issuecomment-465669600
    			if ( this.clear ) renderer.clear( renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil );
    			this.fsQuad.render( renderer );

    		}

    	}

    	dispose() {

    		this.material.dispose();

    		this.fsQuad.dispose();

    	}

    }

    class MaskPass extends Pass {

    	constructor( scene, camera ) {

    		super();

    		this.scene = scene;
    		this.camera = camera;

    		this.clear = true;
    		this.needsSwap = false;

    		this.inverse = false;

    	}

    	render( renderer, writeBuffer, readBuffer /*, deltaTime, maskActive */ ) {

    		const context = renderer.getContext();
    		const state = renderer.state;

    		// don't update color or depth

    		state.buffers.color.setMask( false );
    		state.buffers.depth.setMask( false );

    		// lock buffers

    		state.buffers.color.setLocked( true );
    		state.buffers.depth.setLocked( true );

    		// set up stencil

    		let writeValue, clearValue;

    		if ( this.inverse ) {

    			writeValue = 0;
    			clearValue = 1;

    		} else {

    			writeValue = 1;
    			clearValue = 0;

    		}

    		state.buffers.stencil.setTest( true );
    		state.buffers.stencil.setOp( context.REPLACE, context.REPLACE, context.REPLACE );
    		state.buffers.stencil.setFunc( context.ALWAYS, writeValue, 0xffffffff );
    		state.buffers.stencil.setClear( clearValue );
    		state.buffers.stencil.setLocked( true );

    		// draw into the stencil buffer

    		renderer.setRenderTarget( readBuffer );
    		if ( this.clear ) renderer.clear();
    		renderer.render( this.scene, this.camera );

    		renderer.setRenderTarget( writeBuffer );
    		if ( this.clear ) renderer.clear();
    		renderer.render( this.scene, this.camera );

    		// unlock color and depth buffer for subsequent rendering

    		state.buffers.color.setLocked( false );
    		state.buffers.depth.setLocked( false );

    		// only render where stencil is set to 1

    		state.buffers.stencil.setLocked( false );
    		state.buffers.stencil.setFunc( context.EQUAL, 1, 0xffffffff ); // draw if == 1
    		state.buffers.stencil.setOp( context.KEEP, context.KEEP, context.KEEP );
    		state.buffers.stencil.setLocked( true );

    	}

    }

    class ClearMaskPass extends Pass {

    	constructor() {

    		super();

    		this.needsSwap = false;

    	}

    	render( renderer /*, writeBuffer, readBuffer, deltaTime, maskActive */ ) {

    		renderer.state.buffers.stencil.setLocked( false );
    		renderer.state.buffers.stencil.setTest( false );

    	}

    }

    class EffectComposer {

    	constructor( renderer, renderTarget ) {

    		this.renderer = renderer;

    		if ( renderTarget === undefined ) {

    			const size = renderer.getSize( new Vector2() );
    			this._pixelRatio = renderer.getPixelRatio();
    			this._width = size.width;
    			this._height = size.height;

    			renderTarget = new WebGLRenderTarget( this._width * this._pixelRatio, this._height * this._pixelRatio );
    			renderTarget.texture.name = 'EffectComposer.rt1';

    		} else {

    			this._pixelRatio = 1;
    			this._width = renderTarget.width;
    			this._height = renderTarget.height;

    		}

    		this.renderTarget1 = renderTarget;
    		this.renderTarget2 = renderTarget.clone();
    		this.renderTarget2.texture.name = 'EffectComposer.rt2';

    		this.writeBuffer = this.renderTarget1;
    		this.readBuffer = this.renderTarget2;

    		this.renderToScreen = true;

    		this.passes = [];

    		// dependencies

    		if ( CopyShader === undefined ) {

    			console.error( 'THREE.EffectComposer relies on CopyShader' );

    		}

    		if ( ShaderPass === undefined ) {

    			console.error( 'THREE.EffectComposer relies on ShaderPass' );

    		}

    		this.copyPass = new ShaderPass( CopyShader );

    		this.clock = new Clock();

    	}

    	swapBuffers() {

    		const tmp = this.readBuffer;
    		this.readBuffer = this.writeBuffer;
    		this.writeBuffer = tmp;

    	}

    	addPass( pass ) {

    		this.passes.push( pass );
    		pass.setSize( this._width * this._pixelRatio, this._height * this._pixelRatio );

    	}

    	insertPass( pass, index ) {

    		this.passes.splice( index, 0, pass );
    		pass.setSize( this._width * this._pixelRatio, this._height * this._pixelRatio );

    	}

    	removePass( pass ) {

    		const index = this.passes.indexOf( pass );

    		if ( index !== - 1 ) {

    			this.passes.splice( index, 1 );

    		}

    	}

    	isLastEnabledPass( passIndex ) {

    		for ( let i = passIndex + 1; i < this.passes.length; i ++ ) {

    			if ( this.passes[ i ].enabled ) {

    				return false;

    			}

    		}

    		return true;

    	}

    	render( deltaTime ) {

    		// deltaTime value is in seconds

    		if ( deltaTime === undefined ) {

    			deltaTime = this.clock.getDelta();

    		}

    		const currentRenderTarget = this.renderer.getRenderTarget();

    		let maskActive = false;

    		for ( let i = 0, il = this.passes.length; i < il; i ++ ) {

    			const pass = this.passes[ i ];

    			if ( pass.enabled === false ) continue;

    			pass.renderToScreen = ( this.renderToScreen && this.isLastEnabledPass( i ) );
    			pass.render( this.renderer, this.writeBuffer, this.readBuffer, deltaTime, maskActive );

    			if ( pass.needsSwap ) {

    				if ( maskActive ) {

    					const context = this.renderer.getContext();
    					const stencil = this.renderer.state.buffers.stencil;

    					//context.stencilFunc( context.NOTEQUAL, 1, 0xffffffff );
    					stencil.setFunc( context.NOTEQUAL, 1, 0xffffffff );

    					this.copyPass.render( this.renderer, this.writeBuffer, this.readBuffer, deltaTime );

    					//context.stencilFunc( context.EQUAL, 1, 0xffffffff );
    					stencil.setFunc( context.EQUAL, 1, 0xffffffff );

    				}

    				this.swapBuffers();

    			}

    			if ( MaskPass !== undefined ) {

    				if ( pass instanceof MaskPass ) {

    					maskActive = true;

    				} else if ( pass instanceof ClearMaskPass ) {

    					maskActive = false;

    				}

    			}

    		}

    		this.renderer.setRenderTarget( currentRenderTarget );

    	}

    	reset( renderTarget ) {

    		if ( renderTarget === undefined ) {

    			const size = this.renderer.getSize( new Vector2() );
    			this._pixelRatio = this.renderer.getPixelRatio();
    			this._width = size.width;
    			this._height = size.height;

    			renderTarget = this.renderTarget1.clone();
    			renderTarget.setSize( this._width * this._pixelRatio, this._height * this._pixelRatio );

    		}

    		this.renderTarget1.dispose();
    		this.renderTarget2.dispose();
    		this.renderTarget1 = renderTarget;
    		this.renderTarget2 = renderTarget.clone();

    		this.writeBuffer = this.renderTarget1;
    		this.readBuffer = this.renderTarget2;

    	}

    	setSize( width, height ) {

    		this._width = width;
    		this._height = height;

    		const effectiveWidth = this._width * this._pixelRatio;
    		const effectiveHeight = this._height * this._pixelRatio;

    		this.renderTarget1.setSize( effectiveWidth, effectiveHeight );
    		this.renderTarget2.setSize( effectiveWidth, effectiveHeight );

    		for ( let i = 0; i < this.passes.length; i ++ ) {

    			this.passes[ i ].setSize( effectiveWidth, effectiveHeight );

    		}

    	}

    	setPixelRatio( pixelRatio ) {

    		this._pixelRatio = pixelRatio;

    		this.setSize( this._width, this._height );

    	}

    	dispose() {

    		this.renderTarget1.dispose();
    		this.renderTarget2.dispose();

    		this.copyPass.dispose();

    	}

    }

    // Helper for passes that need to fill the viewport with a single quad.

    new OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );

    // https://github.com/mrdoob/three.js/pull/21358

    const _geometry = new BufferGeometry();
    _geometry.setAttribute( 'position', new Float32BufferAttribute( [ - 1, 3, 0, - 1, - 1, 0, 3, - 1, 0 ], 3 ) );
    _geometry.setAttribute( 'uv', new Float32BufferAttribute( [ 0, 2, 0, 0, 2, 0 ], 2 ) );

    class RenderPass extends Pass {

    	constructor( scene, camera, overrideMaterial, clearColor, clearAlpha ) {

    		super();

    		this.scene = scene;
    		this.camera = camera;

    		this.overrideMaterial = overrideMaterial;

    		this.clearColor = clearColor;
    		this.clearAlpha = ( clearAlpha !== undefined ) ? clearAlpha : 0;

    		this.clear = true;
    		this.clearDepth = false;
    		this.needsSwap = false;
    		this._oldClearColor = new Color$1();

    	}

    	render( renderer, writeBuffer, readBuffer /*, deltaTime, maskActive */ ) {

    		const oldAutoClear = renderer.autoClear;
    		renderer.autoClear = false;

    		let oldClearAlpha, oldOverrideMaterial;

    		if ( this.overrideMaterial !== undefined ) {

    			oldOverrideMaterial = this.scene.overrideMaterial;

    			this.scene.overrideMaterial = this.overrideMaterial;

    		}

    		if ( this.clearColor ) {

    			renderer.getClearColor( this._oldClearColor );
    			oldClearAlpha = renderer.getClearAlpha();

    			renderer.setClearColor( this.clearColor, this.clearAlpha );

    		}

    		if ( this.clearDepth ) {

    			renderer.clearDepth();

    		}

    		renderer.setRenderTarget( this.renderToScreen ? null : readBuffer );

    		// TODO: Avoid using autoClear properties, see https://github.com/mrdoob/three.js/pull/15571#issuecomment-465669600
    		if ( this.clear ) renderer.clear( renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil );
    		renderer.render( this.scene, this.camera );

    		if ( this.clearColor ) {

    			renderer.setClearColor( this._oldClearColor, oldClearAlpha );

    		}

    		if ( this.overrideMaterial !== undefined ) {

    			this.scene.overrideMaterial = oldOverrideMaterial;

    		}

    		renderer.autoClear = oldAutoClear;

    	}

    }

    function _extends() {
      _extends = Object.assign ? Object.assign.bind() : function (target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      };
      return _extends.apply(this, arguments);
    }

    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }

    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };
      return _setPrototypeOf(o, p);
    }

    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }

    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
      };
      return _getPrototypeOf(o);
    }

    function _isNativeFunction(fn) {
      return Function.toString.call(fn).indexOf("[native code]") !== -1;
    }

    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
        return true;
      } catch (e) {
        return false;
      }
    }

    function _construct(Parent, args, Class) {
      if (_isNativeReflectConstruct()) {
        _construct = Reflect.construct.bind();
      } else {
        _construct = function _construct(Parent, args, Class) {
          var a = [null];
          a.push.apply(a, args);
          var Constructor = Function.bind.apply(Parent, a);
          var instance = new Constructor();
          if (Class) _setPrototypeOf(instance, Class.prototype);
          return instance;
        };
      }
      return _construct.apply(null, arguments);
    }

    function _wrapNativeSuper(Class) {
      var _cache = typeof Map === "function" ? new Map() : undefined;
      _wrapNativeSuper = function _wrapNativeSuper(Class) {
        if (Class === null || !_isNativeFunction(Class)) return Class;
        if (typeof Class !== "function") {
          throw new TypeError("Super expression must either be null or a function");
        }
        if (typeof _cache !== "undefined") {
          if (_cache.has(Class)) return _cache.get(Class);
          _cache.set(Class, Wrapper);
        }
        function Wrapper() {
          return _construct(Class, arguments, _getPrototypeOf(this).constructor);
        }
        Wrapper.prototype = Object.create(Class.prototype, {
          constructor: {
            value: Wrapper,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
        return _setPrototypeOf(Wrapper, Class);
      };
      return _wrapNativeSuper(Class);
    }

    /**
     * Create an error file out of errors.md for development and a simple web link to the full errors
     * in production mode.
     * @private
     */


    var PolishedError = /*#__PURE__*/function (_Error) {
      _inheritsLoose(PolishedError, _Error);

      function PolishedError(code) {
        var _this;

        {
          _this = _Error.call(this, "An error occurred. See https://github.com/styled-components/polished/blob/main/src/internalHelpers/errors.md#" + code + " for more information.") || this;
        }

        return _assertThisInitialized(_this);
      }

      return PolishedError;
    }( /*#__PURE__*/_wrapNativeSuper(Error));

    function colorToInt(color) {
      return Math.round(color * 255);
    }

    function convertToInt(red, green, blue) {
      return colorToInt(red) + "," + colorToInt(green) + "," + colorToInt(blue);
    }

    function hslToRgb(hue, saturation, lightness, convert) {
      if (convert === void 0) {
        convert = convertToInt;
      }

      if (saturation === 0) {
        // achromatic
        return convert(lightness, lightness, lightness);
      } // formulae from https://en.wikipedia.org/wiki/HSL_and_HSV


      var huePrime = (hue % 360 + 360) % 360 / 60;
      var chroma = (1 - Math.abs(2 * lightness - 1)) * saturation;
      var secondComponent = chroma * (1 - Math.abs(huePrime % 2 - 1));
      var red = 0;
      var green = 0;
      var blue = 0;

      if (huePrime >= 0 && huePrime < 1) {
        red = chroma;
        green = secondComponent;
      } else if (huePrime >= 1 && huePrime < 2) {
        red = secondComponent;
        green = chroma;
      } else if (huePrime >= 2 && huePrime < 3) {
        green = chroma;
        blue = secondComponent;
      } else if (huePrime >= 3 && huePrime < 4) {
        green = secondComponent;
        blue = chroma;
      } else if (huePrime >= 4 && huePrime < 5) {
        red = secondComponent;
        blue = chroma;
      } else if (huePrime >= 5 && huePrime < 6) {
        red = chroma;
        blue = secondComponent;
      }

      var lightnessModification = lightness - chroma / 2;
      var finalRed = red + lightnessModification;
      var finalGreen = green + lightnessModification;
      var finalBlue = blue + lightnessModification;
      return convert(finalRed, finalGreen, finalBlue);
    }

    var namedColorMap = {
      aliceblue: 'f0f8ff',
      antiquewhite: 'faebd7',
      aqua: '00ffff',
      aquamarine: '7fffd4',
      azure: 'f0ffff',
      beige: 'f5f5dc',
      bisque: 'ffe4c4',
      black: '000',
      blanchedalmond: 'ffebcd',
      blue: '0000ff',
      blueviolet: '8a2be2',
      brown: 'a52a2a',
      burlywood: 'deb887',
      cadetblue: '5f9ea0',
      chartreuse: '7fff00',
      chocolate: 'd2691e',
      coral: 'ff7f50',
      cornflowerblue: '6495ed',
      cornsilk: 'fff8dc',
      crimson: 'dc143c',
      cyan: '00ffff',
      darkblue: '00008b',
      darkcyan: '008b8b',
      darkgoldenrod: 'b8860b',
      darkgray: 'a9a9a9',
      darkgreen: '006400',
      darkgrey: 'a9a9a9',
      darkkhaki: 'bdb76b',
      darkmagenta: '8b008b',
      darkolivegreen: '556b2f',
      darkorange: 'ff8c00',
      darkorchid: '9932cc',
      darkred: '8b0000',
      darksalmon: 'e9967a',
      darkseagreen: '8fbc8f',
      darkslateblue: '483d8b',
      darkslategray: '2f4f4f',
      darkslategrey: '2f4f4f',
      darkturquoise: '00ced1',
      darkviolet: '9400d3',
      deeppink: 'ff1493',
      deepskyblue: '00bfff',
      dimgray: '696969',
      dimgrey: '696969',
      dodgerblue: '1e90ff',
      firebrick: 'b22222',
      floralwhite: 'fffaf0',
      forestgreen: '228b22',
      fuchsia: 'ff00ff',
      gainsboro: 'dcdcdc',
      ghostwhite: 'f8f8ff',
      gold: 'ffd700',
      goldenrod: 'daa520',
      gray: '808080',
      green: '008000',
      greenyellow: 'adff2f',
      grey: '808080',
      honeydew: 'f0fff0',
      hotpink: 'ff69b4',
      indianred: 'cd5c5c',
      indigo: '4b0082',
      ivory: 'fffff0',
      khaki: 'f0e68c',
      lavender: 'e6e6fa',
      lavenderblush: 'fff0f5',
      lawngreen: '7cfc00',
      lemonchiffon: 'fffacd',
      lightblue: 'add8e6',
      lightcoral: 'f08080',
      lightcyan: 'e0ffff',
      lightgoldenrodyellow: 'fafad2',
      lightgray: 'd3d3d3',
      lightgreen: '90ee90',
      lightgrey: 'd3d3d3',
      lightpink: 'ffb6c1',
      lightsalmon: 'ffa07a',
      lightseagreen: '20b2aa',
      lightskyblue: '87cefa',
      lightslategray: '789',
      lightslategrey: '789',
      lightsteelblue: 'b0c4de',
      lightyellow: 'ffffe0',
      lime: '0f0',
      limegreen: '32cd32',
      linen: 'faf0e6',
      magenta: 'f0f',
      maroon: '800000',
      mediumaquamarine: '66cdaa',
      mediumblue: '0000cd',
      mediumorchid: 'ba55d3',
      mediumpurple: '9370db',
      mediumseagreen: '3cb371',
      mediumslateblue: '7b68ee',
      mediumspringgreen: '00fa9a',
      mediumturquoise: '48d1cc',
      mediumvioletred: 'c71585',
      midnightblue: '191970',
      mintcream: 'f5fffa',
      mistyrose: 'ffe4e1',
      moccasin: 'ffe4b5',
      navajowhite: 'ffdead',
      navy: '000080',
      oldlace: 'fdf5e6',
      olive: '808000',
      olivedrab: '6b8e23',
      orange: 'ffa500',
      orangered: 'ff4500',
      orchid: 'da70d6',
      palegoldenrod: 'eee8aa',
      palegreen: '98fb98',
      paleturquoise: 'afeeee',
      palevioletred: 'db7093',
      papayawhip: 'ffefd5',
      peachpuff: 'ffdab9',
      peru: 'cd853f',
      pink: 'ffc0cb',
      plum: 'dda0dd',
      powderblue: 'b0e0e6',
      purple: '800080',
      rebeccapurple: '639',
      red: 'f00',
      rosybrown: 'bc8f8f',
      royalblue: '4169e1',
      saddlebrown: '8b4513',
      salmon: 'fa8072',
      sandybrown: 'f4a460',
      seagreen: '2e8b57',
      seashell: 'fff5ee',
      sienna: 'a0522d',
      silver: 'c0c0c0',
      skyblue: '87ceeb',
      slateblue: '6a5acd',
      slategray: '708090',
      slategrey: '708090',
      snow: 'fffafa',
      springgreen: '00ff7f',
      steelblue: '4682b4',
      tan: 'd2b48c',
      teal: '008080',
      thistle: 'd8bfd8',
      tomato: 'ff6347',
      turquoise: '40e0d0',
      violet: 'ee82ee',
      wheat: 'f5deb3',
      white: 'fff',
      whitesmoke: 'f5f5f5',
      yellow: 'ff0',
      yellowgreen: '9acd32'
    };
    /**
     * Checks if a string is a CSS named color and returns its equivalent hex value, otherwise returns the original color.
     * @private
     */

    function nameToHex(color) {
      if (typeof color !== 'string') return color;
      var normalizedColorName = color.toLowerCase();
      return namedColorMap[normalizedColorName] ? "#" + namedColorMap[normalizedColorName] : color;
    }

    var hexRegex = /^#[a-fA-F0-9]{6}$/;
    var hexRgbaRegex = /^#[a-fA-F0-9]{8}$/;
    var reducedHexRegex = /^#[a-fA-F0-9]{3}$/;
    var reducedRgbaHexRegex = /^#[a-fA-F0-9]{4}$/;
    var rgbRegex = /^rgb\(\s*(\d{1,3})\s*(?:,)?\s*(\d{1,3})\s*(?:,)?\s*(\d{1,3})\s*\)$/i;
    var rgbaRegex = /^rgb(?:a)?\(\s*(\d{1,3})\s*(?:,)?\s*(\d{1,3})\s*(?:,)?\s*(\d{1,3})\s*(?:,|\/)\s*([-+]?\d*[.]?\d+[%]?)\s*\)$/i;
    var hslRegex = /^hsl\(\s*(\d{0,3}[.]?[0-9]+(?:deg)?)\s*(?:,)?\s*(\d{1,3}[.]?[0-9]?)%\s*(?:,)?\s*(\d{1,3}[.]?[0-9]?)%\s*\)$/i;
    var hslaRegex = /^hsl(?:a)?\(\s*(\d{0,3}[.]?[0-9]+(?:deg)?)\s*(?:,)?\s*(\d{1,3}[.]?[0-9]?)%\s*(?:,)?\s*(\d{1,3}[.]?[0-9]?)%\s*(?:,|\/)\s*([-+]?\d*[.]?\d+[%]?)\s*\)$/i;
    /**
     * Returns an RgbColor or RgbaColor object. This utility function is only useful
     * if want to extract a color component. With the color util `toColorString` you
     * can convert a RgbColor or RgbaColor object back to a string.
     *
     * @example
     * // Assigns `{ red: 255, green: 0, blue: 0 }` to color1
     * const color1 = parseToRgb('rgb(255, 0, 0)');
     * // Assigns `{ red: 92, green: 102, blue: 112, alpha: 0.75 }` to color2
     * const color2 = parseToRgb('hsla(210, 10%, 40%, 0.75)');
     */

    function parseToRgb(color) {
      if (typeof color !== 'string') {
        throw new PolishedError(3);
      }

      var normalizedColor = nameToHex(color);

      if (normalizedColor.match(hexRegex)) {
        return {
          red: parseInt("" + normalizedColor[1] + normalizedColor[2], 16),
          green: parseInt("" + normalizedColor[3] + normalizedColor[4], 16),
          blue: parseInt("" + normalizedColor[5] + normalizedColor[6], 16)
        };
      }

      if (normalizedColor.match(hexRgbaRegex)) {
        var alpha = parseFloat((parseInt("" + normalizedColor[7] + normalizedColor[8], 16) / 255).toFixed(2));
        return {
          red: parseInt("" + normalizedColor[1] + normalizedColor[2], 16),
          green: parseInt("" + normalizedColor[3] + normalizedColor[4], 16),
          blue: parseInt("" + normalizedColor[5] + normalizedColor[6], 16),
          alpha: alpha
        };
      }

      if (normalizedColor.match(reducedHexRegex)) {
        return {
          red: parseInt("" + normalizedColor[1] + normalizedColor[1], 16),
          green: parseInt("" + normalizedColor[2] + normalizedColor[2], 16),
          blue: parseInt("" + normalizedColor[3] + normalizedColor[3], 16)
        };
      }

      if (normalizedColor.match(reducedRgbaHexRegex)) {
        var _alpha = parseFloat((parseInt("" + normalizedColor[4] + normalizedColor[4], 16) / 255).toFixed(2));

        return {
          red: parseInt("" + normalizedColor[1] + normalizedColor[1], 16),
          green: parseInt("" + normalizedColor[2] + normalizedColor[2], 16),
          blue: parseInt("" + normalizedColor[3] + normalizedColor[3], 16),
          alpha: _alpha
        };
      }

      var rgbMatched = rgbRegex.exec(normalizedColor);

      if (rgbMatched) {
        return {
          red: parseInt("" + rgbMatched[1], 10),
          green: parseInt("" + rgbMatched[2], 10),
          blue: parseInt("" + rgbMatched[3], 10)
        };
      }

      var rgbaMatched = rgbaRegex.exec(normalizedColor.substring(0, 50));

      if (rgbaMatched) {
        return {
          red: parseInt("" + rgbaMatched[1], 10),
          green: parseInt("" + rgbaMatched[2], 10),
          blue: parseInt("" + rgbaMatched[3], 10),
          alpha: parseFloat("" + rgbaMatched[4]) > 1 ? parseFloat("" + rgbaMatched[4]) / 100 : parseFloat("" + rgbaMatched[4])
        };
      }

      var hslMatched = hslRegex.exec(normalizedColor);

      if (hslMatched) {
        var hue = parseInt("" + hslMatched[1], 10);
        var saturation = parseInt("" + hslMatched[2], 10) / 100;
        var lightness = parseInt("" + hslMatched[3], 10) / 100;
        var rgbColorString = "rgb(" + hslToRgb(hue, saturation, lightness) + ")";
        var hslRgbMatched = rgbRegex.exec(rgbColorString);

        if (!hslRgbMatched) {
          throw new PolishedError(4, normalizedColor, rgbColorString);
        }

        return {
          red: parseInt("" + hslRgbMatched[1], 10),
          green: parseInt("" + hslRgbMatched[2], 10),
          blue: parseInt("" + hslRgbMatched[3], 10)
        };
      }

      var hslaMatched = hslaRegex.exec(normalizedColor.substring(0, 50));

      if (hslaMatched) {
        var _hue = parseInt("" + hslaMatched[1], 10);

        var _saturation = parseInt("" + hslaMatched[2], 10) / 100;

        var _lightness = parseInt("" + hslaMatched[3], 10) / 100;

        var _rgbColorString = "rgb(" + hslToRgb(_hue, _saturation, _lightness) + ")";

        var _hslRgbMatched = rgbRegex.exec(_rgbColorString);

        if (!_hslRgbMatched) {
          throw new PolishedError(4, normalizedColor, _rgbColorString);
        }

        return {
          red: parseInt("" + _hslRgbMatched[1], 10),
          green: parseInt("" + _hslRgbMatched[2], 10),
          blue: parseInt("" + _hslRgbMatched[3], 10),
          alpha: parseFloat("" + hslaMatched[4]) > 1 ? parseFloat("" + hslaMatched[4]) / 100 : parseFloat("" + hslaMatched[4])
        };
      }

      throw new PolishedError(5);
    }

    /**
     * Reduces hex values if possible e.g. #ff8866 to #f86
     * @private
     */
    var reduceHexValue = function reduceHexValue(value) {
      if (value.length === 7 && value[1] === value[2] && value[3] === value[4] && value[5] === value[6]) {
        return "#" + value[1] + value[3] + value[5];
      }

      return value;
    };

    var reduceHexValue$1 = reduceHexValue;

    function numberToHex(value) {
      var hex = value.toString(16);
      return hex.length === 1 ? "0" + hex : hex;
    }

    /**
     * Returns a string value for the color. The returned result is the smallest possible hex notation.
     *
     * @example
     * // Styles as object usage
     * const styles = {
     *   background: rgb(255, 205, 100),
     *   background: rgb({ red: 255, green: 205, blue: 100 }),
     * }
     *
     * // styled-components usage
     * const div = styled.div`
     *   background: ${rgb(255, 205, 100)};
     *   background: ${rgb({ red: 255, green: 205, blue: 100 })};
     * `
     *
     * // CSS in JS Output
     *
     * element {
     *   background: "#ffcd64";
     *   background: "#ffcd64";
     * }
     */
    function rgb(value, green, blue) {
      if (typeof value === 'number' && typeof green === 'number' && typeof blue === 'number') {
        return reduceHexValue$1("#" + numberToHex(value) + numberToHex(green) + numberToHex(blue));
      } else if (typeof value === 'object' && green === undefined && blue === undefined) {
        return reduceHexValue$1("#" + numberToHex(value.red) + numberToHex(value.green) + numberToHex(value.blue));
      }

      throw new PolishedError(6);
    }

    /**
     * Returns a string value for the color. The returned result is the smallest possible rgba or hex notation.
     *
     * Can also be used to fade a color by passing a hex value or named CSS color along with an alpha value.
     *
     * @example
     * // Styles as object usage
     * const styles = {
     *   background: rgba(255, 205, 100, 0.7),
     *   background: rgba({ red: 255, green: 205, blue: 100, alpha: 0.7 }),
     *   background: rgba(255, 205, 100, 1),
     *   background: rgba('#ffffff', 0.4),
     *   background: rgba('black', 0.7),
     * }
     *
     * // styled-components usage
     * const div = styled.div`
     *   background: ${rgba(255, 205, 100, 0.7)};
     *   background: ${rgba({ red: 255, green: 205, blue: 100, alpha: 0.7 })};
     *   background: ${rgba(255, 205, 100, 1)};
     *   background: ${rgba('#ffffff', 0.4)};
     *   background: ${rgba('black', 0.7)};
     * `
     *
     * // CSS in JS Output
     *
     * element {
     *   background: "rgba(255,205,100,0.7)";
     *   background: "rgba(255,205,100,0.7)";
     *   background: "#ffcd64";
     *   background: "rgba(255,255,255,0.4)";
     *   background: "rgba(0,0,0,0.7)";
     * }
     */
    function rgba(firstValue, secondValue, thirdValue, fourthValue) {
      if (typeof firstValue === 'string' && typeof secondValue === 'number') {
        var rgbValue = parseToRgb(firstValue);
        return "rgba(" + rgbValue.red + "," + rgbValue.green + "," + rgbValue.blue + "," + secondValue + ")";
      } else if (typeof firstValue === 'number' && typeof secondValue === 'number' && typeof thirdValue === 'number' && typeof fourthValue === 'number') {
        return fourthValue >= 1 ? rgb(firstValue, secondValue, thirdValue) : "rgba(" + firstValue + "," + secondValue + "," + thirdValue + "," + fourthValue + ")";
      } else if (typeof firstValue === 'object' && secondValue === undefined && thirdValue === undefined && fourthValue === undefined) {
        return firstValue.alpha >= 1 ? rgb(firstValue.red, firstValue.green, firstValue.blue) : "rgba(" + firstValue.red + "," + firstValue.green + "," + firstValue.blue + "," + firstValue.alpha + ")";
      }

      throw new PolishedError(7);
    }

    // Type definitions taken from https://github.com/gcanti/flow-static-land/blob/master/src/Fun.js
    // eslint-disable-next-line no-unused-vars
    // eslint-disable-next-line no-unused-vars
    // eslint-disable-next-line no-redeclare
    function curried(f, length, acc) {
      return function fn() {
        // eslint-disable-next-line prefer-rest-params
        var combined = acc.concat(Array.prototype.slice.call(arguments));
        return combined.length >= length ? f.apply(this, combined) : curried(f, length, combined);
      };
    } // eslint-disable-next-line no-redeclare


    function curry(f) {
      // eslint-disable-line no-redeclare
      return curried(f, f.length, []);
    }

    function guard(lowerBoundary, upperBoundary, value) {
      return Math.max(lowerBoundary, Math.min(upperBoundary, value));
    }

    /**
     * Increases the opacity of a color. Its range for the amount is between 0 to 1.
     *
     *
     * @example
     * // Styles as object usage
     * const styles = {
     *   background: opacify(0.1, 'rgba(255, 255, 255, 0.9)');
     *   background: opacify(0.2, 'hsla(0, 0%, 100%, 0.5)'),
     *   background: opacify('0.5', 'rgba(255, 0, 0, 0.2)'),
     * }
     *
     * // styled-components usage
     * const div = styled.div`
     *   background: ${opacify(0.1, 'rgba(255, 255, 255, 0.9)')};
     *   background: ${opacify(0.2, 'hsla(0, 0%, 100%, 0.5)')},
     *   background: ${opacify('0.5', 'rgba(255, 0, 0, 0.2)')},
     * `
     *
     * // CSS in JS Output
     *
     * element {
     *   background: "#fff";
     *   background: "rgba(255,255,255,0.7)";
     *   background: "rgba(255,0,0,0.7)";
     * }
     */

    function opacify(amount, color) {
      if (color === 'transparent') return color;
      var parsedColor = parseToRgb(color);
      var alpha = typeof parsedColor.alpha === 'number' ? parsedColor.alpha : 1;

      var colorWithAlpha = _extends({}, parsedColor, {
        alpha: guard(0, 1, (alpha * 100 + parseFloat(amount) * 100) / 100)
      });

      return rgba(colorWithAlpha);
    } // prettier-ignore


    var curriedOpacify = /*#__PURE__*/curry
    /* ::<number | string, string, string> */
    (opacify);
    var curriedOpacify$1 = curriedOpacify;

    function styleInject$1(css, ref) {
      if (ref === void 0) ref = {};
      var insertAt = ref.insertAt;
      if (!css || typeof document === 'undefined') {
        return;
      }
      var head = document.head || document.getElementsByTagName('head')[0];
      var style = document.createElement('style');
      style.type = 'text/css';
      if (insertAt === 'top') {
        if (head.firstChild) {
          head.insertBefore(style, head.firstChild);
        } else {
          head.appendChild(style);
        }
      } else {
        head.appendChild(style);
      }
      if (style.styleSheet) {
        style.styleSheet.cssText = css;
      } else {
        style.appendChild(document.createTextNode(css));
      }
    }

    var css_248z$1 = ".scene-nav-info {\n  bottom: 5px;\n  width: 100%;\n  text-align: center;\n  color: slategrey;\n  opacity: 0.7;\n  font-size: 10px;\n}\n\n.scene-tooltip {\n  top: 0;\n  color: lavender;\n  font-size: 15px;\n}\n\n.scene-nav-info, .scene-tooltip {\n  position: absolute;\n  font-family: sans-serif;\n  pointer-events: none;\n}\n\n.scene-container canvas:focus {\n  outline: none;\n}";
    styleInject$1(css_248z$1);

    function _defineProperty$1(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _slicedToArray(arr, i) {
      return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray$1(arr, i) || _nonIterableRest();
    }
    function _toConsumableArray$1(arr) {
      return _arrayWithoutHoles$1(arr) || _iterableToArray$1(arr) || _unsupportedIterableToArray$1(arr) || _nonIterableSpread$1();
    }
    function _arrayWithoutHoles$1(arr) {
      if (Array.isArray(arr)) return _arrayLikeToArray$1(arr);
    }
    function _arrayWithHoles(arr) {
      if (Array.isArray(arr)) return arr;
    }
    function _iterableToArray$1(iter) {
      if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
    }
    function _iterableToArrayLimit(arr, i) {
      var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
      if (_i == null) return;
      var _arr = [];
      var _n = true;
      var _d = false;
      var _s, _e;
      try {
        for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);
          if (i && _arr.length === i) break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"] != null) _i["return"]();
        } finally {
          if (_d) throw _e;
        }
      }
      return _arr;
    }
    function _unsupportedIterableToArray$1(o, minLen) {
      if (!o) return;
      if (typeof o === "string") return _arrayLikeToArray$1(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor) n = o.constructor.name;
      if (n === "Map" || n === "Set") return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$1(o, minLen);
    }
    function _arrayLikeToArray$1(arr, len) {
      if (len == null || len > arr.length) len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
      return arr2;
    }
    function _nonIterableSpread$1() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }

    var three = window.THREE ? window.THREE // Prefer consumption from global THREE, if exists
    : {
      WebGLRenderer: WebGLRenderer,
      Scene: Scene,
      PerspectiveCamera: PerspectiveCamera,
      Raycaster: Raycaster,
      TextureLoader: TextureLoader,
      Vector2: Vector2,
      Vector3: Vector3,
      Box3: Box3,
      Color: Color$1,
      Mesh: Mesh,
      SphereGeometry: SphereGeometry,
      MeshBasicMaterial: MeshBasicMaterial,
      BackSide: BackSide,
      EventDispatcher: EventDispatcher,
      MOUSE: MOUSE,
      Quaternion: Quaternion,
      Spherical: Spherical,
      Clock: Clock
    };
    var threeRenderObjects = index$2({
      props: {
        width: {
          "default": window.innerWidth,
          onChange: function onChange(width, state, prevWidth) {
            isNaN(width) && (state.width = prevWidth);
          }
        },
        height: {
          "default": window.innerHeight,
          onChange: function onChange(height, state, prevHeight) {
            isNaN(height) && (state.height = prevHeight);
          }
        },
        backgroundColor: {
          "default": '#000011'
        },
        backgroundImageUrl: {},
        onBackgroundImageLoaded: {},
        showNavInfo: {
          "default": true
        },
        skyRadius: {
          "default": 50000
        },
        objects: {
          "default": []
        },
        enablePointerInteraction: {
          "default": true,
          onChange: function onChange(_, state) {
            // Reset hover state
            state.hoverObj = null;
            if (state.toolTipElem) state.toolTipElem.innerHTML = '';
          },
          triggerUpdate: false
        },
        lineHoverPrecision: {
          "default": 1,
          triggerUpdate: false
        },
        hoverOrderComparator: {
          "default": function _default() {
            return -1;
          },
          triggerUpdate: false
        },
        // keep existing order by default
        hoverFilter: {
          "default": function _default() {
            return true;
          },
          triggerUpdate: false
        },
        // exclude objects from interaction
        tooltipContent: {
          triggerUpdate: false
        },
        hoverDuringDrag: {
          "default": false,
          triggerUpdate: false
        },
        clickAfterDrag: {
          "default": false,
          triggerUpdate: false
        },
        onHover: {
          "default": function _default() {},
          triggerUpdate: false
        },
        onClick: {
          "default": function _default() {},
          triggerUpdate: false
        },
        onRightClick: {
          triggerUpdate: false
        }
      },
      methods: {
        tick: function tick(state) {
          if (state.initialised) {
            state.controls.update && state.controls.update(state.clock.getDelta()); // timedelta is required for fly controls

            state.postProcessingComposer ? state.postProcessingComposer.render() // if using postprocessing, switch the output to it
            : state.renderer.render(state.scene, state.camera);
            state.extraRenderers.forEach(function (r) {
              return r.render(state.scene, state.camera);
            });
            if (state.enablePointerInteraction) {
              // Update tooltip and trigger onHover events
              var topObject = null;
              if (state.hoverDuringDrag || !state.isPointerDragging) {
                var intersects = this.intersectingObjects(state.pointerPos.x, state.pointerPos.y).filter(function (d) {
                  return state.hoverFilter(d.object);
                }).sort(function (a, b) {
                  return state.hoverOrderComparator(a.object, b.object);
                });
                var topIntersect = intersects.length ? intersects[0] : null;
                topObject = topIntersect ? topIntersect.object : null;
                state.intersectionPoint = topIntersect ? topIntersect.point : null;
              }
              if (topObject !== state.hoverObj) {
                state.onHover(topObject, state.hoverObj);
                state.toolTipElem.innerHTML = topObject ? index$1(state.tooltipContent)(topObject) || '' : '';
                state.hoverObj = topObject;
              }
            }
            exports$1.update(); // update camera animation tweens
          }

          return this;
        },
        getPointerPos: function getPointerPos(state) {
          var _state$pointerPos = state.pointerPos,
            x = _state$pointerPos.x,
            y = _state$pointerPos.y;
          return {
            x: x,
            y: y
          };
        },
        cameraPosition: function cameraPosition(state, position, lookAt, transitionDuration) {
          var camera = state.camera;

          // Setter
          if (position && state.initialised) {
            var finalPos = position;
            var finalLookAt = lookAt || {
              x: 0,
              y: 0,
              z: 0
            };
            if (!transitionDuration) {
              // no animation
              setCameraPos(finalPos);
              setLookAt(finalLookAt);
            } else {
              var camPos = Object.assign({}, camera.position);
              var camLookAt = getLookAt();
              new exports$1.Tween(camPos).to(finalPos, transitionDuration).easing(exports$1.Easing.Quadratic.Out).onUpdate(setCameraPos).start();

              // Face direction in 1/3rd of time
              new exports$1.Tween(camLookAt).to(finalLookAt, transitionDuration / 3).easing(exports$1.Easing.Quadratic.Out).onUpdate(setLookAt).start();
            }
            return this;
          }

          // Getter
          return Object.assign({}, camera.position, {
            lookAt: getLookAt()
          });

          //

          function setCameraPos(pos) {
            var x = pos.x,
              y = pos.y,
              z = pos.z;
            if (x !== undefined) camera.position.x = x;
            if (y !== undefined) camera.position.y = y;
            if (z !== undefined) camera.position.z = z;
          }
          function setLookAt(lookAt) {
            var lookAtVect = new three.Vector3(lookAt.x, lookAt.y, lookAt.z);
            if (state.controls.target) {
              state.controls.target = lookAtVect;
            } else {
              // Fly controls doesn't have target attribute
              camera.lookAt(lookAtVect); // note: lookAt may be overridden by other controls in some cases
            }
          }

          function getLookAt() {
            return Object.assign(new three.Vector3(0, 0, -1000).applyQuaternion(camera.quaternion).add(camera.position));
          }
        },
        zoomToFit: function zoomToFit(state) {
          var transitionDuration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
          var padding = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 10;
          for (var _len = arguments.length, bboxArgs = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {
            bboxArgs[_key - 3] = arguments[_key];
          }
          return this.fitToBbox(this.getBbox.apply(this, bboxArgs), transitionDuration, padding);
        },
        fitToBbox: function fitToBbox(state, bbox) {
          var transitionDuration = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
          var padding = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 10;
          // based on https://discourse.threejs.org/t/camera-zoom-to-fit-object/936/24
          var camera = state.camera;
          if (bbox) {
            var center = new three.Vector3(0, 0, 0); // reset camera aim to center
            var maxBoxSide = Math.max.apply(Math, _toConsumableArray$1(Object.entries(bbox).map(function (_ref) {
              var _ref2 = _slicedToArray(_ref, 2),
                coordType = _ref2[0],
                coords = _ref2[1];
              return Math.max.apply(Math, _toConsumableArray$1(coords.map(function (c) {
                return Math.abs(center[coordType] - c);
              })));
            }))) * 2;

            // find distance that fits whole bbox within padded fov
            var paddedFov = (1 - padding * 2 / state.height) * camera.fov;
            var fitHeightDistance = maxBoxSide / Math.atan(paddedFov * Math.PI / 180);
            var fitWidthDistance = fitHeightDistance / camera.aspect;
            var distance = Math.max(fitHeightDistance, fitWidthDistance);
            if (distance > 0) {
              var newCameraPosition = center.clone().sub(camera.position).normalize().multiplyScalar(-distance);
              this.cameraPosition(newCameraPosition, center, transitionDuration);
            }
          }
          return this;
        },
        getBbox: function getBbox(state) {
          var objFilter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {
            return true;
          };
          var box = new three.Box3(new three.Vector3(0, 0, 0), new three.Vector3(0, 0, 0));
          var objs = state.objects.filter(objFilter);
          if (!objs.length) return null;
          objs.forEach(function (obj) {
            return box.expandByObject(obj);
          });

          // extract global x,y,z min/max
          return Object.assign.apply(Object, _toConsumableArray$1(['x', 'y', 'z'].map(function (c) {
            return _defineProperty$1({}, c, [box.min[c], box.max[c]]);
          })));
        },
        getScreenCoords: function getScreenCoords(state, x, y, z) {
          var vec = new three.Vector3(x, y, z);
          vec.project(this.camera()); // project to the camera plane
          return {
            // align relative pos to canvas dimensions
            x: (vec.x + 1) * state.width / 2,
            y: -(vec.y - 1) * state.height / 2
          };
        },
        getSceneCoords: function getSceneCoords(state, screenX, screenY) {
          var distance = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
          var relCoords = new three.Vector2(screenX / state.width * 2 - 1, -(screenY / state.height) * 2 + 1);
          var raycaster = new three.Raycaster();
          raycaster.setFromCamera(relCoords, state.camera);
          return Object.assign({}, raycaster.ray.at(distance, new three.Vector3()));
        },
        intersectingObjects: function intersectingObjects(state, x, y) {
          var relCoords = new three.Vector2(x / state.width * 2 - 1, -(y / state.height) * 2 + 1);
          var raycaster = new three.Raycaster();
          raycaster.params.Line.threshold = state.lineHoverPrecision; // set linePrecision
          raycaster.setFromCamera(relCoords, state.camera);
          return raycaster.intersectObjects(state.objects, true);
        },
        renderer: function renderer(state) {
          return state.renderer;
        },
        scene: function scene(state) {
          return state.scene;
        },
        camera: function camera(state) {
          return state.camera;
        },
        postProcessingComposer: function postProcessingComposer(state) {
          return state.postProcessingComposer;
        },
        controls: function controls(state) {
          return state.controls;
        },
        tbControls: function tbControls(state) {
          return state.controls;
        } // to be deprecated
      },

      stateInit: function stateInit() {
        return {
          scene: new three.Scene(),
          camera: new three.PerspectiveCamera(),
          clock: new three.Clock()
        };
      },
      init: function init(domNode, state) {
        var _ref4 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
          _ref4$controlType = _ref4.controlType,
          controlType = _ref4$controlType === void 0 ? 'trackball' : _ref4$controlType,
          _ref4$rendererConfig = _ref4.rendererConfig,
          rendererConfig = _ref4$rendererConfig === void 0 ? {} : _ref4$rendererConfig,
          _ref4$extraRenderers = _ref4.extraRenderers,
          extraRenderers = _ref4$extraRenderers === void 0 ? [] : _ref4$extraRenderers,
          _ref4$waitForLoadComp = _ref4.waitForLoadComplete,
          waitForLoadComplete = _ref4$waitForLoadComp === void 0 ? true : _ref4$waitForLoadComp;
        // Wipe DOM
        domNode.innerHTML = '';

        // Add relative container
        domNode.appendChild(state.container = document.createElement('div'));
        state.container.className = 'scene-container';
        state.container.style.position = 'relative';

        // Add nav info section
        state.container.appendChild(state.navInfo = document.createElement('div'));
        state.navInfo.className = 'scene-nav-info';
        state.navInfo.textContent = {
          orbit: 'Left-click: rotate, Mouse-wheel/middle-click: zoom, Right-click: pan',
          trackball: 'Left-click: rotate, Mouse-wheel/middle-click: zoom, Right-click: pan',
          fly: 'WASD: move, R|F: up | down, Q|E: roll, up|down: pitch, left|right: yaw'
        }[controlType] || '';
        state.navInfo.style.display = state.showNavInfo ? null : 'none';

        // Setup tooltip
        state.toolTipElem = document.createElement('div');
        state.toolTipElem.classList.add('scene-tooltip');
        state.container.appendChild(state.toolTipElem);

        // Capture pointer coords on move or touchstart
        state.pointerPos = new three.Vector2();
        state.pointerPos.x = -2; // Initialize off canvas
        state.pointerPos.y = -2;
        ['pointermove', 'pointerdown'].forEach(function (evType) {
          return state.container.addEventListener(evType, function (ev) {
            // track click state
            evType === 'pointerdown' && (state.isPointerPressed = true);

            // detect point drag
            !state.isPointerDragging && ev.type === 'pointermove' && (ev.pressure > 0 || state.isPointerPressed) // ev.pressure always 0 on Safari, so we used the isPointerPressed tracker
            && (ev.pointerType !== 'touch' || ev.movementX === undefined || [ev.movementX, ev.movementY].some(function (m) {
              return Math.abs(m) > 1;
            })) // relax drag trigger sensitivity on touch events
            && (state.isPointerDragging = true);
            if (state.enablePointerInteraction) {
              // update the pointer pos
              var offset = getOffset(state.container);
              state.pointerPos.x = ev.pageX - offset.left;
              state.pointerPos.y = ev.pageY - offset.top;

              // Move tooltip
              state.toolTipElem.style.top = "".concat(state.pointerPos.y, "px");
              state.toolTipElem.style.left = "".concat(state.pointerPos.x, "px");
              // adjust horizontal position to not exceed canvas boundaries
              state.toolTipElem.style.transform = "translate(-".concat(state.pointerPos.x / state.width * 100, "%, ").concat(
              // flip to above if near bottom
              state.height - state.pointerPos.y < 100 ? 'calc(-100% - 8px)' : '21px', ")");
            }
            function getOffset(el) {
              var rect = el.getBoundingClientRect(),
                scrollLeft = window.pageXOffset || document.documentElement.scrollLeft,
                scrollTop = window.pageYOffset || document.documentElement.scrollTop;
              return {
                top: rect.top + scrollTop,
                left: rect.left + scrollLeft
              };
            }
          }, {
            passive: true
          });
        });

        // Handle click events on objs
        state.container.addEventListener('pointerup', function (ev) {
          state.isPointerPressed = false;
          if (state.isPointerDragging) {
            state.isPointerDragging = false;
            if (!state.clickAfterDrag) return; // don't trigger onClick after pointer drag (camera motion via controls)
          }

          requestAnimationFrame(function () {
            // trigger click events asynchronously, to allow hoverObj to be set (on frame)
            if (ev.button === 0) {
              // left-click
              state.onClick(state.hoverObj || null, ev, state.intersectionPoint); // trigger background clicks with null
            }

            if (ev.button === 2 && state.onRightClick) {
              // right-click
              state.onRightClick(state.hoverObj || null, ev, state.intersectionPoint);
            }
          });
        }, {
          passive: true,
          capture: true
        }); // use capture phase to prevent propagation blocking from controls (specifically for fly)

        state.container.addEventListener('contextmenu', function (ev) {
          if (state.onRightClick) ev.preventDefault(); // prevent default contextmenu behavior and allow pointerup to fire instead
        });

        // Setup renderer, camera and controls
        state.renderer = new three.WebGLRenderer(Object.assign({
          antialias: true,
          alpha: true
        }, rendererConfig));
        state.renderer.setPixelRatio(Math.min(2, window.devicePixelRatio)); // clamp device pixel ratio
        state.container.appendChild(state.renderer.domElement);

        // Setup extra renderers
        state.extraRenderers = extraRenderers;
        state.extraRenderers.forEach(function (r) {
          // overlay them on top of main renderer
          r.domElement.style.position = 'absolute';
          r.domElement.style.top = '0px';
          r.domElement.style.pointerEvents = 'none';
          state.container.appendChild(r.domElement);
        });

        // configure post-processing composer
        state.postProcessingComposer = new EffectComposer(state.renderer);
        state.postProcessingComposer.addPass(new RenderPass(state.scene, state.camera)); // render scene as first pass

        // configure controls
        state.controls = new {
          trackball: TrackballControls,
          orbit: OrbitControls,
          fly: FlyControls
        }[controlType](state.camera, state.renderer.domElement);
        if (controlType === 'fly') {
          state.controls.movementSpeed = 300;
          state.controls.rollSpeed = Math.PI / 6;
          state.controls.dragToLook = true;
        }
        if (controlType === 'trackball' || controlType === 'orbit') {
          state.controls.minDistance = 0.1;
          state.controls.maxDistance = state.skyRadius;
          state.controls.addEventListener('start', function () {
            state.controlsEngaged = true;
          });
          state.controls.addEventListener('change', function () {
            if (state.controlsEngaged) {
              state.controlsDragging = true;
            }
          });
          state.controls.addEventListener('end', function () {
            state.controlsEngaged = false;
            state.controlsDragging = false;
          });
        }
        [state.renderer, state.postProcessingComposer].concat(_toConsumableArray$1(state.extraRenderers)).forEach(function (r) {
          return r.setSize(state.width, state.height);
        });
        state.camera.aspect = state.width / state.height;
        state.camera.updateProjectionMatrix();
        state.camera.position.z = 1000;

        // add sky
        state.scene.add(state.skysphere = new three.Mesh());
        state.skysphere.visible = false;
        state.loadComplete = state.scene.visible = !waitForLoadComplete;
        window.scene = state.scene;
      },
      update: function update(state, changedProps) {
        // resize canvas
        if (state.width && state.height && (changedProps.hasOwnProperty('width') || changedProps.hasOwnProperty('height'))) {
          state.container.style.width = "".concat(state.width, "px");
          state.container.style.height = "".concat(state.height, "px");
          [state.renderer, state.postProcessingComposer].concat(_toConsumableArray$1(state.extraRenderers)).forEach(function (r) {
            return r.setSize(state.width, state.height);
          });
          state.camera.aspect = state.width / state.height;
          state.camera.updateProjectionMatrix();
        }
        if (changedProps.hasOwnProperty('skyRadius') && state.skyRadius) {
          state.controls.hasOwnProperty('maxDistance') && changedProps.skyRadius && (state.controls.maxDistance = Math.min(state.controls.maxDistance, state.skyRadius));
          state.camera.far = state.skyRadius * 2.5;
          state.camera.updateProjectionMatrix();
          state.skysphere.geometry = new three.SphereGeometry(state.skyRadius);
        }
        if (changedProps.hasOwnProperty('backgroundColor')) {
          var alpha = parseToRgb(state.backgroundColor).alpha;
          if (alpha === undefined) alpha = 1;
          state.renderer.setClearColor(new three.Color(curriedOpacify$1(1, state.backgroundColor)), alpha);
        }
        if (changedProps.hasOwnProperty('backgroundImageUrl')) {
          if (!state.backgroundImageUrl) {
            state.skysphere.visible = false;
            state.skysphere.material.map = null;
            !state.loadComplete && finishLoad();
          } else {
            new three.TextureLoader().load(state.backgroundImageUrl, function (texture) {
              state.skysphere.material = new three.MeshBasicMaterial({
                map: texture,
                side: three.BackSide
              });
              state.skysphere.visible = true;

              // triggered when background image finishes loading (asynchronously to allow 1 frame to load texture)
              state.onBackgroundImageLoaded && setTimeout(state.onBackgroundImageLoaded);
              !state.loadComplete && finishLoad();
            });
          }
        }
        changedProps.hasOwnProperty('showNavInfo') && (state.navInfo.style.display = state.showNavInfo ? null : 'none');
        if (changedProps.hasOwnProperty('objects')) {
          (changedProps.objects || []).forEach(function (obj) {
            return state.scene.remove(obj);
          }); // Clear the place
          state.objects.forEach(function (obj) {
            return state.scene.add(obj);
          }); // Add to scene
        }

        //

        function finishLoad() {
          state.loadComplete = state.scene.visible = true;
        }
      }
    });

    function styleInject(css, ref) {
      if (ref === void 0) ref = {};
      var insertAt = ref.insertAt;
      if (!css || typeof document === 'undefined') {
        return;
      }
      var head = document.head || document.getElementsByTagName('head')[0];
      var style = document.createElement('style');
      style.type = 'text/css';
      if (insertAt === 'top') {
        if (head.firstChild) {
          head.insertBefore(style, head.firstChild);
        } else {
          head.appendChild(style);
        }
      } else {
        head.appendChild(style);
      }
      if (style.styleSheet) {
        style.styleSheet.cssText = css;
      } else {
        style.appendChild(document.createTextNode(css));
      }
    }

    var css_248z = ".scene-container .clickable {\n  cursor: pointer;\n}";
    styleInject(css_248z);

    function ownKeys$1(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function (sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread2(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys$1(Object(source), !0).forEach(function (key) {
          _defineProperty(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function (key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _objectWithoutPropertiesLoose(source, excluded) {
      if (source == null) return {};
      var target = {};
      var sourceKeys = Object.keys(source);
      var key, i;
      for (i = 0; i < sourceKeys.length; i++) {
        key = sourceKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        target[key] = source[key];
      }
      return target;
    }
    function _objectWithoutProperties(source, excluded) {
      if (source == null) return {};
      var target = _objectWithoutPropertiesLoose(source, excluded);
      var key, i;
      if (Object.getOwnPropertySymbols) {
        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
        for (i = 0; i < sourceSymbolKeys.length; i++) {
          key = sourceSymbolKeys[i];
          if (excluded.indexOf(key) >= 0) continue;
          if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
          target[key] = source[key];
        }
      }
      return target;
    }
    function _toConsumableArray(arr) {
      return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
    }
    function _arrayWithoutHoles(arr) {
      if (Array.isArray(arr)) return _arrayLikeToArray(arr);
    }
    function _iterableToArray(iter) {
      if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o) return;
      if (typeof o === "string") return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor) n = o.constructor.name;
      if (n === "Map" || n === "Set") return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length) len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
      return arr2;
    }
    function _nonIterableSpread() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }

    function linkKapsule (kapsulePropName, kapsuleType) {
      var dummyK = new kapsuleType(); // To extract defaults

      return {
        linkProp: function linkProp(prop) {
          // link property config
          return {
            "default": dummyK[prop](),
            onChange: function onChange(v, state) {
              state[kapsulePropName][prop](v);
            },
            triggerUpdate: false
          };
        },
        linkMethod: function linkMethod(method) {
          // link method pass-through
          return function (state) {
            var kapsuleInstance = state[kapsulePropName];
            for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
              args[_key - 1] = arguments[_key];
            }
            var returnVal = kapsuleInstance[method].apply(kapsuleInstance, args);
            return returnVal === kapsuleInstance ? this // chain based on the parent object, not the inner kapsule
            : returnVal;
          };
        }
      };
    }

    var _excluded = ["rendererConfig", "waitForGlobeReady"];
    var THREE = _objectSpread2(_objectSpread2({}, window.THREE ? window.THREE // Prefer consumption from global THREE, if exists
    : {
      AmbientLight: AmbientLight,
      DirectionalLight: DirectionalLight,
      Vector2: Vector2
    }), {}, {
      CSS2DRenderer: CSS2DRenderer
    });

    //

    // Expose config from ThreeGlobe
    var bindGlobe = linkKapsule('globe', threeGlobe);
    var linkedGlobeProps = Object.assign.apply(Object, _toConsumableArray(['globeImageUrl', 'bumpImageUrl', 'showGlobe', 'showGraticules', 'showAtmosphere', 'atmosphereColor', 'atmosphereAltitude', 'globeMaterial', 'onGlobeReady', 'pointsData', 'pointLat', 'pointLng', 'pointColor', 'pointAltitude', 'pointRadius', 'pointResolution', 'pointsMerge', 'pointsTransitionDuration', 'arcsData', 'arcStartLat', 'arcStartLng', 'arcEndLat', 'arcEndLng', 'arcColor', 'arcAltitude', 'arcAltitudeAutoScale', 'arcStroke', 'arcCurveResolution', 'arcCircularResolution', 'arcDashLength', 'arcDashGap', 'arcDashInitialGap', 'arcDashAnimateTime', 'arcsTransitionDuration', 'polygonsData', 'polygonGeoJsonGeometry', 'polygonCapColor', 'polygonCapMaterial', 'polygonSideColor', 'polygonSideMaterial', 'polygonStrokeColor', 'polygonAltitude', 'polygonCapCurvatureResolution', 'polygonsTransitionDuration', 'pathsData', 'pathPoints', 'pathPointLat', 'pathPointLng', 'pathPointAlt', 'pathResolution', 'pathColor', 'pathStroke', 'pathDashLength', 'pathDashGap', 'pathDashInitialGap', 'pathDashAnimateTime', 'pathTransitionDuration', 'hexBinPointsData', 'hexBinPointLat', 'hexBinPointLng', 'hexBinPointWeight', 'hexBinResolution', 'hexMargin', 'hexTopCurvatureResolution', 'hexTopColor', 'hexSideColor', 'hexAltitude', 'hexBinMerge', 'hexTransitionDuration', 'hexPolygonsData', 'hexPolygonGeoJsonGeometry', 'hexPolygonColor', 'hexPolygonAltitude', 'hexPolygonResolution', 'hexPolygonMargin', 'hexPolygonCurvatureResolution', 'hexPolygonsTransitionDuration', 'tilesData', 'tileLat', 'tileLng', 'tileAltitude', 'tileWidth', 'tileHeight', 'tileUseGlobeProjection', 'tileMaterial', 'tileCurvatureResolution', 'tilesTransitionDuration', 'ringsData', 'ringLat', 'ringLng', 'ringAltitude', 'ringColor', 'ringResolution', 'ringMaxRadius', 'ringPropagationSpeed', 'ringRepeatPeriod', 'labelsData', 'labelLat', 'labelLng', 'labelAltitude', 'labelRotation', 'labelText', 'labelSize', 'labelTypeFace', 'labelColor', 'labelResolution', 'labelIncludeDot', 'labelDotRadius', 'labelDotOrientation', 'labelsTransitionDuration', 'htmlElementsData', 'htmlLat', 'htmlLng', 'htmlAltitude', 'htmlElement', 'htmlTransitionDuration', 'objectsData', 'objectLat', 'objectLng', 'objectAltitude', 'objectThreeObject', 'customLayerData', 'customThreeObject', 'customThreeObjectUpdate'].map(function (p) {
      return _defineProperty({}, p, bindGlobe.linkProp(p));
    })));
    var linkedGlobeMethods = Object.assign.apply(Object, _toConsumableArray(['getGlobeRadius', 'getCoords', 'toGeoCoords'].map(function (p) {
      return _defineProperty({}, p, bindGlobe.linkMethod(p));
    })));

    // Expose config from renderObjs
    var bindRenderObjs = linkKapsule('renderObjs', threeRenderObjects);
    var linkedRenderObjsProps = Object.assign.apply(Object, _toConsumableArray(['width', 'height', 'backgroundColor', 'backgroundImageUrl', 'enablePointerInteraction'].map(function (p) {
      return _defineProperty({}, p, bindRenderObjs.linkProp(p));
    })));
    var linkedRenderObjsMethods = Object.assign.apply(Object, _toConsumableArray(['postProcessingComposer'].map(function (p) {
      return _defineProperty({}, p, bindRenderObjs.linkMethod(p));
    })));

    //

    var globe = index$2({
      props: _objectSpread2(_objectSpread2({
        onZoom: {
          triggerUpdate: false
        },
        onGlobeClick: {
          triggerUpdate: false
        },
        onGlobeRightClick: {
          triggerUpdate: false
        },
        pointLabel: {
          "default": 'name',
          triggerUpdate: false
        },
        onPointClick: {
          triggerUpdate: false
        },
        onPointRightClick: {
          triggerUpdate: false
        },
        onPointHover: {
          triggerUpdate: false
        },
        arcLabel: {
          "default": 'name',
          triggerUpdate: false
        },
        onArcClick: {
          triggerUpdate: false
        },
        onArcRightClick: {
          triggerUpdate: false
        },
        onArcHover: {
          triggerUpdate: false
        },
        polygonLabel: {
          "default": 'name',
          triggerUpdate: false
        },
        onPolygonClick: {
          triggerUpdate: false
        },
        onPolygonRightClick: {
          triggerUpdate: false
        },
        onPolygonHover: {
          triggerUpdate: false
        },
        pathLabel: {
          "default": 'name',
          triggerUpdate: false
        },
        onPathClick: {
          triggerUpdate: false
        },
        onPathRightClick: {
          triggerUpdate: false
        },
        onPathHover: {
          triggerUpdate: false
        },
        hexLabel: {
          triggerUpdate: false
        },
        onHexClick: {
          triggerUpdate: false
        },
        onHexRightClick: {
          triggerUpdate: false
        },
        onHexHover: {
          triggerUpdate: false
        },
        hexPolygonLabel: {
          triggerUpdate: false
        },
        onHexPolygonClick: {
          triggerUpdate: false
        },
        onHexPolygonRightClick: {
          triggerUpdate: false
        },
        onHexPolygonHover: {
          triggerUpdate: false
        },
        tileLabel: {
          "default": 'name',
          triggerUpdate: false
        },
        onTileClick: {
          triggerUpdate: false
        },
        onTileRightClick: {
          triggerUpdate: false
        },
        onTileHover: {
          triggerUpdate: false
        },
        labelLabel: {
          triggerUpdate: false
        },
        onLabelClick: {
          triggerUpdate: false
        },
        onLabelRightClick: {
          triggerUpdate: false
        },
        onLabelHover: {
          triggerUpdate: false
        },
        objectLabel: {
          "default": 'name',
          triggerUpdate: false
        },
        onObjectClick: {
          triggerUpdate: false
        },
        onObjectRightClick: {
          triggerUpdate: false
        },
        onObjectHover: {
          triggerUpdate: false
        },
        customLayerLabel: {
          "default": 'name',
          triggerUpdate: false
        },
        onCustomLayerClick: {
          triggerUpdate: false
        },
        onCustomLayerRightClick: {
          triggerUpdate: false
        },
        onCustomLayerHover: {
          triggerUpdate: false
        },
        pointerEventsFilter: {
          "default": function _default() {
            return true;
          },
          triggerUpdate: false,
          onChange: function onChange(filterFn, state) {
            return state.renderObjs.hoverFilter(function (obj) {
              return filterFn(obj, obj.__data);
            });
          }
        },
        lineHoverPrecision: {
          "default": 0.2,
          triggerUpdate: false,
          onChange: function onChange(val, state) {
            return state.renderObjs.lineHoverPrecision(val);
          }
        }
      }, linkedGlobeProps), linkedRenderObjsProps),
      methods: _objectSpread2(_objectSpread2({
        pauseAnimation: function pauseAnimation(state) {
          if (state.animationFrameRequestId !== null) {
            cancelAnimationFrame(state.animationFrameRequestId);
            state.animationFrameRequestId = null;
          }
          return this;
        },
        resumeAnimation: function resumeAnimation(state) {
          if (state.animationFrameRequestId === null) {
            this._animationCycle();
          }
          return this;
        },
        _animationCycle: function _animationCycle(state) {
          // Frame cycle
          state.renderObjs.tick();
          state.animationFrameRequestId = requestAnimationFrame(this._animationCycle);
        },
        pointOfView: function pointOfView(state) {
          var geoCoords = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
          var transitionDuration = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
          var curGeoCoords = getGeoCoords();

          // Getter
          if (geoCoords.lat === undefined && geoCoords.lng === undefined && geoCoords.altitude === undefined) {
            return curGeoCoords;
          } else {
            // Setter
            var finalGeoCoords = Object.assign({}, curGeoCoords, geoCoords);
            ['lat', 'lng', 'altitude'].forEach(function (p) {
              return finalGeoCoords[p] = +finalGeoCoords[p];
            }); // coerce coords to number

            if (!transitionDuration) {
              // no animation
              setCameraPos(finalGeoCoords);
            } else {
              // Avoid rotating more than 180deg longitude
              while (curGeoCoords.lng - finalGeoCoords.lng > 180) {
                curGeoCoords.lng -= 360;
              }
              while (curGeoCoords.lng - finalGeoCoords.lng < -180) {
                curGeoCoords.lng += 360;
              }
              new exports$1.Tween(curGeoCoords).to(finalGeoCoords, transitionDuration).easing(exports$1.Easing.Cubic.InOut).onUpdate(setCameraPos).start();
            }
            return this;
          }

          //

          function getGeoCoords() {
            return state.globe.toGeoCoords(state.renderObjs.cameraPosition());
          }
          function setCameraPos(_ref5) {
            var lat = _ref5.lat,
              lng = _ref5.lng,
              altitude = _ref5.altitude;
            state.renderObjs.cameraPosition(state.globe.getCoords(lat, lng, altitude));
          }
        },
        getScreenCoords: function getScreenCoords(state) {
          var _state$globe;
          for (var _len = arguments.length, geoCoords = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            geoCoords[_key - 1] = arguments[_key];
          }
          var cartesianCoords = (_state$globe = state.globe).getCoords.apply(_state$globe, geoCoords);
          return state.renderObjs.getScreenCoords(cartesianCoords.x, cartesianCoords.y, cartesianCoords.z);
        },
        toGlobeCoords: function toGlobeCoords(state, x, y) {
          var globeIntersects = state.renderObjs.intersectingObjects(x, y).find(function (d) {
            return d.object.__globeObjType === 'globe';
          });
          if (!globeIntersects) return null; // coords outside globe

          var _state$globe$toGeoCoo = state.globe.toGeoCoords(globeIntersects.point),
            lat = _state$globe$toGeoCoo.lat,
            lng = _state$globe$toGeoCoo.lng;
          return {
            lat: lat,
            lng: lng
          };
        },
        scene: function scene(state) {
          return state.renderObjs.scene();
        },
        // Expose scene
        camera: function camera(state) {
          return state.renderObjs.camera();
        },
        // Expose camera
        renderer: function renderer(state) {
          return state.renderObjs.renderer();
        },
        // Expose renderer
        controls: function controls(state) {
          return state.renderObjs.controls();
        },
        // Expose controls
        _destructor: function _destructor() {
          this.pauseAnimation();
          this.pointsData([]);
          this.arcsData([]);
          this.polygonsData([]);
          this.pathsData([]);
          this.hexBinPointsData([]);
          this.hexPolygonsData([]);
          this.tilesData([]);
          this.labelsData([]);
          this.htmlElementsData([]);
          this.objectsData([]);
          this.customLayerData([]);
        }
      }, linkedGlobeMethods), linkedRenderObjsMethods),
      stateInit: function stateInit(_ref6) {
        var rendererConfig = _ref6.rendererConfig,
          _ref6$waitForGlobeRea = _ref6.waitForGlobeReady,
          waitForGlobeReady = _ref6$waitForGlobeRea === void 0 ? true : _ref6$waitForGlobeRea,
          globeInitConfig = _objectWithoutProperties(_ref6, _excluded);
        var globe = new threeGlobe(_objectSpread2({
          waitForGlobeReady: waitForGlobeReady
        }, globeInitConfig));
        return {
          globe: globe,
          renderObjs: threeRenderObjects({
            controlType: 'orbit',
            rendererConfig: rendererConfig,
            waitForLoadComplete: waitForGlobeReady,
            extraRenderers: [new THREE.CSS2DRenderer()] // Used in HTML elements layer
          }).skyRadius(globe.getGlobeRadius() * 500).showNavInfo(false)
        };
      },
      init: function init(domNode, state) {
        var _this = this;
        // Wipe DOM
        domNode.innerHTML = '';

        // Add relative container
        domNode.appendChild(state.container = document.createElement('div'));
        state.container.style.position = 'relative';

        // Add renderObjs
        var roDomNode = document.createElement('div');
        state.container.appendChild(roDomNode);
        state.renderObjs(roDomNode);

        // inject renderer size on three-globe
        state.globe.rendererSize(state.renderObjs.renderer().getSize(new THREE.Vector2()));

        // set initial distance
        this.pointOfView({
          altitude: 2.5
        });

        // calibrate orbit controls
        var globeR = state.globe.getGlobeRadius();
        var controls = state.renderObjs.controls();
        controls.minDistance = globeR * 1.01; // just above the surface
        controls.maxDistance = globeR * 100;
        controls.enablePan = false;
        controls.enableDamping = true;
        controls.dampingFactor = 0.1;
        controls.rotateSpeed = 0.3;
        controls.zoomSpeed = 0.3;
        controls.addEventListener('change', function () {
          // adjust controls speed based on altitude
          var pov = _this.pointOfView();
          controls.rotateSpeed = pov.altitude * 0.2; // Math.pow(pov.altitude + 1, 2) * 0.025;
          controls.zoomSpeed = (pov.altitude + 1) * 0.1; // Math.sqrt(pov.altitude) * 0.2;

          // Update three-globe pov when camera moves, for proper hiding of elements
          state.globe.setPointOfView(state.renderObjs.camera().position);
          state.onZoom && state.onZoom(pov);
        });

        // config renderObjs
        var getGlobeObj = function getGlobeObj(object) {
          var obj = object;
          // recurse up object chain until finding the globe object
          while (obj && !obj.hasOwnProperty('__globeObjType')) {
            obj = obj.parent;
          }
          return obj;
        };
        var dataAccessors = {
          point: function point(d) {
            return d;
          },
          arc: function arc(d) {
            return d;
          },
          polygon: function polygon(d) {
            return d.data;
          },
          path: function path(d) {
            return d;
          },
          hexbin: function hexbin(d) {
            return d;
          },
          hexPolygon: function hexPolygon(d) {
            return d;
          },
          tile: function tile(d) {
            return d;
          },
          label: function label(d) {
            return d;
          },
          object: function object(d) {
            return d;
          },
          custom: function custom(d) {
            return d;
          }
        };
        state.renderObjs.objects([
        // Populate scene
        new THREE.AmbientLight(0xbbbbbb), new THREE.DirectionalLight(0xffffff, 0.6), state.globe]).hoverOrderComparator(function (a, b) {
          var aObj = getGlobeObj(a);
          var bObj = getGlobeObj(b);

          // de-prioritize background / non-globe objects
          var isBackground = function isBackground(o) {
            return !o;
          }; // || o.__globeObjType === 'globe' || o.__globeObjType === 'atmosphere';
          return isBackground(aObj) - isBackground(bObj);
        }).tooltipContent(function (obj) {
          var objAccessors = {
            point: state.pointLabel,
            arc: state.arcLabel,
            polygon: state.polygonLabel,
            path: state.pathLabel,
            hexbin: state.hexLabel,
            hexPolygon: state.hexPolygonLabel,
            tile: state.tileLabel,
            label: state.labelLabel,
            object: state.objectLabel,
            custom: state.customLayerLabel
          };
          var globeObj = getGlobeObj(obj);
          var objType = globeObj && globeObj.__globeObjType;
          return globeObj && objType && objAccessors.hasOwnProperty(objType) && dataAccessors.hasOwnProperty(objType) ? index$1(objAccessors[objType])(dataAccessors[objType](globeObj.__data)) || '' : '';
        }).onHover(function (obj) {
          // Update tooltip and trigger onHover events
          var hoverObjFns = {
            point: state.onPointHover,
            arc: state.onArcHover,
            polygon: state.onPolygonHover,
            path: state.onPathHover,
            hexbin: state.onHexHover,
            hexPolygon: state.onHexPolygonHover,
            tile: state.onTileHover,
            label: state.onLabelHover,
            object: state.onObjectHover,
            custom: state.onCustomLayerHover
          };
          var clickObjFns = {
            globe: state.onGlobeClick,
            point: state.onPointClick,
            arc: state.onArcClick,
            polygon: state.onPolygonClick,
            path: state.onPathClick,
            hexbin: state.onHexClick,
            hexPolygon: state.onHexPolygonClick,
            tile: state.onTileClick,
            label: state.onLabelClick,
            object: state.onObjectClick,
            custom: state.onCustomLayerClick
          };
          var hoverObj = getGlobeObj(obj);

          // ignore non-recognised obj types
          hoverObj && !hoverObjFns.hasOwnProperty(hoverObj.__globeObjType) && (hoverObj = null);
          if (hoverObj !== state.hoverObj) {
            var prevObjType = state.hoverObj ? state.hoverObj.__globeObjType : null;
            var prevObjData = state.hoverObj ? dataAccessors[prevObjType](state.hoverObj.__data) : null;
            var objType = hoverObj ? hoverObj.__globeObjType : null;
            var objData = hoverObj ? dataAccessors[objType](hoverObj.__data) : null;
            if (prevObjType && prevObjType !== objType) {
              // Hover out
              hoverObjFns[prevObjType] && hoverObjFns[prevObjType](null, prevObjData);
            }
            if (objType) {
              // Hover in
              hoverObjFns[objType] && hoverObjFns[objType](objData, prevObjType === objType ? prevObjData : null);
            }

            // set pointer if hovered object is clickable
            state.renderObjs.renderer().domElement.classList[objType && clickObjFns[objType] ? 'add' : 'remove']('clickable');
            state.hoverObj = hoverObj;
          }
        }).onClick(function (obj, ev, point) {
          if (!obj) return; // ignore background clicks

          // Handle click events on objects
          var objFns = {
            globe: state.onGlobeClick,
            point: state.onPointClick,
            arc: state.onArcClick,
            polygon: state.onPolygonClick,
            path: state.onPathClick,
            hexbin: state.onHexClick,
            hexPolygon: state.onHexPolygonClick,
            tile: state.onTileClick,
            label: state.onLabelClick,
            object: state.onObjectClick,
            custom: state.onCustomLayerClick
          };
          var globeObj = getGlobeObj(obj);
          var objType = globeObj.__globeObjType;
          if (globeObj && objFns.hasOwnProperty(objType) && objFns[objType]) {
            var args = [ev];

            // include click coords
            if (objType === 'globe') {
              var _this$toGeoCoords = _this.toGeoCoords(point),
                lat = _this$toGeoCoords.lat,
                lng = _this$toGeoCoords.lng;
              args.unshift({
                lat: lat,
                lng: lng
              });
            } else {
              args.push(_this.toGeoCoords(point));
            }
            dataAccessors.hasOwnProperty(objType) && args.unshift(dataAccessors[objType](globeObj.__data));
            objFns[objType].apply(objFns, args);
          }
        }).onRightClick(function (obj, ev, point) {
          if (!obj) return; // ignore background clicks

          // Handle right-click events
          var objFns = {
            globe: state.onGlobeRightClick,
            point: state.onPointRightClick,
            arc: state.onArcRightClick,
            polygon: state.onPolygonRightClick,
            path: state.onPathRightClick,
            hexbin: state.onHexRightClick,
            hexPolygon: state.onHexPolygonRightClick,
            tile: state.onTileRightClick,
            label: state.onLabelRightClick,
            object: state.onObjectRightClick,
            custom: state.onCustomLayerRightClick
          };
          var globeObj = getGlobeObj(obj);
          var objType = globeObj.__globeObjType;
          if (globeObj && objFns.hasOwnProperty(objType) && objFns[objType]) {
            var args = [ev];

            // include click coords
            if (objType === 'globe') {
              var _this$toGeoCoords2 = _this.toGeoCoords(point),
                lat = _this$toGeoCoords2.lat,
                lng = _this$toGeoCoords2.lng;
              args.unshift({
                lat: lat,
                lng: lng
              });
            } else {
              args.push(_this.toGeoCoords(point));
            }
            dataAccessors.hasOwnProperty(objType) && args.unshift(dataAccessors[objType](globeObj.__data));
            objFns[objType].apply(objFns, args);
          }
        });

        //

        // Kick-off renderer
        this._animationCycle();
      }
    });

    /* src/lib/globe/Globe.svelte generated by Svelte v3.53.1 */

    const { console: console_1 } = globals;
    const file$l = "src/lib/globe/Globe.svelte";

    // (85:4) {:else}
    function create_else_block$7(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			attr_dev(div, "id", "cards-globe");
    			attr_dev(div, "class", "svelte-nak7pz");
    			add_location(div, file$l, 85, 8, 2844);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$7.name,
    		type: "else",
    		source: "(85:4) {:else}",
    		ctx
    	});

    	return block;
    }

    // (83:4) {#if targetNode=='intro-globe'}
    function create_if_block$9(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			attr_dev(div, "id", "intro-globe");
    			attr_dev(div, "class", "svelte-nak7pz");
    			add_location(div, file$l, 83, 8, 2795);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$9.name,
    		type: "if",
    		source: "(83:4) {#if targetNode=='intro-globe'}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$l(ctx) {
    	let div;

    	function select_block_type(ctx, dirty) {
    		if (/*targetNode*/ ctx[0] == 'intro-globe') return create_if_block$9;
    		return create_else_block$7;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if_block.c();
    			add_location(div, file$l, 81, 0, 2745);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if_block.m(div, null);
    		},
    		p: function update(ctx, [dirty]) {
    			if (current_block_type !== (current_block_type = select_block_type(ctx))) {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(div, null);
    				}
    			}
    		},
    		i: noop$2,
    		o: noop$2,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$l.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$l($$self, $$props, $$invalidate) {
    	let $data;
    	let $activePage;
    	validate_store(data, 'data');
    	component_subscribe($$self, data, $$value => $$invalidate(1, $data = $$value));
    	validate_store(activePage, 'activePage');
    	component_subscribe($$self, activePage, $$value => $$invalidate(2, $activePage = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Globe', slots, []);
    	let { targetNode } = $$props;

    	function init(data, targetNode) {
    		/* const newElement = document.createElement("div");
    newElement.setAttribute('id', targetNode);
    const elem = document.getElementById(targetNode); */
    		console.log("drawing globe with", data.length, "features");

    		// elements
    		const elem = document.getElementById(targetNode);

    		document.querySelector(".title-section");
    		const textureImg = 'assets/venus-texture.png';

    		// globe settings
    		//const width = globeWrapper == null ? 275 : globeWrapper.offsetWidth * 0.7;
    		const width = $activePage == "intro" ? 275 : 315;

    		const myGlobe = globe({ animateIn: false });
    		let world;

    		if (targetNode == 'intro-globe') {
    			world = myGlobe(elem).width(width).height(width).backgroundColor("#03030300").globeImageUrl(textureImg).atmosphereColor(0x2d150400).atmosphereAltitude(0);
    		} else {
    			world = myGlobe(elem).width(width).height(width).backgroundColor("#03030300").globeImageUrl(textureImg).atmosphereColor(0x2d150400).atmosphereAltitude(0).//points info
    			pointsData(data).pointLat('center_lat').pointLng('center_long').pointAltitude(0.1).pointRadius(0).pointColor(d => {
    				return getThemeColor(d.type, 100, false); // initial value
    			});

    			// update store with the cards globe
    			globe$1.set(world);
    		}

    		// settings
    		world.controls().autoRotate = true;

    		world.controls().autoRotateSpeed = 0.4;
    		myGlobe.globeMaterial().shininess = 0;
    	} /* 
    // Add a displacement map - not needed since globe is so small
    const displacementImg = 'assets/height.jpg'
    new TextureLoader().load(displacementImg, texture => {
        const globeMaterial = myGlobe.globeMaterial()
        globeMaterial.displacementMap = texture;
        globeMaterial.displacementScale = 25;
        globeMaterial.shininess = 0;
    }) 
    */

    	onMount(async () => {
    		init($data, targetNode);
    	});

    	$$self.$$.on_mount.push(function () {
    		if (targetNode === undefined && !('targetNode' in $$props || $$self.$$.bound[$$self.$$.props['targetNode']])) {
    			console_1.warn("<Globe> was created without expected prop 'targetNode'");
    		}
    	});

    	const writable_props = ['targetNode'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1.warn(`<Globe> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('targetNode' in $$props) $$invalidate(0, targetNode = $$props.targetNode);
    	};

    	$$self.$capture_state = () => ({
    		Globe: globe,
    		data,
    		globe: globe$1,
    		activePage,
    		getThemeColor,
    		onMount,
    		targetNode,
    		init,
    		$data,
    		$activePage
    	});

    	$$self.$inject_state = $$props => {
    		if ('targetNode' in $$props) $$invalidate(0, targetNode = $$props.targetNode);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [targetNode];
    }

    class Globe_1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$l, create_fragment$l, safe_not_equal, { targetNode: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Globe_1",
    			options,
    			id: create_fragment$l.name
    		});
    	}

    	get targetNode() {
    		throw new Error("<Globe>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set targetNode(value) {
    		throw new Error("<Globe>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var featureData = [
    	{
    		feature: "crater",
    		feature_plural: "craters",
    		definition: "A circular depression created by an impact event. On Venus, craters under 20km in diameter are named after common female first names.",
    		diameter: "Under 20km",
    		naming_convention: "Common female first names",
    		type: "Common female first names"
    	},
    	{
    		feature: "patera",
    		feature_plural: "paterae",
    		definition: "An irregular crater, usually referring to the dish-shaped depression atop a volcano. On Venus, paterae are named after famous women.",
    		diameter: "",
    		naming_convention: "Famous women",
    		type: "Famous women"
    	},
    	{
    		feature: "crater",
    		feature_plural: "craters",
    		definition: "A circular depression created by an impact event. On Venus, craters 20km or wider in diameter are named after famous women.",
    		diameter: "20km or over",
    		naming_convention: "Famous women",
    		type: "Famous women"
    	},
    	{
    		feature: "regio",
    		feature_plural: "regiones",
    		definition: "A large area that is strongly differentiated in color or brightness from its surroundings. On Venus, regiones are named after giantesses and titanesses (and two after Greek letters of the alphabet).",
    		diameter: "",
    		naming_convention: "Giantesses and Titanesses (and two after Greek letters of the alphabet)",
    		type: "Female giants and titans"
    	},
    	{
    		feature: "vallis",
    		feature_plural: "valles",
    		definition: "A valley. On Venus, valles under 400km in length are named after river goddesses.",
    		diameter: "Under 400km",
    		naming_convention: "River goddesses",
    		type: "Goddesses"
    	},
    	{
    		feature: "chasma",
    		feature_plural: "chasmata",
    		definition: "A deep, elongated, steep-sided depression. On Venus, chasmata are named after goddesses of the hunt or moon.",
    		diameter: "",
    		naming_convention: "Goddesses of the hunt or moon",
    		type: "Goddesses"
    	},
    	{
    		feature: "colles",
    		feature_plural: "colles",
    		definition: "A collection of small hills or knobs. On Venus, colles are named after sea goddesses.",
    		diameter: "",
    		naming_convention: "Sea goddesses",
    		type: "Goddesses"
    	},
    	{
    		feature: "dorsum",
    		feature_plural: "dorsa",
    		definition: "A ridge, sometimes called a wrinkle ridge. On Venus, dorsa are named after sky goddesses.",
    		diameter: "",
    		naming_convention: "Sky goddesses",
    		type: "Goddesses"
    	},
    	{
    		feature: "fluctus",
    		feature_plural: "fluctūs",
    		definition: "Terrain covered by outflow of liquid, like lava. On Venus, fluctūs are named after miscellaneous goddesses.",
    		diameter: "",
    		naming_convention: "Miscellaneous goddesses",
    		type: "Goddesses"
    	},
    	{
    		feature: "fossa",
    		feature_plural: "fossae",
    		definition: "A long, narrow, shallow depression. On Venus, fossae are named after goddesses of war.",
    		diameter: "",
    		naming_convention: "Goddesses of war",
    		type: "Goddesses"
    	},
    	{
    		feature: "labyrinthus",
    		feature_plural: "labyrinthi",
    		definition: "A complex of intersecting valleys or ridges. On Venus, labyrinthi are named after miscellaneous goddesses.",
    		diameter: "",
    		naming_convention: "Miscellaneous goddesses",
    		type: "Goddesses"
    	},
    	{
    		feature: "mons",
    		feature_plural: "montes",
    		definition: "A mountain; plural montes. On Venus, montes are named after miscellaneous goddesses, and one radar scientist.",
    		diameter: "",
    		naming_convention: "Miscellaneous goddesses, and one radar scientist",
    		type: "Goddesses"
    	},
    	{
    		feature: "planum",
    		feature_plural: "plana",
    		definition: "A plateau or high plain. On Venus, plana are named after goddesses of prosperity.",
    		diameter: "",
    		naming_convention: "Goddesses of prosperity",
    		type: "Goddesses"
    	},
    	{
    		feature: "rupes",
    		feature_plural: "rupēs",
    		definition: "A very steep bank or slope; i.e. a scarp. On Venus, rupēs are named after goddesses of the hearth and home.",
    		diameter: "",
    		naming_convention: "Goddesses of the hearth and home",
    		type: "Goddesses"
    	},
    	{
    		feature: "terra",
    		feature_plural: "terrae",
    		definition: "An extensive land mass or region that contains other surface features. On Venus, terrae are named after goddesses of love.",
    		diameter: "",
    		naming_convention: "Goddesses of love",
    		type: "Goddesses"
    	},
    	{
    		feature: "tholus",
    		feature_plural: "tholi",
    		definition: "A small domical mountain or hill. On Venus, tholi are named after miscellaneous goddesses.",
    		diameter: "",
    		naming_convention: "Miscellaneous goddesses",
    		type: "Goddesses"
    	},
    	{
    		feature: "unda",
    		feature_plural: "undae",
    		definition: "A field of dunes. On Venus, undae are named after desert goddesses.",
    		diameter: "",
    		naming_convention: "Desert goddesses",
    		type: "Goddesses"
    	},
    	{
    		feature: "corona",
    		feature_plural: "coronae",
    		definition: "An oval-shaped feature. On Venus, coronae are named after fertility and earth goddesses.",
    		diameter: "",
    		naming_convention: "Fertility and earth goddesses",
    		type: "Goddesses"
    	},
    	{
    		feature: "farrum",
    		feature_plural: "farra",
    		definition: "A pancake-like structure, or a row of such structures. On Venus, farra are named after water goddesses.",
    		diameter: "",
    		naming_convention: "Water goddesses",
    		type: "Goddesses"
    	},
    	{
    		feature: "linea",
    		feature_plural: "lineae",
    		definition: "A general term for any long marking, dark or bright, on a planet's surface. On Venus, lineae are named after goddesses of war.",
    		diameter: "",
    		naming_convention: "Goddesses of war",
    		type: "Goddesses"
    	},
    	{
    		feature: "tessera",
    		feature_plural: "tesserae",
    		definition: "An area of tile-like, polygonal terrain. Often represents the oldest material at any given location. On Venus, tesserae are named after goddesses of fate and fortune.",
    		diameter: "",
    		naming_convention: "Goddesses of fate and fortune",
    		type: "Goddesses"
    	},
    	{
    		feature: "planitia",
    		feature_plural: "planitiae",
    		definition: "A low plain. On Venus, planitiae are named after mythological heroines.",
    		diameter: "",
    		naming_convention: "Mythological heroines",
    		type: "Heroines"
    	},
    	{
    		feature: "vallis",
    		feature_plural: "valles",
    		definition: "A valley. On Venus, valles 400km or longer in length are named after the word for Venus in various world languages.",
    		diameter: "400km or over",
    		naming_convention: "The word for Venus in various world languages",
    		type: "Words for Venus"
    	}
    ];

    var top = 'top';
    var bottom = 'bottom';
    var right = 'right';
    var left = 'left';
    var auto = 'auto';
    var basePlacements = [top, bottom, right, left];
    var start = 'start';
    var end = 'end';
    var clippingParents = 'clippingParents';
    var viewport = 'viewport';
    var popper = 'popper';
    var reference = 'reference';
    var variationPlacements = /*#__PURE__*/basePlacements.reduce(function (acc, placement) {
      return acc.concat([placement + "-" + start, placement + "-" + end]);
    }, []);
    var placements = /*#__PURE__*/[].concat(basePlacements, [auto]).reduce(function (acc, placement) {
      return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
    }, []); // modifiers that need to read the DOM

    var beforeRead = 'beforeRead';
    var read = 'read';
    var afterRead = 'afterRead'; // pure-logic modifiers

    var beforeMain = 'beforeMain';
    var main = 'main';
    var afterMain = 'afterMain'; // modifier with the purpose to write to the DOM (or write into a framework state)

    var beforeWrite = 'beforeWrite';
    var write = 'write';
    var afterWrite = 'afterWrite';
    var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];

    function getNodeName(element) {
      return element ? (element.nodeName || '').toLowerCase() : null;
    }

    function getWindow(node) {
      if (node == null) {
        return window;
      }

      if (node.toString() !== '[object Window]') {
        var ownerDocument = node.ownerDocument;
        return ownerDocument ? ownerDocument.defaultView || window : window;
      }

      return node;
    }

    function isElement$1(node) {
      var OwnElement = getWindow(node).Element;
      return node instanceof OwnElement || node instanceof Element;
    }

    function isHTMLElement$1(node) {
      var OwnElement = getWindow(node).HTMLElement;
      return node instanceof OwnElement || node instanceof HTMLElement;
    }

    function isShadowRoot(node) {
      // IE 11 has no ShadowRoot
      if (typeof ShadowRoot === 'undefined') {
        return false;
      }

      var OwnElement = getWindow(node).ShadowRoot;
      return node instanceof OwnElement || node instanceof ShadowRoot;
    }

    // and applies them to the HTMLElements such as popper and arrow

    function applyStyles(_ref) {
      var state = _ref.state;
      Object.keys(state.elements).forEach(function (name) {
        var style = state.styles[name] || {};
        var attributes = state.attributes[name] || {};
        var element = state.elements[name]; // arrow is optional + virtual elements

        if (!isHTMLElement$1(element) || !getNodeName(element)) {
          return;
        } // Flow doesn't support to extend this property, but it's the most
        // effective way to apply styles to an HTMLElement
        // $FlowFixMe[cannot-write]


        Object.assign(element.style, style);
        Object.keys(attributes).forEach(function (name) {
          var value = attributes[name];

          if (value === false) {
            element.removeAttribute(name);
          } else {
            element.setAttribute(name, value === true ? '' : value);
          }
        });
      });
    }

    function effect$2(_ref2) {
      var state = _ref2.state;
      var initialStyles = {
        popper: {
          position: state.options.strategy,
          left: '0',
          top: '0',
          margin: '0'
        },
        arrow: {
          position: 'absolute'
        },
        reference: {}
      };
      Object.assign(state.elements.popper.style, initialStyles.popper);
      state.styles = initialStyles;

      if (state.elements.arrow) {
        Object.assign(state.elements.arrow.style, initialStyles.arrow);
      }

      return function () {
        Object.keys(state.elements).forEach(function (name) {
          var element = state.elements[name];
          var attributes = state.attributes[name] || {};
          var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]); // Set all values to an empty string to unset them

          var style = styleProperties.reduce(function (style, property) {
            style[property] = '';
            return style;
          }, {}); // arrow is optional + virtual elements

          if (!isHTMLElement$1(element) || !getNodeName(element)) {
            return;
          }

          Object.assign(element.style, style);
          Object.keys(attributes).forEach(function (attribute) {
            element.removeAttribute(attribute);
          });
        });
      };
    } // eslint-disable-next-line import/no-unused-modules


    var applyStyles$1 = {
      name: 'applyStyles',
      enabled: true,
      phase: 'write',
      fn: applyStyles,
      effect: effect$2,
      requires: ['computeStyles']
    };

    function getBasePlacement$1(placement) {
      return placement.split('-')[0];
    }

    var max$1 = Math.max;
    var min$1 = Math.min;
    var round = Math.round;

    function getUAString() {
      var uaData = navigator.userAgentData;

      if (uaData != null && uaData.brands) {
        return uaData.brands.map(function (item) {
          return item.brand + "/" + item.version;
        }).join(' ');
      }

      return navigator.userAgent;
    }

    function isLayoutViewport() {
      return !/^((?!chrome|android).)*safari/i.test(getUAString());
    }

    function getBoundingClientRect(element, includeScale, isFixedStrategy) {
      if (includeScale === void 0) {
        includeScale = false;
      }

      if (isFixedStrategy === void 0) {
        isFixedStrategy = false;
      }

      var clientRect = element.getBoundingClientRect();
      var scaleX = 1;
      var scaleY = 1;

      if (includeScale && isHTMLElement$1(element)) {
        scaleX = element.offsetWidth > 0 ? round(clientRect.width) / element.offsetWidth || 1 : 1;
        scaleY = element.offsetHeight > 0 ? round(clientRect.height) / element.offsetHeight || 1 : 1;
      }

      var _ref = isElement$1(element) ? getWindow(element) : window,
          visualViewport = _ref.visualViewport;

      var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
      var x = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
      var y = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
      var width = clientRect.width / scaleX;
      var height = clientRect.height / scaleY;
      return {
        width: width,
        height: height,
        top: y,
        right: x + width,
        bottom: y + height,
        left: x,
        x: x,
        y: y
      };
    }

    // means it doesn't take into account transforms.

    function getLayoutRect(element) {
      var clientRect = getBoundingClientRect(element); // Use the clientRect sizes if it's not been transformed.
      // Fixes https://github.com/popperjs/popper-core/issues/1223

      var width = element.offsetWidth;
      var height = element.offsetHeight;

      if (Math.abs(clientRect.width - width) <= 1) {
        width = clientRect.width;
      }

      if (Math.abs(clientRect.height - height) <= 1) {
        height = clientRect.height;
      }

      return {
        x: element.offsetLeft,
        y: element.offsetTop,
        width: width,
        height: height
      };
    }

    function contains(parent, child) {
      var rootNode = child.getRootNode && child.getRootNode(); // First, attempt with faster native method

      if (parent.contains(child)) {
        return true;
      } // then fallback to custom implementation with Shadow DOM support
      else if (rootNode && isShadowRoot(rootNode)) {
          var next = child;

          do {
            if (next && parent.isSameNode(next)) {
              return true;
            } // $FlowFixMe[prop-missing]: need a better way to handle this...


            next = next.parentNode || next.host;
          } while (next);
        } // Give up, the result is false


      return false;
    }

    function getComputedStyle$1(element) {
      return getWindow(element).getComputedStyle(element);
    }

    function isTableElement(element) {
      return ['table', 'td', 'th'].indexOf(getNodeName(element)) >= 0;
    }

    function getDocumentElement(element) {
      // $FlowFixMe[incompatible-return]: assume body is always available
      return ((isElement$1(element) ? element.ownerDocument : // $FlowFixMe[prop-missing]
      element.document) || window.document).documentElement;
    }

    function getParentNode(element) {
      if (getNodeName(element) === 'html') {
        return element;
      }

      return (// this is a quicker (but less type safe) way to save quite some bytes from the bundle
        // $FlowFixMe[incompatible-return]
        // $FlowFixMe[prop-missing]
        element.assignedSlot || // step into the shadow DOM of the parent of a slotted node
        element.parentNode || ( // DOM Element detected
        isShadowRoot(element) ? element.host : null) || // ShadowRoot detected
        // $FlowFixMe[incompatible-call]: HTMLElement is a Node
        getDocumentElement(element) // fallback

      );
    }

    function getTrueOffsetParent(element) {
      if (!isHTMLElement$1(element) || // https://github.com/popperjs/popper-core/issues/837
      getComputedStyle$1(element).position === 'fixed') {
        return null;
      }

      return element.offsetParent;
    } // `.offsetParent` reports `null` for fixed elements, while absolute elements
    // return the containing block


    function getContainingBlock(element) {
      var isFirefox = /firefox/i.test(getUAString());
      var isIE = /Trident/i.test(getUAString());

      if (isIE && isHTMLElement$1(element)) {
        // In IE 9, 10 and 11 fixed elements containing block is always established by the viewport
        var elementCss = getComputedStyle$1(element);

        if (elementCss.position === 'fixed') {
          return null;
        }
      }

      var currentNode = getParentNode(element);

      if (isShadowRoot(currentNode)) {
        currentNode = currentNode.host;
      }

      while (isHTMLElement$1(currentNode) && ['html', 'body'].indexOf(getNodeName(currentNode)) < 0) {
        var css = getComputedStyle$1(currentNode); // This is non-exhaustive but covers the most common CSS properties that
        // create a containing block.
        // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block

        if (css.transform !== 'none' || css.perspective !== 'none' || css.contain === 'paint' || ['transform', 'perspective'].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === 'filter' || isFirefox && css.filter && css.filter !== 'none') {
          return currentNode;
        } else {
          currentNode = currentNode.parentNode;
        }
      }

      return null;
    } // Gets the closest ancestor positioned element. Handles some edge cases,
    // such as table ancestors and cross browser bugs.


    function getOffsetParent(element) {
      var window = getWindow(element);
      var offsetParent = getTrueOffsetParent(element);

      while (offsetParent && isTableElement(offsetParent) && getComputedStyle$1(offsetParent).position === 'static') {
        offsetParent = getTrueOffsetParent(offsetParent);
      }

      if (offsetParent && (getNodeName(offsetParent) === 'html' || getNodeName(offsetParent) === 'body' && getComputedStyle$1(offsetParent).position === 'static')) {
        return window;
      }

      return offsetParent || getContainingBlock(element) || window;
    }

    function getMainAxisFromPlacement(placement) {
      return ['top', 'bottom'].indexOf(placement) >= 0 ? 'x' : 'y';
    }

    function within(min, value, max) {
      return max$1(min, min$1(value, max));
    }
    function withinMaxClamp(min, value, max) {
      var v = within(min, value, max);
      return v > max ? max : v;
    }

    function getFreshSideObject() {
      return {
        top: 0,
        right: 0,
        bottom: 0,
        left: 0
      };
    }

    function mergePaddingObject(paddingObject) {
      return Object.assign({}, getFreshSideObject(), paddingObject);
    }

    function expandToHashMap(value, keys) {
      return keys.reduce(function (hashMap, key) {
        hashMap[key] = value;
        return hashMap;
      }, {});
    }

    var toPaddingObject = function toPaddingObject(padding, state) {
      padding = typeof padding === 'function' ? padding(Object.assign({}, state.rects, {
        placement: state.placement
      })) : padding;
      return mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));
    };

    function arrow(_ref) {
      var _state$modifiersData$;

      var state = _ref.state,
          name = _ref.name,
          options = _ref.options;
      var arrowElement = state.elements.arrow;
      var popperOffsets = state.modifiersData.popperOffsets;
      var basePlacement = getBasePlacement$1(state.placement);
      var axis = getMainAxisFromPlacement(basePlacement);
      var isVertical = [left, right].indexOf(basePlacement) >= 0;
      var len = isVertical ? 'height' : 'width';

      if (!arrowElement || !popperOffsets) {
        return;
      }

      var paddingObject = toPaddingObject(options.padding, state);
      var arrowRect = getLayoutRect(arrowElement);
      var minProp = axis === 'y' ? top : left;
      var maxProp = axis === 'y' ? bottom : right;
      var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets[axis] - state.rects.popper[len];
      var startDiff = popperOffsets[axis] - state.rects.reference[axis];
      var arrowOffsetParent = getOffsetParent(arrowElement);
      var clientSize = arrowOffsetParent ? axis === 'y' ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
      var centerToReference = endDiff / 2 - startDiff / 2; // Make sure the arrow doesn't overflow the popper if the center point is
      // outside of the popper bounds

      var min = paddingObject[minProp];
      var max = clientSize - arrowRect[len] - paddingObject[maxProp];
      var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
      var offset = within(min, center, max); // Prevents breaking syntax highlighting...

      var axisProp = axis;
      state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset, _state$modifiersData$.centerOffset = offset - center, _state$modifiersData$);
    }

    function effect$1(_ref2) {
      var state = _ref2.state,
          options = _ref2.options;
      var _options$element = options.element,
          arrowElement = _options$element === void 0 ? '[data-popper-arrow]' : _options$element;

      if (arrowElement == null) {
        return;
      } // CSS selector


      if (typeof arrowElement === 'string') {
        arrowElement = state.elements.popper.querySelector(arrowElement);

        if (!arrowElement) {
          return;
        }
      }

      if (!contains(state.elements.popper, arrowElement)) {

        return;
      }

      state.elements.arrow = arrowElement;
    } // eslint-disable-next-line import/no-unused-modules


    var arrow$1 = {
      name: 'arrow',
      enabled: true,
      phase: 'main',
      fn: arrow,
      effect: effect$1,
      requires: ['popperOffsets'],
      requiresIfExists: ['preventOverflow']
    };

    function getVariation(placement) {
      return placement.split('-')[1];
    }

    var unsetSides = {
      top: 'auto',
      right: 'auto',
      bottom: 'auto',
      left: 'auto'
    }; // Round the offsets to the nearest suitable subpixel based on the DPR.
    // Zooming can change the DPR, but it seems to report a value that will
    // cleanly divide the values into the appropriate subpixels.

    function roundOffsetsByDPR(_ref) {
      var x = _ref.x,
          y = _ref.y;
      var win = window;
      var dpr = win.devicePixelRatio || 1;
      return {
        x: round(x * dpr) / dpr || 0,
        y: round(y * dpr) / dpr || 0
      };
    }

    function mapToStyles(_ref2) {
      var _Object$assign2;

      var popper = _ref2.popper,
          popperRect = _ref2.popperRect,
          placement = _ref2.placement,
          variation = _ref2.variation,
          offsets = _ref2.offsets,
          position = _ref2.position,
          gpuAcceleration = _ref2.gpuAcceleration,
          adaptive = _ref2.adaptive,
          roundOffsets = _ref2.roundOffsets,
          isFixed = _ref2.isFixed;
      var _offsets$x = offsets.x,
          x = _offsets$x === void 0 ? 0 : _offsets$x,
          _offsets$y = offsets.y,
          y = _offsets$y === void 0 ? 0 : _offsets$y;

      var _ref3 = typeof roundOffsets === 'function' ? roundOffsets({
        x: x,
        y: y
      }) : {
        x: x,
        y: y
      };

      x = _ref3.x;
      y = _ref3.y;
      var hasX = offsets.hasOwnProperty('x');
      var hasY = offsets.hasOwnProperty('y');
      var sideX = left;
      var sideY = top;
      var win = window;

      if (adaptive) {
        var offsetParent = getOffsetParent(popper);
        var heightProp = 'clientHeight';
        var widthProp = 'clientWidth';

        if (offsetParent === getWindow(popper)) {
          offsetParent = getDocumentElement(popper);

          if (getComputedStyle$1(offsetParent).position !== 'static' && position === 'absolute') {
            heightProp = 'scrollHeight';
            widthProp = 'scrollWidth';
          }
        } // $FlowFixMe[incompatible-cast]: force type refinement, we compare offsetParent with window above, but Flow doesn't detect it


        offsetParent = offsetParent;

        if (placement === top || (placement === left || placement === right) && variation === end) {
          sideY = bottom;
          var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : // $FlowFixMe[prop-missing]
          offsetParent[heightProp];
          y -= offsetY - popperRect.height;
          y *= gpuAcceleration ? 1 : -1;
        }

        if (placement === left || (placement === top || placement === bottom) && variation === end) {
          sideX = right;
          var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : // $FlowFixMe[prop-missing]
          offsetParent[widthProp];
          x -= offsetX - popperRect.width;
          x *= gpuAcceleration ? 1 : -1;
        }
      }

      var commonStyles = Object.assign({
        position: position
      }, adaptive && unsetSides);

      var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
        x: x,
        y: y
      }) : {
        x: x,
        y: y
      };

      x = _ref4.x;
      y = _ref4.y;

      if (gpuAcceleration) {
        var _Object$assign;

        return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? '0' : '', _Object$assign[sideX] = hasX ? '0' : '', _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign));
      }

      return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : '', _Object$assign2[sideX] = hasX ? x + "px" : '', _Object$assign2.transform = '', _Object$assign2));
    }

    function computeStyles(_ref5) {
      var state = _ref5.state,
          options = _ref5.options;
      var _options$gpuAccelerat = options.gpuAcceleration,
          gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat,
          _options$adaptive = options.adaptive,
          adaptive = _options$adaptive === void 0 ? true : _options$adaptive,
          _options$roundOffsets = options.roundOffsets,
          roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;

      var commonStyles = {
        placement: getBasePlacement$1(state.placement),
        variation: getVariation(state.placement),
        popper: state.elements.popper,
        popperRect: state.rects.popper,
        gpuAcceleration: gpuAcceleration,
        isFixed: state.options.strategy === 'fixed'
      };

      if (state.modifiersData.popperOffsets != null) {
        state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
          offsets: state.modifiersData.popperOffsets,
          position: state.options.strategy,
          adaptive: adaptive,
          roundOffsets: roundOffsets
        })));
      }

      if (state.modifiersData.arrow != null) {
        state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
          offsets: state.modifiersData.arrow,
          position: 'absolute',
          adaptive: false,
          roundOffsets: roundOffsets
        })));
      }

      state.attributes.popper = Object.assign({}, state.attributes.popper, {
        'data-popper-placement': state.placement
      });
    } // eslint-disable-next-line import/no-unused-modules


    var computeStyles$1 = {
      name: 'computeStyles',
      enabled: true,
      phase: 'beforeWrite',
      fn: computeStyles,
      data: {}
    };

    var passive = {
      passive: true
    };

    function effect(_ref) {
      var state = _ref.state,
          instance = _ref.instance,
          options = _ref.options;
      var _options$scroll = options.scroll,
          scroll = _options$scroll === void 0 ? true : _options$scroll,
          _options$resize = options.resize,
          resize = _options$resize === void 0 ? true : _options$resize;
      var window = getWindow(state.elements.popper);
      var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);

      if (scroll) {
        scrollParents.forEach(function (scrollParent) {
          scrollParent.addEventListener('scroll', instance.update, passive);
        });
      }

      if (resize) {
        window.addEventListener('resize', instance.update, passive);
      }

      return function () {
        if (scroll) {
          scrollParents.forEach(function (scrollParent) {
            scrollParent.removeEventListener('scroll', instance.update, passive);
          });
        }

        if (resize) {
          window.removeEventListener('resize', instance.update, passive);
        }
      };
    } // eslint-disable-next-line import/no-unused-modules


    var eventListeners = {
      name: 'eventListeners',
      enabled: true,
      phase: 'write',
      fn: function fn() {},
      effect: effect,
      data: {}
    };

    var hash$1 = {
      left: 'right',
      right: 'left',
      bottom: 'top',
      top: 'bottom'
    };
    function getOppositePlacement(placement) {
      return placement.replace(/left|right|bottom|top/g, function (matched) {
        return hash$1[matched];
      });
    }

    var hash = {
      start: 'end',
      end: 'start'
    };
    function getOppositeVariationPlacement(placement) {
      return placement.replace(/start|end/g, function (matched) {
        return hash[matched];
      });
    }

    function getWindowScroll(node) {
      var win = getWindow(node);
      var scrollLeft = win.pageXOffset;
      var scrollTop = win.pageYOffset;
      return {
        scrollLeft: scrollLeft,
        scrollTop: scrollTop
      };
    }

    function getWindowScrollBarX(element) {
      // If <html> has a CSS width greater than the viewport, then this will be
      // incorrect for RTL.
      // Popper 1 is broken in this case and never had a bug report so let's assume
      // it's not an issue. I don't think anyone ever specifies width on <html>
      // anyway.
      // Browsers where the left scrollbar doesn't cause an issue report `0` for
      // this (e.g. Edge 2019, IE11, Safari)
      return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
    }

    function getViewportRect(element, strategy) {
      var win = getWindow(element);
      var html = getDocumentElement(element);
      var visualViewport = win.visualViewport;
      var width = html.clientWidth;
      var height = html.clientHeight;
      var x = 0;
      var y = 0;

      if (visualViewport) {
        width = visualViewport.width;
        height = visualViewport.height;
        var layoutViewport = isLayoutViewport();

        if (layoutViewport || !layoutViewport && strategy === 'fixed') {
          x = visualViewport.offsetLeft;
          y = visualViewport.offsetTop;
        }
      }

      return {
        width: width,
        height: height,
        x: x + getWindowScrollBarX(element),
        y: y
      };
    }

    // of the `<html>` and `<body>` rect bounds if horizontally scrollable

    function getDocumentRect(element) {
      var _element$ownerDocumen;

      var html = getDocumentElement(element);
      var winScroll = getWindowScroll(element);
      var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
      var width = max$1(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
      var height = max$1(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
      var x = -winScroll.scrollLeft + getWindowScrollBarX(element);
      var y = -winScroll.scrollTop;

      if (getComputedStyle$1(body || html).direction === 'rtl') {
        x += max$1(html.clientWidth, body ? body.clientWidth : 0) - width;
      }

      return {
        width: width,
        height: height,
        x: x,
        y: y
      };
    }

    function isScrollParent(element) {
      // Firefox wants us to check `-x` and `-y` variations as well
      var _getComputedStyle = getComputedStyle$1(element),
          overflow = _getComputedStyle.overflow,
          overflowX = _getComputedStyle.overflowX,
          overflowY = _getComputedStyle.overflowY;

      return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
    }

    function getScrollParent(node) {
      if (['html', 'body', '#document'].indexOf(getNodeName(node)) >= 0) {
        // $FlowFixMe[incompatible-return]: assume body is always available
        return node.ownerDocument.body;
      }

      if (isHTMLElement$1(node) && isScrollParent(node)) {
        return node;
      }

      return getScrollParent(getParentNode(node));
    }

    /*
    given a DOM element, return the list of all scroll parents, up the list of ancesors
    until we get to the top window object. This list is what we attach scroll listeners
    to, because if any of these parent elements scroll, we'll need to re-calculate the
    reference element's position.
    */

    function listScrollParents(element, list) {
      var _element$ownerDocumen;

      if (list === void 0) {
        list = [];
      }

      var scrollParent = getScrollParent(element);
      var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
      var win = getWindow(scrollParent);
      var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
      var updatedList = list.concat(target);
      return isBody ? updatedList : // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
      updatedList.concat(listScrollParents(getParentNode(target)));
    }

    function rectToClientRect(rect) {
      return Object.assign({}, rect, {
        left: rect.x,
        top: rect.y,
        right: rect.x + rect.width,
        bottom: rect.y + rect.height
      });
    }

    function getInnerBoundingClientRect(element, strategy) {
      var rect = getBoundingClientRect(element, false, strategy === 'fixed');
      rect.top = rect.top + element.clientTop;
      rect.left = rect.left + element.clientLeft;
      rect.bottom = rect.top + element.clientHeight;
      rect.right = rect.left + element.clientWidth;
      rect.width = element.clientWidth;
      rect.height = element.clientHeight;
      rect.x = rect.left;
      rect.y = rect.top;
      return rect;
    }

    function getClientRectFromMixedType(element, clippingParent, strategy) {
      return clippingParent === viewport ? rectToClientRect(getViewportRect(element, strategy)) : isElement$1(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
    } // A "clipping parent" is an overflowable container with the characteristic of
    // clipping (or hiding) overflowing elements with a position different from
    // `initial`


    function getClippingParents(element) {
      var clippingParents = listScrollParents(getParentNode(element));
      var canEscapeClipping = ['absolute', 'fixed'].indexOf(getComputedStyle$1(element).position) >= 0;
      var clipperElement = canEscapeClipping && isHTMLElement$1(element) ? getOffsetParent(element) : element;

      if (!isElement$1(clipperElement)) {
        return [];
      } // $FlowFixMe[incompatible-return]: https://github.com/facebook/flow/issues/1414


      return clippingParents.filter(function (clippingParent) {
        return isElement$1(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== 'body';
      });
    } // Gets the maximum area that the element is visible in due to any number of
    // clipping parents


    function getClippingRect(element, boundary, rootBoundary, strategy) {
      var mainClippingParents = boundary === 'clippingParents' ? getClippingParents(element) : [].concat(boundary);
      var clippingParents = [].concat(mainClippingParents, [rootBoundary]);
      var firstClippingParent = clippingParents[0];
      var clippingRect = clippingParents.reduce(function (accRect, clippingParent) {
        var rect = getClientRectFromMixedType(element, clippingParent, strategy);
        accRect.top = max$1(rect.top, accRect.top);
        accRect.right = min$1(rect.right, accRect.right);
        accRect.bottom = min$1(rect.bottom, accRect.bottom);
        accRect.left = max$1(rect.left, accRect.left);
        return accRect;
      }, getClientRectFromMixedType(element, firstClippingParent, strategy));
      clippingRect.width = clippingRect.right - clippingRect.left;
      clippingRect.height = clippingRect.bottom - clippingRect.top;
      clippingRect.x = clippingRect.left;
      clippingRect.y = clippingRect.top;
      return clippingRect;
    }

    function computeOffsets(_ref) {
      var reference = _ref.reference,
          element = _ref.element,
          placement = _ref.placement;
      var basePlacement = placement ? getBasePlacement$1(placement) : null;
      var variation = placement ? getVariation(placement) : null;
      var commonX = reference.x + reference.width / 2 - element.width / 2;
      var commonY = reference.y + reference.height / 2 - element.height / 2;
      var offsets;

      switch (basePlacement) {
        case top:
          offsets = {
            x: commonX,
            y: reference.y - element.height
          };
          break;

        case bottom:
          offsets = {
            x: commonX,
            y: reference.y + reference.height
          };
          break;

        case right:
          offsets = {
            x: reference.x + reference.width,
            y: commonY
          };
          break;

        case left:
          offsets = {
            x: reference.x - element.width,
            y: commonY
          };
          break;

        default:
          offsets = {
            x: reference.x,
            y: reference.y
          };
      }

      var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;

      if (mainAxis != null) {
        var len = mainAxis === 'y' ? 'height' : 'width';

        switch (variation) {
          case start:
            offsets[mainAxis] = offsets[mainAxis] - (reference[len] / 2 - element[len] / 2);
            break;

          case end:
            offsets[mainAxis] = offsets[mainAxis] + (reference[len] / 2 - element[len] / 2);
            break;
        }
      }

      return offsets;
    }

    function detectOverflow(state, options) {
      if (options === void 0) {
        options = {};
      }

      var _options = options,
          _options$placement = _options.placement,
          placement = _options$placement === void 0 ? state.placement : _options$placement,
          _options$strategy = _options.strategy,
          strategy = _options$strategy === void 0 ? state.strategy : _options$strategy,
          _options$boundary = _options.boundary,
          boundary = _options$boundary === void 0 ? clippingParents : _options$boundary,
          _options$rootBoundary = _options.rootBoundary,
          rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary,
          _options$elementConte = _options.elementContext,
          elementContext = _options$elementConte === void 0 ? popper : _options$elementConte,
          _options$altBoundary = _options.altBoundary,
          altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary,
          _options$padding = _options.padding,
          padding = _options$padding === void 0 ? 0 : _options$padding;
      var paddingObject = mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));
      var altContext = elementContext === popper ? reference : popper;
      var popperRect = state.rects.popper;
      var element = state.elements[altBoundary ? altContext : elementContext];
      var clippingClientRect = getClippingRect(isElement$1(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary, strategy);
      var referenceClientRect = getBoundingClientRect(state.elements.reference);
      var popperOffsets = computeOffsets({
        reference: referenceClientRect,
        element: popperRect,
        strategy: 'absolute',
        placement: placement
      });
      var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets));
      var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect; // positive = overflowing the clipping rect
      // 0 or negative = within the clipping rect

      var overflowOffsets = {
        top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
        bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
        left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
        right: elementClientRect.right - clippingClientRect.right + paddingObject.right
      };
      var offsetData = state.modifiersData.offset; // Offsets can be applied only to the popper element

      if (elementContext === popper && offsetData) {
        var offset = offsetData[placement];
        Object.keys(overflowOffsets).forEach(function (key) {
          var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
          var axis = [top, bottom].indexOf(key) >= 0 ? 'y' : 'x';
          overflowOffsets[key] += offset[axis] * multiply;
        });
      }

      return overflowOffsets;
    }

    function computeAutoPlacement(state, options) {
      if (options === void 0) {
        options = {};
      }

      var _options = options,
          placement = _options.placement,
          boundary = _options.boundary,
          rootBoundary = _options.rootBoundary,
          padding = _options.padding,
          flipVariations = _options.flipVariations,
          _options$allowedAutoP = _options.allowedAutoPlacements,
          allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
      var variation = getVariation(placement);
      var placements$1 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function (placement) {
        return getVariation(placement) === variation;
      }) : basePlacements;
      var allowedPlacements = placements$1.filter(function (placement) {
        return allowedAutoPlacements.indexOf(placement) >= 0;
      });

      if (allowedPlacements.length === 0) {
        allowedPlacements = placements$1;
      } // $FlowFixMe[incompatible-type]: Flow seems to have problems with two array unions...


      var overflows = allowedPlacements.reduce(function (acc, placement) {
        acc[placement] = detectOverflow(state, {
          placement: placement,
          boundary: boundary,
          rootBoundary: rootBoundary,
          padding: padding
        })[getBasePlacement$1(placement)];
        return acc;
      }, {});
      return Object.keys(overflows).sort(function (a, b) {
        return overflows[a] - overflows[b];
      });
    }

    function getExpandedFallbackPlacements(placement) {
      if (getBasePlacement$1(placement) === auto) {
        return [];
      }

      var oppositePlacement = getOppositePlacement(placement);
      return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
    }

    function flip(_ref) {
      var state = _ref.state,
          options = _ref.options,
          name = _ref.name;

      if (state.modifiersData[name]._skip) {
        return;
      }

      var _options$mainAxis = options.mainAxis,
          checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
          _options$altAxis = options.altAxis,
          checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis,
          specifiedFallbackPlacements = options.fallbackPlacements,
          padding = options.padding,
          boundary = options.boundary,
          rootBoundary = options.rootBoundary,
          altBoundary = options.altBoundary,
          _options$flipVariatio = options.flipVariations,
          flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio,
          allowedAutoPlacements = options.allowedAutoPlacements;
      var preferredPlacement = state.options.placement;
      var basePlacement = getBasePlacement$1(preferredPlacement);
      var isBasePlacement = basePlacement === preferredPlacement;
      var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
      var placements = [preferredPlacement].concat(fallbackPlacements).reduce(function (acc, placement) {
        return acc.concat(getBasePlacement$1(placement) === auto ? computeAutoPlacement(state, {
          placement: placement,
          boundary: boundary,
          rootBoundary: rootBoundary,
          padding: padding,
          flipVariations: flipVariations,
          allowedAutoPlacements: allowedAutoPlacements
        }) : placement);
      }, []);
      var referenceRect = state.rects.reference;
      var popperRect = state.rects.popper;
      var checksMap = new Map();
      var makeFallbackChecks = true;
      var firstFittingPlacement = placements[0];

      for (var i = 0; i < placements.length; i++) {
        var placement = placements[i];

        var _basePlacement = getBasePlacement$1(placement);

        var isStartVariation = getVariation(placement) === start;
        var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
        var len = isVertical ? 'width' : 'height';
        var overflow = detectOverflow(state, {
          placement: placement,
          boundary: boundary,
          rootBoundary: rootBoundary,
          altBoundary: altBoundary,
          padding: padding
        });
        var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;

        if (referenceRect[len] > popperRect[len]) {
          mainVariationSide = getOppositePlacement(mainVariationSide);
        }

        var altVariationSide = getOppositePlacement(mainVariationSide);
        var checks = [];

        if (checkMainAxis) {
          checks.push(overflow[_basePlacement] <= 0);
        }

        if (checkAltAxis) {
          checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
        }

        if (checks.every(function (check) {
          return check;
        })) {
          firstFittingPlacement = placement;
          makeFallbackChecks = false;
          break;
        }

        checksMap.set(placement, checks);
      }

      if (makeFallbackChecks) {
        // `2` may be desired in some cases – research later
        var numberOfChecks = flipVariations ? 3 : 1;

        var _loop = function _loop(_i) {
          var fittingPlacement = placements.find(function (placement) {
            var checks = checksMap.get(placement);

            if (checks) {
              return checks.slice(0, _i).every(function (check) {
                return check;
              });
            }
          });

          if (fittingPlacement) {
            firstFittingPlacement = fittingPlacement;
            return "break";
          }
        };

        for (var _i = numberOfChecks; _i > 0; _i--) {
          var _ret = _loop(_i);

          if (_ret === "break") break;
        }
      }

      if (state.placement !== firstFittingPlacement) {
        state.modifiersData[name]._skip = true;
        state.placement = firstFittingPlacement;
        state.reset = true;
      }
    } // eslint-disable-next-line import/no-unused-modules


    var flip$1 = {
      name: 'flip',
      enabled: true,
      phase: 'main',
      fn: flip,
      requiresIfExists: ['offset'],
      data: {
        _skip: false
      }
    };

    function getSideOffsets(overflow, rect, preventedOffsets) {
      if (preventedOffsets === void 0) {
        preventedOffsets = {
          x: 0,
          y: 0
        };
      }

      return {
        top: overflow.top - rect.height - preventedOffsets.y,
        right: overflow.right - rect.width + preventedOffsets.x,
        bottom: overflow.bottom - rect.height + preventedOffsets.y,
        left: overflow.left - rect.width - preventedOffsets.x
      };
    }

    function isAnySideFullyClipped(overflow) {
      return [top, right, bottom, left].some(function (side) {
        return overflow[side] >= 0;
      });
    }

    function hide(_ref) {
      var state = _ref.state,
          name = _ref.name;
      var referenceRect = state.rects.reference;
      var popperRect = state.rects.popper;
      var preventedOffsets = state.modifiersData.preventOverflow;
      var referenceOverflow = detectOverflow(state, {
        elementContext: 'reference'
      });
      var popperAltOverflow = detectOverflow(state, {
        altBoundary: true
      });
      var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
      var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
      var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
      var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
      state.modifiersData[name] = {
        referenceClippingOffsets: referenceClippingOffsets,
        popperEscapeOffsets: popperEscapeOffsets,
        isReferenceHidden: isReferenceHidden,
        hasPopperEscaped: hasPopperEscaped
      };
      state.attributes.popper = Object.assign({}, state.attributes.popper, {
        'data-popper-reference-hidden': isReferenceHidden,
        'data-popper-escaped': hasPopperEscaped
      });
    } // eslint-disable-next-line import/no-unused-modules


    var hide$1 = {
      name: 'hide',
      enabled: true,
      phase: 'main',
      requiresIfExists: ['preventOverflow'],
      fn: hide
    };

    function distanceAndSkiddingToXY(placement, rects, offset) {
      var basePlacement = getBasePlacement$1(placement);
      var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;

      var _ref = typeof offset === 'function' ? offset(Object.assign({}, rects, {
        placement: placement
      })) : offset,
          skidding = _ref[0],
          distance = _ref[1];

      skidding = skidding || 0;
      distance = (distance || 0) * invertDistance;
      return [left, right].indexOf(basePlacement) >= 0 ? {
        x: distance,
        y: skidding
      } : {
        x: skidding,
        y: distance
      };
    }

    function offset(_ref2) {
      var state = _ref2.state,
          options = _ref2.options,
          name = _ref2.name;
      var _options$offset = options.offset,
          offset = _options$offset === void 0 ? [0, 0] : _options$offset;
      var data = placements.reduce(function (acc, placement) {
        acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset);
        return acc;
      }, {});
      var _data$state$placement = data[state.placement],
          x = _data$state$placement.x,
          y = _data$state$placement.y;

      if (state.modifiersData.popperOffsets != null) {
        state.modifiersData.popperOffsets.x += x;
        state.modifiersData.popperOffsets.y += y;
      }

      state.modifiersData[name] = data;
    } // eslint-disable-next-line import/no-unused-modules


    var offset$1 = {
      name: 'offset',
      enabled: true,
      phase: 'main',
      requires: ['popperOffsets'],
      fn: offset
    };

    function popperOffsets(_ref) {
      var state = _ref.state,
          name = _ref.name;
      // Offsets are the actual position the popper needs to have to be
      // properly positioned near its reference element
      // This is the most basic placement, and will be adjusted by
      // the modifiers in the next step
      state.modifiersData[name] = computeOffsets({
        reference: state.rects.reference,
        element: state.rects.popper,
        strategy: 'absolute',
        placement: state.placement
      });
    } // eslint-disable-next-line import/no-unused-modules


    var popperOffsets$1 = {
      name: 'popperOffsets',
      enabled: true,
      phase: 'read',
      fn: popperOffsets,
      data: {}
    };

    function getAltAxis(axis) {
      return axis === 'x' ? 'y' : 'x';
    }

    function preventOverflow(_ref) {
      var state = _ref.state,
          options = _ref.options,
          name = _ref.name;
      var _options$mainAxis = options.mainAxis,
          checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
          _options$altAxis = options.altAxis,
          checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis,
          boundary = options.boundary,
          rootBoundary = options.rootBoundary,
          altBoundary = options.altBoundary,
          padding = options.padding,
          _options$tether = options.tether,
          tether = _options$tether === void 0 ? true : _options$tether,
          _options$tetherOffset = options.tetherOffset,
          tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
      var overflow = detectOverflow(state, {
        boundary: boundary,
        rootBoundary: rootBoundary,
        padding: padding,
        altBoundary: altBoundary
      });
      var basePlacement = getBasePlacement$1(state.placement);
      var variation = getVariation(state.placement);
      var isBasePlacement = !variation;
      var mainAxis = getMainAxisFromPlacement(basePlacement);
      var altAxis = getAltAxis(mainAxis);
      var popperOffsets = state.modifiersData.popperOffsets;
      var referenceRect = state.rects.reference;
      var popperRect = state.rects.popper;
      var tetherOffsetValue = typeof tetherOffset === 'function' ? tetherOffset(Object.assign({}, state.rects, {
        placement: state.placement
      })) : tetherOffset;
      var normalizedTetherOffsetValue = typeof tetherOffsetValue === 'number' ? {
        mainAxis: tetherOffsetValue,
        altAxis: tetherOffsetValue
      } : Object.assign({
        mainAxis: 0,
        altAxis: 0
      }, tetherOffsetValue);
      var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
      var data = {
        x: 0,
        y: 0
      };

      if (!popperOffsets) {
        return;
      }

      if (checkMainAxis) {
        var _offsetModifierState$;

        var mainSide = mainAxis === 'y' ? top : left;
        var altSide = mainAxis === 'y' ? bottom : right;
        var len = mainAxis === 'y' ? 'height' : 'width';
        var offset = popperOffsets[mainAxis];
        var min = offset + overflow[mainSide];
        var max = offset - overflow[altSide];
        var additive = tether ? -popperRect[len] / 2 : 0;
        var minLen = variation === start ? referenceRect[len] : popperRect[len];
        var maxLen = variation === start ? -popperRect[len] : -referenceRect[len]; // We need to include the arrow in the calculation so the arrow doesn't go
        // outside the reference bounds

        var arrowElement = state.elements.arrow;
        var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
          width: 0,
          height: 0
        };
        var arrowPaddingObject = state.modifiersData['arrow#persistent'] ? state.modifiersData['arrow#persistent'].padding : getFreshSideObject();
        var arrowPaddingMin = arrowPaddingObject[mainSide];
        var arrowPaddingMax = arrowPaddingObject[altSide]; // If the reference length is smaller than the arrow length, we don't want
        // to include its full size in the calculation. If the reference is small
        // and near the edge of a boundary, the popper can overflow even if the
        // reference is not overflowing as well (e.g. virtual elements with no
        // width or height)

        var arrowLen = within(0, referenceRect[len], arrowRect[len]);
        var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
        var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
        var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
        var clientOffset = arrowOffsetParent ? mainAxis === 'y' ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
        var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
        var tetherMin = offset + minOffset - offsetModifierValue - clientOffset;
        var tetherMax = offset + maxOffset - offsetModifierValue;
        var preventedOffset = within(tether ? min$1(min, tetherMin) : min, offset, tether ? max$1(max, tetherMax) : max);
        popperOffsets[mainAxis] = preventedOffset;
        data[mainAxis] = preventedOffset - offset;
      }

      if (checkAltAxis) {
        var _offsetModifierState$2;

        var _mainSide = mainAxis === 'x' ? top : left;

        var _altSide = mainAxis === 'x' ? bottom : right;

        var _offset = popperOffsets[altAxis];

        var _len = altAxis === 'y' ? 'height' : 'width';

        var _min = _offset + overflow[_mainSide];

        var _max = _offset - overflow[_altSide];

        var isOriginSide = [top, left].indexOf(basePlacement) !== -1;

        var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;

        var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;

        var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;

        var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);

        popperOffsets[altAxis] = _preventedOffset;
        data[altAxis] = _preventedOffset - _offset;
      }

      state.modifiersData[name] = data;
    } // eslint-disable-next-line import/no-unused-modules


    var preventOverflow$1 = {
      name: 'preventOverflow',
      enabled: true,
      phase: 'main',
      fn: preventOverflow,
      requiresIfExists: ['offset']
    };

    function getHTMLElementScroll(element) {
      return {
        scrollLeft: element.scrollLeft,
        scrollTop: element.scrollTop
      };
    }

    function getNodeScroll(node) {
      if (node === getWindow(node) || !isHTMLElement$1(node)) {
        return getWindowScroll(node);
      } else {
        return getHTMLElementScroll(node);
      }
    }

    function isElementScaled(element) {
      var rect = element.getBoundingClientRect();
      var scaleX = round(rect.width) / element.offsetWidth || 1;
      var scaleY = round(rect.height) / element.offsetHeight || 1;
      return scaleX !== 1 || scaleY !== 1;
    } // Returns the composite rect of an element relative to its offsetParent.
    // Composite means it takes into account transforms as well as layout.


    function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
      if (isFixed === void 0) {
        isFixed = false;
      }

      var isOffsetParentAnElement = isHTMLElement$1(offsetParent);
      var offsetParentIsScaled = isHTMLElement$1(offsetParent) && isElementScaled(offsetParent);
      var documentElement = getDocumentElement(offsetParent);
      var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed);
      var scroll = {
        scrollLeft: 0,
        scrollTop: 0
      };
      var offsets = {
        x: 0,
        y: 0
      };

      if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
        if (getNodeName(offsetParent) !== 'body' || // https://github.com/popperjs/popper-core/issues/1078
        isScrollParent(documentElement)) {
          scroll = getNodeScroll(offsetParent);
        }

        if (isHTMLElement$1(offsetParent)) {
          offsets = getBoundingClientRect(offsetParent, true);
          offsets.x += offsetParent.clientLeft;
          offsets.y += offsetParent.clientTop;
        } else if (documentElement) {
          offsets.x = getWindowScrollBarX(documentElement);
        }
      }

      return {
        x: rect.left + scroll.scrollLeft - offsets.x,
        y: rect.top + scroll.scrollTop - offsets.y,
        width: rect.width,
        height: rect.height
      };
    }

    function order(modifiers) {
      var map = new Map();
      var visited = new Set();
      var result = [];
      modifiers.forEach(function (modifier) {
        map.set(modifier.name, modifier);
      }); // On visiting object, check for its dependencies and visit them recursively

      function sort(modifier) {
        visited.add(modifier.name);
        var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
        requires.forEach(function (dep) {
          if (!visited.has(dep)) {
            var depModifier = map.get(dep);

            if (depModifier) {
              sort(depModifier);
            }
          }
        });
        result.push(modifier);
      }

      modifiers.forEach(function (modifier) {
        if (!visited.has(modifier.name)) {
          // check for visited object
          sort(modifier);
        }
      });
      return result;
    }

    function orderModifiers(modifiers) {
      // order based on dependencies
      var orderedModifiers = order(modifiers); // order based on phase

      return modifierPhases.reduce(function (acc, phase) {
        return acc.concat(orderedModifiers.filter(function (modifier) {
          return modifier.phase === phase;
        }));
      }, []);
    }

    function debounce$1(fn) {
      var pending;
      return function () {
        if (!pending) {
          pending = new Promise(function (resolve) {
            Promise.resolve().then(function () {
              pending = undefined;
              resolve(fn());
            });
          });
        }

        return pending;
      };
    }

    function mergeByName(modifiers) {
      var merged = modifiers.reduce(function (merged, current) {
        var existing = merged[current.name];
        merged[current.name] = existing ? Object.assign({}, existing, current, {
          options: Object.assign({}, existing.options, current.options),
          data: Object.assign({}, existing.data, current.data)
        }) : current;
        return merged;
      }, {}); // IE11 does not support Object.values

      return Object.keys(merged).map(function (key) {
        return merged[key];
      });
    }

    var DEFAULT_OPTIONS = {
      placement: 'bottom',
      modifiers: [],
      strategy: 'absolute'
    };

    function areValidElements() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return !args.some(function (element) {
        return !(element && typeof element.getBoundingClientRect === 'function');
      });
    }

    function popperGenerator(generatorOptions) {
      if (generatorOptions === void 0) {
        generatorOptions = {};
      }

      var _generatorOptions = generatorOptions,
          _generatorOptions$def = _generatorOptions.defaultModifiers,
          defaultModifiers = _generatorOptions$def === void 0 ? [] : _generatorOptions$def,
          _generatorOptions$def2 = _generatorOptions.defaultOptions,
          defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
      return function createPopper(reference, popper, options) {
        if (options === void 0) {
          options = defaultOptions;
        }

        var state = {
          placement: 'bottom',
          orderedModifiers: [],
          options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
          modifiersData: {},
          elements: {
            reference: reference,
            popper: popper
          },
          attributes: {},
          styles: {}
        };
        var effectCleanupFns = [];
        var isDestroyed = false;
        var instance = {
          state: state,
          setOptions: function setOptions(setOptionsAction) {
            var options = typeof setOptionsAction === 'function' ? setOptionsAction(state.options) : setOptionsAction;
            cleanupModifierEffects();
            state.options = Object.assign({}, defaultOptions, state.options, options);
            state.scrollParents = {
              reference: isElement$1(reference) ? listScrollParents(reference) : reference.contextElement ? listScrollParents(reference.contextElement) : [],
              popper: listScrollParents(popper)
            }; // Orders the modifiers based on their dependencies and `phase`
            // properties

            var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers, state.options.modifiers))); // Strip out disabled modifiers

            state.orderedModifiers = orderedModifiers.filter(function (m) {
              return m.enabled;
            }); // Validate the provided modifiers so that the consumer will get warned

            runModifierEffects();
            return instance.update();
          },
          // Sync update – it will always be executed, even if not necessary. This
          // is useful for low frequency updates where sync behavior simplifies the
          // logic.
          // For high frequency updates (e.g. `resize` and `scroll` events), always
          // prefer the async Popper#update method
          forceUpdate: function forceUpdate() {
            if (isDestroyed) {
              return;
            }

            var _state$elements = state.elements,
                reference = _state$elements.reference,
                popper = _state$elements.popper; // Don't proceed if `reference` or `popper` are not valid elements
            // anymore

            if (!areValidElements(reference, popper)) {

              return;
            } // Store the reference and popper rects to be read by modifiers


            state.rects = {
              reference: getCompositeRect(reference, getOffsetParent(popper), state.options.strategy === 'fixed'),
              popper: getLayoutRect(popper)
            }; // Modifiers have the ability to reset the current update cycle. The
            // most common use case for this is the `flip` modifier changing the
            // placement, which then needs to re-run all the modifiers, because the
            // logic was previously ran for the previous placement and is therefore
            // stale/incorrect

            state.reset = false;
            state.placement = state.options.placement; // On each update cycle, the `modifiersData` property for each modifier
            // is filled with the initial data specified by the modifier. This means
            // it doesn't persist and is fresh on each update.
            // To ensure persistent data, use `${name}#persistent`

            state.orderedModifiers.forEach(function (modifier) {
              return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
            });

            for (var index = 0; index < state.orderedModifiers.length; index++) {

              if (state.reset === true) {
                state.reset = false;
                index = -1;
                continue;
              }

              var _state$orderedModifie = state.orderedModifiers[index],
                  fn = _state$orderedModifie.fn,
                  _state$orderedModifie2 = _state$orderedModifie.options,
                  _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2,
                  name = _state$orderedModifie.name;

              if (typeof fn === 'function') {
                state = fn({
                  state: state,
                  options: _options,
                  name: name,
                  instance: instance
                }) || state;
              }
            }
          },
          // Async and optimistically optimized update – it will not be executed if
          // not necessary (debounced to run at most once-per-tick)
          update: debounce$1(function () {
            return new Promise(function (resolve) {
              instance.forceUpdate();
              resolve(state);
            });
          }),
          destroy: function destroy() {
            cleanupModifierEffects();
            isDestroyed = true;
          }
        };

        if (!areValidElements(reference, popper)) {

          return instance;
        }

        instance.setOptions(options).then(function (state) {
          if (!isDestroyed && options.onFirstUpdate) {
            options.onFirstUpdate(state);
          }
        }); // Modifiers have the ability to execute arbitrary code before the first
        // update cycle runs. They will be executed in the same order as the update
        // cycle. This is useful when a modifier adds some persistent data that
        // other modifiers need to use, but the modifier is run after the dependent
        // one.

        function runModifierEffects() {
          state.orderedModifiers.forEach(function (_ref3) {
            var name = _ref3.name,
                _ref3$options = _ref3.options,
                options = _ref3$options === void 0 ? {} : _ref3$options,
                effect = _ref3.effect;

            if (typeof effect === 'function') {
              var cleanupFn = effect({
                state: state,
                name: name,
                instance: instance,
                options: options
              });

              var noopFn = function noopFn() {};

              effectCleanupFns.push(cleanupFn || noopFn);
            }
          });
        }

        function cleanupModifierEffects() {
          effectCleanupFns.forEach(function (fn) {
            return fn();
          });
          effectCleanupFns = [];
        }

        return instance;
      };
    }

    var defaultModifiers = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1, offset$1, flip$1, preventOverflow$1, arrow$1, hide$1];
    var createPopper = /*#__PURE__*/popperGenerator({
      defaultModifiers: defaultModifiers
    }); // eslint-disable-next-line import/no-unused-modules

    /**!
    * tippy.js v6.0.3
    * (c) 2017-2020 atomiks
    * MIT License
    */

    var PASSIVE = {
      passive: true
    };
    var IOS_CLASS = "tippy-iOS";
    var BOX_CLASS = "tippy-box";
    var CONTENT_CLASS = "tippy-content";
    var BACKDROP_CLASS = "tippy-backdrop";
    var ARROW_CLASS = "tippy-arrow";
    var SVG_ARROW_CLASS = "tippy-svg-arrow";
    function getValueAtIndexOrReturn(value, index, defaultValue) {
      if (Array.isArray(value)) {
        var v = value[index];
        return v == null ? Array.isArray(defaultValue) ? defaultValue[index] : defaultValue : v;
      }

      return value;
    }
    function isType(value, type) {
      var str = {}.toString.call(value);
      return str.indexOf('[object') === 0 && str.indexOf(type + "]") > -1;
    }
    function invokeWithArgsOrReturn(value, args) {
      return typeof value === 'function' ? value.apply(void 0, args) : value;
    }
    function debounce(fn, ms) {
      // Avoid wrapping in `setTimeout` if ms is 0 anyway
      if (ms === 0) {
        return fn;
      }

      var timeout;
      return function (arg) {
        clearTimeout(timeout);
        timeout = setTimeout(function () {
          fn(arg);
        }, ms);
      };
    }
    function splitBySpaces(value) {
      return value.split(/\s+/).filter(Boolean);
    }
    function normalizeToArray(value) {
      return [].concat(value);
    }
    function pushIfUnique(arr, value) {
      if (arr.indexOf(value) === -1) {
        arr.push(value);
      }
    }
    function unique(arr) {
      return arr.filter(function (item, index) {
        return arr.indexOf(item) === index;
      });
    }
    function getBasePlacement(placement) {
      return placement.split('-')[0];
    }
    function arrayFrom(value) {
      return [].slice.call(value);
    }

    function div() {
      return document.createElement('div');
    }
    function isElement(value) {
      return isType(value, 'Element');
    }
    function isNodeList(value) {
      return isType(value, 'NodeList');
    }
    function isMouseEvent(value) {
      return isType(value, 'MouseEvent');
    }
    function isReferenceElement(value) {
      return !!(value && value._tippy && value._tippy.reference === value);
    }
    function getArrayOfElements(value) {
      if (isElement(value)) {
        return [value];
      }

      if (isNodeList(value)) {
        return arrayFrom(value);
      }

      if (Array.isArray(value)) {
        return value;
      }

      return arrayFrom(document.querySelectorAll(value));
    }
    function setTransitionDuration(els, value) {
      els.forEach(function (el) {
        if (el) {
          el.style.transitionDuration = value + "ms";
        }
      });
    }
    function setVisibilityState(els, state) {
      els.forEach(function (el) {
        if (el) {
          el.setAttribute('data-state', state);
        }
      });
    }
    function getOwnerDocument(elementOrElements) {
      var _normalizeToArray = normalizeToArray(elementOrElements),
          element = _normalizeToArray[0];

      return element ? element.ownerDocument || document : document;
    }
    function isCursorOutsideInteractiveBorder(popperTreeData, event) {
      var clientX = event.clientX,
          clientY = event.clientY;
      return popperTreeData.every(function (_ref) {
        var popperRect = _ref.popperRect,
            popperState = _ref.popperState,
            props = _ref.props;
        var interactiveBorder = props.interactiveBorder;
        var basePlacement = getBasePlacement(popperState.placement);
        var offsetData = popperState.modifiersData.offset;

        if (!offsetData) {
          return true;
        }

        var topDistance = basePlacement === 'bottom' ? offsetData.top.y : 0;
        var bottomDistance = basePlacement === 'top' ? offsetData.bottom.y : 0;
        var leftDistance = basePlacement === 'right' ? offsetData.left.x : 0;
        var rightDistance = basePlacement === 'left' ? offsetData.right.x : 0;
        var exceedsTop = popperRect.top - clientY + topDistance > interactiveBorder;
        var exceedsBottom = clientY - popperRect.bottom - bottomDistance > interactiveBorder;
        var exceedsLeft = popperRect.left - clientX + leftDistance > interactiveBorder;
        var exceedsRight = clientX - popperRect.right - rightDistance > interactiveBorder;
        return exceedsTop || exceedsBottom || exceedsLeft || exceedsRight;
      });
    }
    function updateTransitionEndListener(box, action, listener) {
      var method = action + "EventListener"; // some browsers apparently support `transition` (unprefixed) but only fire
      // `webkitTransitionEnd`...

      ['transitionend', 'webkitTransitionEnd'].forEach(function (event) {
        box[method](event, listener);
      });
    }

    var currentInput = {
      isTouch: false
    };
    var lastMouseMoveTime = 0;
    /**
     * When a `touchstart` event is fired, it's assumed the user is using touch
     * input. We'll bind a `mousemove` event listener to listen for mouse input in
     * the future. This way, the `isTouch` property is fully dynamic and will handle
     * hybrid devices that use a mix of touch + mouse input.
     */

    function onDocumentTouchStart() {
      if (currentInput.isTouch) {
        return;
      }

      currentInput.isTouch = true;

      if (window.performance) {
        document.addEventListener('mousemove', onDocumentMouseMove);
      }
    }
    /**
     * When two `mousemove` event are fired consecutively within 20ms, it's assumed
     * the user is using mouse input again. `mousemove` can fire on touch devices as
     * well, but very rarely that quickly.
     */

    function onDocumentMouseMove() {
      var now = performance.now();

      if (now - lastMouseMoveTime < 20) {
        currentInput.isTouch = false;
        document.removeEventListener('mousemove', onDocumentMouseMove);
      }

      lastMouseMoveTime = now;
    }
    /**
     * When an element is in focus and has a tippy, leaving the tab/window and
     * returning causes it to show again. For mouse users this is unexpected, but
     * for keyboard use it makes sense.
     * TODO: find a better technique to solve this problem
     */

    function onWindowBlur() {
      var activeElement = document.activeElement;

      if (isReferenceElement(activeElement)) {
        var instance = activeElement._tippy;

        if (activeElement.blur && !instance.state.isVisible) {
          activeElement.blur();
        }
      }
    }
    function bindGlobalEventListeners() {
      document.addEventListener('touchstart', onDocumentTouchStart, Object.assign({}, PASSIVE, {
        capture: true
      }));
      window.addEventListener('blur', onWindowBlur);
    }

    var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined';
    var ua = isBrowser ? navigator.userAgent : '';
    var isIE = /MSIE |Trident\//.test(ua);
    var isIOS = isBrowser && /iPhone|iPad|iPod/.test(navigator.platform);

    var pluginProps = {
      animateFill: false,
      followCursor: false,
      inlinePositioning: false,
      sticky: false
    };
    var renderProps = {
      allowHTML: false,
      animation: 'fade',
      arrow: true,
      content: '',
      inertia: false,
      maxWidth: 350,
      role: 'tooltip',
      theme: '',
      zIndex: 9999
    };
    var defaultProps = Object.assign({
      appendTo: function appendTo() {
        return document.body;
      },
      aria: {
        content: 'auto',
        expanded: 'auto'
      },
      content: '',
      delay: 0,
      duration: [300, 250],
      getReferenceClientRect: null,
      hideOnClick: true,
      ignoreAttributes: false,
      interactive: false,
      interactiveBorder: 2,
      interactiveDebounce: 0,
      moveTransition: '',
      offset: [0, 10],
      onAfterUpdate: function onAfterUpdate() {},
      onBeforeUpdate: function onBeforeUpdate() {},
      onCreate: function onCreate() {},
      onDestroy: function onDestroy() {},
      onHidden: function onHidden() {},
      onHide: function onHide() {},
      onMount: function onMount() {},
      onShow: function onShow() {},
      onShown: function onShown() {},
      onTrigger: function onTrigger() {},
      onUntrigger: function onUntrigger() {},
      placement: 'top',
      plugins: [],
      popperOptions: {},
      render: null,
      showOnCreate: false,
      touch: true,
      trigger: 'mouseenter focus',
      triggerTarget: null
    }, pluginProps, {}, renderProps);
    var defaultKeys = Object.keys(defaultProps);
    var setDefaultProps = function setDefaultProps(partialProps) {

      var keys = Object.keys(partialProps);
      keys.forEach(function (key) {
        defaultProps[key] = partialProps[key];
      });
    };
    function getExtendedPassedProps(passedProps) {
      var plugins = passedProps.plugins || [];
      var pluginProps = plugins.reduce(function (acc, plugin) {
        var name = plugin.name,
            defaultValue = plugin.defaultValue;

        if (name) {
          acc[name] = passedProps[name] !== undefined ? passedProps[name] : defaultValue;
        }

        return acc;
      }, {});
      return Object.assign({}, passedProps, {}, pluginProps);
    }
    function getDataAttributeProps(reference, plugins) {
      var propKeys = plugins ? Object.keys(getExtendedPassedProps(Object.assign({}, defaultProps, {
        plugins: plugins
      }))) : defaultKeys;
      var props = propKeys.reduce(function (acc, key) {
        var valueAsString = (reference.getAttribute("data-tippy-" + key) || '').trim();

        if (!valueAsString) {
          return acc;
        }

        if (key === 'content') {
          acc[key] = valueAsString;
        } else {
          try {
            acc[key] = JSON.parse(valueAsString);
          } catch (e) {
            acc[key] = valueAsString;
          }
        }

        return acc;
      }, {});
      return props;
    }
    function evaluateProps(reference, props) {
      var out = Object.assign({}, props, {
        content: invokeWithArgsOrReturn(props.content, [reference])
      }, props.ignoreAttributes ? {} : getDataAttributeProps(reference, props.plugins));
      out.aria = Object.assign({}, defaultProps.aria, {}, out.aria);
      out.aria = {
        expanded: out.aria.expanded === 'auto' ? props.interactive : out.aria.expanded,
        content: out.aria.content === 'auto' ? props.interactive ? null : 'describedby' : out.aria.content
      };
      return out;
    }

    var innerHTML = function innerHTML() {
      return 'innerHTML';
    };

    function dangerouslySetInnerHTML(element, html) {
      element[innerHTML()] = html;
    }

    function createArrowElement(value) {
      var arrow = div();

      if (value === true) {
        arrow.className = ARROW_CLASS;
      } else {
        arrow.className = SVG_ARROW_CLASS;

        if (isElement(value)) {
          arrow.appendChild(value);
        } else {
          dangerouslySetInnerHTML(arrow, value);
        }
      }

      return arrow;
    }

    function setContent(content, props) {
      if (isElement(props.content)) {
        dangerouslySetInnerHTML(content, '');
        content.appendChild(props.content);
      } else if (typeof props.content !== 'function') {
        if (props.allowHTML) {
          dangerouslySetInnerHTML(content, props.content);
        } else {
          content.textContent = props.content;
        }
      }
    }
    function getChildren(popper) {
      var box = popper.firstElementChild;
      var boxChildren = arrayFrom(box.children);
      return {
        box: box,
        content: boxChildren.find(function (node) {
          return node.classList.contains(CONTENT_CLASS);
        }),
        arrow: boxChildren.find(function (node) {
          return node.classList.contains(ARROW_CLASS) || node.classList.contains(SVG_ARROW_CLASS);
        }),
        backdrop: boxChildren.find(function (node) {
          return node.classList.contains(BACKDROP_CLASS);
        })
      };
    }
    function render(instance) {
      var popper = div();
      var box = div();
      box.className = BOX_CLASS;
      box.setAttribute('data-state', 'hidden');
      box.setAttribute('tabindex', '-1');
      var content = div();
      content.className = CONTENT_CLASS;
      content.setAttribute('data-state', 'hidden');
      setContent(content, instance.props);
      popper.appendChild(box);
      box.appendChild(content);
      onUpdate(instance.props, instance.props);

      function onUpdate(prevProps, nextProps) {
        var _getChildren = getChildren(popper),
            box = _getChildren.box,
            content = _getChildren.content,
            arrow = _getChildren.arrow;

        if (nextProps.theme) {
          box.setAttribute('data-theme', nextProps.theme);
        } else {
          box.removeAttribute('data-theme');
        }

        if (typeof nextProps.animation === 'string') {
          box.setAttribute('data-animation', nextProps.animation);
        } else {
          box.removeAttribute('data-animation');
        }

        if (nextProps.inertia) {
          box.setAttribute('data-inertia', '');
        } else {
          box.removeAttribute('data-inertia');
        }

        box.style.maxWidth = typeof nextProps.maxWidth === 'number' ? nextProps.maxWidth + "px" : nextProps.maxWidth;

        if (nextProps.role) {
          box.setAttribute('role', nextProps.role);
        } else {
          box.removeAttribute('role');
        }

        if (prevProps.content !== nextProps.content) {
          setContent(content, instance.props);
        }

        if (nextProps.arrow) {
          if (!arrow) {
            box.appendChild(createArrowElement(nextProps.arrow));
          } else if (prevProps.arrow !== nextProps.arrow) {
            box.removeChild(arrow);
            box.appendChild(createArrowElement(nextProps.arrow));
          }
        } else if (arrow) {
          box.removeChild(arrow);
        }
      }

      return {
        popper: popper,
        onUpdate: onUpdate
      };
    } // Runtime check to identify if the render function is the default one; this
    // way we can apply default CSS transitions logic and it can be tree-shaken away

    render.$$tippy = true;

    var idCounter = 1;
    var mouseMoveListeners = []; // Used by `hideAll()`

    var mountedInstances = [];
    function createTippy(reference, passedProps) {
      var props = evaluateProps(reference, Object.assign({}, defaultProps, {}, getExtendedPassedProps(passedProps))); // ===========================================================================
      // 🔒 Private members
      // ===========================================================================

      var showTimeout;
      var hideTimeout;
      var scheduleHideAnimationFrame;
      var isVisibleFromClick = false;
      var didHideDueToDocumentMouseDown = false;
      var ignoreOnFirstUpdate = false;
      var lastTriggerEvent;
      var currentTransitionEndListener;
      var onFirstUpdate;
      var listeners = [];
      var debouncedOnMouseMove = debounce(onMouseMove, props.interactiveDebounce);
      var currentTarget;
      var doc = getOwnerDocument(props.triggerTarget || reference); // ===========================================================================
      // 🔑 Public members
      // ===========================================================================

      var id = idCounter++;
      var popperInstance = null;
      var plugins = unique(props.plugins);
      var state = {
        // Is the instance currently enabled?
        isEnabled: true,
        // Is the tippy currently showing and not transitioning out?
        isVisible: false,
        // Has the instance been destroyed?
        isDestroyed: false,
        // Is the tippy currently mounted to the DOM?
        isMounted: false,
        // Has the tippy finished transitioning in?
        isShown: false
      };
      var instance = {
        // properties
        id: id,
        reference: reference,
        popper: div(),
        popperInstance: popperInstance,
        props: props,
        state: state,
        plugins: plugins,
        // methods
        clearDelayTimeouts: clearDelayTimeouts,
        setProps: setProps,
        setContent: setContent,
        show: show,
        hide: hide,
        enable: enable,
        disable: disable,
        unmount: unmount,
        destroy: destroy
      }; // TODO: Investigate why this early return causes a TDZ error in the tests —
      // it doesn't seem to happen in the browser

      /* istanbul ignore if */

      if (!props.render) {

        return instance;
      } // ===========================================================================
      // Initial mutations
      // ===========================================================================


      var _props$render = props.render(instance),
          popper = _props$render.popper,
          onUpdate = _props$render.onUpdate;

      popper.setAttribute('data-tippy-root', '');
      popper.id = "tippy-" + instance.id;
      instance.popper = popper;
      reference._tippy = instance;
      popper._tippy = instance;
      var pluginsHooks = plugins.map(function (plugin) {
        return plugin.fn(instance);
      });
      var hasAriaExpanded = reference.hasAttribute('aria-expanded');
      addListeners();
      handleAriaExpandedAttribute();
      handleStyles();
      invokeHook('onCreate', [instance]);

      if (props.showOnCreate) {
        scheduleShow();
      } // Prevent a tippy with a delay from hiding if the cursor left then returned
      // before it started hiding


      popper.addEventListener('mouseenter', function () {
        if (instance.props.interactive && instance.state.isVisible) {
          instance.clearDelayTimeouts();
        }
      });
      popper.addEventListener('mouseleave', function (event) {
        if (instance.props.interactive && instance.props.trigger.indexOf('mouseenter') >= 0) {
          doc.addEventListener('mousemove', debouncedOnMouseMove);
          debouncedOnMouseMove(event);
        }
      });
      return instance; // ===========================================================================
      // 🔒 Private methods
      // ===========================================================================

      function getNormalizedTouchSettings() {
        var touch = instance.props.touch;
        return Array.isArray(touch) ? touch : [touch, 0];
      }

      function getIsCustomTouchBehavior() {
        return getNormalizedTouchSettings()[0] === 'hold';
      }

      function getIsDefaultRenderFn() {
        var _instance$props$rende;

        // @ts-ignore
        return !!((_instance$props$rende = instance.props.render) == null ? void 0 : _instance$props$rende.$$tippy);
      }

      function getCurrentTarget() {
        return currentTarget || reference;
      }

      function getDefaultTemplateChildren() {
        return getChildren(popper);
      }

      function getDelay(isShow) {
        // For touch or keyboard input, force `0` delay for UX reasons
        // Also if the instance is mounted but not visible (transitioning out),
        // ignore delay
        if (instance.state.isMounted && !instance.state.isVisible || currentInput.isTouch || lastTriggerEvent && lastTriggerEvent.type === 'focus') {
          return 0;
        }

        return getValueAtIndexOrReturn(instance.props.delay, isShow ? 0 : 1, defaultProps.delay);
      }

      function handleStyles() {
        popper.style.pointerEvents = instance.props.interactive && instance.state.isVisible ? '' : 'none';
        popper.style.zIndex = "" + instance.props.zIndex;
      }

      function updateIOSClass(isAdd) {
        var shouldAdd = isAdd && isIOS && currentInput.isTouch;
        doc.body.classList[shouldAdd ? 'add' : 'remove'](IOS_CLASS);
      }

      function invokeHook(hook, args, shouldInvokePropsHook) {
        if (shouldInvokePropsHook === void 0) {
          shouldInvokePropsHook = true;
        }

        pluginsHooks.forEach(function (pluginHooks) {
          if (pluginHooks[hook]) {
            pluginHooks[hook].apply(void 0, args);
          }
        });

        if (shouldInvokePropsHook) {
          var _instance$props;

          (_instance$props = instance.props)[hook].apply(_instance$props, args);
        }
      }

      function handleAriaContentAttribute() {
        var aria = instance.props.aria;

        if (!aria.content) {
          return;
        }

        var attr = "aria-" + aria.content;
        var id = popper.id;
        var nodes = normalizeToArray(instance.props.triggerTarget || reference);
        nodes.forEach(function (node) {
          var currentValue = node.getAttribute(attr);

          if (instance.state.isVisible) {
            node.setAttribute(attr, currentValue ? currentValue + " " + id : id);
          } else {
            var nextValue = currentValue && currentValue.replace(id, '').trim();

            if (nextValue) {
              node.setAttribute(attr, nextValue);
            } else {
              node.removeAttribute(attr);
            }
          }
        });
      }

      function handleAriaExpandedAttribute() {
        if (hasAriaExpanded || !instance.props.aria.expanded) {
          return;
        }

        var nodes = normalizeToArray(instance.props.triggerTarget || reference);
        nodes.forEach(function (node) {
          if (instance.props.interactive) {
            node.setAttribute('aria-expanded', instance.state.isVisible && node === getCurrentTarget() ? 'true' : 'false');
          } else {
            node.removeAttribute('aria-expanded');
          }
        });
      }

      function cleanupInteractiveMouseListeners() {
        doc.body.removeEventListener('mouseleave', scheduleHide);
        doc.removeEventListener('mousemove', debouncedOnMouseMove);
        mouseMoveListeners = mouseMoveListeners.filter(function (listener) {
          return listener !== debouncedOnMouseMove;
        });
      }

      function onDocumentMouseDown(event) {
        // Clicked on interactive popper
        if (instance.props.interactive && popper.contains(event.target)) {
          return;
        } // Clicked on the event listeners target


        if (getCurrentTarget().contains(event.target)) {
          if (currentInput.isTouch) {
            return;
          }

          if (instance.state.isVisible && instance.props.trigger.indexOf('click') >= 0) {
            return;
          }
        }

        if (instance.props.hideOnClick === true) {
          isVisibleFromClick = false;
          instance.clearDelayTimeouts();
          instance.hide(); // `mousedown` event is fired right before `focus` if pressing the
          // currentTarget. This lets a tippy with `focus` trigger know that it
          // should not show

          didHideDueToDocumentMouseDown = true;
          setTimeout(function () {
            didHideDueToDocumentMouseDown = false;
          }); // The listener gets added in `scheduleShow()`, but this may be hiding it
          // before it shows, and hide()'s early bail-out behavior can prevent it
          // from being cleaned up

          if (!instance.state.isMounted) {
            removeDocumentMouseDownListener();
          }
        }
      }

      function addDocumentMouseDownListener() {
        doc.addEventListener('mousedown', onDocumentMouseDown, true);
      }

      function removeDocumentMouseDownListener() {
        doc.removeEventListener('mousedown', onDocumentMouseDown, true);
      }

      function onTransitionedOut(duration, callback) {
        onTransitionEnd(duration, function () {
          if (!instance.state.isVisible && popper.parentNode && popper.parentNode.contains(popper)) {
            callback();
          }
        });
      }

      function onTransitionedIn(duration, callback) {
        onTransitionEnd(duration, callback);
      }

      function onTransitionEnd(duration, callback) {
        var box = getDefaultTemplateChildren().box;

        function listener(event) {
          if (event.target === box) {
            updateTransitionEndListener(box, 'remove', listener);
            callback();
          }
        } // Make callback synchronous if duration is 0
        // `transitionend` won't fire otherwise


        if (duration === 0) {
          return callback();
        }

        updateTransitionEndListener(box, 'remove', currentTransitionEndListener);
        updateTransitionEndListener(box, 'add', listener);
        currentTransitionEndListener = listener;
      }

      function on(eventType, handler, options) {
        if (options === void 0) {
          options = false;
        }

        var nodes = normalizeToArray(instance.props.triggerTarget || reference);
        nodes.forEach(function (node) {
          node.addEventListener(eventType, handler, options);
          listeners.push({
            node: node,
            eventType: eventType,
            handler: handler,
            options: options
          });
        });
      }

      function addListeners() {
        if (getIsCustomTouchBehavior()) {
          on('touchstart', onTrigger, PASSIVE);
          on('touchend', onMouseLeave, PASSIVE);
        }

        splitBySpaces(instance.props.trigger).forEach(function (eventType) {
          if (eventType === 'manual') {
            return;
          }

          on(eventType, onTrigger);

          switch (eventType) {
            case 'mouseenter':
              on('mouseleave', onMouseLeave);
              break;

            case 'focus':
              on(isIE ? 'focusout' : 'blur', onBlurOrFocusOut);
              break;

            case 'focusin':
              on('focusout', onBlurOrFocusOut);
              break;
          }
        });
      }

      function removeListeners() {
        listeners.forEach(function (_ref) {
          var node = _ref.node,
              eventType = _ref.eventType,
              handler = _ref.handler,
              options = _ref.options;
          node.removeEventListener(eventType, handler, options);
        });
        listeners = [];
      }

      function onTrigger(event) {
        var shouldScheduleClickHide = false;

        if (!instance.state.isEnabled || isEventListenerStopped(event) || didHideDueToDocumentMouseDown) {
          return;
        }

        lastTriggerEvent = event;
        currentTarget = event.currentTarget;
        handleAriaExpandedAttribute();

        if (!instance.state.isVisible && isMouseEvent(event)) {
          // If scrolling, `mouseenter` events can be fired if the cursor lands
          // over a new target, but `mousemove` events don't get fired. This
          // causes interactive tooltips to get stuck open until the cursor is
          // moved
          mouseMoveListeners.forEach(function (listener) {
            return listener(event);
          });
        } // Toggle show/hide when clicking click-triggered tooltips


        if (event.type === 'click' && (instance.props.trigger.indexOf('mouseenter') < 0 || isVisibleFromClick) && instance.props.hideOnClick !== false && instance.state.isVisible) {
          shouldScheduleClickHide = true;
        } else {
          var _getNormalizedTouchSe = getNormalizedTouchSettings(),
              value = _getNormalizedTouchSe[0],
              duration = _getNormalizedTouchSe[1];

          if (currentInput.isTouch && value === 'hold' && duration) {
            // We can hijack the show timeout here, it will be cleared by
            // `scheduleHide()` when necessary
            showTimeout = setTimeout(function () {
              scheduleShow(event);
            }, duration);
          } else {
            scheduleShow(event);
          }
        }

        if (event.type === 'click') {
          isVisibleFromClick = !shouldScheduleClickHide;
        }

        if (shouldScheduleClickHide) {
          scheduleHide(event);
        }
      }

      function onMouseMove(event) {
        var target = event.target;
        var isCursorOverReferenceOrPopper = reference.contains(target) || popper.contains(target);

        if (event.type === 'mousemove' && isCursorOverReferenceOrPopper) {
          return;
        }

        var popperTreeData = getNestedPopperTree().concat(popper).map(function (popper) {
          var _instance$popperInsta;

          var instance = popper._tippy;
          var state = (_instance$popperInsta = instance.popperInstance) == null ? void 0 : _instance$popperInsta.state;

          if (state) {
            return {
              popperRect: popper.getBoundingClientRect(),
              popperState: state,
              props: props
            };
          }

          return null;
        }).filter(Boolean);

        if (isCursorOutsideInteractiveBorder(popperTreeData, event)) {
          cleanupInteractiveMouseListeners();
          scheduleHide(event);
        }
      }

      function onMouseLeave(event) {
        var shouldBail = isEventListenerStopped(event) || instance.props.trigger.indexOf('click') >= 0 && isVisibleFromClick;

        if (shouldBail) {
          return;
        }

        if (instance.props.interactive) {
          doc.body.addEventListener('mouseleave', scheduleHide);
          doc.addEventListener('mousemove', debouncedOnMouseMove);
          pushIfUnique(mouseMoveListeners, debouncedOnMouseMove);
          debouncedOnMouseMove(event);
          return;
        }

        scheduleHide(event);
      }

      function onBlurOrFocusOut(event) {
        if (instance.props.trigger.indexOf('focusin') < 0 && event.target !== getCurrentTarget()) {
          return;
        } // If focus was moved to within the popper


        if (instance.props.interactive && event.relatedTarget && popper.contains(event.relatedTarget)) {
          return;
        }

        scheduleHide(event);
      }

      function isEventListenerStopped(event) {
        return currentInput.isTouch ? getIsCustomTouchBehavior() !== event.type.indexOf('touch') >= 0 : false;
      }

      function createPopperInstance() {
        destroyPopperInstance();
        var _instance$props2 = instance.props,
            popperOptions = _instance$props2.popperOptions,
            placement = _instance$props2.placement,
            offset = _instance$props2.offset,
            getReferenceClientRect = _instance$props2.getReferenceClientRect,
            moveTransition = _instance$props2.moveTransition;
        var arrow = getIsDefaultRenderFn() ? getChildren(popper).arrow : null;
        var computedReference = getReferenceClientRect ? {
          getBoundingClientRect: getReferenceClientRect
        } : reference;
        var tippyModifier = {
          name: '$$tippy',
          enabled: true,
          phase: 'beforeWrite',
          requires: ['computeStyles'],
          fn: function fn(_ref2) {
            var state = _ref2.state;

            if (getIsDefaultRenderFn()) {
              var _getDefaultTemplateCh = getDefaultTemplateChildren(),
                  box = _getDefaultTemplateCh.box;

              ['placement', 'reference-hidden', 'escaped'].forEach(function (attr) {
                if (attr === 'placement') {
                  box.setAttribute('data-placement', state.placement);
                } else {
                  if (state.attributes.popper["data-popper-" + attr]) {
                    box.setAttribute("data-" + attr, '');
                  } else {
                    box.removeAttribute("data-" + attr);
                  }
                }
              });
              state.attributes.popper = {};
            }
          }
        };
        var arrowModifier = {
          name: 'arrow',
          enabled: !!arrow,
          options: {
            element: arrow,
            padding: 3
          }
        };
        var modifiers = [{
          name: 'offset',
          options: {
            offset: offset
          }
        }, {
          name: 'preventOverflow',
          options: {
            padding: {
              top: 2,
              bottom: 2,
              left: 5,
              right: 5
            }
          }
        }, {
          name: 'flip',
          options: {
            padding: 5
          }
        }, {
          name: 'computeStyles',
          options: {
            adaptive: !moveTransition
          }
        }].concat(getIsDefaultRenderFn() ? [arrowModifier] : [], (popperOptions == null ? void 0 : popperOptions.modifiers) || [], [tippyModifier]);
        instance.popperInstance = createPopper(computedReference, popper, Object.assign({}, popperOptions, {
          placement: placement,
          onFirstUpdate: onFirstUpdate,
          modifiers: modifiers
        }));
      }

      function destroyPopperInstance() {
        if (instance.popperInstance) {
          instance.popperInstance.destroy();
          instance.popperInstance = null;
        }
      }

      function mount() {
        var appendTo = instance.props.appendTo;
        var parentNode; // By default, we'll append the popper to the triggerTargets's parentNode so
        // it's directly after the reference element so the elements inside the
        // tippy can be tabbed to
        // If there are clipping issues, the user can specify a different appendTo
        // and ensure focus management is handled correctly manually

        var node = getCurrentTarget();

        if (instance.props.interactive && appendTo === defaultProps.appendTo || appendTo === 'parent') {
          parentNode = node.parentNode;
        } else {
          parentNode = invokeWithArgsOrReturn(appendTo, [node]);
        } // The popper element needs to exist on the DOM before its position can be
        // updated as Popper needs to read its dimensions


        if (!parentNode.contains(popper)) {
          parentNode.appendChild(popper);
        }

        createPopperInstance();
      }

      function getNestedPopperTree() {
        return arrayFrom(popper.querySelectorAll('[data-tippy-root]'));
      }

      function scheduleShow(event) {
        instance.clearDelayTimeouts();

        if (event) {
          invokeHook('onTrigger', [instance, event]);
        }

        addDocumentMouseDownListener();
        var delay = getDelay(true);

        if (delay) {
          showTimeout = setTimeout(function () {
            instance.show();
          }, delay);
        } else {
          instance.show();
        }
      }

      function scheduleHide(event) {
        instance.clearDelayTimeouts();
        invokeHook('onUntrigger', [instance, event]);

        if (!instance.state.isVisible) {
          removeDocumentMouseDownListener();
          return;
        } // For interactive tippies, scheduleHide is added to a document.body handler
        // from onMouseLeave so must intercept scheduled hides from mousemove/leave
        // events when trigger contains mouseenter and click, and the tip is
        // currently shown as a result of a click.


        if (instance.props.trigger.indexOf('mouseenter') >= 0 && instance.props.trigger.indexOf('click') >= 0 && ['mouseleave', 'mousemove'].indexOf(event.type) >= 0 && isVisibleFromClick) {
          return;
        }

        var delay = getDelay(false);

        if (delay) {
          hideTimeout = setTimeout(function () {
            if (instance.state.isVisible) {
              instance.hide();
            }
          }, delay);
        } else {
          // Fixes a `transitionend` problem when it fires 1 frame too
          // late sometimes, we don't want hide() to be called.
          scheduleHideAnimationFrame = requestAnimationFrame(function () {
            instance.hide();
          });
        }
      } // ===========================================================================
      // 🔑 Public methods
      // ===========================================================================


      function enable() {
        instance.state.isEnabled = true;
      }

      function disable() {
        // Disabling the instance should also hide it
        // https://github.com/atomiks/tippy.js-react/issues/106
        instance.hide();
        instance.state.isEnabled = false;
      }

      function clearDelayTimeouts() {
        clearTimeout(showTimeout);
        clearTimeout(hideTimeout);
        cancelAnimationFrame(scheduleHideAnimationFrame);
      }

      function setProps(partialProps) {

        if (instance.state.isDestroyed) {
          return;
        }

        invokeHook('onBeforeUpdate', [instance, partialProps]);
        removeListeners();
        var prevProps = instance.props;
        var nextProps = evaluateProps(reference, Object.assign({}, instance.props, {}, partialProps, {
          ignoreAttributes: true
        }));
        instance.props = nextProps;
        addListeners();

        if (prevProps.interactiveDebounce !== nextProps.interactiveDebounce) {
          cleanupInteractiveMouseListeners();
          debouncedOnMouseMove = debounce(onMouseMove, nextProps.interactiveDebounce);
        } // Ensure stale aria-expanded attributes are removed


        if (prevProps.triggerTarget && !nextProps.triggerTarget) {
          normalizeToArray(prevProps.triggerTarget).forEach(function (node) {
            node.removeAttribute('aria-expanded');
          });
        } else if (nextProps.triggerTarget) {
          reference.removeAttribute('aria-expanded');
        }

        handleAriaExpandedAttribute();
        handleStyles();

        if (onUpdate) {
          onUpdate(prevProps, nextProps);
        }

        if (instance.popperInstance) {
          createPopperInstance(); // Fixes an issue with nested tippies if they are all getting re-rendered,
          // and the nested ones get re-rendered first.
          // https://github.com/atomiks/tippyjs-react/issues/177
          // TODO: find a cleaner / more efficient solution(!)

          getNestedPopperTree().forEach(function (nestedPopper) {
            // React (and other UI libs likely) requires a rAF wrapper as it flushes
            // its work in one
            requestAnimationFrame(nestedPopper._tippy.popperInstance.forceUpdate);
          });
        }

        invokeHook('onAfterUpdate', [instance, partialProps]);
      }

      function setContent(content) {
        instance.setProps({
          content: content
        });
      }

      function show() {


        var isAlreadyVisible = instance.state.isVisible;
        var isDestroyed = instance.state.isDestroyed;
        var isDisabled = !instance.state.isEnabled;
        var isTouchAndTouchDisabled = currentInput.isTouch && !instance.props.touch;
        var duration = getValueAtIndexOrReturn(instance.props.duration, 0, defaultProps.duration);

        if (isAlreadyVisible || isDestroyed || isDisabled || isTouchAndTouchDisabled) {
          return;
        } // Normalize `disabled` behavior across browsers.
        // Firefox allows events on disabled elements, but Chrome doesn't.
        // Using a wrapper element (i.e. <span>) is recommended.


        if (getCurrentTarget().hasAttribute('disabled')) {
          return;
        }

        invokeHook('onShow', [instance], false);

        if (instance.props.onShow(instance) === false) {
          return;
        }

        instance.state.isVisible = true;

        if (getIsDefaultRenderFn()) {
          popper.style.visibility = 'visible';
        }

        handleStyles();
        addDocumentMouseDownListener();

        if (!instance.state.isMounted) {
          popper.style.transition = 'none';
        } // If flipping to the opposite side after hiding at least once, the
        // animation will use the wrong placement without resetting the duration


        if (getIsDefaultRenderFn()) {
          var _getDefaultTemplateCh2 = getDefaultTemplateChildren(),
              box = _getDefaultTemplateCh2.box,
              content = _getDefaultTemplateCh2.content;

          setTransitionDuration([box, content], 0);
        }

        onFirstUpdate = function onFirstUpdate() {
          if (!instance.state.isVisible || ignoreOnFirstUpdate) {
            return;
          }

          ignoreOnFirstUpdate = true; // reflow

          void popper.offsetHeight;
          popper.style.transition = instance.props.moveTransition;

          if (getIsDefaultRenderFn() && instance.props.animation) {
            var _getDefaultTemplateCh3 = getDefaultTemplateChildren(),
                _box = _getDefaultTemplateCh3.box,
                _content = _getDefaultTemplateCh3.content;

            setTransitionDuration([_box, _content], duration);
            setVisibilityState([_box, _content], 'visible');
          }

          handleAriaContentAttribute();
          handleAriaExpandedAttribute();
          pushIfUnique(mountedInstances, instance);
          updateIOSClass(true);
          instance.state.isMounted = true;
          invokeHook('onMount', [instance]);

          if (instance.props.animation && getIsDefaultRenderFn()) {
            onTransitionedIn(duration, function () {
              instance.state.isShown = true;
              invokeHook('onShown', [instance]);
            });
          }
        };

        mount();
      }

      function hide() {


        var isAlreadyHidden = !instance.state.isVisible;
        var isDestroyed = instance.state.isDestroyed;
        var isDisabled = !instance.state.isEnabled;
        var duration = getValueAtIndexOrReturn(instance.props.duration, 1, defaultProps.duration);

        if (isAlreadyHidden || isDestroyed || isDisabled) {
          return;
        }

        invokeHook('onHide', [instance], false);

        if (instance.props.onHide(instance) === false) {
          return;
        }

        instance.state.isVisible = false;
        instance.state.isShown = false;
        ignoreOnFirstUpdate = false;

        if (getIsDefaultRenderFn()) {
          popper.style.visibility = 'hidden';
        }

        cleanupInteractiveMouseListeners();
        removeDocumentMouseDownListener();
        handleStyles();

        if (getIsDefaultRenderFn()) {
          var _getDefaultTemplateCh4 = getDefaultTemplateChildren(),
              box = _getDefaultTemplateCh4.box,
              content = _getDefaultTemplateCh4.content;

          if (instance.props.animation) {
            setTransitionDuration([box, content], duration);
            setVisibilityState([box, content], 'hidden');
          }
        }

        handleAriaContentAttribute();
        handleAriaExpandedAttribute();

        if (instance.props.animation) {
          if (getIsDefaultRenderFn()) {
            onTransitionedOut(duration, instance.unmount);
          }
        } else {
          instance.unmount();
        }
      }

      function unmount() {
        if (instance.state.isVisible) {
          instance.hide();
        }

        if (!instance.state.isMounted) {
          return;
        }

        destroyPopperInstance(); // If a popper is not interactive, it will be appended outside the popper
        // tree by default. This seems mainly for interactive tippies, but we should
        // find a workaround if possible

        getNestedPopperTree().forEach(function (nestedPopper) {
          nestedPopper._tippy.unmount();
        });

        if (popper.parentNode) {
          popper.parentNode.removeChild(popper);
        }

        mountedInstances = mountedInstances.filter(function (i) {
          return i !== instance;
        });

        if (mountedInstances.length === 0) {
          updateIOSClass(false);
        }

        instance.state.isMounted = false;
        invokeHook('onHidden', [instance]);
      }

      function destroy() {

        if (instance.state.isDestroyed) {
          return;
        }

        instance.clearDelayTimeouts();
        instance.unmount();
        removeListeners();
        delete reference._tippy;
        instance.state.isDestroyed = true;
        invokeHook('onDestroy', [instance]);
      }
    }

    function tippy$1(targets, optionalProps) {
      if (optionalProps === void 0) {
        optionalProps = {};
      }

      var plugins = defaultProps.plugins.concat(optionalProps.plugins || []);

      bindGlobalEventListeners();
      var passedProps = Object.assign({}, optionalProps, {
        plugins: plugins
      });
      var elements = getArrayOfElements(targets);

      var instances = elements.reduce(function (acc, reference) {
        var instance = reference && createTippy(reference, passedProps);

        if (instance) {
          acc.push(instance);
        }

        return acc;
      }, []);
      return isElement(targets) ? instances[0] : instances;
    }

    tippy$1.defaultProps = defaultProps;
    tippy$1.setDefaultProps = setDefaultProps;
    tippy$1.currentInput = currentInput;

    tippy$1.setDefaultProps({
      render: render
    });

    function tippy(node, props) {
      tippy$1(node, props);
    }

    /* src/lib/filter/FilterButton.svelte generated by Svelte v3.53.1 */
    const file$k = "src/lib/filter/FilterButton.svelte";

    // (95:4) {:else}
    function create_else_block_1$1(ctx) {
    	let button;
    	let t;
    	let button_title_value;
    	let button_id_value;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			button = element("button");
    			t = text(/*value*/ ctx[1]);
    			attr_dev(button, "title", button_title_value = `Click to show "${/*value*/ ctx[1]}"`);
    			attr_dev(button, "id", button_id_value = "filter-" + /*variable*/ ctx[0] + "-" + parseValue(/*value*/ ctx[1]) + "-inactive");
    			attr_dev(button, "class", "inactive-filter filter-item svelte-15mwd52");
    			set_style(button, "background-color", getBgColor(/*variable*/ ctx[0], /*value*/ ctx[1]));
    			add_location(button, file$k, 95, 8, 3154);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			append_dev(button, t);

    			if (!mounted) {
    				dispose = [
    					listen_dev(
    						button,
    						"click",
    						function () {
    							if (is_function(filterData(/*$filterObj*/ ctx[3], [/*value*/ ctx[1]], /*variable*/ ctx[0], /*$data*/ ctx[4], true))) filterData(/*$filterObj*/ ctx[3], [/*value*/ ctx[1]], /*variable*/ ctx[0], /*$data*/ ctx[4], true).apply(this, arguments);
    						},
    						false,
    						false,
    						false
    					),
    					action_destroyer(tippy.call(null, button, /*buttonTippyProps*/ ctx[7]))
    				];

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty & /*value*/ 2) set_data_dev(t, /*value*/ ctx[1]);

    			if (dirty & /*value*/ 2 && button_title_value !== (button_title_value = `Click to show "${/*value*/ ctx[1]}"`)) {
    				attr_dev(button, "title", button_title_value);
    			}

    			if (dirty & /*variable, value*/ 3 && button_id_value !== (button_id_value = "filter-" + /*variable*/ ctx[0] + "-" + parseValue(/*value*/ ctx[1]) + "-inactive")) {
    				attr_dev(button, "id", button_id_value);
    			}

    			if (dirty & /*variable, value*/ 3) {
    				set_style(button, "background-color", getBgColor(/*variable*/ ctx[0], /*value*/ ctx[1]));
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1$1.name,
    		type: "else",
    		source: "(95:4) {:else}",
    		ctx
    	});

    	return block;
    }

    // (85:4) {#if buttonTippyProps.content == null}
    function create_if_block_2$2(ctx) {
    	let button;
    	let t;
    	let button_title_value;
    	let button_id_value;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			button = element("button");
    			t = text(/*value*/ ctx[1]);
    			attr_dev(button, "title", button_title_value = `Click to show "${/*value*/ ctx[1]}"`);
    			attr_dev(button, "id", button_id_value = "filter-" + /*variable*/ ctx[0] + "-" + parseValue(/*value*/ ctx[1]) + "-inactive");
    			attr_dev(button, "class", "inactive-filter filter-item svelte-15mwd52");
    			set_style(button, "background-color", getBgColor(/*variable*/ ctx[0], /*value*/ ctx[1]));
    			add_location(button, file$k, 85, 8, 2772);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			append_dev(button, t);

    			if (!mounted) {
    				dispose = listen_dev(
    					button,
    					"click",
    					function () {
    						if (is_function(filterData(/*$filterObj*/ ctx[3], [/*value*/ ctx[1]], /*variable*/ ctx[0], /*$data*/ ctx[4], true))) filterData(/*$filterObj*/ ctx[3], [/*value*/ ctx[1]], /*variable*/ ctx[0], /*$data*/ ctx[4], true).apply(this, arguments);
    					},
    					false,
    					false,
    					false
    				);

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty & /*value*/ 2) set_data_dev(t, /*value*/ ctx[1]);

    			if (dirty & /*value*/ 2 && button_title_value !== (button_title_value = `Click to show "${/*value*/ ctx[1]}"`)) {
    				attr_dev(button, "title", button_title_value);
    			}

    			if (dirty & /*variable, value*/ 3 && button_id_value !== (button_id_value = "filter-" + /*variable*/ ctx[0] + "-" + parseValue(/*value*/ ctx[1]) + "-inactive")) {
    				attr_dev(button, "id", button_id_value);
    			}

    			if (dirty & /*variable, value*/ 3) {
    				set_style(button, "background-color", getBgColor(/*variable*/ ctx[0], /*value*/ ctx[1]));
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$2.name,
    		type: "if",
    		source: "(85:4) {#if buttonTippyProps.content == null}",
    		ctx
    	});

    	return block;
    }

    // (55:0) {#if activeStatus == true}
    function create_if_block$8(ctx) {
    	let if_block_anchor;

    	function select_block_type_1(ctx, dirty) {
    		if (/*buttonTippyProps*/ ctx[7].content == null) return create_if_block_1$3;
    		return create_else_block$6;
    	}

    	let current_block_type = select_block_type_1(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty$1();
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if_block.p(ctx, dirty);
    		},
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$8.name,
    		type: "if",
    		source: "(55:0) {#if activeStatus == true}",
    		ctx
    	});

    	return block;
    }

    // (69:4) {:else}
    function create_else_block$6(ctx) {
    	let button;
    	let t;
    	let button_title_value;
    	let button_id_value;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			button = element("button");
    			t = text(/*value*/ ctx[1]);
    			attr_dev(button, "title", button_title_value = `Click to filter out "${/*value*/ ctx[1]}".`);
    			attr_dev(button, "id", button_id_value = "filter-" + /*variable*/ ctx[0] + "-" + parseValue(/*value*/ ctx[1]) + "-active");
    			attr_dev(button, "class", "" + (null_to_empty(`active-filter filter-item`) + " svelte-15mwd52"));
    			set_style(button, "background-color", getBgColor(/*variable*/ ctx[0], /*value*/ ctx[1]));
    			add_location(button, file$k, 69, 8, 2132);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			append_dev(button, t);

    			if (!mounted) {
    				dispose = [
    					listen_dev(
    						button,
    						"click",
    						function () {
    							if (is_function(filterData(/*$filterObj*/ ctx[3], [/*value*/ ctx[1]], /*variable*/ ctx[0], /*$data*/ ctx[4], false))) filterData(/*$filterObj*/ ctx[3], [/*value*/ ctx[1]], /*variable*/ ctx[0], /*$data*/ ctx[4], false).apply(this, arguments);
    						},
    						false,
    						false,
    						false
    					),
    					listen_dev(button, "mouseover", /*mouseover_handler_1*/ ctx[11], false, false, false),
    					listen_dev(button, "focus", /*focus_handler_1*/ ctx[12], false, false, false),
    					listen_dev(button, "mouseleave", /*mouseleave_handler_1*/ ctx[13], false, false, false),
    					action_destroyer(tippy.call(null, button, /*buttonTippyProps*/ ctx[7]))
    				];

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty & /*value*/ 2) set_data_dev(t, /*value*/ ctx[1]);

    			if (dirty & /*value*/ 2 && button_title_value !== (button_title_value = `Click to filter out "${/*value*/ ctx[1]}".`)) {
    				attr_dev(button, "title", button_title_value);
    			}

    			if (dirty & /*variable, value*/ 3 && button_id_value !== (button_id_value = "filter-" + /*variable*/ ctx[0] + "-" + parseValue(/*value*/ ctx[1]) + "-active")) {
    				attr_dev(button, "id", button_id_value);
    			}

    			if (dirty & /*variable, value*/ 3) {
    				set_style(button, "background-color", getBgColor(/*variable*/ ctx[0], /*value*/ ctx[1]));
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$6.name,
    		type: "else",
    		source: "(69:4) {:else}",
    		ctx
    	});

    	return block;
    }

    // (56:4) {#if buttonTippyProps.content == null}
    function create_if_block_1$3(ctx) {
    	let button;
    	let t;
    	let button_title_value;
    	let button_id_value;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			button = element("button");
    			t = text(/*value*/ ctx[1]);
    			attr_dev(button, "title", button_title_value = `Click to filter out "${/*value*/ ctx[1]}".`);
    			attr_dev(button, "id", button_id_value = "filter-" + /*variable*/ ctx[0] + "-" + parseValue(/*value*/ ctx[1]) + "-active");
    			attr_dev(button, "class", "" + (null_to_empty(`active-filter filter-item`) + " svelte-15mwd52"));
    			set_style(button, "background-color", getBgColor(/*variable*/ ctx[0], /*value*/ ctx[1]));
    			add_location(button, file$k, 56, 8, 1582);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			append_dev(button, t);

    			if (!mounted) {
    				dispose = [
    					listen_dev(
    						button,
    						"click",
    						function () {
    							if (is_function(filterData(/*$filterObj*/ ctx[3], [/*value*/ ctx[1]], /*variable*/ ctx[0], /*$data*/ ctx[4], false))) filterData(/*$filterObj*/ ctx[3], [/*value*/ ctx[1]], /*variable*/ ctx[0], /*$data*/ ctx[4], false).apply(this, arguments);
    						},
    						false,
    						false,
    						false
    					),
    					listen_dev(button, "mouseover", /*mouseover_handler*/ ctx[8], false, false, false),
    					listen_dev(button, "focus", /*focus_handler*/ ctx[9], false, false, false),
    					listen_dev(button, "mouseleave", /*mouseleave_handler*/ ctx[10], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty & /*value*/ 2) set_data_dev(t, /*value*/ ctx[1]);

    			if (dirty & /*value*/ 2 && button_title_value !== (button_title_value = `Click to filter out "${/*value*/ ctx[1]}".`)) {
    				attr_dev(button, "title", button_title_value);
    			}

    			if (dirty & /*variable, value*/ 3 && button_id_value !== (button_id_value = "filter-" + /*variable*/ ctx[0] + "-" + parseValue(/*value*/ ctx[1]) + "-active")) {
    				attr_dev(button, "id", button_id_value);
    			}

    			if (dirty & /*variable, value*/ 3) {
    				set_style(button, "background-color", getBgColor(/*variable*/ ctx[0], /*value*/ ctx[1]));
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$3.name,
    		type: "if",
    		source: "(56:4) {#if buttonTippyProps.content == null}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$k(ctx) {
    	let if_block_anchor;

    	function select_block_type(ctx, dirty) {
    		if (/*activeStatus*/ ctx[2] == true) return create_if_block$8;
    		if (/*buttonTippyProps*/ ctx[7].content == null) return create_if_block_2$2;
    		return create_else_block_1$1;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty$1();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, [dirty]) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		i: noop$2,
    		o: noop$2,
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$k.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function getBgColor(variable, value) {
    	let colorMap;

    	if (variable == "type") {
    		colorMap = {
    			"Default": "#6b6b6b",
    			"Goddess": "#D7A954",
    			"Heroine": "#8AB67B",
    			"First Name": "#6CB4CC",
    			"Famous Woman": "#C97889",
    			"Other": "#9B9B9B"
    		};

    		return colorMap[value];
    	} else {
    		return "white";
    	}
    }

    function instance$k($$self, $$props, $$invalidate) {
    	let $filterObj;
    	let $data;
    	validate_store(filterObj, 'filterObj');
    	component_subscribe($$self, filterObj, $$value => $$invalidate(3, $filterObj = $$value));
    	validate_store(data, 'data');
    	component_subscribe($$self, data, $$value => $$invalidate(4, $data = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('FilterButton', slots, []);
    	let { variable } = $$props;
    	let { value } = $$props;
    	let { activeStatus } = $$props;

    	function getFeatureDefinition(value) {
    		const found = featureData.find(v => v.feature == String(value).toLowerCase());

    		if (found == undefined) {
    			return null;
    		} else {
    			return found["definition"];
    		}
    	}

    	function highlightBar(value) {
    		const bar = document.querySelector(`#bar-${variable}-${parseValue(value)}`);
    		bar.style.opacity = "100%";
    	}

    	function removeHighlightBar(value) {
    		const bar = document.querySelector(`#bar-${variable}-${parseValue(value)}`);
    		bar.style.opacity = "80%";
    	}

    	const buttonTippyProps = {
    		content: getFeatureDefinition(value),
    		allowHTML: true,
    		arrow: true
    	};

    	$$self.$$.on_mount.push(function () {
    		if (variable === undefined && !('variable' in $$props || $$self.$$.bound[$$self.$$.props['variable']])) {
    			console.warn("<FilterButton> was created without expected prop 'variable'");
    		}

    		if (value === undefined && !('value' in $$props || $$self.$$.bound[$$self.$$.props['value']])) {
    			console.warn("<FilterButton> was created without expected prop 'value'");
    		}

    		if (activeStatus === undefined && !('activeStatus' in $$props || $$self.$$.bound[$$self.$$.props['activeStatus']])) {
    			console.warn("<FilterButton> was created without expected prop 'activeStatus'");
    		}
    	});

    	const writable_props = ['variable', 'value', 'activeStatus'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<FilterButton> was created with unknown prop '${key}'`);
    	});

    	const mouseover_handler = () => highlightBar(value);
    	const focus_handler = () => highlightBar(value);
    	const mouseleave_handler = () => removeHighlightBar(value);
    	const mouseover_handler_1 = () => highlightBar(value);
    	const focus_handler_1 = () => highlightBar(value);
    	const mouseleave_handler_1 = () => removeHighlightBar(value);

    	$$self.$$set = $$props => {
    		if ('variable' in $$props) $$invalidate(0, variable = $$props.variable);
    		if ('value' in $$props) $$invalidate(1, value = $$props.value);
    		if ('activeStatus' in $$props) $$invalidate(2, activeStatus = $$props.activeStatus);
    	};

    	$$self.$capture_state = () => ({
    		filterObj,
    		data,
    		filterData,
    		parseValue,
    		featureData,
    		tippy,
    		variable,
    		value,
    		activeStatus,
    		getFeatureDefinition,
    		getBgColor,
    		highlightBar,
    		removeHighlightBar,
    		buttonTippyProps,
    		$filterObj,
    		$data
    	});

    	$$self.$inject_state = $$props => {
    		if ('variable' in $$props) $$invalidate(0, variable = $$props.variable);
    		if ('value' in $$props) $$invalidate(1, value = $$props.value);
    		if ('activeStatus' in $$props) $$invalidate(2, activeStatus = $$props.activeStatus);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		variable,
    		value,
    		activeStatus,
    		$filterObj,
    		$data,
    		highlightBar,
    		removeHighlightBar,
    		buttonTippyProps,
    		mouseover_handler,
    		focus_handler,
    		mouseleave_handler,
    		mouseover_handler_1,
    		focus_handler_1,
    		mouseleave_handler_1
    	];
    }

    class FilterButton extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$k, create_fragment$k, safe_not_equal, { variable: 0, value: 1, activeStatus: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "FilterButton",
    			options,
    			id: create_fragment$k.name
    		});
    	}

    	get variable() {
    		throw new Error("<FilterButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set variable(value) {
    		throw new Error("<FilterButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get value() {
    		throw new Error("<FilterButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set value(value) {
    		throw new Error("<FilterButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get activeStatus() {
    		throw new Error("<FilterButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set activeStatus(value) {
    		throw new Error("<FilterButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/lib/filter/MiniBar.svelte generated by Svelte v3.53.1 */
    const file$j = "src/lib/filter/MiniBar.svelte";

    function create_fragment$j(ctx) {
    	let div;
    	let div_id_value;
    	let tippy_action;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div = element("div");
    			attr_dev(div, "class", "value-bar svelte-10jg9rj");
    			attr_dev(div, "id", div_id_value = "bar-" + /*variable*/ ctx[1] + "-" + parseValue(/*value*/ ctx[2]));
    			set_style(div, "width", /*width*/ ctx[0] + "%");
    			set_style(div, "background-color", /*bgColor*/ ctx[4]);
    			add_location(div, file$j, 11, 0, 230);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (!mounted) {
    				dispose = action_destroyer(tippy_action = tippy.call(null, div, /*tippyProps*/ ctx[3]));
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*variable, value*/ 6 && div_id_value !== (div_id_value = "bar-" + /*variable*/ ctx[1] + "-" + parseValue(/*value*/ ctx[2]))) {
    				attr_dev(div, "id", div_id_value);
    			}

    			if (dirty & /*width*/ 1) {
    				set_style(div, "width", /*width*/ ctx[0] + "%");
    			}

    			if (dirty & /*bgColor*/ 16) {
    				set_style(div, "background-color", /*bgColor*/ ctx[4]);
    			}

    			if (tippy_action && is_function(tippy_action.update) && dirty & /*tippyProps*/ 8) tippy_action.update.call(null, /*tippyProps*/ ctx[3]);
    		},
    		i: noop$2,
    		o: noop$2,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$j.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$j($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('MiniBar', slots, []);
    	let { width } = $$props;
    	let { variable } = $$props;
    	let { value } = $$props;
    	let { tippyProps } = $$props;
    	let { bgColor } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (width === undefined && !('width' in $$props || $$self.$$.bound[$$self.$$.props['width']])) {
    			console.warn("<MiniBar> was created without expected prop 'width'");
    		}

    		if (variable === undefined && !('variable' in $$props || $$self.$$.bound[$$self.$$.props['variable']])) {
    			console.warn("<MiniBar> was created without expected prop 'variable'");
    		}

    		if (value === undefined && !('value' in $$props || $$self.$$.bound[$$self.$$.props['value']])) {
    			console.warn("<MiniBar> was created without expected prop 'value'");
    		}

    		if (tippyProps === undefined && !('tippyProps' in $$props || $$self.$$.bound[$$self.$$.props['tippyProps']])) {
    			console.warn("<MiniBar> was created without expected prop 'tippyProps'");
    		}

    		if (bgColor === undefined && !('bgColor' in $$props || $$self.$$.bound[$$self.$$.props['bgColor']])) {
    			console.warn("<MiniBar> was created without expected prop 'bgColor'");
    		}
    	});

    	const writable_props = ['width', 'variable', 'value', 'tippyProps', 'bgColor'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<MiniBar> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('width' in $$props) $$invalidate(0, width = $$props.width);
    		if ('variable' in $$props) $$invalidate(1, variable = $$props.variable);
    		if ('value' in $$props) $$invalidate(2, value = $$props.value);
    		if ('tippyProps' in $$props) $$invalidate(3, tippyProps = $$props.tippyProps);
    		if ('bgColor' in $$props) $$invalidate(4, bgColor = $$props.bgColor);
    	};

    	$$self.$capture_state = () => ({
    		parseValue,
    		tippy,
    		width,
    		variable,
    		value,
    		tippyProps,
    		bgColor
    	});

    	$$self.$inject_state = $$props => {
    		if ('width' in $$props) $$invalidate(0, width = $$props.width);
    		if ('variable' in $$props) $$invalidate(1, variable = $$props.variable);
    		if ('value' in $$props) $$invalidate(2, value = $$props.value);
    		if ('tippyProps' in $$props) $$invalidate(3, tippyProps = $$props.tippyProps);
    		if ('bgColor' in $$props) $$invalidate(4, bgColor = $$props.bgColor);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [width, variable, value, tippyProps, bgColor];
    }

    class MiniBar extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$j, create_fragment$j, safe_not_equal, {
    			width: 0,
    			variable: 1,
    			value: 2,
    			tippyProps: 3,
    			bgColor: 4
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "MiniBar",
    			options,
    			id: create_fragment$j.name
    		});
    	}

    	get width() {
    		throw new Error("<MiniBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set width(value) {
    		throw new Error("<MiniBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get variable() {
    		throw new Error("<MiniBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set variable(value) {
    		throw new Error("<MiniBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get value() {
    		throw new Error("<MiniBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set value(value) {
    		throw new Error("<MiniBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get tippyProps() {
    		throw new Error("<MiniBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tippyProps(value) {
    		throw new Error("<MiniBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get bgColor() {
    		throw new Error("<MiniBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set bgColor(value) {
    		throw new Error("<MiniBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    function Transform(k, x, y) {
      this.k = k;
      this.x = x;
      this.y = y;
    }

    Transform.prototype = {
      constructor: Transform,
      scale: function(k) {
        return k === 1 ? this : new Transform(this.k * k, this.x, this.y);
      },
      translate: function(x, y) {
        return x === 0 & y === 0 ? this : new Transform(this.k, this.x + this.k * x, this.y + this.k * y);
      },
      apply: function(point) {
        return [point[0] * this.k + this.x, point[1] * this.k + this.y];
      },
      applyX: function(x) {
        return x * this.k + this.x;
      },
      applyY: function(y) {
        return y * this.k + this.y;
      },
      invert: function(location) {
        return [(location[0] - this.x) / this.k, (location[1] - this.y) / this.k];
      },
      invertX: function(x) {
        return (x - this.x) / this.k;
      },
      invertY: function(y) {
        return (y - this.y) / this.k;
      },
      rescaleX: function(x) {
        return x.copy().domain(x.range().map(this.invertX, this).map(x.invert, x));
      },
      rescaleY: function(y) {
        return y.copy().domain(y.range().map(this.invertY, this).map(y.invert, y));
      },
      toString: function() {
        return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
      }
    };

    new Transform(1, 0, 0);

    Transform.prototype;

    /* src/lib/filter/Filter.svelte generated by Svelte v3.53.1 */
    const file$i = "src/lib/filter/Filter.svelte";

    function get_each_context$3(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[8] = list[i];
    	return child_ctx;
    }

    function get_each_context_1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[11] = list[i];
    	return child_ctx;
    }

    // (60:4) {:else}
    function create_else_block_1(ctx) {
    	let p;
    	let t0;
    	let b;
    	let t1;
    	let t2;
    	let t3_value = /*$filterObj*/ ctx[3][/*variable*/ ctx[0]].length + "";
    	let t3;
    	let t4;

    	const block = {
    		c: function create() {
    			p = element("p");
    			t0 = text("Filter ");
    			b = element("b");
    			t1 = text(/*variable*/ ctx[0]);
    			t2 = text("  (");
    			t3 = text(t3_value);
    			t4 = text(" active)");
    			add_location(b, file$i, 60, 18, 2029);
    			attr_dev(p, "class", "svelte-16lcpap");
    			add_location(p, file$i, 60, 8, 2019);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    			append_dev(p, t0);
    			append_dev(p, b);
    			append_dev(b, t1);
    			append_dev(p, t2);
    			append_dev(p, t3);
    			append_dev(p, t4);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*variable*/ 1) set_data_dev(t1, /*variable*/ ctx[0]);
    			if (dirty & /*$filterObj, variable*/ 9 && t3_value !== (t3_value = /*$filterObj*/ ctx[3][/*variable*/ ctx[0]].length + "")) set_data_dev(t3, t3_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1.name,
    		type: "else",
    		source: "(60:4) {:else}",
    		ctx
    	});

    	return block;
    }

    // (53:4) {#if $isMobile == true}
    function create_if_block_2$1(ctx) {
    	let button;
    	let div;
    	let p0;
    	let t0;
    	let b;
    	let t1;
    	let t2;
    	let span;
    	let t3;
    	let t4_value = /*$filterObj*/ ctx[3][/*variable*/ ctx[0]].length + "";
    	let t4;
    	let t5;
    	let t6;
    	let p1;
    	let raw_value = (/*open*/ ctx[1] == true ? "&#9650;" : "&#9660;") + "";
    	let button_title_value;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			button = element("button");
    			div = element("div");
    			p0 = element("p");
    			t0 = text("Filter ");
    			b = element("b");
    			t1 = text(/*variable*/ ctx[0]);
    			t2 = text("  ");
    			span = element("span");
    			t3 = text("(");
    			t4 = text(t4_value);
    			t5 = text(" active)");
    			t6 = space();
    			p1 = element("p");
    			add_location(b, file$i, 55, 26, 1764);
    			attr_dev(span, "class", "filter-visible-number svelte-16lcpap");
    			add_location(span, file$i, 55, 50, 1788);
    			attr_dev(p0, "class", "svelte-16lcpap");
    			add_location(p0, file$i, 55, 16, 1754);
    			add_location(div, file$i, 54, 12, 1732);
    			attr_dev(p1, "class", "open-close-btn svelte-16lcpap");
    			add_location(p1, file$i, 57, 12, 1905);
    			attr_dev(button, "title", button_title_value = "Click to " + (/*open*/ ctx[1] == true ? 'close' : 'open') + " the " + /*variable*/ ctx[0] + " filter");
    			attr_dev(button, "class", "svelte-16lcpap");
    			add_location(button, file$i, 53, 8, 1609);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			append_dev(button, div);
    			append_dev(div, p0);
    			append_dev(p0, t0);
    			append_dev(p0, b);
    			append_dev(b, t1);
    			append_dev(p0, t2);
    			append_dev(p0, span);
    			append_dev(span, t3);
    			append_dev(span, t4);
    			append_dev(span, t5);
    			append_dev(button, t6);
    			append_dev(button, p1);
    			p1.innerHTML = raw_value;

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*handleButtonClick*/ ctx[6], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*variable*/ 1) set_data_dev(t1, /*variable*/ ctx[0]);
    			if (dirty & /*$filterObj, variable*/ 9 && t4_value !== (t4_value = /*$filterObj*/ ctx[3][/*variable*/ ctx[0]].length + "")) set_data_dev(t4, t4_value);
    			if (dirty & /*open*/ 2 && raw_value !== (raw_value = (/*open*/ ctx[1] == true ? "&#9650;" : "&#9660;") + "")) p1.innerHTML = raw_value;
    			if (dirty & /*open, variable*/ 3 && button_title_value !== (button_title_value = "Click to " + (/*open*/ ctx[1] == true ? 'close' : 'open') + " the " + /*variable*/ ctx[0] + " filter")) {
    				attr_dev(button, "title", button_title_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$1.name,
    		type: "if",
    		source: "(53:4) {#if $isMobile == true}",
    		ctx
    	});

    	return block;
    }

    // (68:8) {#each $percentages[variable] as valuePair}
    function create_each_block_1(ctx) {
    	let minibar;
    	let current;

    	minibar = new MiniBar({
    			props: {
    				width: /*valuePair*/ ctx[11][1],
    				variable: /*variable*/ ctx[0],
    				value: /*valuePair*/ ctx[11][0],
    				tippyProps: getTippyProps(/*valuePair*/ ctx[11]),
    				bgColor: /*getBgColor*/ ctx[7](/*variable*/ ctx[0], /*valuePair*/ ctx[11])
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(minibar.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(minibar, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const minibar_changes = {};
    			if (dirty & /*$percentages, variable*/ 17) minibar_changes.width = /*valuePair*/ ctx[11][1];
    			if (dirty & /*variable*/ 1) minibar_changes.variable = /*variable*/ ctx[0];
    			if (dirty & /*$percentages, variable*/ 17) minibar_changes.value = /*valuePair*/ ctx[11][0];
    			if (dirty & /*$percentages, variable*/ 17) minibar_changes.tippyProps = getTippyProps(/*valuePair*/ ctx[11]);
    			if (dirty & /*variable, $percentages*/ 17) minibar_changes.bgColor = /*getBgColor*/ ctx[7](/*variable*/ ctx[0], /*valuePair*/ ctx[11]);
    			minibar.$set(minibar_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(minibar.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(minibar.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(minibar, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1.name,
    		type: "each",
    		source: "(68:8) {#each $percentages[variable] as valuePair}",
    		ctx
    	});

    	return block;
    }

    // (67:4) {#key $percentages}
    function create_key_block$1(ctx) {
    	let each_1_anchor;
    	let current;
    	let each_value_1 = /*$percentages*/ ctx[4][/*variable*/ ctx[0]];
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty$1();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$percentages, variable, getTippyProps, getBgColor*/ 145) {
    				each_value_1 = /*$percentages*/ ctx[4][/*variable*/ ctx[0]];
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block_1(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value_1.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value_1.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_key_block$1.name,
    		type: "key",
    		source: "(67:4) {#key $percentages}",
    		ctx
    	});

    	return block;
    }

    // (81:0) {#if open}
    function create_if_block$7(ctx) {
    	let div;
    	let current;
    	let each_value = /*allValues*/ ctx[5];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$3(get_each_context$3(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			div = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(div, "class", "filter-buttons");
    			add_location(div, file$i, 81, 4, 2567);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*variable, allValues, $filterObj*/ 41) {
    				each_value = /*allValues*/ ctx[5];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$3(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$3(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(div, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$7.name,
    		type: "if",
    		source: "(81:0) {#if open}",
    		ctx
    	});

    	return block;
    }

    // (86:12) {:else}
    function create_else_block$5(ctx) {
    	let filterbutton;
    	let current;

    	filterbutton = new FilterButton({
    			props: {
    				variable: /*variable*/ ctx[0],
    				value: /*value*/ ctx[8],
    				activeStatus: false
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(filterbutton.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(filterbutton, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const filterbutton_changes = {};
    			if (dirty & /*variable*/ 1) filterbutton_changes.variable = /*variable*/ ctx[0];
    			filterbutton.$set(filterbutton_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(filterbutton.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(filterbutton.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(filterbutton, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$5.name,
    		type: "else",
    		source: "(86:12) {:else}",
    		ctx
    	});

    	return block;
    }

    // (84:12) {#if $filterObj[variable].includes(value)}
    function create_if_block_1$2(ctx) {
    	let filterbutton;
    	let current;

    	filterbutton = new FilterButton({
    			props: {
    				variable: /*variable*/ ctx[0],
    				value: /*value*/ ctx[8],
    				activeStatus: true
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(filterbutton.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(filterbutton, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const filterbutton_changes = {};
    			if (dirty & /*variable*/ 1) filterbutton_changes.variable = /*variable*/ ctx[0];
    			filterbutton.$set(filterbutton_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(filterbutton.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(filterbutton.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(filterbutton, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$2.name,
    		type: "if",
    		source: "(84:12) {#if $filterObj[variable].includes(value)}",
    		ctx
    	});

    	return block;
    }

    // (83:8) {#each allValues as value}
    function create_each_block$3(ctx) {
    	let show_if;
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block_1$2, create_else_block$5];
    	const if_blocks = [];

    	function select_block_type_1(ctx, dirty) {
    		if (dirty & /*$filterObj, variable*/ 9) show_if = null;
    		if (show_if == null) show_if = !!/*$filterObj*/ ctx[3][/*variable*/ ctx[0]].includes(/*value*/ ctx[8]);
    		if (show_if) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_1(ctx, -1);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty$1();
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_1(ctx, dirty);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$3.name,
    		type: "each",
    		source: "(83:8) {#each allValues as value}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$i(ctx) {
    	let div2;
    	let div0;
    	let t0;
    	let div1;
    	let previous_key = /*$percentages*/ ctx[4];
    	let t1;
    	let current;

    	function select_block_type(ctx, dirty) {
    		if (/*$isMobile*/ ctx[2] == true) return create_if_block_2$1;
    		return create_else_block_1;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block0 = current_block_type(ctx);
    	let key_block = create_key_block$1(ctx);
    	let if_block1 = /*open*/ ctx[1] && create_if_block$7(ctx);

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div0 = element("div");
    			if_block0.c();
    			t0 = space();
    			div1 = element("div");
    			key_block.c();
    			t1 = space();
    			if (if_block1) if_block1.c();
    			attr_dev(div0, "class", "filter-header svelte-16lcpap");
    			add_location(div0, file$i, 51, 0, 1545);
    			attr_dev(div1, "class", "bar-container svelte-16lcpap");
    			add_location(div1, file$i, 65, 0, 2128);
    			attr_dev(div2, "class", "filter-group svelte-16lcpap");
    			add_location(div2, file$i, 48, 0, 1500);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div0);
    			if_block0.m(div0, null);
    			append_dev(div2, t0);
    			append_dev(div2, div1);
    			key_block.m(div1, null);
    			append_dev(div2, t1);
    			if (if_block1) if_block1.m(div2, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block0) {
    				if_block0.p(ctx, dirty);
    			} else {
    				if_block0.d(1);
    				if_block0 = current_block_type(ctx);

    				if (if_block0) {
    					if_block0.c();
    					if_block0.m(div0, null);
    				}
    			}

    			if (dirty & /*$percentages*/ 16 && safe_not_equal(previous_key, previous_key = /*$percentages*/ ctx[4])) {
    				group_outros();
    				transition_out(key_block, 1, 1, noop$2);
    				check_outros();
    				key_block = create_key_block$1(ctx);
    				key_block.c();
    				transition_in(key_block, 1);
    				key_block.m(div1, null);
    			} else {
    				key_block.p(ctx, dirty);
    			}

    			if (/*open*/ ctx[1]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty & /*open*/ 2) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block$7(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div2, null);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(key_block);
    			transition_in(if_block1);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(key_block);
    			transition_out(if_block1);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			if_block0.d();
    			key_block.d(detaching);
    			if (if_block1) if_block1.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$i.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function getTippyProps(valuePair) {
    	return {
    		content: `${valuePair[0]}: ${Math.round(valuePair[1])}%`,
    		allowHTML: true,
    		arrow: true
    	};
    }

    function instance$i($$self, $$props, $$invalidate) {
    	let $isMobile;
    	let $filterObj;
    	let $percentages;
    	validate_store(isMobile, 'isMobile');
    	component_subscribe($$self, isMobile, $$value => $$invalidate(2, $isMobile = $$value));
    	validate_store(filterObj, 'filterObj');
    	component_subscribe($$self, filterObj, $$value => $$invalidate(3, $filterObj = $$value));
    	validate_store(percentages, 'percentages');
    	component_subscribe($$self, percentages, $$value => $$invalidate(4, $percentages = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Filter', slots, []);
    	let { variable } = $$props;
    	let open = $isMobile == true ? false : true;
    	const allValues = [...new Set(dataSource.map(d => d[variable]))].sort();

    	function handleButtonClick() {
    		$$invalidate(1, open = !open);
    	} //setPercentages(getPercentages($data, defaultFilters));

    	function getBgColor(variable, valuePair) {
    		if (variable == "type") {
    			const colorMap = {
    				"Default": "#6b6b6b",
    				"Goddess": "#D7A954",
    				"Heroine": "#8AB67B",
    				"First Name": "#6CB4CC",
    				"Famous Woman": "#C97889",
    				"Other": "#9B9B9B"
    			};

    			return colorMap[valuePair[0]];
    		} else {
    			const colors = linear().domain([0, 100]).range(["#181818", "#ffffff"]);
    			return colors(valuePair[1]);
    		}
    	}

    	$$self.$$.on_mount.push(function () {
    		if (variable === undefined && !('variable' in $$props || $$self.$$.bound[$$self.$$.props['variable']])) {
    			console.warn("<Filter> was created without expected prop 'variable'");
    		}
    	});

    	const writable_props = ['variable'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Filter> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('variable' in $$props) $$invalidate(0, variable = $$props.variable);
    	};

    	$$self.$capture_state = () => ({
    		data,
    		filterObj,
    		isMobile,
    		percentages,
    		setPercentages,
    		defaultFilters,
    		getPercentages,
    		writable,
    		dataSource,
    		FilterButton,
    		MiniBar,
    		scaleLinear: linear,
    		variable,
    		open,
    		allValues,
    		handleButtonClick,
    		getTippyProps,
    		getBgColor,
    		$isMobile,
    		$filterObj,
    		$percentages
    	});

    	$$self.$inject_state = $$props => {
    		if ('variable' in $$props) $$invalidate(0, variable = $$props.variable);
    		if ('open' in $$props) $$invalidate(1, open = $$props.open);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		variable,
    		open,
    		$isMobile,
    		$filterObj,
    		$percentages,
    		allValues,
    		handleButtonClick,
    		getBgColor
    	];
    }

    class Filter extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$i, create_fragment$i, safe_not_equal, { variable: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Filter",
    			options,
    			id: create_fragment$i.name
    		});
    	}

    	get variable() {
    		throw new Error("<Filter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set variable(value) {
    		throw new Error("<Filter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/lib/svg/VenusIcon.svelte generated by Svelte v3.53.1 */

    const file$h = "src/lib/svg/VenusIcon.svelte";

    function create_fragment$h(ctx) {
    	let svg;
    	let g;
    	let circle;
    	let path0;
    	let path1;

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			g = svg_element("g");
    			circle = svg_element("circle");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			attr_dev(circle, "id", "border");
    			attr_dev(circle, "cx", "9");
    			attr_dev(circle, "cy", "9");
    			attr_dev(circle, "r", "8");
    			attr_dev(circle, "fill", /*themeBg*/ ctx[1]);
    			attr_dev(circle, "stroke", /*themeFill*/ ctx[0]);
    			attr_dev(circle, "stroke-width", "1.2");
    			add_location(circle, file$h, 8, 4, 280);
    			attr_dev(path0, "id", "big-blob");
    			attr_dev(path0, "d", "M3.15 9.8998L0.900004 8.0998C0.450003 8.9998 0.900005 11.2498 1.35 12.5998C1.81938 14.008 2.85 14.2498 3.6 14.8498L4.95 15.7498H6.3L7.65 15.2998L9 14.3998H9.9L10.8 14.8498L12.6 13.9498V13.0498L13.95 12.5998L14.4 11.6998V10.3498L14.85 9.4498V7.6498L13.5 6.2998L12.6 4.4998L11.25 4.0498H9.9L9.45 4.9498V6.2998L10.35 7.6498L10.8 8.5498V9.4498L9.45 9.8998H8.1L6.3 11.6998H4.5L3.15 9.8998Z");
    			attr_dev(path0, "fill", /*themeFill*/ ctx[0]);
    			add_location(path0, file$h, 9, 4, 379);
    			attr_dev(path1, "id", "left-blob");
    			attr_dev(path1, "d", "M3.6 6.1201L3.96 5.4001L4.68 4.6801L5.4 3.9601L6.84 3.6001L7.47 4.6801L6.84 5.4001L6.48 6.1201H5.76V6.4801V6.8401V7.9201H4.32L3.6 7.5601V6.4801V6.1201Z");
    			attr_dev(path1, "fill", /*themeFill*/ ctx[0]);
    			add_location(path1, file$h, 10, 4, 811);
    			add_location(g, file$h, 7, 4, 272);
    			attr_dev(svg, "class", "venus-icon svelte-adhadr");
    			set_style(svg, "opacity", /*opacityNum*/ ctx[2] + "%");
    			attr_dev(svg, "width", "18");
    			attr_dev(svg, "height", "18");
    			attr_dev(svg, "viewBox", "0 0 18 18");
    			attr_dev(svg, "fill", "none");
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			add_location(svg, file$h, 6, 0, 122);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, g);
    			append_dev(g, circle);
    			append_dev(g, path0);
    			append_dev(g, path1);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*themeBg*/ 2) {
    				attr_dev(circle, "fill", /*themeBg*/ ctx[1]);
    			}

    			if (dirty & /*themeFill*/ 1) {
    				attr_dev(circle, "stroke", /*themeFill*/ ctx[0]);
    			}

    			if (dirty & /*themeFill*/ 1) {
    				attr_dev(path0, "fill", /*themeFill*/ ctx[0]);
    			}

    			if (dirty & /*themeFill*/ 1) {
    				attr_dev(path1, "fill", /*themeFill*/ ctx[0]);
    			}

    			if (dirty & /*opacityNum*/ 4) {
    				set_style(svg, "opacity", /*opacityNum*/ ctx[2] + "%");
    			}
    		},
    		i: noop$2,
    		o: noop$2,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$h.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$h($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('VenusIcon', slots, []);
    	let { themeFill = "white" } = $$props;
    	let { themeBg = "#181818" } = $$props;
    	let { opacityNum = 75 } = $$props;
    	const writable_props = ['themeFill', 'themeBg', 'opacityNum'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<VenusIcon> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('themeFill' in $$props) $$invalidate(0, themeFill = $$props.themeFill);
    		if ('themeBg' in $$props) $$invalidate(1, themeBg = $$props.themeBg);
    		if ('opacityNum' in $$props) $$invalidate(2, opacityNum = $$props.opacityNum);
    	};

    	$$self.$capture_state = () => ({ themeFill, themeBg, opacityNum });

    	$$self.$inject_state = $$props => {
    		if ('themeFill' in $$props) $$invalidate(0, themeFill = $$props.themeFill);
    		if ('themeBg' in $$props) $$invalidate(1, themeBg = $$props.themeBg);
    		if ('opacityNum' in $$props) $$invalidate(2, opacityNum = $$props.opacityNum);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [themeFill, themeBg, opacityNum];
    }

    class VenusIcon extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$h, create_fragment$h, safe_not_equal, { themeFill: 0, themeBg: 1, opacityNum: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "VenusIcon",
    			options,
    			id: create_fragment$h.name
    		});
    	}

    	get themeFill() {
    		throw new Error("<VenusIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set themeFill(value) {
    		throw new Error("<VenusIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get themeBg() {
    		throw new Error("<VenusIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set themeBg(value) {
    		throw new Error("<VenusIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get opacityNum() {
    		throw new Error("<VenusIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set opacityNum(value) {
    		throw new Error("<VenusIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/lib/elements/PageNavigation.svelte generated by Svelte v3.53.1 */
    const file$g = "src/lib/elements/PageNavigation.svelte";

    function get_each_context$2(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[9] = list[i];
    	return child_ctx;
    }

    // (39:16) {:else}
    function create_else_block$4(ctx) {
    	let button;
    	let t_value = /*pageNumber*/ ctx[9] + 1 + "";
    	let t;
    	let button_id_value;
    	let button_class_value;
    	let button_value_value;
    	let button_title_value;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			button = element("button");
    			t = text(t_value);
    			attr_dev(button, "id", button_id_value = "page-button-" + /*pageNumber*/ ctx[9]);

    			attr_dev(button, "class", button_class_value = "" + (null_to_empty(/*pageNumber*/ ctx[9] == /*$page*/ ctx[1]
    			? 'page-button active-page-button'
    			: 'page-button') + " svelte-lilanx"));

    			button.value = button_value_value = /*pageNumber*/ ctx[9];
    			attr_dev(button, "title", button_title_value = "Go to page " + (/*pageNumber*/ ctx[9] + 1));
    			set_style(button, "margin", "2px");
    			add_location(button, file$g, 39, 20, 1655);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			append_dev(button, t);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*click_handler_1*/ ctx[8], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*pageArray*/ 4 && t_value !== (t_value = /*pageNumber*/ ctx[9] + 1 + "")) set_data_dev(t, t_value);

    			if (dirty & /*pageArray*/ 4 && button_id_value !== (button_id_value = "page-button-" + /*pageNumber*/ ctx[9])) {
    				attr_dev(button, "id", button_id_value);
    			}

    			if (dirty & /*pageArray, $page*/ 6 && button_class_value !== (button_class_value = "" + (null_to_empty(/*pageNumber*/ ctx[9] == /*$page*/ ctx[1]
    			? 'page-button active-page-button'
    			: 'page-button') + " svelte-lilanx"))) {
    				attr_dev(button, "class", button_class_value);
    			}

    			if (dirty & /*pageArray*/ 4 && button_value_value !== (button_value_value = /*pageNumber*/ ctx[9])) {
    				prop_dev(button, "value", button_value_value);
    			}

    			if (dirty & /*pageArray*/ 4 && button_title_value !== (button_title_value = "Go to page " + (/*pageNumber*/ ctx[9] + 1))) {
    				attr_dev(button, "title", button_title_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$4.name,
    		type: "else",
    		source: "(39:16) {:else}",
    		ctx
    	});

    	return block;
    }

    // (37:16) {#if pageNumber == "..."}
    function create_if_block$6(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			div.textContent = "...";
    			add_location(div, file$g, 37, 20, 1596);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		p: noop$2,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$6.name,
    		type: "if",
    		source: "(37:16) {#if pageNumber == \\\"...\\\"}",
    		ctx
    	});

    	return block;
    }

    // (36:12) {#each pageArray as pageNumber}
    function create_each_block$2(ctx) {
    	let if_block_anchor;

    	function select_block_type(ctx, dirty) {
    		if (/*pageNumber*/ ctx[9] == "...") return create_if_block$6;
    		return create_else_block$4;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty$1();
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$2.name,
    		type: "each",
    		source: "(36:12) {#each pageArray as pageNumber}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$g(ctx) {
    	let div3;
    	let div1;
    	let button0;
    	let t0;
    	let button0_disabled_value;
    	let t1;
    	let div0;
    	let t2;
    	let button1;
    	let t3;
    	let button1_disabled_value;
    	let t4;
    	let div2;
    	let venusicon;
    	let t5;
    	let p;
    	let current;
    	let mounted;
    	let dispose;
    	let each_value = /*pageArray*/ ctx[2];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$2(get_each_context$2(ctx, each_value, i));
    	}

    	venusicon = new VenusIcon({
    			props: { opacityNum: 50 },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div3 = element("div");
    			div1 = element("div");
    			button0 = element("button");
    			t0 = text("←");
    			t1 = space();
    			div0 = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t2 = space();
    			button1 = element("button");
    			t3 = text("→");
    			t4 = space();
    			div2 = element("div");
    			create_component(venusicon.$$.fragment);
    			t5 = space();
    			p = element("p");
    			p.textContent = "Click on features with this symbol to learn more";
    			attr_dev(button0, "class", "nav-arrow svelte-lilanx");
    			attr_dev(button0, "aria-expanded", "false");
    			attr_dev(button0, "id", "previous-button");
    			attr_dev(button0, "title", "Go to the previous page");
    			button0.disabled = button0_disabled_value = /*$page*/ ctx[1] <= 0;
    			add_location(button0, file$g, 33, 8, 1271);
    			attr_dev(div0, "class", "page-button-group svelte-lilanx");
    			add_location(div0, file$g, 34, 8, 1458);
    			attr_dev(button1, "class", "nav-arrow svelte-lilanx");
    			attr_dev(button1, "aria-expanded", "false");
    			attr_dev(button1, "id", "next-button");
    			attr_dev(button1, "title", "Go to the next page");
    			button1.disabled = button1_disabled_value = /*$page*/ ctx[1] + 1 > /*numberOfPages*/ ctx[0] - 1;
    			add_location(button1, file$g, 43, 8, 1992);
    			attr_dev(div1, "class", "nav-buttons svelte-lilanx");
    			add_location(div1, file$g, 32, 4, 1237);
    			attr_dev(p, "class", "more-info-text svelte-lilanx");
    			add_location(p, file$g, 48, 8, 2275);
    			attr_dev(div2, "class", "more-info-explanation svelte-lilanx");
    			add_location(div2, file$g, 46, 4, 2193);
    			attr_dev(div3, "class", "navbar svelte-lilanx");
    			set_style(div3, "--theme-color", /*themeColor*/ ctx[3]);
    			add_location(div3, file$g, 30, 0, 1085);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div3, anchor);
    			append_dev(div3, div1);
    			append_dev(div1, button0);
    			append_dev(button0, t0);
    			append_dev(div1, t1);
    			append_dev(div1, div0);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div0, null);
    			}

    			append_dev(div1, t2);
    			append_dev(div1, button1);
    			append_dev(button1, t3);
    			append_dev(div3, t4);
    			append_dev(div3, div2);
    			mount_component(venusicon, div2, null);
    			append_dev(div2, t5);
    			append_dev(div2, p);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*click_handler*/ ctx[7], false, false, false),
    					listen_dev(
    						button1,
    						"click",
    						function () {
    							if (is_function(page.set(/*$page*/ ctx[1] + 1))) page.set(/*$page*/ ctx[1] + 1).apply(this, arguments);
    						},
    						false,
    						false,
    						false
    					)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, [dirty]) {
    			ctx = new_ctx;

    			if (!current || dirty & /*$page*/ 2 && button0_disabled_value !== (button0_disabled_value = /*$page*/ ctx[1] <= 0)) {
    				prop_dev(button0, "disabled", button0_disabled_value);
    			}

    			if (dirty & /*pageArray, $page, page, parseInt*/ 6) {
    				each_value = /*pageArray*/ ctx[2];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$2(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$2(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div0, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (!current || dirty & /*$page, numberOfPages*/ 3 && button1_disabled_value !== (button1_disabled_value = /*$page*/ ctx[1] + 1 > /*numberOfPages*/ ctx[0] - 1)) {
    				prop_dev(button1, "disabled", button1_disabled_value);
    			}

    			if (!current || dirty & /*themeColor*/ 8) {
    				set_style(div3, "--theme-color", /*themeColor*/ ctx[3]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(venusicon.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(venusicon.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div3);
    			destroy_each(each_blocks, detaching);
    			destroy_component(venusicon);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$g.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$g($$self, $$props, $$invalidate) {
    	let themeColor;
    	let numberOfPages;
    	let $page;
    	let $cardsPerPage;
    	let $data;
    	let $pageTheme;
    	validate_store(page, 'page');
    	component_subscribe($$self, page, $$value => $$invalidate(1, $page = $$value));
    	validate_store(cardsPerPage, 'cardsPerPage');
    	component_subscribe($$self, cardsPerPage, $$value => $$invalidate(4, $cardsPerPage = $$value));
    	validate_store(data, 'data');
    	component_subscribe($$self, data, $$value => $$invalidate(5, $data = $$value));
    	validate_store(pageTheme, 'pageTheme');
    	component_subscribe($$self, pageTheme, $$value => $$invalidate(6, $pageTheme = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('PageNavigation', slots, []);
    	let pageArray = [];
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<PageNavigation> was created with unknown prop '${key}'`);
    	});

    	const click_handler = e => page.set($page - 1);
    	const click_handler_1 = e => page.set(parseInt(e.target.value));

    	$$self.$capture_state = () => ({
    		page,
    		data,
    		pageTheme,
    		cardsPerPage,
    		getThemeColor,
    		VenusIcon,
    		pageArray,
    		numberOfPages,
    		themeColor,
    		$page,
    		$cardsPerPage,
    		$data,
    		$pageTheme
    	});

    	$$self.$inject_state = $$props => {
    		if ('pageArray' in $$props) $$invalidate(2, pageArray = $$props.pageArray);
    		if ('numberOfPages' in $$props) $$invalidate(0, numberOfPages = $$props.numberOfPages);
    		if ('themeColor' in $$props) $$invalidate(3, themeColor = $$props.themeColor);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$pageTheme*/ 64) {
    			$$invalidate(3, themeColor = getThemeColor($pageTheme, 100, false));
    		}

    		if ($$self.$$.dirty & /*$data, $cardsPerPage*/ 48) {
    			$$invalidate(0, numberOfPages = Math.ceil($data.length / $cardsPerPage));
    		}

    		if ($$self.$$.dirty & /*numberOfPages, $page*/ 3) {
    			// Dynamically show pagination buttons
    			{
    				if (numberOfPages >= 8) {
    					const firstPages = [0, 1, 2];
    					const lastPages = firstPages.map(v => numberOfPages - v - 1).sort((a, b) => a - b);

    					// format the navigation bar
    					if (firstPages.includes($page) || lastPages.includes($page)) {
    						$$invalidate(2, pageArray = [firstPages, "...", lastPages].flat());
    					} else if ($page == Math.max(...firstPages) + 1) {
    						$$invalidate(2, pageArray = [firstPages, $page, "...", lastPages].flat());
    					} else if ($page == Math.min(...lastPages) - 1) {
    						$$invalidate(2, pageArray = [firstPages, "...", $page, lastPages].flat());
    					} else {
    						$$invalidate(2, pageArray = [firstPages, "...", $page, "...", lastPages].flat());
    					}
    				} else {
    					$$invalidate(2, pageArray = [...Array(numberOfPages).keys()]);
    				}
    			}
    		}
    	};

    	return [
    		numberOfPages,
    		$page,
    		pageArray,
    		themeColor,
    		$cardsPerPage,
    		$data,
    		$pageTheme,
    		click_handler,
    		click_handler_1
    	];
    }

    class PageNavigation extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$g, create_fragment$g, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "PageNavigation",
    			options,
    			id: create_fragment$g.name
    		});
    	}
    }

    /**
     * Combines valid class names.
     *
     * @param classes - An array with classes.
     *
     * @return A concatenated string with provided class names.
     */
    function classNames(...classes) {
        return classes.filter(Boolean).join(' ');
    }

    /**
     * Iterates over the provided object by own enumerable keys with calling the iteratee function.
     *
     * @param object   - An object to iterate over.
     * @param iteratee - An iteratee function that takes the value and key as arguments.
     *
     * @return A provided object itself.
     */
    function forOwn$1(object, iteratee) {
        if (object) {
            const keys = Object.keys(object);
            for (let i = 0; i < keys.length; i++) {
                const key = keys[i];
                if (key !== '__proto__') {
                    if (iteratee(object[key], key) === false) {
                        break;
                    }
                }
            }
        }
        return object;
    }

    function getSlides(splide) {
        const children = splide.Components.Elements?.list.children;
        return children && Array.prototype.slice.call(children) || [];
    }

    /**
     * Checks if the given subject is an object or not.
     *
     * @param subject - A subject to check.
     *
     * @return `true` if the subject is an object, or otherwise `false`.
     */
    function isObject$1(subject) {
        return subject !== null && typeof subject === 'object';
    }

    /**
     * Checks if provided two arrays are shallowly equal or not.
     *
     * @param subject1 - An array to test.
     * @param subject2 - Anther array to test.
     *
     * @return `true` if they are considered as equal, or otherwise `false`.
     */
    function isEqualDeep(subject1, subject2) {
        if (Array.isArray(subject1) && Array.isArray(subject2)) {
            return subject1.length === subject2.length
                && !subject1.some((elm, index) => !isEqualDeep(elm, subject2[index]));
        }
        if (isObject$1(subject1) && isObject$1(subject2)) {
            const keys1 = Object.keys(subject1);
            const keys2 = Object.keys(subject2);
            return keys1.length === keys2.length && !keys1.some(key => {
                return !Object.prototype.hasOwnProperty.call(subject2, key)
                    || !isEqualDeep(subject1[key], subject2[key]);
            });
        }
        return subject1 === subject2;
    }

    /**
     * Checks if provided two arrays are shallowly equal or not.
     *
     * @param array1 - An array to test.
     * @param array2 - Anther array to test.
     *
     * @return `true` if they are considered as equal, or otherwise `false`.
     */
    function isEqualShallow(array1, array2) {
        return array1.length === array2.length
            && !array1.some((elm, index) => elm !== array2[index]);
    }

    /**
     * Recursively merges source properties to the object.
     * Be aware that this method does not merge arrays. They are just duplicated by `slice()`.
     *
     * @param object - An object to merge properties to.
     * @param source - A source object to merge properties from.
     *
     * @return A new object with merged properties.
     */
    function merge$1(object, source) {
        const merged = object;
        forOwn$1(source, (value, key) => {
            if (Array.isArray(value)) {
                merged[key] = value.slice();
            }
            else if (isObject$1(value)) {
                merged[key] = merge$1(isObject$1(merged[key]) ? merged[key] : {}, value);
            }
            else {
                merged[key] = value;
            }
        });
        return merged;
    }

    function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

    function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

    /*!
     * Splide.js
     * Version  : 4.1.4
     * License  : MIT
     * Copyright: 2022 Naotoshi Fujita
     */
    var MEDIA_PREFERS_REDUCED_MOTION = "(prefers-reduced-motion: reduce)";
    var CREATED = 1;
    var MOUNTED = 2;
    var IDLE = 3;
    var MOVING = 4;
    var SCROLLING = 5;
    var DRAGGING = 6;
    var DESTROYED = 7;
    var STATES = {
      CREATED: CREATED,
      MOUNTED: MOUNTED,
      IDLE: IDLE,
      MOVING: MOVING,
      SCROLLING: SCROLLING,
      DRAGGING: DRAGGING,
      DESTROYED: DESTROYED
    };

    function empty(array) {
      array.length = 0;
    }

    function slice(arrayLike, start, end) {
      return Array.prototype.slice.call(arrayLike, start, end);
    }

    function apply(func) {
      return func.bind.apply(func, [null].concat(slice(arguments, 1)));
    }

    var nextTick = setTimeout;

    var noop = function noop() {};

    function raf(func) {
      return requestAnimationFrame(func);
    }

    function typeOf(type, subject) {
      return typeof subject === type;
    }

    function isObject(subject) {
      return !isNull(subject) && typeOf("object", subject);
    }

    var isArray = Array.isArray;
    var isFunction = apply(typeOf, "function");
    var isString = apply(typeOf, "string");
    var isUndefined = apply(typeOf, "undefined");

    function isNull(subject) {
      return subject === null;
    }

    function isHTMLElement(subject) {
      try {
        return subject instanceof (subject.ownerDocument.defaultView || window).HTMLElement;
      } catch (e) {
        return false;
      }
    }

    function toArray(value) {
      return isArray(value) ? value : [value];
    }

    function forEach(values, iteratee) {
      toArray(values).forEach(iteratee);
    }

    function includes(array, value) {
      return array.indexOf(value) > -1;
    }

    function push(array, items) {
      array.push.apply(array, toArray(items));
      return array;
    }

    function toggleClass(elm, classes, add) {
      if (elm) {
        forEach(classes, function (name) {
          if (name) {
            elm.classList[add ? "add" : "remove"](name);
          }
        });
      }
    }

    function addClass(elm, classes) {
      toggleClass(elm, isString(classes) ? classes.split(" ") : classes, true);
    }

    function append(parent, children) {
      forEach(children, parent.appendChild.bind(parent));
    }

    function before(nodes, ref) {
      forEach(nodes, function (node) {
        var parent = (ref || node).parentNode;

        if (parent) {
          parent.insertBefore(node, ref);
        }
      });
    }

    function matches(elm, selector) {
      return isHTMLElement(elm) && (elm["msMatchesSelector"] || elm.matches).call(elm, selector);
    }

    function children(parent, selector) {
      var children2 = parent ? slice(parent.children) : [];
      return selector ? children2.filter(function (child) {
        return matches(child, selector);
      }) : children2;
    }

    function child(parent, selector) {
      return selector ? children(parent, selector)[0] : parent.firstElementChild;
    }

    var ownKeys = Object.keys;

    function forOwn(object, iteratee, right) {
      if (object) {
        (right ? ownKeys(object).reverse() : ownKeys(object)).forEach(function (key) {
          key !== "__proto__" && iteratee(object[key], key);
        });
      }

      return object;
    }

    function assign(object) {
      slice(arguments, 1).forEach(function (source) {
        forOwn(source, function (value, key) {
          object[key] = source[key];
        });
      });
      return object;
    }

    function merge(object) {
      slice(arguments, 1).forEach(function (source) {
        forOwn(source, function (value, key) {
          if (isArray(value)) {
            object[key] = value.slice();
          } else if (isObject(value)) {
            object[key] = merge({}, isObject(object[key]) ? object[key] : {}, value);
          } else {
            object[key] = value;
          }
        });
      });
      return object;
    }

    function omit(object, keys) {
      forEach(keys || ownKeys(object), function (key) {
        delete object[key];
      });
    }

    function removeAttribute(elms, attrs) {
      forEach(elms, function (elm) {
        forEach(attrs, function (attr) {
          elm && elm.removeAttribute(attr);
        });
      });
    }

    function setAttribute(elms, attrs, value) {
      if (isObject(attrs)) {
        forOwn(attrs, function (value2, name) {
          setAttribute(elms, name, value2);
        });
      } else {
        forEach(elms, function (elm) {
          isNull(value) || value === "" ? removeAttribute(elm, attrs) : elm.setAttribute(attrs, String(value));
        });
      }
    }

    function create(tag, attrs, parent) {
      var elm = document.createElement(tag);

      if (attrs) {
        isString(attrs) ? addClass(elm, attrs) : setAttribute(elm, attrs);
      }

      parent && append(parent, elm);
      return elm;
    }

    function style(elm, prop, value) {
      if (isUndefined(value)) {
        return getComputedStyle(elm)[prop];
      }

      if (!isNull(value)) {
        elm.style[prop] = "" + value;
      }
    }

    function display(elm, display2) {
      style(elm, "display", display2);
    }

    function focus(elm) {
      elm["setActive"] && elm["setActive"]() || elm.focus({
        preventScroll: true
      });
    }

    function getAttribute(elm, attr) {
      return elm.getAttribute(attr);
    }

    function hasClass(elm, className) {
      return elm && elm.classList.contains(className);
    }

    function rect(target) {
      return target.getBoundingClientRect();
    }

    function remove(nodes) {
      forEach(nodes, function (node) {
        if (node && node.parentNode) {
          node.parentNode.removeChild(node);
        }
      });
    }

    function parseHtml(html) {
      return child(new DOMParser().parseFromString(html, "text/html").body);
    }

    function prevent(e, stopPropagation) {
      e.preventDefault();

      if (stopPropagation) {
        e.stopPropagation();
        e.stopImmediatePropagation();
      }
    }

    function query(parent, selector) {
      return parent && parent.querySelector(selector);
    }

    function queryAll(parent, selector) {
      return selector ? slice(parent.querySelectorAll(selector)) : [];
    }

    function removeClass(elm, classes) {
      toggleClass(elm, classes, false);
    }

    function timeOf(e) {
      return e.timeStamp;
    }

    function unit(value) {
      return isString(value) ? value : value ? value + "px" : "";
    }

    var PROJECT_CODE = "splide";
    var DATA_ATTRIBUTE = "data-" + PROJECT_CODE;

    function assert(condition, message) {
      if (!condition) {
        throw new Error("[" + PROJECT_CODE + "] " + (message || ""));
      }
    }

    var min = Math.min,
        max = Math.max,
        floor = Math.floor,
        ceil = Math.ceil,
        abs = Math.abs;

    function approximatelyEqual(x, y, epsilon) {
      return abs(x - y) < epsilon;
    }

    function between(number, x, y, exclusive) {
      var minimum = min(x, y);
      var maximum = max(x, y);
      return exclusive ? minimum < number && number < maximum : minimum <= number && number <= maximum;
    }

    function clamp(number, x, y) {
      var minimum = min(x, y);
      var maximum = max(x, y);
      return min(max(minimum, number), maximum);
    }

    function sign(x) {
      return +(x > 0) - +(x < 0);
    }

    function format(string, replacements) {
      forEach(replacements, function (replacement) {
        string = string.replace("%s", "" + replacement);
      });
      return string;
    }

    function pad(number) {
      return number < 10 ? "0" + number : "" + number;
    }

    var ids = {};

    function uniqueId(prefix) {
      return "" + prefix + pad(ids[prefix] = (ids[prefix] || 0) + 1);
    }

    function EventBinder() {
      var listeners = [];

      function bind(targets, events, callback, options) {
        forEachEvent(targets, events, function (target, event, namespace) {
          var isEventTarget = ("addEventListener" in target);
          var remover = isEventTarget ? target.removeEventListener.bind(target, event, callback, options) : target["removeListener"].bind(target, callback);
          isEventTarget ? target.addEventListener(event, callback, options) : target["addListener"](callback);
          listeners.push([target, event, namespace, callback, remover]);
        });
      }

      function unbind(targets, events, callback) {
        forEachEvent(targets, events, function (target, event, namespace) {
          listeners = listeners.filter(function (listener) {
            if (listener[0] === target && listener[1] === event && listener[2] === namespace && (!callback || listener[3] === callback)) {
              listener[4]();
              return false;
            }

            return true;
          });
        });
      }

      function dispatch(target, type, detail) {
        var e;
        var bubbles = true;

        if (typeof CustomEvent === "function") {
          e = new CustomEvent(type, {
            bubbles: bubbles,
            detail: detail
          });
        } else {
          e = document.createEvent("CustomEvent");
          e.initCustomEvent(type, bubbles, false, detail);
        }

        target.dispatchEvent(e);
        return e;
      }

      function forEachEvent(targets, events, iteratee) {
        forEach(targets, function (target) {
          target && forEach(events, function (events2) {
            events2.split(" ").forEach(function (eventNS) {
              var fragment = eventNS.split(".");
              iteratee(target, fragment[0], fragment[1]);
            });
          });
        });
      }

      function destroy() {
        listeners.forEach(function (data) {
          data[4]();
        });
        empty(listeners);
      }

      return {
        bind: bind,
        unbind: unbind,
        dispatch: dispatch,
        destroy: destroy
      };
    }

    var EVENT_MOUNTED = "mounted";
    var EVENT_READY = "ready";
    var EVENT_MOVE = "move";
    var EVENT_MOVED = "moved";
    var EVENT_CLICK = "click";
    var EVENT_ACTIVE = "active";
    var EVENT_INACTIVE = "inactive";
    var EVENT_VISIBLE = "visible";
    var EVENT_HIDDEN = "hidden";
    var EVENT_REFRESH = "refresh";
    var EVENT_UPDATED = "updated";
    var EVENT_RESIZE = "resize";
    var EVENT_RESIZED = "resized";
    var EVENT_DRAG = "drag";
    var EVENT_DRAGGING = "dragging";
    var EVENT_DRAGGED = "dragged";
    var EVENT_SCROLL = "scroll";
    var EVENT_SCROLLED = "scrolled";
    var EVENT_OVERFLOW = "overflow";
    var EVENT_DESTROY = "destroy";
    var EVENT_ARROWS_MOUNTED = "arrows:mounted";
    var EVENT_ARROWS_UPDATED = "arrows:updated";
    var EVENT_PAGINATION_MOUNTED = "pagination:mounted";
    var EVENT_PAGINATION_UPDATED = "pagination:updated";
    var EVENT_NAVIGATION_MOUNTED = "navigation:mounted";
    var EVENT_AUTOPLAY_PLAY = "autoplay:play";
    var EVENT_AUTOPLAY_PLAYING = "autoplay:playing";
    var EVENT_AUTOPLAY_PAUSE = "autoplay:pause";
    var EVENT_LAZYLOAD_LOADED = "lazyload:loaded";
    var EVENT_SLIDE_KEYDOWN = "sk";
    var EVENT_SHIFTED = "sh";
    var EVENT_END_INDEX_CHANGED = "ei";

    function EventInterface(Splide2) {
      var bus = Splide2 ? Splide2.event.bus : document.createDocumentFragment();
      var binder = EventBinder();

      function on(events, callback) {
        binder.bind(bus, toArray(events).join(" "), function (e) {
          callback.apply(callback, isArray(e.detail) ? e.detail : []);
        });
      }

      function emit(event) {
        binder.dispatch(bus, event, slice(arguments, 1));
      }

      if (Splide2) {
        Splide2.event.on(EVENT_DESTROY, binder.destroy);
      }

      return assign(binder, {
        bus: bus,
        on: on,
        off: apply(binder.unbind, bus),
        emit: emit
      });
    }

    function RequestInterval(interval, onInterval, onUpdate, limit) {
      var now = Date.now;
      var startTime;
      var rate = 0;
      var id;
      var paused = true;
      var count = 0;

      function update() {
        if (!paused) {
          rate = interval ? min((now() - startTime) / interval, 1) : 1;
          onUpdate && onUpdate(rate);

          if (rate >= 1) {
            onInterval();
            startTime = now();

            if (limit && ++count >= limit) {
              return pause();
            }
          }

          id = raf(update);
        }
      }

      function start(resume) {
        resume || cancel();
        startTime = now() - (resume ? rate * interval : 0);
        paused = false;
        id = raf(update);
      }

      function pause() {
        paused = true;
      }

      function rewind() {
        startTime = now();
        rate = 0;

        if (onUpdate) {
          onUpdate(rate);
        }
      }

      function cancel() {
        id && cancelAnimationFrame(id);
        rate = 0;
        id = 0;
        paused = true;
      }

      function set(time) {
        interval = time;
      }

      function isPaused() {
        return paused;
      }

      return {
        start: start,
        rewind: rewind,
        pause: pause,
        cancel: cancel,
        set: set,
        isPaused: isPaused
      };
    }

    function State(initialState) {
      var state = initialState;

      function set(value) {
        state = value;
      }

      function is(states) {
        return includes(toArray(states), state);
      }

      return {
        set: set,
        is: is
      };
    }

    function Throttle(func, duration) {
      var interval = RequestInterval(duration || 0, func, null, 1);
      return function () {
        interval.isPaused() && interval.start();
      };
    }

    function Media(Splide2, Components2, options) {
      var state = Splide2.state;
      var breakpoints = options.breakpoints || {};
      var reducedMotion = options.reducedMotion || {};
      var binder = EventBinder();
      var queries = [];

      function setup() {
        var isMin = options.mediaQuery === "min";
        ownKeys(breakpoints).sort(function (n, m) {
          return isMin ? +n - +m : +m - +n;
        }).forEach(function (key) {
          register(breakpoints[key], "(" + (isMin ? "min" : "max") + "-width:" + key + "px)");
        });
        register(reducedMotion, MEDIA_PREFERS_REDUCED_MOTION);
        update();
      }

      function destroy(completely) {
        if (completely) {
          binder.destroy();
        }
      }

      function register(options2, query) {
        var queryList = matchMedia(query);
        binder.bind(queryList, "change", update);
        queries.push([options2, queryList]);
      }

      function update() {
        var destroyed = state.is(DESTROYED);
        var direction = options.direction;
        var merged = queries.reduce(function (merged2, entry) {
          return merge(merged2, entry[1].matches ? entry[0] : {});
        }, {});
        omit(options);
        set(merged);

        if (options.destroy) {
          Splide2.destroy(options.destroy === "completely");
        } else if (destroyed) {
          destroy(true);
          Splide2.mount();
        } else {
          direction !== options.direction && Splide2.refresh();
        }
      }

      function reduce(enable) {
        if (matchMedia(MEDIA_PREFERS_REDUCED_MOTION).matches) {
          enable ? merge(options, reducedMotion) : omit(options, ownKeys(reducedMotion));
        }
      }

      function set(opts, base, notify) {
        merge(options, opts);
        base && merge(Object.getPrototypeOf(options), opts);

        if (notify || !state.is(CREATED)) {
          Splide2.emit(EVENT_UPDATED, options);
        }
      }

      return {
        setup: setup,
        destroy: destroy,
        reduce: reduce,
        set: set
      };
    }

    var ARROW = "Arrow";
    var ARROW_LEFT = ARROW + "Left";
    var ARROW_RIGHT = ARROW + "Right";
    var ARROW_UP = ARROW + "Up";
    var ARROW_DOWN = ARROW + "Down";
    var RTL = "rtl";
    var TTB = "ttb";
    var ORIENTATION_MAP = {
      width: ["height"],
      left: ["top", "right"],
      right: ["bottom", "left"],
      x: ["y"],
      X: ["Y"],
      Y: ["X"],
      ArrowLeft: [ARROW_UP, ARROW_RIGHT],
      ArrowRight: [ARROW_DOWN, ARROW_LEFT]
    };

    function Direction(Splide2, Components2, options) {
      function resolve(prop, axisOnly, direction) {
        direction = direction || options.direction;
        var index = direction === RTL && !axisOnly ? 1 : direction === TTB ? 0 : -1;
        return ORIENTATION_MAP[prop] && ORIENTATION_MAP[prop][index] || prop.replace(/width|left|right/i, function (match, offset) {
          var replacement = ORIENTATION_MAP[match.toLowerCase()][index] || match;
          return offset > 0 ? replacement.charAt(0).toUpperCase() + replacement.slice(1) : replacement;
        });
      }

      function orient(value) {
        return value * (options.direction === RTL ? 1 : -1);
      }

      return {
        resolve: resolve,
        orient: orient
      };
    }

    var ROLE = "role";
    var TAB_INDEX = "tabindex";
    var DISABLED = "disabled";
    var ARIA_PREFIX = "aria-";
    var ARIA_CONTROLS = ARIA_PREFIX + "controls";
    var ARIA_CURRENT = ARIA_PREFIX + "current";
    var ARIA_SELECTED = ARIA_PREFIX + "selected";
    var ARIA_LABEL = ARIA_PREFIX + "label";
    var ARIA_LABELLEDBY = ARIA_PREFIX + "labelledby";
    var ARIA_HIDDEN = ARIA_PREFIX + "hidden";
    var ARIA_ORIENTATION = ARIA_PREFIX + "orientation";
    var ARIA_ROLEDESCRIPTION = ARIA_PREFIX + "roledescription";
    var ARIA_LIVE = ARIA_PREFIX + "live";
    var ARIA_BUSY = ARIA_PREFIX + "busy";
    var ARIA_ATOMIC = ARIA_PREFIX + "atomic";
    var ALL_ATTRIBUTES = [ROLE, TAB_INDEX, DISABLED, ARIA_CONTROLS, ARIA_CURRENT, ARIA_LABEL, ARIA_LABELLEDBY, ARIA_HIDDEN, ARIA_ORIENTATION, ARIA_ROLEDESCRIPTION];
    var CLASS_PREFIX = PROJECT_CODE + "__";
    var STATUS_CLASS_PREFIX = "is-";
    var CLASS_ROOT = PROJECT_CODE;
    var CLASS_TRACK = CLASS_PREFIX + "track";
    var CLASS_LIST = CLASS_PREFIX + "list";
    var CLASS_SLIDE = CLASS_PREFIX + "slide";
    var CLASS_CLONE = CLASS_SLIDE + "--clone";
    var CLASS_CONTAINER = CLASS_SLIDE + "__container";
    var CLASS_ARROWS = CLASS_PREFIX + "arrows";
    var CLASS_ARROW = CLASS_PREFIX + "arrow";
    var CLASS_ARROW_PREV = CLASS_ARROW + "--prev";
    var CLASS_ARROW_NEXT = CLASS_ARROW + "--next";
    var CLASS_PAGINATION = CLASS_PREFIX + "pagination";
    var CLASS_PAGINATION_PAGE = CLASS_PAGINATION + "__page";
    var CLASS_PROGRESS = CLASS_PREFIX + "progress";
    var CLASS_PROGRESS_BAR = CLASS_PROGRESS + "__bar";
    var CLASS_TOGGLE = CLASS_PREFIX + "toggle";
    var CLASS_SPINNER = CLASS_PREFIX + "spinner";
    var CLASS_SR = CLASS_PREFIX + "sr";
    var CLASS_INITIALIZED = STATUS_CLASS_PREFIX + "initialized";
    var CLASS_ACTIVE = STATUS_CLASS_PREFIX + "active";
    var CLASS_PREV = STATUS_CLASS_PREFIX + "prev";
    var CLASS_NEXT = STATUS_CLASS_PREFIX + "next";
    var CLASS_VISIBLE = STATUS_CLASS_PREFIX + "visible";
    var CLASS_LOADING = STATUS_CLASS_PREFIX + "loading";
    var CLASS_FOCUS_IN = STATUS_CLASS_PREFIX + "focus-in";
    var CLASS_OVERFLOW = STATUS_CLASS_PREFIX + "overflow";
    var STATUS_CLASSES = [CLASS_ACTIVE, CLASS_VISIBLE, CLASS_PREV, CLASS_NEXT, CLASS_LOADING, CLASS_FOCUS_IN, CLASS_OVERFLOW];
    var CLASSES = {
      slide: CLASS_SLIDE,
      clone: CLASS_CLONE,
      arrows: CLASS_ARROWS,
      arrow: CLASS_ARROW,
      prev: CLASS_ARROW_PREV,
      next: CLASS_ARROW_NEXT,
      pagination: CLASS_PAGINATION,
      page: CLASS_PAGINATION_PAGE,
      spinner: CLASS_SPINNER
    };

    function closest(from, selector) {
      if (isFunction(from.closest)) {
        return from.closest(selector);
      }

      var elm = from;

      while (elm && elm.nodeType === 1) {
        if (matches(elm, selector)) {
          break;
        }

        elm = elm.parentElement;
      }

      return elm;
    }

    var FRICTION = 5;
    var LOG_INTERVAL = 200;
    var POINTER_DOWN_EVENTS = "touchstart mousedown";
    var POINTER_MOVE_EVENTS = "touchmove mousemove";
    var POINTER_UP_EVENTS = "touchend touchcancel mouseup click";

    function Elements(Splide2, Components2, options) {
      var _EventInterface = EventInterface(Splide2),
          on = _EventInterface.on,
          bind = _EventInterface.bind;

      var root = Splide2.root;
      var i18n = options.i18n;
      var elements = {};
      var slides = [];
      var rootClasses = [];
      var trackClasses = [];
      var track;
      var list;
      var isUsingKey;

      function setup() {
        collect();
        init();
        update();
      }

      function mount() {
        on(EVENT_REFRESH, destroy);
        on(EVENT_REFRESH, setup);
        on(EVENT_UPDATED, update);
        bind(document, POINTER_DOWN_EVENTS + " keydown", function (e) {
          isUsingKey = e.type === "keydown";
        }, {
          capture: true
        });
        bind(root, "focusin", function () {
          toggleClass(root, CLASS_FOCUS_IN, !!isUsingKey);
        });
      }

      function destroy(completely) {
        var attrs = ALL_ATTRIBUTES.concat("style");
        empty(slides);
        removeClass(root, rootClasses);
        removeClass(track, trackClasses);
        removeAttribute([track, list], attrs);
        removeAttribute(root, completely ? attrs : ["style", ARIA_ROLEDESCRIPTION]);
      }

      function update() {
        removeClass(root, rootClasses);
        removeClass(track, trackClasses);
        rootClasses = getClasses(CLASS_ROOT);
        trackClasses = getClasses(CLASS_TRACK);
        addClass(root, rootClasses);
        addClass(track, trackClasses);
        setAttribute(root, ARIA_LABEL, options.label);
        setAttribute(root, ARIA_LABELLEDBY, options.labelledby);
      }

      function collect() {
        track = find("." + CLASS_TRACK);
        list = child(track, "." + CLASS_LIST);
        assert(track && list, "A track/list element is missing.");
        push(slides, children(list, "." + CLASS_SLIDE + ":not(." + CLASS_CLONE + ")"));
        forOwn({
          arrows: CLASS_ARROWS,
          pagination: CLASS_PAGINATION,
          prev: CLASS_ARROW_PREV,
          next: CLASS_ARROW_NEXT,
          bar: CLASS_PROGRESS_BAR,
          toggle: CLASS_TOGGLE
        }, function (className, key) {
          elements[key] = find("." + className);
        });
        assign(elements, {
          root: root,
          track: track,
          list: list,
          slides: slides
        });
      }

      function init() {
        var id = root.id || uniqueId(PROJECT_CODE);
        var role = options.role;
        root.id = id;
        track.id = track.id || id + "-track";
        list.id = list.id || id + "-list";

        if (!getAttribute(root, ROLE) && root.tagName !== "SECTION" && role) {
          setAttribute(root, ROLE, role);
        }

        setAttribute(root, ARIA_ROLEDESCRIPTION, i18n.carousel);
        setAttribute(list, ROLE, "presentation");
      }

      function find(selector) {
        var elm = query(root, selector);
        return elm && closest(elm, "." + CLASS_ROOT) === root ? elm : void 0;
      }

      function getClasses(base) {
        return [base + "--" + options.type, base + "--" + options.direction, options.drag && base + "--draggable", options.isNavigation && base + "--nav", base === CLASS_ROOT && CLASS_ACTIVE];
      }

      return assign(elements, {
        setup: setup,
        mount: mount,
        destroy: destroy
      });
    }

    var SLIDE = "slide";
    var LOOP = "loop";
    var FADE = "fade";

    function Slide$1(Splide2, index, slideIndex, slide) {
      var event = EventInterface(Splide2);
      var on = event.on,
          emit = event.emit,
          bind = event.bind;
      var Components = Splide2.Components,
          root = Splide2.root,
          options = Splide2.options;
      var isNavigation = options.isNavigation,
          updateOnMove = options.updateOnMove,
          i18n = options.i18n,
          pagination = options.pagination,
          slideFocus = options.slideFocus;
      var resolve = Components.Direction.resolve;
      var styles = getAttribute(slide, "style");
      var label = getAttribute(slide, ARIA_LABEL);
      var isClone = slideIndex > -1;
      var container = child(slide, "." + CLASS_CONTAINER);
      var destroyed;

      function mount() {
        if (!isClone) {
          slide.id = root.id + "-slide" + pad(index + 1);
          setAttribute(slide, ROLE, pagination ? "tabpanel" : "group");
          setAttribute(slide, ARIA_ROLEDESCRIPTION, i18n.slide);
          setAttribute(slide, ARIA_LABEL, label || format(i18n.slideLabel, [index + 1, Splide2.length]));
        }

        listen();
      }

      function listen() {
        bind(slide, "click", apply(emit, EVENT_CLICK, self));
        bind(slide, "keydown", apply(emit, EVENT_SLIDE_KEYDOWN, self));
        on([EVENT_MOVED, EVENT_SHIFTED, EVENT_SCROLLED], update);
        on(EVENT_NAVIGATION_MOUNTED, initNavigation);

        if (updateOnMove) {
          on(EVENT_MOVE, onMove);
        }
      }

      function destroy() {
        destroyed = true;
        event.destroy();
        removeClass(slide, STATUS_CLASSES);
        removeAttribute(slide, ALL_ATTRIBUTES);
        setAttribute(slide, "style", styles);
        setAttribute(slide, ARIA_LABEL, label || "");
      }

      function initNavigation() {
        var controls = Splide2.splides.map(function (target) {
          var Slide2 = target.splide.Components.Slides.getAt(index);
          return Slide2 ? Slide2.slide.id : "";
        }).join(" ");
        setAttribute(slide, ARIA_LABEL, format(i18n.slideX, (isClone ? slideIndex : index) + 1));
        setAttribute(slide, ARIA_CONTROLS, controls);
        setAttribute(slide, ROLE, slideFocus ? "button" : "");
        slideFocus && removeAttribute(slide, ARIA_ROLEDESCRIPTION);
      }

      function onMove() {
        if (!destroyed) {
          update();
        }
      }

      function update() {
        if (!destroyed) {
          var curr = Splide2.index;
          updateActivity();
          updateVisibility();
          toggleClass(slide, CLASS_PREV, index === curr - 1);
          toggleClass(slide, CLASS_NEXT, index === curr + 1);
        }
      }

      function updateActivity() {
        var active = isActive();

        if (active !== hasClass(slide, CLASS_ACTIVE)) {
          toggleClass(slide, CLASS_ACTIVE, active);
          setAttribute(slide, ARIA_CURRENT, isNavigation && active || "");
          emit(active ? EVENT_ACTIVE : EVENT_INACTIVE, self);
        }
      }

      function updateVisibility() {
        var visible = isVisible();
        var hidden = !visible && (!isActive() || isClone);

        if (!Splide2.state.is([MOVING, SCROLLING])) {
          setAttribute(slide, ARIA_HIDDEN, hidden || "");
        }

        setAttribute(queryAll(slide, options.focusableNodes || ""), TAB_INDEX, hidden ? -1 : "");

        if (slideFocus) {
          setAttribute(slide, TAB_INDEX, hidden ? -1 : 0);
        }

        if (visible !== hasClass(slide, CLASS_VISIBLE)) {
          toggleClass(slide, CLASS_VISIBLE, visible);
          emit(visible ? EVENT_VISIBLE : EVENT_HIDDEN, self);
        }

        if (!visible && document.activeElement === slide) {
          var Slide2 = Components.Slides.getAt(Splide2.index);
          Slide2 && focus(Slide2.slide);
        }
      }

      function style$1(prop, value, useContainer) {
        style(useContainer && container || slide, prop, value);
      }

      function isActive() {
        var curr = Splide2.index;
        return curr === index || options.cloneStatus && curr === slideIndex;
      }

      function isVisible() {
        if (Splide2.is(FADE)) {
          return isActive();
        }

        var trackRect = rect(Components.Elements.track);
        var slideRect = rect(slide);
        var left = resolve("left", true);
        var right = resolve("right", true);
        return floor(trackRect[left]) <= ceil(slideRect[left]) && floor(slideRect[right]) <= ceil(trackRect[right]);
      }

      function isWithin(from, distance) {
        var diff = abs(from - index);

        if (!isClone && (options.rewind || Splide2.is(LOOP))) {
          diff = min(diff, Splide2.length - diff);
        }

        return diff <= distance;
      }

      var self = {
        index: index,
        slideIndex: slideIndex,
        slide: slide,
        container: container,
        isClone: isClone,
        mount: mount,
        destroy: destroy,
        update: update,
        style: style$1,
        isWithin: isWithin
      };
      return self;
    }

    function Slides(Splide2, Components2, options) {
      var _EventInterface2 = EventInterface(Splide2),
          on = _EventInterface2.on,
          emit = _EventInterface2.emit,
          bind = _EventInterface2.bind;

      var _Components2$Elements = Components2.Elements,
          slides = _Components2$Elements.slides,
          list = _Components2$Elements.list;
      var Slides2 = [];

      function mount() {
        init();
        on(EVENT_REFRESH, destroy);
        on(EVENT_REFRESH, init);
      }

      function init() {
        slides.forEach(function (slide, index) {
          register(slide, index, -1);
        });
      }

      function destroy() {
        forEach$1(function (Slide2) {
          Slide2.destroy();
        });
        empty(Slides2);
      }

      function update() {
        forEach$1(function (Slide2) {
          Slide2.update();
        });
      }

      function register(slide, index, slideIndex) {
        var object = Slide$1(Splide2, index, slideIndex, slide);
        object.mount();
        Slides2.push(object);
        Slides2.sort(function (Slide1, Slide2) {
          return Slide1.index - Slide2.index;
        });
      }

      function get(excludeClones) {
        return excludeClones ? filter(function (Slide2) {
          return !Slide2.isClone;
        }) : Slides2;
      }

      function getIn(page) {
        var Controller = Components2.Controller;
        var index = Controller.toIndex(page);
        var max = Controller.hasFocus() ? 1 : options.perPage;
        return filter(function (Slide2) {
          return between(Slide2.index, index, index + max - 1);
        });
      }

      function getAt(index) {
        return filter(index)[0];
      }

      function add(items, index) {
        forEach(items, function (slide) {
          if (isString(slide)) {
            slide = parseHtml(slide);
          }

          if (isHTMLElement(slide)) {
            var ref = slides[index];
            ref ? before(slide, ref) : append(list, slide);
            addClass(slide, options.classes.slide);
            observeImages(slide, apply(emit, EVENT_RESIZE));
          }
        });
        emit(EVENT_REFRESH);
      }

      function remove$1(matcher) {
        remove(filter(matcher).map(function (Slide2) {
          return Slide2.slide;
        }));
        emit(EVENT_REFRESH);
      }

      function forEach$1(iteratee, excludeClones) {
        get(excludeClones).forEach(iteratee);
      }

      function filter(matcher) {
        return Slides2.filter(isFunction(matcher) ? matcher : function (Slide2) {
          return isString(matcher) ? matches(Slide2.slide, matcher) : includes(toArray(matcher), Slide2.index);
        });
      }

      function style(prop, value, useContainer) {
        forEach$1(function (Slide2) {
          Slide2.style(prop, value, useContainer);
        });
      }

      function observeImages(elm, callback) {
        var images = queryAll(elm, "img");
        var length = images.length;

        if (length) {
          images.forEach(function (img) {
            bind(img, "load error", function () {
              if (! --length) {
                callback();
              }
            });
          });
        } else {
          callback();
        }
      }

      function getLength(excludeClones) {
        return excludeClones ? slides.length : Slides2.length;
      }

      function isEnough() {
        return Slides2.length > options.perPage;
      }

      return {
        mount: mount,
        destroy: destroy,
        update: update,
        register: register,
        get: get,
        getIn: getIn,
        getAt: getAt,
        add: add,
        remove: remove$1,
        forEach: forEach$1,
        filter: filter,
        style: style,
        getLength: getLength,
        isEnough: isEnough
      };
    }

    function Layout(Splide2, Components2, options) {
      var _EventInterface3 = EventInterface(Splide2),
          on = _EventInterface3.on,
          bind = _EventInterface3.bind,
          emit = _EventInterface3.emit;

      var Slides = Components2.Slides;
      var resolve = Components2.Direction.resolve;
      var _Components2$Elements2 = Components2.Elements,
          root = _Components2$Elements2.root,
          track = _Components2$Elements2.track,
          list = _Components2$Elements2.list;
      var getAt = Slides.getAt,
          styleSlides = Slides.style;
      var vertical;
      var rootRect;
      var overflow;

      function mount() {
        init();
        bind(window, "resize load", Throttle(apply(emit, EVENT_RESIZE)));
        on([EVENT_UPDATED, EVENT_REFRESH], init);
        on(EVENT_RESIZE, resize);
      }

      function init() {
        vertical = options.direction === TTB;
        style(root, "maxWidth", unit(options.width));
        style(track, resolve("paddingLeft"), cssPadding(false));
        style(track, resolve("paddingRight"), cssPadding(true));
        resize(true);
      }

      function resize(force) {
        var newRect = rect(root);

        if (force || rootRect.width !== newRect.width || rootRect.height !== newRect.height) {
          style(track, "height", cssTrackHeight());
          styleSlides(resolve("marginRight"), unit(options.gap));
          styleSlides("width", cssSlideWidth());
          styleSlides("height", cssSlideHeight(), true);
          rootRect = newRect;
          emit(EVENT_RESIZED);

          if (overflow !== (overflow = isOverflow())) {
            toggleClass(root, CLASS_OVERFLOW, overflow);
            emit(EVENT_OVERFLOW, overflow);
          }
        }
      }

      function cssPadding(right) {
        var padding = options.padding;
        var prop = resolve(right ? "right" : "left");
        return padding && unit(padding[prop] || (isObject(padding) ? 0 : padding)) || "0px";
      }

      function cssTrackHeight() {
        var height = "";

        if (vertical) {
          height = cssHeight();
          assert(height, "height or heightRatio is missing.");
          height = "calc(" + height + " - " + cssPadding(false) + " - " + cssPadding(true) + ")";
        }

        return height;
      }

      function cssHeight() {
        return unit(options.height || rect(list).width * options.heightRatio);
      }

      function cssSlideWidth() {
        return options.autoWidth ? null : unit(options.fixedWidth) || (vertical ? "" : cssSlideSize());
      }

      function cssSlideHeight() {
        return unit(options.fixedHeight) || (vertical ? options.autoHeight ? null : cssSlideSize() : cssHeight());
      }

      function cssSlideSize() {
        var gap = unit(options.gap);
        return "calc((100%" + (gap && " + " + gap) + ")/" + (options.perPage || 1) + (gap && " - " + gap) + ")";
      }

      function listSize() {
        return rect(list)[resolve("width")];
      }

      function slideSize(index, withoutGap) {
        var Slide = getAt(index || 0);
        return Slide ? rect(Slide.slide)[resolve("width")] + (withoutGap ? 0 : getGap()) : 0;
      }

      function totalSize(index, withoutGap) {
        var Slide = getAt(index);

        if (Slide) {
          var right = rect(Slide.slide)[resolve("right")];
          var left = rect(list)[resolve("left")];
          return abs(right - left) + (withoutGap ? 0 : getGap());
        }

        return 0;
      }

      function sliderSize(withoutGap) {
        return totalSize(Splide2.length - 1) - totalSize(0) + slideSize(0, withoutGap);
      }

      function getGap() {
        var Slide = getAt(0);
        return Slide && parseFloat(style(Slide.slide, resolve("marginRight"))) || 0;
      }

      function getPadding(right) {
        return parseFloat(style(track, resolve("padding" + (right ? "Right" : "Left")))) || 0;
      }

      function isOverflow() {
        return Splide2.is(FADE) || sliderSize(true) > listSize();
      }

      return {
        mount: mount,
        resize: resize,
        listSize: listSize,
        slideSize: slideSize,
        sliderSize: sliderSize,
        totalSize: totalSize,
        getPadding: getPadding,
        isOverflow: isOverflow
      };
    }

    var MULTIPLIER = 2;

    function Clones(Splide2, Components2, options) {
      var event = EventInterface(Splide2);
      var on = event.on;
      var Elements = Components2.Elements,
          Slides = Components2.Slides;
      var resolve = Components2.Direction.resolve;
      var clones = [];
      var cloneCount;

      function mount() {
        on(EVENT_REFRESH, remount);
        on([EVENT_UPDATED, EVENT_RESIZE], observe);

        if (cloneCount = computeCloneCount()) {
          generate(cloneCount);
          Components2.Layout.resize(true);
        }
      }

      function remount() {
        destroy();
        mount();
      }

      function destroy() {
        remove(clones);
        empty(clones);
        event.destroy();
      }

      function observe() {
        var count = computeCloneCount();

        if (cloneCount !== count) {
          if (cloneCount < count || !count) {
            event.emit(EVENT_REFRESH);
          }
        }
      }

      function generate(count) {
        var slides = Slides.get().slice();
        var length = slides.length;

        if (length) {
          while (slides.length < count) {
            push(slides, slides);
          }

          push(slides.slice(-count), slides.slice(0, count)).forEach(function (Slide, index) {
            var isHead = index < count;
            var clone = cloneDeep(Slide.slide, index);
            isHead ? before(clone, slides[0].slide) : append(Elements.list, clone);
            push(clones, clone);
            Slides.register(clone, index - count + (isHead ? 0 : length), Slide.index);
          });
        }
      }

      function cloneDeep(elm, index) {
        var clone = elm.cloneNode(true);
        addClass(clone, options.classes.clone);
        clone.id = Splide2.root.id + "-clone" + pad(index + 1);
        return clone;
      }

      function computeCloneCount() {
        var clones2 = options.clones;

        if (!Splide2.is(LOOP)) {
          clones2 = 0;
        } else if (isUndefined(clones2)) {
          var fixedSize = options[resolve("fixedWidth")] && Components2.Layout.slideSize(0);
          var fixedCount = fixedSize && ceil(rect(Elements.track)[resolve("width")] / fixedSize);
          clones2 = fixedCount || options[resolve("autoWidth")] && Splide2.length || options.perPage * MULTIPLIER;
        }

        return clones2;
      }

      return {
        mount: mount,
        destroy: destroy
      };
    }

    function Move(Splide2, Components2, options) {
      var _EventInterface4 = EventInterface(Splide2),
          on = _EventInterface4.on,
          emit = _EventInterface4.emit;

      var set = Splide2.state.set;
      var _Components2$Layout = Components2.Layout,
          slideSize = _Components2$Layout.slideSize,
          getPadding = _Components2$Layout.getPadding,
          totalSize = _Components2$Layout.totalSize,
          listSize = _Components2$Layout.listSize,
          sliderSize = _Components2$Layout.sliderSize;
      var _Components2$Directio = Components2.Direction,
          resolve = _Components2$Directio.resolve,
          orient = _Components2$Directio.orient;
      var _Components2$Elements3 = Components2.Elements,
          list = _Components2$Elements3.list,
          track = _Components2$Elements3.track;
      var Transition;

      function mount() {
        Transition = Components2.Transition;
        on([EVENT_MOUNTED, EVENT_RESIZED, EVENT_UPDATED, EVENT_REFRESH], reposition);
      }

      function reposition() {
        if (!Components2.Controller.isBusy()) {
          Components2.Scroll.cancel();
          jump(Splide2.index);
          Components2.Slides.update();
        }
      }

      function move(dest, index, prev, callback) {
        if (dest !== index && canShift(dest > prev)) {
          cancel();
          translate(shift(getPosition(), dest > prev), true);
        }

        set(MOVING);
        emit(EVENT_MOVE, index, prev, dest);
        Transition.start(index, function () {
          set(IDLE);
          emit(EVENT_MOVED, index, prev, dest);
          callback && callback();
        });
      }

      function jump(index) {
        translate(toPosition(index, true));
      }

      function translate(position, preventLoop) {
        if (!Splide2.is(FADE)) {
          var destination = preventLoop ? position : loop(position);
          style(list, "transform", "translate" + resolve("X") + "(" + destination + "px)");
          position !== destination && emit(EVENT_SHIFTED);
        }
      }

      function loop(position) {
        if (Splide2.is(LOOP)) {
          var index = toIndex(position);
          var exceededMax = index > Components2.Controller.getEnd();
          var exceededMin = index < 0;

          if (exceededMin || exceededMax) {
            position = shift(position, exceededMax);
          }
        }

        return position;
      }

      function shift(position, backwards) {
        var excess = position - getLimit(backwards);
        var size = sliderSize();
        position -= orient(size * (ceil(abs(excess) / size) || 1)) * (backwards ? 1 : -1);
        return position;
      }

      function cancel() {
        translate(getPosition(), true);
        Transition.cancel();
      }

      function toIndex(position) {
        var Slides = Components2.Slides.get();
        var index = 0;
        var minDistance = Infinity;

        for (var i = 0; i < Slides.length; i++) {
          var slideIndex = Slides[i].index;
          var distance = abs(toPosition(slideIndex, true) - position);

          if (distance <= minDistance) {
            minDistance = distance;
            index = slideIndex;
          } else {
            break;
          }
        }

        return index;
      }

      function toPosition(index, trimming) {
        var position = orient(totalSize(index - 1) - offset(index));
        return trimming ? trim(position) : position;
      }

      function getPosition() {
        var left = resolve("left");
        return rect(list)[left] - rect(track)[left] + orient(getPadding(false));
      }

      function trim(position) {
        if (options.trimSpace && Splide2.is(SLIDE)) {
          position = clamp(position, 0, orient(sliderSize(true) - listSize()));
        }

        return position;
      }

      function offset(index) {
        var focus = options.focus;
        return focus === "center" ? (listSize() - slideSize(index, true)) / 2 : +focus * slideSize(index) || 0;
      }

      function getLimit(max) {
        return toPosition(max ? Components2.Controller.getEnd() : 0, !!options.trimSpace);
      }

      function canShift(backwards) {
        var shifted = orient(shift(getPosition(), backwards));
        return backwards ? shifted >= 0 : shifted <= list[resolve("scrollWidth")] - rect(track)[resolve("width")];
      }

      function exceededLimit(max, position) {
        position = isUndefined(position) ? getPosition() : position;
        var exceededMin = max !== true && orient(position) < orient(getLimit(false));
        var exceededMax = max !== false && orient(position) > orient(getLimit(true));
        return exceededMin || exceededMax;
      }

      return {
        mount: mount,
        move: move,
        jump: jump,
        translate: translate,
        shift: shift,
        cancel: cancel,
        toIndex: toIndex,
        toPosition: toPosition,
        getPosition: getPosition,
        getLimit: getLimit,
        exceededLimit: exceededLimit,
        reposition: reposition
      };
    }

    function Controller(Splide2, Components2, options) {
      var _EventInterface5 = EventInterface(Splide2),
          on = _EventInterface5.on,
          emit = _EventInterface5.emit;

      var Move = Components2.Move;
      var getPosition = Move.getPosition,
          getLimit = Move.getLimit,
          toPosition = Move.toPosition;
      var _Components2$Slides = Components2.Slides,
          isEnough = _Components2$Slides.isEnough,
          getLength = _Components2$Slides.getLength;
      var omitEnd = options.omitEnd;
      var isLoop = Splide2.is(LOOP);
      var isSlide = Splide2.is(SLIDE);
      var getNext = apply(getAdjacent, false);
      var getPrev = apply(getAdjacent, true);
      var currIndex = options.start || 0;
      var endIndex;
      var prevIndex = currIndex;
      var slideCount;
      var perMove;
      var perPage;

      function mount() {
        init();
        on([EVENT_UPDATED, EVENT_REFRESH, EVENT_END_INDEX_CHANGED], init);
        on(EVENT_RESIZED, onResized);
      }

      function init() {
        slideCount = getLength(true);
        perMove = options.perMove;
        perPage = options.perPage;
        endIndex = getEnd();
        var index = clamp(currIndex, 0, omitEnd ? endIndex : slideCount - 1);

        if (index !== currIndex) {
          currIndex = index;
          Move.reposition();
        }
      }

      function onResized() {
        if (endIndex !== getEnd()) {
          emit(EVENT_END_INDEX_CHANGED);
        }
      }

      function go(control, allowSameIndex, callback) {
        if (!isBusy()) {
          var dest = parse(control);
          var index = loop(dest);

          if (index > -1 && (allowSameIndex || index !== currIndex)) {
            setIndex(index);
            Move.move(dest, index, prevIndex, callback);
          }
        }
      }

      function scroll(destination, duration, snap, callback) {
        Components2.Scroll.scroll(destination, duration, snap, function () {
          var index = loop(Move.toIndex(getPosition()));
          setIndex(omitEnd ? min(index, endIndex) : index);
          callback && callback();
        });
      }

      function parse(control) {
        var index = currIndex;

        if (isString(control)) {
          var _ref = control.match(/([+\-<>])(\d+)?/) || [],
              indicator = _ref[1],
              number = _ref[2];

          if (indicator === "+" || indicator === "-") {
            index = computeDestIndex(currIndex + +("" + indicator + (+number || 1)), currIndex);
          } else if (indicator === ">") {
            index = number ? toIndex(+number) : getNext(true);
          } else if (indicator === "<") {
            index = getPrev(true);
          }
        } else {
          index = isLoop ? control : clamp(control, 0, endIndex);
        }

        return index;
      }

      function getAdjacent(prev, destination) {
        var number = perMove || (hasFocus() ? 1 : perPage);
        var dest = computeDestIndex(currIndex + number * (prev ? -1 : 1), currIndex, !(perMove || hasFocus()));

        if (dest === -1 && isSlide) {
          if (!approximatelyEqual(getPosition(), getLimit(!prev), 1)) {
            return prev ? 0 : endIndex;
          }
        }

        return destination ? dest : loop(dest);
      }

      function computeDestIndex(dest, from, snapPage) {
        if (isEnough() || hasFocus()) {
          var index = computeMovableDestIndex(dest);

          if (index !== dest) {
            from = dest;
            dest = index;
            snapPage = false;
          }

          if (dest < 0 || dest > endIndex) {
            if (!perMove && (between(0, dest, from, true) || between(endIndex, from, dest, true))) {
              dest = toIndex(toPage(dest));
            } else {
              if (isLoop) {
                dest = snapPage ? dest < 0 ? -(slideCount % perPage || perPage) : slideCount : dest;
              } else if (options.rewind) {
                dest = dest < 0 ? endIndex : 0;
              } else {
                dest = -1;
              }
            }
          } else {
            if (snapPage && dest !== from) {
              dest = toIndex(toPage(from) + (dest < from ? -1 : 1));
            }
          }
        } else {
          dest = -1;
        }

        return dest;
      }

      function computeMovableDestIndex(dest) {
        if (isSlide && options.trimSpace === "move" && dest !== currIndex) {
          var position = getPosition();

          while (position === toPosition(dest, true) && between(dest, 0, Splide2.length - 1, !options.rewind)) {
            dest < currIndex ? --dest : ++dest;
          }
        }

        return dest;
      }

      function loop(index) {
        return isLoop ? (index + slideCount) % slideCount || 0 : index;
      }

      function getEnd() {
        var end = slideCount - (hasFocus() || isLoop && perMove ? 1 : perPage);

        while (omitEnd && end-- > 0) {
          if (toPosition(slideCount - 1, true) !== toPosition(end, true)) {
            end++;
            break;
          }
        }

        return clamp(end, 0, slideCount - 1);
      }

      function toIndex(page) {
        return clamp(hasFocus() ? page : perPage * page, 0, endIndex);
      }

      function toPage(index) {
        return hasFocus() ? min(index, endIndex) : floor((index >= endIndex ? slideCount - 1 : index) / perPage);
      }

      function toDest(destination) {
        var closest = Move.toIndex(destination);
        return isSlide ? clamp(closest, 0, endIndex) : closest;
      }

      function setIndex(index) {
        if (index !== currIndex) {
          prevIndex = currIndex;
          currIndex = index;
        }
      }

      function getIndex(prev) {
        return prev ? prevIndex : currIndex;
      }

      function hasFocus() {
        return !isUndefined(options.focus) || options.isNavigation;
      }

      function isBusy() {
        return Splide2.state.is([MOVING, SCROLLING]) && !!options.waitForTransition;
      }

      return {
        mount: mount,
        go: go,
        scroll: scroll,
        getNext: getNext,
        getPrev: getPrev,
        getAdjacent: getAdjacent,
        getEnd: getEnd,
        setIndex: setIndex,
        getIndex: getIndex,
        toIndex: toIndex,
        toPage: toPage,
        toDest: toDest,
        hasFocus: hasFocus,
        isBusy: isBusy
      };
    }

    var XML_NAME_SPACE = "http://www.w3.org/2000/svg";
    var PATH = "m15.5 0.932-4.3 4.38 14.5 14.6-14.5 14.5 4.3 4.4 14.6-14.6 4.4-4.3-4.4-4.4-14.6-14.6z";
    var SIZE = 40;

    function Arrows(Splide2, Components2, options) {
      var event = EventInterface(Splide2);
      var on = event.on,
          bind = event.bind,
          emit = event.emit;
      var classes = options.classes,
          i18n = options.i18n;
      var Elements = Components2.Elements,
          Controller = Components2.Controller;
      var placeholder = Elements.arrows,
          track = Elements.track;
      var wrapper = placeholder;
      var prev = Elements.prev;
      var next = Elements.next;
      var created;
      var wrapperClasses;
      var arrows = {};

      function mount() {
        init();
        on(EVENT_UPDATED, remount);
      }

      function remount() {
        destroy();
        mount();
      }

      function init() {
        var enabled = options.arrows;

        if (enabled && !(prev && next)) {
          createArrows();
        }

        if (prev && next) {
          assign(arrows, {
            prev: prev,
            next: next
          });
          display(wrapper, enabled ? "" : "none");
          addClass(wrapper, wrapperClasses = CLASS_ARROWS + "--" + options.direction);

          if (enabled) {
            listen();
            update();
            setAttribute([prev, next], ARIA_CONTROLS, track.id);
            emit(EVENT_ARROWS_MOUNTED, prev, next);
          }
        }
      }

      function destroy() {
        event.destroy();
        removeClass(wrapper, wrapperClasses);

        if (created) {
          remove(placeholder ? [prev, next] : wrapper);
          prev = next = null;
        } else {
          removeAttribute([prev, next], ALL_ATTRIBUTES);
        }
      }

      function listen() {
        on([EVENT_MOUNTED, EVENT_MOVED, EVENT_REFRESH, EVENT_SCROLLED, EVENT_END_INDEX_CHANGED], update);
        bind(next, "click", apply(go, ">"));
        bind(prev, "click", apply(go, "<"));
      }

      function go(control) {
        Controller.go(control, true);
      }

      function createArrows() {
        wrapper = placeholder || create("div", classes.arrows);
        prev = createArrow(true);
        next = createArrow(false);
        created = true;
        append(wrapper, [prev, next]);
        !placeholder && before(wrapper, track);
      }

      function createArrow(prev2) {
        var arrow = "<button class=\"" + classes.arrow + " " + (prev2 ? classes.prev : classes.next) + "\" type=\"button\"><svg xmlns=\"" + XML_NAME_SPACE + "\" viewBox=\"0 0 " + SIZE + " " + SIZE + "\" width=\"" + SIZE + "\" height=\"" + SIZE + "\" focusable=\"false\"><path d=\"" + (options.arrowPath || PATH) + "\" />";
        return parseHtml(arrow);
      }

      function update() {
        if (prev && next) {
          var index = Splide2.index;
          var prevIndex = Controller.getPrev();
          var nextIndex = Controller.getNext();
          var prevLabel = prevIndex > -1 && index < prevIndex ? i18n.last : i18n.prev;
          var nextLabel = nextIndex > -1 && index > nextIndex ? i18n.first : i18n.next;
          prev.disabled = prevIndex < 0;
          next.disabled = nextIndex < 0;
          setAttribute(prev, ARIA_LABEL, prevLabel);
          setAttribute(next, ARIA_LABEL, nextLabel);
          emit(EVENT_ARROWS_UPDATED, prev, next, prevIndex, nextIndex);
        }
      }

      return {
        arrows: arrows,
        mount: mount,
        destroy: destroy,
        update: update
      };
    }

    var INTERVAL_DATA_ATTRIBUTE = DATA_ATTRIBUTE + "-interval";

    function Autoplay(Splide2, Components2, options) {
      var _EventInterface6 = EventInterface(Splide2),
          on = _EventInterface6.on,
          bind = _EventInterface6.bind,
          emit = _EventInterface6.emit;

      var interval = RequestInterval(options.interval, Splide2.go.bind(Splide2, ">"), onAnimationFrame);
      var isPaused = interval.isPaused;
      var Elements = Components2.Elements,
          _Components2$Elements4 = Components2.Elements,
          root = _Components2$Elements4.root,
          toggle = _Components2$Elements4.toggle;
      var autoplay = options.autoplay;
      var hovered;
      var focused;
      var stopped = autoplay === "pause";

      function mount() {
        if (autoplay) {
          listen();
          toggle && setAttribute(toggle, ARIA_CONTROLS, Elements.track.id);
          stopped || play();
          update();
        }
      }

      function listen() {
        if (options.pauseOnHover) {
          bind(root, "mouseenter mouseleave", function (e) {
            hovered = e.type === "mouseenter";
            autoToggle();
          });
        }

        if (options.pauseOnFocus) {
          bind(root, "focusin focusout", function (e) {
            focused = e.type === "focusin";
            autoToggle();
          });
        }

        if (toggle) {
          bind(toggle, "click", function () {
            stopped ? play() : pause(true);
          });
        }

        on([EVENT_MOVE, EVENT_SCROLL, EVENT_REFRESH], interval.rewind);
        on(EVENT_MOVE, onMove);
      }

      function play() {
        if (isPaused() && Components2.Slides.isEnough()) {
          interval.start(!options.resetProgress);
          focused = hovered = stopped = false;
          update();
          emit(EVENT_AUTOPLAY_PLAY);
        }
      }

      function pause(stop) {
        if (stop === void 0) {
          stop = true;
        }

        stopped = !!stop;
        update();

        if (!isPaused()) {
          interval.pause();
          emit(EVENT_AUTOPLAY_PAUSE);
        }
      }

      function autoToggle() {
        if (!stopped) {
          hovered || focused ? pause(false) : play();
        }
      }

      function update() {
        if (toggle) {
          toggleClass(toggle, CLASS_ACTIVE, !stopped);
          setAttribute(toggle, ARIA_LABEL, options.i18n[stopped ? "play" : "pause"]);
        }
      }

      function onAnimationFrame(rate) {
        var bar = Elements.bar;
        bar && style(bar, "width", rate * 100 + "%");
        emit(EVENT_AUTOPLAY_PLAYING, rate);
      }

      function onMove(index) {
        var Slide = Components2.Slides.getAt(index);
        interval.set(Slide && +getAttribute(Slide.slide, INTERVAL_DATA_ATTRIBUTE) || options.interval);
      }

      return {
        mount: mount,
        destroy: interval.cancel,
        play: play,
        pause: pause,
        isPaused: isPaused
      };
    }

    function Cover(Splide2, Components2, options) {
      var _EventInterface7 = EventInterface(Splide2),
          on = _EventInterface7.on;

      function mount() {
        if (options.cover) {
          on(EVENT_LAZYLOAD_LOADED, apply(toggle, true));
          on([EVENT_MOUNTED, EVENT_UPDATED, EVENT_REFRESH], apply(cover, true));
        }
      }

      function cover(cover2) {
        Components2.Slides.forEach(function (Slide) {
          var img = child(Slide.container || Slide.slide, "img");

          if (img && img.src) {
            toggle(cover2, img, Slide);
          }
        });
      }

      function toggle(cover2, img, Slide) {
        Slide.style("background", cover2 ? "center/cover no-repeat url(\"" + img.src + "\")" : "", true);
        display(img, cover2 ? "none" : "");
      }

      return {
        mount: mount,
        destroy: apply(cover, false)
      };
    }

    var BOUNCE_DIFF_THRESHOLD = 10;
    var BOUNCE_DURATION = 600;
    var FRICTION_FACTOR = 0.6;
    var BASE_VELOCITY = 1.5;
    var MIN_DURATION = 800;

    function Scroll(Splide2, Components2, options) {
      var _EventInterface8 = EventInterface(Splide2),
          on = _EventInterface8.on,
          emit = _EventInterface8.emit;

      var set = Splide2.state.set;
      var Move = Components2.Move;
      var getPosition = Move.getPosition,
          getLimit = Move.getLimit,
          exceededLimit = Move.exceededLimit,
          translate = Move.translate;
      var isSlide = Splide2.is(SLIDE);
      var interval;
      var callback;
      var friction = 1;

      function mount() {
        on(EVENT_MOVE, clear);
        on([EVENT_UPDATED, EVENT_REFRESH], cancel);
      }

      function scroll(destination, duration, snap, onScrolled, noConstrain) {
        var from = getPosition();
        clear();

        if (snap && (!isSlide || !exceededLimit())) {
          var size = Components2.Layout.sliderSize();
          var offset = sign(destination) * size * floor(abs(destination) / size) || 0;
          destination = Move.toPosition(Components2.Controller.toDest(destination % size)) + offset;
        }

        var noDistance = approximatelyEqual(from, destination, 1);
        friction = 1;
        duration = noDistance ? 0 : duration || max(abs(destination - from) / BASE_VELOCITY, MIN_DURATION);
        callback = onScrolled;
        interval = RequestInterval(duration, onEnd, apply(update, from, destination, noConstrain), 1);
        set(SCROLLING);
        emit(EVENT_SCROLL);
        interval.start();
      }

      function onEnd() {
        set(IDLE);
        callback && callback();
        emit(EVENT_SCROLLED);
      }

      function update(from, to, noConstrain, rate) {
        var position = getPosition();
        var target = from + (to - from) * easing(rate);
        var diff = (target - position) * friction;
        translate(position + diff);

        if (isSlide && !noConstrain && exceededLimit()) {
          friction *= FRICTION_FACTOR;

          if (abs(diff) < BOUNCE_DIFF_THRESHOLD) {
            scroll(getLimit(exceededLimit(true)), BOUNCE_DURATION, false, callback, true);
          }
        }
      }

      function clear() {
        if (interval) {
          interval.cancel();
        }
      }

      function cancel() {
        if (interval && !interval.isPaused()) {
          clear();
          onEnd();
        }
      }

      function easing(t) {
        var easingFunc = options.easingFunc;
        return easingFunc ? easingFunc(t) : 1 - Math.pow(1 - t, 4);
      }

      return {
        mount: mount,
        destroy: clear,
        scroll: scroll,
        cancel: cancel
      };
    }

    var SCROLL_LISTENER_OPTIONS = {
      passive: false,
      capture: true
    };

    function Drag(Splide2, Components2, options) {
      var _EventInterface9 = EventInterface(Splide2),
          on = _EventInterface9.on,
          emit = _EventInterface9.emit,
          bind = _EventInterface9.bind,
          unbind = _EventInterface9.unbind;

      var state = Splide2.state;
      var Move = Components2.Move,
          Scroll = Components2.Scroll,
          Controller = Components2.Controller,
          track = Components2.Elements.track,
          reduce = Components2.Media.reduce;
      var _Components2$Directio2 = Components2.Direction,
          resolve = _Components2$Directio2.resolve,
          orient = _Components2$Directio2.orient;
      var getPosition = Move.getPosition,
          exceededLimit = Move.exceededLimit;
      var basePosition;
      var baseEvent;
      var prevBaseEvent;
      var isFree;
      var dragging;
      var exceeded = false;
      var clickPrevented;
      var disabled;
      var target;

      function mount() {
        bind(track, POINTER_MOVE_EVENTS, noop, SCROLL_LISTENER_OPTIONS);
        bind(track, POINTER_UP_EVENTS, noop, SCROLL_LISTENER_OPTIONS);
        bind(track, POINTER_DOWN_EVENTS, onPointerDown, SCROLL_LISTENER_OPTIONS);
        bind(track, "click", onClick, {
          capture: true
        });
        bind(track, "dragstart", prevent);
        on([EVENT_MOUNTED, EVENT_UPDATED], init);
      }

      function init() {
        var drag = options.drag;
        disable(!drag);
        isFree = drag === "free";
      }

      function onPointerDown(e) {
        clickPrevented = false;

        if (!disabled) {
          var isTouch = isTouchEvent(e);

          if (isDraggable(e.target) && (isTouch || !e.button)) {
            if (!Controller.isBusy()) {
              target = isTouch ? track : window;
              dragging = state.is([MOVING, SCROLLING]);
              prevBaseEvent = null;
              bind(target, POINTER_MOVE_EVENTS, onPointerMove, SCROLL_LISTENER_OPTIONS);
              bind(target, POINTER_UP_EVENTS, onPointerUp, SCROLL_LISTENER_OPTIONS);
              Move.cancel();
              Scroll.cancel();
              save(e);
            } else {
              prevent(e, true);
            }
          }
        }
      }

      function onPointerMove(e) {
        if (!state.is(DRAGGING)) {
          state.set(DRAGGING);
          emit(EVENT_DRAG);
        }

        if (e.cancelable) {
          if (dragging) {
            Move.translate(basePosition + constrain(diffCoord(e)));
            var expired = diffTime(e) > LOG_INTERVAL;
            var hasExceeded = exceeded !== (exceeded = exceededLimit());

            if (expired || hasExceeded) {
              save(e);
            }

            clickPrevented = true;
            emit(EVENT_DRAGGING);
            prevent(e);
          } else if (isSliderDirection(e)) {
            dragging = shouldStart(e);
            prevent(e);
          }
        }
      }

      function onPointerUp(e) {
        if (state.is(DRAGGING)) {
          state.set(IDLE);
          emit(EVENT_DRAGGED);
        }

        if (dragging) {
          move(e);
          prevent(e);
        }

        unbind(target, POINTER_MOVE_EVENTS, onPointerMove);
        unbind(target, POINTER_UP_EVENTS, onPointerUp);
        dragging = false;
      }

      function onClick(e) {
        if (!disabled && clickPrevented) {
          prevent(e, true);
        }
      }

      function save(e) {
        prevBaseEvent = baseEvent;
        baseEvent = e;
        basePosition = getPosition();
      }

      function move(e) {
        var velocity = computeVelocity(e);
        var destination = computeDestination(velocity);
        var rewind = options.rewind && options.rewindByDrag;
        reduce(false);

        if (isFree) {
          Controller.scroll(destination, 0, options.snap);
        } else if (Splide2.is(FADE)) {
          Controller.go(orient(sign(velocity)) < 0 ? rewind ? "<" : "-" : rewind ? ">" : "+");
        } else if (Splide2.is(SLIDE) && exceeded && rewind) {
          Controller.go(exceededLimit(true) ? ">" : "<");
        } else {
          Controller.go(Controller.toDest(destination), true);
        }

        reduce(true);
      }

      function shouldStart(e) {
        var thresholds = options.dragMinThreshold;
        var isObj = isObject(thresholds);
        var mouse = isObj && thresholds.mouse || 0;
        var touch = (isObj ? thresholds.touch : +thresholds) || 10;
        return abs(diffCoord(e)) > (isTouchEvent(e) ? touch : mouse);
      }

      function isSliderDirection(e) {
        return abs(diffCoord(e)) > abs(diffCoord(e, true));
      }

      function computeVelocity(e) {
        if (Splide2.is(LOOP) || !exceeded) {
          var time = diffTime(e);

          if (time && time < LOG_INTERVAL) {
            return diffCoord(e) / time;
          }
        }

        return 0;
      }

      function computeDestination(velocity) {
        return getPosition() + sign(velocity) * min(abs(velocity) * (options.flickPower || 600), isFree ? Infinity : Components2.Layout.listSize() * (options.flickMaxPages || 1));
      }

      function diffCoord(e, orthogonal) {
        return coordOf(e, orthogonal) - coordOf(getBaseEvent(e), orthogonal);
      }

      function diffTime(e) {
        return timeOf(e) - timeOf(getBaseEvent(e));
      }

      function getBaseEvent(e) {
        return baseEvent === e && prevBaseEvent || baseEvent;
      }

      function coordOf(e, orthogonal) {
        return (isTouchEvent(e) ? e.changedTouches[0] : e)["page" + resolve(orthogonal ? "Y" : "X")];
      }

      function constrain(diff) {
        return diff / (exceeded && Splide2.is(SLIDE) ? FRICTION : 1);
      }

      function isDraggable(target2) {
        var noDrag = options.noDrag;
        return !matches(target2, "." + CLASS_PAGINATION_PAGE + ", ." + CLASS_ARROW) && (!noDrag || !matches(target2, noDrag));
      }

      function isTouchEvent(e) {
        return typeof TouchEvent !== "undefined" && e instanceof TouchEvent;
      }

      function isDragging() {
        return dragging;
      }

      function disable(value) {
        disabled = value;
      }

      return {
        mount: mount,
        disable: disable,
        isDragging: isDragging
      };
    }

    var NORMALIZATION_MAP = {
      Spacebar: " ",
      Right: ARROW_RIGHT,
      Left: ARROW_LEFT,
      Up: ARROW_UP,
      Down: ARROW_DOWN
    };

    function normalizeKey(key) {
      key = isString(key) ? key : key.key;
      return NORMALIZATION_MAP[key] || key;
    }

    var KEYBOARD_EVENT = "keydown";

    function Keyboard(Splide2, Components2, options) {
      var _EventInterface10 = EventInterface(Splide2),
          on = _EventInterface10.on,
          bind = _EventInterface10.bind,
          unbind = _EventInterface10.unbind;

      var root = Splide2.root;
      var resolve = Components2.Direction.resolve;
      var target;
      var disabled;

      function mount() {
        init();
        on(EVENT_UPDATED, destroy);
        on(EVENT_UPDATED, init);
        on(EVENT_MOVE, onMove);
      }

      function init() {
        var keyboard = options.keyboard;

        if (keyboard) {
          target = keyboard === "global" ? window : root;
          bind(target, KEYBOARD_EVENT, onKeydown);
        }
      }

      function destroy() {
        unbind(target, KEYBOARD_EVENT);
      }

      function disable(value) {
        disabled = value;
      }

      function onMove() {
        var _disabled = disabled;
        disabled = true;
        nextTick(function () {
          disabled = _disabled;
        });
      }

      function onKeydown(e) {
        if (!disabled) {
          var key = normalizeKey(e);

          if (key === resolve(ARROW_LEFT)) {
            Splide2.go("<");
          } else if (key === resolve(ARROW_RIGHT)) {
            Splide2.go(">");
          }
        }
      }

      return {
        mount: mount,
        destroy: destroy,
        disable: disable
      };
    }

    var SRC_DATA_ATTRIBUTE = DATA_ATTRIBUTE + "-lazy";
    var SRCSET_DATA_ATTRIBUTE = SRC_DATA_ATTRIBUTE + "-srcset";
    var IMAGE_SELECTOR = "[" + SRC_DATA_ATTRIBUTE + "], [" + SRCSET_DATA_ATTRIBUTE + "]";

    function LazyLoad(Splide2, Components2, options) {
      var _EventInterface11 = EventInterface(Splide2),
          on = _EventInterface11.on,
          off = _EventInterface11.off,
          bind = _EventInterface11.bind,
          emit = _EventInterface11.emit;

      var isSequential = options.lazyLoad === "sequential";
      var events = [EVENT_MOVED, EVENT_SCROLLED];
      var entries = [];

      function mount() {
        if (options.lazyLoad) {
          init();
          on(EVENT_REFRESH, init);
        }
      }

      function init() {
        empty(entries);
        register();

        if (isSequential) {
          loadNext();
        } else {
          off(events);
          on(events, check);
          check();
        }
      }

      function register() {
        Components2.Slides.forEach(function (Slide) {
          queryAll(Slide.slide, IMAGE_SELECTOR).forEach(function (img) {
            var src = getAttribute(img, SRC_DATA_ATTRIBUTE);
            var srcset = getAttribute(img, SRCSET_DATA_ATTRIBUTE);

            if (src !== img.src || srcset !== img.srcset) {
              var className = options.classes.spinner;
              var parent = img.parentElement;
              var spinner = child(parent, "." + className) || create("span", className, parent);
              entries.push([img, Slide, spinner]);
              img.src || display(img, "none");
            }
          });
        });
      }

      function check() {
        entries = entries.filter(function (data) {
          var distance = options.perPage * ((options.preloadPages || 1) + 1) - 1;
          return data[1].isWithin(Splide2.index, distance) ? load(data) : true;
        });
        entries.length || off(events);
      }

      function load(data) {
        var img = data[0];
        addClass(data[1].slide, CLASS_LOADING);
        bind(img, "load error", apply(onLoad, data));
        setAttribute(img, "src", getAttribute(img, SRC_DATA_ATTRIBUTE));
        setAttribute(img, "srcset", getAttribute(img, SRCSET_DATA_ATTRIBUTE));
        removeAttribute(img, SRC_DATA_ATTRIBUTE);
        removeAttribute(img, SRCSET_DATA_ATTRIBUTE);
      }

      function onLoad(data, e) {
        var img = data[0],
            Slide = data[1];
        removeClass(Slide.slide, CLASS_LOADING);

        if (e.type !== "error") {
          remove(data[2]);
          display(img, "");
          emit(EVENT_LAZYLOAD_LOADED, img, Slide);
          emit(EVENT_RESIZE);
        }

        isSequential && loadNext();
      }

      function loadNext() {
        entries.length && load(entries.shift());
      }

      return {
        mount: mount,
        destroy: apply(empty, entries),
        check: check
      };
    }

    function Pagination(Splide2, Components2, options) {
      var event = EventInterface(Splide2);
      var on = event.on,
          emit = event.emit,
          bind = event.bind;
      var Slides = Components2.Slides,
          Elements = Components2.Elements,
          Controller = Components2.Controller;
      var hasFocus = Controller.hasFocus,
          getIndex = Controller.getIndex,
          go = Controller.go;
      var resolve = Components2.Direction.resolve;
      var placeholder = Elements.pagination;
      var items = [];
      var list;
      var paginationClasses;

      function mount() {
        destroy();
        on([EVENT_UPDATED, EVENT_REFRESH, EVENT_END_INDEX_CHANGED], mount);
        var enabled = options.pagination;
        placeholder && display(placeholder, enabled ? "" : "none");

        if (enabled) {
          on([EVENT_MOVE, EVENT_SCROLL, EVENT_SCROLLED], update);
          createPagination();
          update();
          emit(EVENT_PAGINATION_MOUNTED, {
            list: list,
            items: items
          }, getAt(Splide2.index));
        }
      }

      function destroy() {
        if (list) {
          remove(placeholder ? slice(list.children) : list);
          removeClass(list, paginationClasses);
          empty(items);
          list = null;
        }

        event.destroy();
      }

      function createPagination() {
        var length = Splide2.length;
        var classes = options.classes,
            i18n = options.i18n,
            perPage = options.perPage;
        var max = hasFocus() ? Controller.getEnd() + 1 : ceil(length / perPage);
        list = placeholder || create("ul", classes.pagination, Elements.track.parentElement);
        addClass(list, paginationClasses = CLASS_PAGINATION + "--" + getDirection());
        setAttribute(list, ROLE, "tablist");
        setAttribute(list, ARIA_LABEL, i18n.select);
        setAttribute(list, ARIA_ORIENTATION, getDirection() === TTB ? "vertical" : "");

        for (var i = 0; i < max; i++) {
          var li = create("li", null, list);
          var button = create("button", {
            class: classes.page,
            type: "button"
          }, li);
          var controls = Slides.getIn(i).map(function (Slide) {
            return Slide.slide.id;
          });
          var text = !hasFocus() && perPage > 1 ? i18n.pageX : i18n.slideX;
          bind(button, "click", apply(onClick, i));

          if (options.paginationKeyboard) {
            bind(button, "keydown", apply(onKeydown, i));
          }

          setAttribute(li, ROLE, "presentation");
          setAttribute(button, ROLE, "tab");
          setAttribute(button, ARIA_CONTROLS, controls.join(" "));
          setAttribute(button, ARIA_LABEL, format(text, i + 1));
          setAttribute(button, TAB_INDEX, -1);
          items.push({
            li: li,
            button: button,
            page: i
          });
        }
      }

      function onClick(page) {
        go(">" + page, true);
      }

      function onKeydown(page, e) {
        var length = items.length;
        var key = normalizeKey(e);
        var dir = getDirection();
        var nextPage = -1;

        if (key === resolve(ARROW_RIGHT, false, dir)) {
          nextPage = ++page % length;
        } else if (key === resolve(ARROW_LEFT, false, dir)) {
          nextPage = (--page + length) % length;
        } else if (key === "Home") {
          nextPage = 0;
        } else if (key === "End") {
          nextPage = length - 1;
        }

        var item = items[nextPage];

        if (item) {
          focus(item.button);
          go(">" + nextPage);
          prevent(e, true);
        }
      }

      function getDirection() {
        return options.paginationDirection || options.direction;
      }

      function getAt(index) {
        return items[Controller.toPage(index)];
      }

      function update() {
        var prev = getAt(getIndex(true));
        var curr = getAt(getIndex());

        if (prev) {
          var button = prev.button;
          removeClass(button, CLASS_ACTIVE);
          removeAttribute(button, ARIA_SELECTED);
          setAttribute(button, TAB_INDEX, -1);
        }

        if (curr) {
          var _button = curr.button;
          addClass(_button, CLASS_ACTIVE);
          setAttribute(_button, ARIA_SELECTED, true);
          setAttribute(_button, TAB_INDEX, "");
        }

        emit(EVENT_PAGINATION_UPDATED, {
          list: list,
          items: items
        }, prev, curr);
      }

      return {
        items: items,
        mount: mount,
        destroy: destroy,
        getAt: getAt,
        update: update
      };
    }

    var TRIGGER_KEYS = [" ", "Enter"];

    function Sync(Splide2, Components2, options) {
      var isNavigation = options.isNavigation,
          slideFocus = options.slideFocus;
      var events = [];

      function mount() {
        Splide2.splides.forEach(function (target) {
          if (!target.isParent) {
            sync(Splide2, target.splide);
            sync(target.splide, Splide2);
          }
        });

        if (isNavigation) {
          navigate();
        }
      }

      function destroy() {
        events.forEach(function (event) {
          event.destroy();
        });
        empty(events);
      }

      function remount() {
        destroy();
        mount();
      }

      function sync(splide, target) {
        var event = EventInterface(splide);
        event.on(EVENT_MOVE, function (index, prev, dest) {
          target.go(target.is(LOOP) ? dest : index);
        });
        events.push(event);
      }

      function navigate() {
        var event = EventInterface(Splide2);
        var on = event.on;
        on(EVENT_CLICK, onClick);
        on(EVENT_SLIDE_KEYDOWN, onKeydown);
        on([EVENT_MOUNTED, EVENT_UPDATED], update);
        events.push(event);
        event.emit(EVENT_NAVIGATION_MOUNTED, Splide2.splides);
      }

      function update() {
        setAttribute(Components2.Elements.list, ARIA_ORIENTATION, options.direction === TTB ? "vertical" : "");
      }

      function onClick(Slide) {
        Splide2.go(Slide.index);
      }

      function onKeydown(Slide, e) {
        if (includes(TRIGGER_KEYS, normalizeKey(e))) {
          onClick(Slide);
          prevent(e);
        }
      }

      return {
        setup: apply(Components2.Media.set, {
          slideFocus: isUndefined(slideFocus) ? isNavigation : slideFocus
        }, true),
        mount: mount,
        destroy: destroy,
        remount: remount
      };
    }

    function Wheel(Splide2, Components2, options) {
      var _EventInterface12 = EventInterface(Splide2),
          bind = _EventInterface12.bind;

      var lastTime = 0;

      function mount() {
        if (options.wheel) {
          bind(Components2.Elements.track, "wheel", onWheel, SCROLL_LISTENER_OPTIONS);
        }
      }

      function onWheel(e) {
        if (e.cancelable) {
          var deltaY = e.deltaY;
          var backwards = deltaY < 0;
          var timeStamp = timeOf(e);

          var _min = options.wheelMinThreshold || 0;

          var sleep = options.wheelSleep || 0;

          if (abs(deltaY) > _min && timeStamp - lastTime > sleep) {
            Splide2.go(backwards ? "<" : ">");
            lastTime = timeStamp;
          }

          shouldPrevent(backwards) && prevent(e);
        }
      }

      function shouldPrevent(backwards) {
        return !options.releaseWheel || Splide2.state.is(MOVING) || Components2.Controller.getAdjacent(backwards) !== -1;
      }

      return {
        mount: mount
      };
    }

    var SR_REMOVAL_DELAY = 90;

    function Live(Splide2, Components2, options) {
      var _EventInterface13 = EventInterface(Splide2),
          on = _EventInterface13.on;

      var track = Components2.Elements.track;
      var enabled = options.live && !options.isNavigation;
      var sr = create("span", CLASS_SR);
      var interval = RequestInterval(SR_REMOVAL_DELAY, apply(toggle, false));

      function mount() {
        if (enabled) {
          disable(!Components2.Autoplay.isPaused());
          setAttribute(track, ARIA_ATOMIC, true);
          sr.textContent = "\u2026";
          on(EVENT_AUTOPLAY_PLAY, apply(disable, true));
          on(EVENT_AUTOPLAY_PAUSE, apply(disable, false));
          on([EVENT_MOVED, EVENT_SCROLLED], apply(toggle, true));
        }
      }

      function toggle(active) {
        setAttribute(track, ARIA_BUSY, active);

        if (active) {
          append(track, sr);
          interval.start();
        } else {
          remove(sr);
          interval.cancel();
        }
      }

      function destroy() {
        removeAttribute(track, [ARIA_LIVE, ARIA_ATOMIC, ARIA_BUSY]);
        remove(sr);
      }

      function disable(disabled) {
        if (enabled) {
          setAttribute(track, ARIA_LIVE, disabled ? "off" : "polite");
        }
      }

      return {
        mount: mount,
        disable: disable,
        destroy: destroy
      };
    }

    var ComponentConstructors = /*#__PURE__*/Object.freeze({
      __proto__: null,
      Media: Media,
      Direction: Direction,
      Elements: Elements,
      Slides: Slides,
      Layout: Layout,
      Clones: Clones,
      Move: Move,
      Controller: Controller,
      Arrows: Arrows,
      Autoplay: Autoplay,
      Cover: Cover,
      Scroll: Scroll,
      Drag: Drag,
      Keyboard: Keyboard,
      LazyLoad: LazyLoad,
      Pagination: Pagination,
      Sync: Sync,
      Wheel: Wheel,
      Live: Live
    });
    var I18N = {
      prev: "Previous slide",
      next: "Next slide",
      first: "Go to first slide",
      last: "Go to last slide",
      slideX: "Go to slide %s",
      pageX: "Go to page %s",
      play: "Start autoplay",
      pause: "Pause autoplay",
      carousel: "carousel",
      slide: "slide",
      select: "Select a slide to show",
      slideLabel: "%s of %s"
    };
    var DEFAULTS = {
      type: "slide",
      role: "region",
      speed: 400,
      perPage: 1,
      cloneStatus: true,
      arrows: true,
      pagination: true,
      paginationKeyboard: true,
      interval: 5e3,
      pauseOnHover: true,
      pauseOnFocus: true,
      resetProgress: true,
      easing: "cubic-bezier(0.25, 1, 0.5, 1)",
      drag: true,
      direction: "ltr",
      trimSpace: true,
      focusableNodes: "a, button, textarea, input, select, iframe",
      live: true,
      classes: CLASSES,
      i18n: I18N,
      reducedMotion: {
        speed: 0,
        rewindSpeed: 0,
        autoplay: "pause"
      }
    };

    function Fade(Splide2, Components2, options) {
      var Slides = Components2.Slides;

      function mount() {
        EventInterface(Splide2).on([EVENT_MOUNTED, EVENT_REFRESH], init);
      }

      function init() {
        Slides.forEach(function (Slide) {
          Slide.style("transform", "translateX(-" + 100 * Slide.index + "%)");
        });
      }

      function start(index, done) {
        Slides.style("transition", "opacity " + options.speed + "ms " + options.easing);
        nextTick(done);
      }

      return {
        mount: mount,
        start: start,
        cancel: noop
      };
    }

    function Slide(Splide2, Components2, options) {
      var Move = Components2.Move,
          Controller = Components2.Controller,
          Scroll = Components2.Scroll;
      var list = Components2.Elements.list;
      var transition = apply(style, list, "transition");
      var endCallback;

      function mount() {
        EventInterface(Splide2).bind(list, "transitionend", function (e) {
          if (e.target === list && endCallback) {
            cancel();
            endCallback();
          }
        });
      }

      function start(index, done) {
        var destination = Move.toPosition(index, true);
        var position = Move.getPosition();
        var speed = getSpeed(index);

        if (abs(destination - position) >= 1 && speed >= 1) {
          if (options.useScroll) {
            Scroll.scroll(destination, speed, false, done);
          } else {
            transition("transform " + speed + "ms " + options.easing);
            Move.translate(destination, true);
            endCallback = done;
          }
        } else {
          Move.jump(index);
          done();
        }
      }

      function cancel() {
        transition("");
        Scroll.cancel();
      }

      function getSpeed(index) {
        var rewindSpeed = options.rewindSpeed;

        if (Splide2.is(SLIDE) && rewindSpeed) {
          var prev = Controller.getIndex(true);
          var end = Controller.getEnd();

          if (prev === 0 && index >= end || prev >= end && index === 0) {
            return rewindSpeed;
          }
        }

        return options.speed;
      }

      return {
        mount: mount,
        start: start,
        cancel: cancel
      };
    }

    var _Splide = /*#__PURE__*/function () {
      function _Splide(target, options) {
        this.event = EventInterface();
        this.Components = {};
        this.state = State(CREATED);
        this.splides = [];
        this._o = {};
        this._E = {};
        var root = isString(target) ? query(document, target) : target;
        assert(root, root + " is invalid.");
        this.root = root;
        options = merge({
          label: getAttribute(root, ARIA_LABEL) || "",
          labelledby: getAttribute(root, ARIA_LABELLEDBY) || ""
        }, DEFAULTS, _Splide.defaults, options || {});

        try {
          merge(options, JSON.parse(getAttribute(root, DATA_ATTRIBUTE)));
        } catch (e) {
          assert(false, "Invalid JSON");
        }

        this._o = Object.create(merge({}, options));
      }

      var _proto = _Splide.prototype;

      _proto.mount = function mount(Extensions, Transition) {
        var _this = this;

        var state = this.state,
            Components2 = this.Components;
        assert(state.is([CREATED, DESTROYED]), "Already mounted!");
        state.set(CREATED);
        this._C = Components2;
        this._T = Transition || this._T || (this.is(FADE) ? Fade : Slide);
        this._E = Extensions || this._E;
        var Constructors = assign({}, ComponentConstructors, this._E, {
          Transition: this._T
        });
        forOwn(Constructors, function (Component, key) {
          var component = Component(_this, Components2, _this._o);
          Components2[key] = component;
          component.setup && component.setup();
        });
        forOwn(Components2, function (component) {
          component.mount && component.mount();
        });
        this.emit(EVENT_MOUNTED);
        addClass(this.root, CLASS_INITIALIZED);
        state.set(IDLE);
        this.emit(EVENT_READY);
        return this;
      };

      _proto.sync = function sync(splide) {
        this.splides.push({
          splide: splide
        });
        splide.splides.push({
          splide: this,
          isParent: true
        });

        if (this.state.is(IDLE)) {
          this._C.Sync.remount();

          splide.Components.Sync.remount();
        }

        return this;
      };

      _proto.go = function go(control) {
        this._C.Controller.go(control);

        return this;
      };

      _proto.on = function on(events, callback) {
        this.event.on(events, callback);
        return this;
      };

      _proto.off = function off(events) {
        this.event.off(events);
        return this;
      };

      _proto.emit = function emit(event) {
        var _this$event;

        (_this$event = this.event).emit.apply(_this$event, [event].concat(slice(arguments, 1)));

        return this;
      };

      _proto.add = function add(slides, index) {
        this._C.Slides.add(slides, index);

        return this;
      };

      _proto.remove = function remove(matcher) {
        this._C.Slides.remove(matcher);

        return this;
      };

      _proto.is = function is(type) {
        return this._o.type === type;
      };

      _proto.refresh = function refresh() {
        this.emit(EVENT_REFRESH);
        return this;
      };

      _proto.destroy = function destroy(completely) {
        if (completely === void 0) {
          completely = true;
        }

        var event = this.event,
            state = this.state;

        if (state.is(CREATED)) {
          EventInterface(this).on(EVENT_READY, this.destroy.bind(this, completely));
        } else {
          forOwn(this._C, function (component) {
            component.destroy && component.destroy(completely);
          }, true);
          event.emit(EVENT_DESTROY);
          event.destroy();
          completely && empty(this.splides);
          state.set(DESTROYED);
        }

        return this;
      };

      _createClass(_Splide, [{
        key: "options",
        get: function get() {
          return this._o;
        },
        set: function set(options) {
          this._C.Media.set(options, true, true);
        }
      }, {
        key: "length",
        get: function get() {
          return this._C.Slides.getLength(true);
        }
      }, {
        key: "index",
        get: function get() {
          return this._C.Controller.getIndex();
        }
      }]);

      return _Splide;
    }();

    var Splide = _Splide;
    Splide.defaults = {};
    Splide.STATES = STATES;

    const EVENTS_WITHOUT_ARGS = [
        EVENT_MOUNTED,
        EVENT_REFRESH,
        EVENT_RESIZE,
        EVENT_RESIZED,
        EVENT_DRAG,
        EVENT_DRAGGING,
        EVENT_DRAGGED,
        EVENT_SCROLL,
        EVENT_SCROLLED,
        EVENT_DESTROY,
        EVENT_AUTOPLAY_PLAY,
        EVENT_AUTOPLAY_PAUSE,
    ];
    /**
     * Binds Splide events to the svelte dispatcher.
     *
     * @since 0.1.0
     *
     * @param splide     - A splide instance.
     * @param dispatchFn - A dispatch function created by `createEventDispatcher()`.
     */
    function bind(splide, dispatchFn) {
        const dispatch = (event, detail = {}) => {
            dispatchFn(transform(event), { splide, ...detail });
        };
        splide.on(EVENT_CLICK, (Slide, e) => {
            dispatch(EVENT_CLICK, { Slide, e });
        });
        splide.on(EVENT_MOVE, (index, prev, dest) => {
            dispatch(EVENT_MOVE, { index, prev, dest });
        });
        splide.on(EVENT_MOVED, (index, prev, dest) => {
            dispatch(EVENT_MOVED, { index, prev, dest });
        });
        splide.on(EVENT_ACTIVE, (Slide) => {
            dispatch(EVENT_ACTIVE, { Slide });
        });
        splide.on(EVENT_INACTIVE, (Slide) => {
            dispatch(EVENT_INACTIVE, { Slide });
        });
        splide.on(EVENT_VISIBLE, (Slide) => {
            dispatch(EVENT_VISIBLE, { Slide });
        });
        splide.on(EVENT_HIDDEN, (Slide) => {
            dispatch(EVENT_HIDDEN, { Slide });
        });
        splide.on(EVENT_UPDATED, (options) => {
            dispatch(EVENT_UPDATED, options);
        });
        splide.on(EVENT_ARROWS_MOUNTED, (prev, next) => {
            dispatch(EVENT_ARROWS_MOUNTED, { prev, next });
        });
        splide.on(EVENT_ARROWS_UPDATED, (prev, next) => {
            dispatch(EVENT_ARROWS_UPDATED, { prev, next });
        });
        splide.on(EVENT_PAGINATION_MOUNTED, (data, item) => {
            dispatch(EVENT_PAGINATION_MOUNTED, { data, item });
        });
        splide.on(EVENT_PAGINATION_UPDATED, (data, prev, curr) => {
            dispatch(EVENT_PAGINATION_UPDATED, { data, prev, curr });
        });
        splide.on(EVENT_NAVIGATION_MOUNTED, (splides) => {
            dispatch(EVENT_NAVIGATION_MOUNTED, { splides });
        });
        splide.on(EVENT_AUTOPLAY_PLAYING, (rate) => {
            dispatch(EVENT_AUTOPLAY_PLAYING, { rate });
        });
        splide.on(EVENT_LAZYLOAD_LOADED, (img, Slide) => {
            dispatch(EVENT_LAZYLOAD_LOADED, { img, Slide });
        });
        EVENTS_WITHOUT_ARGS.forEach(event => {
            splide.on(event, () => {
                dispatch(event);
            });
        });
    }
    /**
     * Transforms Splide event names to the camel case.
     *
     * @since 0.1.0
     *
     * @param event - An event name to transform.
     *
     * @return A transformed event name.
     */
    function transform(event) {
        return event.split(':')
            .map((fragment, index) => {
            return index > 0 ? fragment.charAt(0).toUpperCase() + fragment.slice(1) : fragment;
        })
            .join('')
            .replace('Lazyload', 'LazyLoad');
    }

    /* node_modules/@splidejs/svelte-splide/components/Splide/Splide.svelte generated by Svelte v3.53.1 */
    const file$f = "node_modules/@splidejs/svelte-splide/components/Splide/Splide.svelte";

    // (102:2) { :else }
    function create_else_block$3(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[11].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[13], null);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 8192)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[13],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[13])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[13], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$3.name,
    		type: "else",
    		source: "(102:2) { :else }",
    		ctx
    	});

    	return block;
    }

    // (98:2) { #if hasTrack }
    function create_if_block$5(ctx) {
    	let splidetrack;
    	let current;

    	splidetrack = new SplideTrack({
    			props: {
    				$$slots: { default: [create_default_slot$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(splidetrack.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(splidetrack, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const splidetrack_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				splidetrack_changes.$$scope = { dirty, ctx };
    			}

    			splidetrack.$set(splidetrack_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(splidetrack.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(splidetrack.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(splidetrack, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$5.name,
    		type: "if",
    		source: "(98:2) { #if hasTrack }",
    		ctx
    	});

    	return block;
    }

    // (99:4) <SplideTrack>
    function create_default_slot$1(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[11].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[13], null);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 8192)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[13],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[13])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[13], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$1.name,
    		type: "slot",
    		source: "(99:4) <SplideTrack>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$f(ctx) {
    	let div;
    	let current_block_type_index;
    	let if_block;
    	let div_class_value;
    	let current;
    	const if_block_creators = [create_if_block$5, create_else_block$3];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*hasTrack*/ ctx[1]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	let div_levels = [
    		{
    			class: div_class_value = classNames('splide', /*className*/ ctx[0])
    		},
    		/*$$restProps*/ ctx[3]
    	];

    	let div_data = {};

    	for (let i = 0; i < div_levels.length; i += 1) {
    		div_data = assign$1(div_data, div_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			if_block.c();
    			set_attributes(div, div_data);
    			add_location(div, file$f, 92, 0, 2389);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if_blocks[current_block_type_index].m(div, null);
    			/*div_binding*/ ctx[12](div);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(div, null);
    			}

    			set_attributes(div, div_data = get_spread_update(div_levels, [
    				(!current || dirty & /*className*/ 1 && div_class_value !== (div_class_value = classNames('splide', /*className*/ ctx[0]))) && { class: div_class_value },
    				dirty & /*$$restProps*/ 8 && /*$$restProps*/ ctx[3]
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if_blocks[current_block_type_index].d();
    			/*div_binding*/ ctx[12](null);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$f.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$f($$self, $$props, $$invalidate) {
    	const omit_props_names = ["class","options","splide","extensions","transition","hasTrack","go","sync"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Splide', slots, ['default']);
    	let { class: className = undefined } = $$props;
    	let { options = {} } = $$props;
    	let { splide = undefined } = $$props;
    	let { extensions = undefined } = $$props;
    	let { transition = undefined } = $$props;
    	let { hasTrack = true } = $$props;

    	/**
     * A dispatcher function.
     * The `createEventDispatcher` type assertion does not accept a type alias.
     * If specified, the svelte kit fails to generate a type of `events` and it will be `CustomEvent<any>`.
     * Also, the svelte action does not provide the way to specify event types.
     */
    	const dispatch = createEventDispatcher();

    	/**
     * The root element.
     */
    	let root;

    	/**
     * Holds the previous slide elements.
     */
    	let prevSlides;

    	/**
     * Holds the previous options.
     */
    	let prevOptions = merge$1({}, options);

    	onMount(() => {
    		$$invalidate(4, splide = new Splide(root, options));
    		bind(splide, dispatch);
    		splide.mount(extensions, transition);
    		prevSlides = getSlides(splide);
    		return () => splide.destroy();
    	});

    	afterUpdate(() => {
    		if (splide) {
    			const newSlides = getSlides(splide);

    			if (!isEqualShallow(prevSlides, newSlides)) {
    				splide.refresh();
    				prevSlides = newSlides.slice();
    			}
    		}
    	});

    	function go(control) {
    		splide?.go(control);
    	}

    	function sync(target) {
    		splide?.sync(target);
    	}

    	function div_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			root = $$value;
    			$$invalidate(2, root);
    		});
    	}

    	$$self.$$set = $$new_props => {
    		$$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('class' in $$new_props) $$invalidate(0, className = $$new_props.class);
    		if ('options' in $$new_props) $$invalidate(5, options = $$new_props.options);
    		if ('splide' in $$new_props) $$invalidate(4, splide = $$new_props.splide);
    		if ('extensions' in $$new_props) $$invalidate(6, extensions = $$new_props.extensions);
    		if ('transition' in $$new_props) $$invalidate(7, transition = $$new_props.transition);
    		if ('hasTrack' in $$new_props) $$invalidate(1, hasTrack = $$new_props.hasTrack);
    		if ('$$scope' in $$new_props) $$invalidate(13, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		classNames,
    		getSlides,
    		isEqualDeep,
    		isEqualShallow,
    		merge: merge$1,
    		Splide,
    		afterUpdate,
    		createEventDispatcher,
    		onMount,
    		bind,
    		SplideTrack,
    		className,
    		options,
    		splide,
    		extensions,
    		transition,
    		hasTrack,
    		dispatch,
    		root,
    		prevSlides,
    		prevOptions,
    		go,
    		sync
    	});

    	$$self.$inject_state = $$new_props => {
    		if ('className' in $$props) $$invalidate(0, className = $$new_props.className);
    		if ('options' in $$props) $$invalidate(5, options = $$new_props.options);
    		if ('splide' in $$props) $$invalidate(4, splide = $$new_props.splide);
    		if ('extensions' in $$props) $$invalidate(6, extensions = $$new_props.extensions);
    		if ('transition' in $$props) $$invalidate(7, transition = $$new_props.transition);
    		if ('hasTrack' in $$props) $$invalidate(1, hasTrack = $$new_props.hasTrack);
    		if ('root' in $$props) $$invalidate(2, root = $$new_props.root);
    		if ('prevSlides' in $$props) prevSlides = $$new_props.prevSlides;
    		if ('prevOptions' in $$props) $$invalidate(10, prevOptions = $$new_props.prevOptions);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*splide, prevOptions, options*/ 1072) {
    			/**
     * Updates splide options only when they have difference with previous options.
     */
    			if (splide && !isEqualDeep(prevOptions, options)) {
    				$$invalidate(4, splide.options = options, splide);
    				$$invalidate(10, prevOptions = merge$1({}, prevOptions));
    			}
    		}
    	};

    	return [
    		className,
    		hasTrack,
    		root,
    		$$restProps,
    		splide,
    		options,
    		extensions,
    		transition,
    		go,
    		sync,
    		prevOptions,
    		slots,
    		div_binding,
    		$$scope
    	];
    }

    class Splide_1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$f, create_fragment$f, safe_not_equal, {
    			class: 0,
    			options: 5,
    			splide: 4,
    			extensions: 6,
    			transition: 7,
    			hasTrack: 1,
    			go: 8,
    			sync: 9
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Splide_1",
    			options,
    			id: create_fragment$f.name
    		});
    	}

    	get class() {
    		return this.$$.ctx[0];
    	}

    	set class(className) {
    		this.$$set({ class: className });
    		flush();
    	}

    	get options() {
    		return this.$$.ctx[5];
    	}

    	set options(options) {
    		this.$$set({ options });
    		flush();
    	}

    	get splide() {
    		return this.$$.ctx[4];
    	}

    	set splide(splide) {
    		this.$$set({ splide });
    		flush();
    	}

    	get extensions() {
    		return this.$$.ctx[6];
    	}

    	set extensions(extensions) {
    		this.$$set({ extensions });
    		flush();
    	}

    	get transition() {
    		return this.$$.ctx[7];
    	}

    	set transition(transition) {
    		this.$$set({ transition });
    		flush();
    	}

    	get hasTrack() {
    		return this.$$.ctx[1];
    	}

    	set hasTrack(hasTrack) {
    		this.$$set({ hasTrack });
    		flush();
    	}

    	get go() {
    		return this.$$.ctx[8];
    	}

    	set go(value) {
    		throw new Error("<Splide>: Cannot set read-only property 'go'");
    	}

    	get sync() {
    		return this.$$.ctx[9];
    	}

    	set sync(value) {
    		throw new Error("<Splide>: Cannot set read-only property 'sync'");
    	}
    }

    /* node_modules/@splidejs/svelte-splide/components/SplideTrack/SplideTrack.svelte generated by Svelte v3.53.1 */
    const file$e = "node_modules/@splidejs/svelte-splide/components/SplideTrack/SplideTrack.svelte";

    function create_fragment$e(ctx) {
    	let div;
    	let ul;
    	let div_class_value;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[3].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[2], null);

    	let div_levels = [
    		{
    			class: div_class_value = classNames('splide__track', /*className*/ ctx[0])
    		},
    		/*$$restProps*/ ctx[1]
    	];

    	let div_data = {};

    	for (let i = 0; i < div_levels.length; i += 1) {
    		div_data = assign$1(div_data, div_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			ul = element("ul");
    			if (default_slot) default_slot.c();
    			attr_dev(ul, "class", "splide__list");
    			add_location(ul, file$e, 6, 2, 204);
    			set_attributes(div, div_data);
    			add_location(div, file$e, 5, 0, 125);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, ul);

    			if (default_slot) {
    				default_slot.m(ul, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 4)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[2],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[2])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[2], dirty, null),
    						null
    					);
    				}
    			}

    			set_attributes(div, div_data = get_spread_update(div_levels, [
    				(!current || dirty & /*className*/ 1 && div_class_value !== (div_class_value = classNames('splide__track', /*className*/ ctx[0]))) && { class: div_class_value },
    				dirty & /*$$restProps*/ 2 && /*$$restProps*/ ctx[1]
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$e.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$e($$self, $$props, $$invalidate) {
    	const omit_props_names = ["class"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('SplideTrack', slots, ['default']);
    	let { class: className = undefined } = $$props;

    	$$self.$$set = $$new_props => {
    		$$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('class' in $$new_props) $$invalidate(0, className = $$new_props.class);
    		if ('$$scope' in $$new_props) $$invalidate(2, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({ classNames, className });

    	$$self.$inject_state = $$new_props => {
    		if ('className' in $$props) $$invalidate(0, className = $$new_props.className);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [className, $$restProps, $$scope, slots];
    }

    class SplideTrack extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$e, create_fragment$e, safe_not_equal, { class: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "SplideTrack",
    			options,
    			id: create_fragment$e.name
    		});
    	}

    	get class() {
    		throw new Error("<SplideTrack>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<SplideTrack>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/@splidejs/svelte-splide/components/SplideSlide/SplideSlide.svelte generated by Svelte v3.53.1 */
    const file$d = "node_modules/@splidejs/svelte-splide/components/SplideSlide/SplideSlide.svelte";

    function create_fragment$d(ctx) {
    	let li;
    	let li_class_value;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[3].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[2], null);

    	let li_levels = [
    		{
    			class: li_class_value = classNames('splide__slide', /*className*/ ctx[0])
    		},
    		/*$$restProps*/ ctx[1]
    	];

    	let li_data = {};

    	for (let i = 0; i < li_levels.length; i += 1) {
    		li_data = assign$1(li_data, li_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			li = element("li");
    			if (default_slot) default_slot.c();
    			set_attributes(li, li_data);
    			add_location(li, file$d, 5, 0, 125);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);

    			if (default_slot) {
    				default_slot.m(li, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 4)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[2],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[2])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[2], dirty, null),
    						null
    					);
    				}
    			}

    			set_attributes(li, li_data = get_spread_update(li_levels, [
    				(!current || dirty & /*className*/ 1 && li_class_value !== (li_class_value = classNames('splide__slide', /*className*/ ctx[0]))) && { class: li_class_value },
    				dirty & /*$$restProps*/ 2 && /*$$restProps*/ ctx[1]
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$d.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$d($$self, $$props, $$invalidate) {
    	const omit_props_names = ["class"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('SplideSlide', slots, ['default']);
    	let { class: className = undefined } = $$props;

    	$$self.$$set = $$new_props => {
    		$$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('class' in $$new_props) $$invalidate(0, className = $$new_props.class);
    		if ('$$scope' in $$new_props) $$invalidate(2, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({ classNames, className });

    	$$self.$inject_state = $$new_props => {
    		if ('className' in $$props) $$invalidate(0, className = $$new_props.className);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [className, $$restProps, $$scope, slots];
    }

    class SplideSlide extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$d, create_fragment$d, safe_not_equal, { class: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "SplideSlide",
    			options,
    			id: create_fragment$d.name
    		});
    	}

    	get class() {
    		throw new Error("<SplideSlide>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<SplideSlide>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/lib/elements/IntroTextCard.svelte generated by Svelte v3.53.1 */

    const file$c = "src/lib/elements/IntroTextCard.svelte";

    function create_fragment$c(ctx) {
    	let div3;
    	let div2;
    	let div1;
    	let div0;
    	let div3_id_value;
    	let div3_class_value;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[2].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[1], null);

    	const block = {
    		c: function create() {
    			div3 = element("div");
    			div2 = element("div");
    			div1 = element("div");
    			div0 = element("div");
    			if (default_slot) default_slot.c();
    			attr_dev(div0, "class", "content svelte-1y413mt");
    			add_location(div0, file$c, 7, 12, 180);
    			attr_dev(div1, "class", "inner-border svelte-1y413mt");
    			add_location(div1, file$c, 6, 8, 141);
    			attr_dev(div2, "class", "outer-border svelte-1y413mt");
    			add_location(div2, file$c, 5, 4, 106);
    			attr_dev(div3, "id", div3_id_value = "card-" + /*cardNumber*/ ctx[0]);
    			attr_dev(div3, "class", div3_class_value = "card-" + /*cardNumber*/ ctx[0] + " svelte-1y413mt");
    			add_location(div3, file$c, 4, 0, 47);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div3, anchor);
    			append_dev(div3, div2);
    			append_dev(div2, div1);
    			append_dev(div1, div0);

    			if (default_slot) {
    				default_slot.m(div0, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 2)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[1],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[1])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[1], dirty, null),
    						null
    					);
    				}
    			}

    			if (!current || dirty & /*cardNumber*/ 1 && div3_id_value !== (div3_id_value = "card-" + /*cardNumber*/ ctx[0])) {
    				attr_dev(div3, "id", div3_id_value);
    			}

    			if (!current || dirty & /*cardNumber*/ 1 && div3_class_value !== (div3_class_value = "card-" + /*cardNumber*/ ctx[0] + " svelte-1y413mt")) {
    				attr_dev(div3, "class", div3_class_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div3);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$c.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$c($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('IntroTextCard', slots, ['default']);
    	let { cardNumber } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (cardNumber === undefined && !('cardNumber' in $$props || $$self.$$.bound[$$self.$$.props['cardNumber']])) {
    			console.warn("<IntroTextCard> was created without expected prop 'cardNumber'");
    		}
    	});

    	const writable_props = ['cardNumber'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<IntroTextCard> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('cardNumber' in $$props) $$invalidate(0, cardNumber = $$props.cardNumber);
    		if ('$$scope' in $$props) $$invalidate(1, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({ cardNumber });

    	$$self.$inject_state = $$props => {
    		if ('cardNumber' in $$props) $$invalidate(0, cardNumber = $$props.cardNumber);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [cardNumber, $$scope, slots];
    }

    class IntroTextCard extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$c, create_fragment$c, safe_not_equal, { cardNumber: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "IntroTextCard",
    			options,
    			id: create_fragment$c.name
    		});
    	}

    	get cardNumber() {
    		throw new Error("<IntroTextCard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set cardNumber(value) {
    		throw new Error("<IntroTextCard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/lib/svg/TitleCard.svelte generated by Svelte v3.53.1 */

    const file$b = "src/lib/svg/TitleCard.svelte";

    function create_fragment$b(ctx) {
    	let svg;
    	let g0;
    	let rect0;
    	let rect1;
    	let rect2;
    	let g1;
    	let path0;
    	let path1;
    	let path2;
    	let path3;
    	let path4;
    	let path5;
    	let path6;
    	let path7;
    	let path8;
    	let path9;
    	let path10;
    	let path11;
    	let path12;
    	let path13;
    	let path14;
    	let path15;
    	let path16;
    	let path17;
    	let path18;
    	let path19;
    	let path20;
    	let path21;
    	let path22;
    	let path23;
    	let path24;
    	let path25;
    	let path26;
    	let path27;
    	let path28;
    	let path29;
    	let path30;
    	let path31;
    	let path32;
    	let path33;
    	let path34;
    	let path35;
    	let path36;
    	let path37;
    	let path38;
    	let path39;
    	let path40;
    	let path41;
    	let path42;
    	let path43;
    	let path44;
    	let path45;
    	let path46;
    	let path47;
    	let path48;
    	let path49;
    	let path50;
    	let path51;
    	let path52;
    	let path53;
    	let path54;
    	let path55;
    	let path56;
    	let path57;
    	let path58;
    	let path59;
    	let path60;
    	let path61;
    	let path62;
    	let path63;
    	let path64;
    	let path65;
    	let path66;
    	let path67;
    	let path68;
    	let path69;
    	let path70;
    	let path71;
    	let path72;
    	let path73;
    	let path74;
    	let path75;
    	let path76;
    	let path77;
    	let path78;
    	let path79;
    	let path80;
    	let path81;
    	let path82;
    	let path83;
    	let path84;
    	let path85;
    	let path86;
    	let path87;
    	let path88;
    	let path89;
    	let path90;
    	let path91;
    	let path92;
    	let path93;
    	let path94;
    	let path95;
    	let path96;
    	let path97;
    	let path98;
    	let path99;
    	let path100;
    	let path101;
    	let path102;
    	let path103;
    	let path104;
    	let path105;
    	let path106;
    	let path107;
    	let path108;
    	let path109;
    	let path110;
    	let path111;
    	let path112;
    	let path113;
    	let path114;
    	let path115;
    	let path116;
    	let path117;
    	let path118;
    	let path119;
    	let path120;
    	let path121;
    	let path122;
    	let path123;
    	let path124;
    	let path125;
    	let path126;
    	let path127;
    	let path128;
    	let path129;
    	let path130;
    	let path131;
    	let path132;
    	let path133;
    	let path134;
    	let path135;
    	let path136;
    	let path137;
    	let path138;
    	let path139;
    	let path140;
    	let path141;
    	let path142;
    	let path143;
    	let path144;
    	let path145;
    	let path146;
    	let path147;
    	let path148;
    	let path149;
    	let path150;
    	let path151;
    	let path152;
    	let path153;
    	let path154;
    	let path155;
    	let path156;
    	let path157;
    	let path158;
    	let path159;
    	let path160;
    	let path161;
    	let path162;
    	let path163;
    	let path164;
    	let path165;
    	let path166;
    	let path167;
    	let path168;
    	let path169;
    	let path170;
    	let path171;
    	let path172;
    	let path173;
    	let path174;
    	let path175;
    	let path176;
    	let path177;
    	let path178;
    	let path179;
    	let path180;
    	let path181;
    	let path182;
    	let path183;
    	let path184;
    	let path185;
    	let path186;
    	let path187;
    	let path188;
    	let path189;
    	let path190;
    	let path191;
    	let path192;
    	let path193;
    	let path194;
    	let path195;
    	let path196;
    	let path197;
    	let path198;
    	let path199;
    	let g2;
    	let path200;
    	let g3;
    	let path201;
    	let g13;
    	let g4;
    	let circle0;
    	let circle1;
    	let g5;
    	let circle2;
    	let circle3;
    	let circle4;
    	let g6;
    	let circle5;
    	let circle6;
    	let circle7;
    	let g7;
    	let circle8;
    	let circle9;
    	let circle10;
    	let g8;
    	let circle11;
    	let circle12;
    	let circle13;
    	let g9;
    	let path202;
    	let path203;
    	let path204;
    	let path205;
    	let g10;
    	let path206;
    	let path207;
    	let path208;
    	let path209;
    	let g11;
    	let path210;
    	let path211;
    	let path212;
    	let path213;
    	let g12;
    	let path214;
    	let path215;
    	let path216;
    	let path217;
    	let svg_viewBox_value;

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			g0 = svg_element("g");
    			rect0 = svg_element("rect");
    			rect1 = svg_element("rect");
    			rect2 = svg_element("rect");
    			g1 = svg_element("g");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			path2 = svg_element("path");
    			path3 = svg_element("path");
    			path4 = svg_element("path");
    			path5 = svg_element("path");
    			path6 = svg_element("path");
    			path7 = svg_element("path");
    			path8 = svg_element("path");
    			path9 = svg_element("path");
    			path10 = svg_element("path");
    			path11 = svg_element("path");
    			path12 = svg_element("path");
    			path13 = svg_element("path");
    			path14 = svg_element("path");
    			path15 = svg_element("path");
    			path16 = svg_element("path");
    			path17 = svg_element("path");
    			path18 = svg_element("path");
    			path19 = svg_element("path");
    			path20 = svg_element("path");
    			path21 = svg_element("path");
    			path22 = svg_element("path");
    			path23 = svg_element("path");
    			path24 = svg_element("path");
    			path25 = svg_element("path");
    			path26 = svg_element("path");
    			path27 = svg_element("path");
    			path28 = svg_element("path");
    			path29 = svg_element("path");
    			path30 = svg_element("path");
    			path31 = svg_element("path");
    			path32 = svg_element("path");
    			path33 = svg_element("path");
    			path34 = svg_element("path");
    			path35 = svg_element("path");
    			path36 = svg_element("path");
    			path37 = svg_element("path");
    			path38 = svg_element("path");
    			path39 = svg_element("path");
    			path40 = svg_element("path");
    			path41 = svg_element("path");
    			path42 = svg_element("path");
    			path43 = svg_element("path");
    			path44 = svg_element("path");
    			path45 = svg_element("path");
    			path46 = svg_element("path");
    			path47 = svg_element("path");
    			path48 = svg_element("path");
    			path49 = svg_element("path");
    			path50 = svg_element("path");
    			path51 = svg_element("path");
    			path52 = svg_element("path");
    			path53 = svg_element("path");
    			path54 = svg_element("path");
    			path55 = svg_element("path");
    			path56 = svg_element("path");
    			path57 = svg_element("path");
    			path58 = svg_element("path");
    			path59 = svg_element("path");
    			path60 = svg_element("path");
    			path61 = svg_element("path");
    			path62 = svg_element("path");
    			path63 = svg_element("path");
    			path64 = svg_element("path");
    			path65 = svg_element("path");
    			path66 = svg_element("path");
    			path67 = svg_element("path");
    			path68 = svg_element("path");
    			path69 = svg_element("path");
    			path70 = svg_element("path");
    			path71 = svg_element("path");
    			path72 = svg_element("path");
    			path73 = svg_element("path");
    			path74 = svg_element("path");
    			path75 = svg_element("path");
    			path76 = svg_element("path");
    			path77 = svg_element("path");
    			path78 = svg_element("path");
    			path79 = svg_element("path");
    			path80 = svg_element("path");
    			path81 = svg_element("path");
    			path82 = svg_element("path");
    			path83 = svg_element("path");
    			path84 = svg_element("path");
    			path85 = svg_element("path");
    			path86 = svg_element("path");
    			path87 = svg_element("path");
    			path88 = svg_element("path");
    			path89 = svg_element("path");
    			path90 = svg_element("path");
    			path91 = svg_element("path");
    			path92 = svg_element("path");
    			path93 = svg_element("path");
    			path94 = svg_element("path");
    			path95 = svg_element("path");
    			path96 = svg_element("path");
    			path97 = svg_element("path");
    			path98 = svg_element("path");
    			path99 = svg_element("path");
    			path100 = svg_element("path");
    			path101 = svg_element("path");
    			path102 = svg_element("path");
    			path103 = svg_element("path");
    			path104 = svg_element("path");
    			path105 = svg_element("path");
    			path106 = svg_element("path");
    			path107 = svg_element("path");
    			path108 = svg_element("path");
    			path109 = svg_element("path");
    			path110 = svg_element("path");
    			path111 = svg_element("path");
    			path112 = svg_element("path");
    			path113 = svg_element("path");
    			path114 = svg_element("path");
    			path115 = svg_element("path");
    			path116 = svg_element("path");
    			path117 = svg_element("path");
    			path118 = svg_element("path");
    			path119 = svg_element("path");
    			path120 = svg_element("path");
    			path121 = svg_element("path");
    			path122 = svg_element("path");
    			path123 = svg_element("path");
    			path124 = svg_element("path");
    			path125 = svg_element("path");
    			path126 = svg_element("path");
    			path127 = svg_element("path");
    			path128 = svg_element("path");
    			path129 = svg_element("path");
    			path130 = svg_element("path");
    			path131 = svg_element("path");
    			path132 = svg_element("path");
    			path133 = svg_element("path");
    			path134 = svg_element("path");
    			path135 = svg_element("path");
    			path136 = svg_element("path");
    			path137 = svg_element("path");
    			path138 = svg_element("path");
    			path139 = svg_element("path");
    			path140 = svg_element("path");
    			path141 = svg_element("path");
    			path142 = svg_element("path");
    			path143 = svg_element("path");
    			path144 = svg_element("path");
    			path145 = svg_element("path");
    			path146 = svg_element("path");
    			path147 = svg_element("path");
    			path148 = svg_element("path");
    			path149 = svg_element("path");
    			path150 = svg_element("path");
    			path151 = svg_element("path");
    			path152 = svg_element("path");
    			path153 = svg_element("path");
    			path154 = svg_element("path");
    			path155 = svg_element("path");
    			path156 = svg_element("path");
    			path157 = svg_element("path");
    			path158 = svg_element("path");
    			path159 = svg_element("path");
    			path160 = svg_element("path");
    			path161 = svg_element("path");
    			path162 = svg_element("path");
    			path163 = svg_element("path");
    			path164 = svg_element("path");
    			path165 = svg_element("path");
    			path166 = svg_element("path");
    			path167 = svg_element("path");
    			path168 = svg_element("path");
    			path169 = svg_element("path");
    			path170 = svg_element("path");
    			path171 = svg_element("path");
    			path172 = svg_element("path");
    			path173 = svg_element("path");
    			path174 = svg_element("path");
    			path175 = svg_element("path");
    			path176 = svg_element("path");
    			path177 = svg_element("path");
    			path178 = svg_element("path");
    			path179 = svg_element("path");
    			path180 = svg_element("path");
    			path181 = svg_element("path");
    			path182 = svg_element("path");
    			path183 = svg_element("path");
    			path184 = svg_element("path");
    			path185 = svg_element("path");
    			path186 = svg_element("path");
    			path187 = svg_element("path");
    			path188 = svg_element("path");
    			path189 = svg_element("path");
    			path190 = svg_element("path");
    			path191 = svg_element("path");
    			path192 = svg_element("path");
    			path193 = svg_element("path");
    			path194 = svg_element("path");
    			path195 = svg_element("path");
    			path196 = svg_element("path");
    			path197 = svg_element("path");
    			path198 = svg_element("path");
    			path199 = svg_element("path");
    			g2 = svg_element("g");
    			path200 = svg_element("path");
    			g3 = svg_element("g");
    			path201 = svg_element("path");
    			g13 = svg_element("g");
    			g4 = svg_element("g");
    			circle0 = svg_element("circle");
    			circle1 = svg_element("circle");
    			g5 = svg_element("g");
    			circle2 = svg_element("circle");
    			circle3 = svg_element("circle");
    			circle4 = svg_element("circle");
    			g6 = svg_element("g");
    			circle5 = svg_element("circle");
    			circle6 = svg_element("circle");
    			circle7 = svg_element("circle");
    			g7 = svg_element("g");
    			circle8 = svg_element("circle");
    			circle9 = svg_element("circle");
    			circle10 = svg_element("circle");
    			g8 = svg_element("g");
    			circle11 = svg_element("circle");
    			circle12 = svg_element("circle");
    			circle13 = svg_element("circle");
    			g9 = svg_element("g");
    			path202 = svg_element("path");
    			path203 = svg_element("path");
    			path204 = svg_element("path");
    			path205 = svg_element("path");
    			g10 = svg_element("g");
    			path206 = svg_element("path");
    			path207 = svg_element("path");
    			path208 = svg_element("path");
    			path209 = svg_element("path");
    			g11 = svg_element("g");
    			path210 = svg_element("path");
    			path211 = svg_element("path");
    			path212 = svg_element("path");
    			path213 = svg_element("path");
    			g12 = svg_element("g");
    			path214 = svg_element("path");
    			path215 = svg_element("path");
    			path216 = svg_element("path");
    			path217 = svg_element("path");
    			attr_dev(rect0, "width", "350");
    			attr_dev(rect0, "height", "600");
    			attr_dev(rect0, "fill", "#181818");
    			add_location(rect0, file$b, 8, 8, 266);
    			attr_dev(rect1, "x", "32.1871");
    			attr_dev(rect1, "y", "29.5");
    			attr_dev(rect1, "width", "285.626");
    			attr_dev(rect1, "height", "541");
    			attr_dev(rect1, "rx", "2.5");
    			attr_dev(rect1, "stroke", "#4F4F4F");
    			add_location(rect1, file$b, 9, 8, 322);
    			attr_dev(rect2, "x", "15.5");
    			attr_dev(rect2, "y", "12.5");
    			attr_dev(rect2, "width", "319");
    			attr_dev(rect2, "height", "575");
    			attr_dev(rect2, "rx", "8.5");
    			attr_dev(rect2, "stroke", "#4F4F4F");
    			add_location(rect2, file$b, 10, 8, 414);
    			attr_dev(g0, "class", "title-svg-background");
    			add_location(g0, file$b, 7, 4, 205);
    			attr_dev(path0, "d", "M19.908 406.25C19.908 406.25 27.736 406.25 27.736 397.426C27.736 388.602 19.908 388.602 19.908 388.602");
    			attr_dev(path0, "stroke", "#4F4F4F");
    			attr_dev(path0, "stroke-linecap", "round");
    			add_location(path0, file$b, 14, 8, 562);
    			attr_dev(path1, "d", "M27.736 388.602C27.736 388.602 19.908 388.602 19.908 397.426C19.908 406.25 27.736 406.25 27.736 406.25");
    			attr_dev(path1, "stroke", "#4F4F4F");
    			attr_dev(path1, "stroke-linecap", "round");
    			add_location(path1, file$b, 15, 8, 725);
    			attr_dev(path2, "d", "M19.908 423.887C19.908 423.887 27.736 423.887 27.736 415.063C27.736 406.239 19.908 406.239 19.908 406.239");
    			attr_dev(path2, "stroke", "#4F4F4F");
    			attr_dev(path2, "stroke-linecap", "round");
    			add_location(path2, file$b, 16, 8, 888);
    			attr_dev(path3, "d", "M27.736 406.239C27.736 406.239 19.908 406.239 19.908 415.063C19.908 423.887 27.736 423.887 27.736 423.887");
    			attr_dev(path3, "stroke", "#4F4F4F");
    			attr_dev(path3, "stroke-linecap", "round");
    			add_location(path3, file$b, 17, 8, 1054);
    			attr_dev(path4, "d", "M19.908 441.535C19.908 441.535 27.736 441.535 27.736 432.711C27.736 423.887 19.908 423.887 19.908 423.887");
    			attr_dev(path4, "stroke", "#4F4F4F");
    			attr_dev(path4, "stroke-linecap", "round");
    			add_location(path4, file$b, 18, 8, 1220);
    			attr_dev(path5, "d", "M27.736 423.887C27.736 423.887 19.908 423.887 19.908 432.712C19.908 441.536 27.736 441.536 27.736 441.536");
    			attr_dev(path5, "stroke", "#4F4F4F");
    			attr_dev(path5, "stroke-linecap", "round");
    			add_location(path5, file$b, 19, 8, 1386);
    			attr_dev(path6, "d", "M19.908 353.317C19.908 353.317 27.736 353.317 27.736 344.493C27.736 335.669 19.908 335.669 19.908 335.669");
    			attr_dev(path6, "stroke", "#4F4F4F");
    			attr_dev(path6, "stroke-linecap", "round");
    			add_location(path6, file$b, 20, 8, 1552);
    			attr_dev(path7, "d", "M27.736 335.669C27.736 335.669 19.908 335.669 19.908 344.493C19.908 353.317 27.736 353.317 27.736 353.317");
    			attr_dev(path7, "stroke", "#4F4F4F");
    			attr_dev(path7, "stroke-linecap", "round");
    			add_location(path7, file$b, 21, 8, 1718);
    			attr_dev(path8, "d", "M19.908 370.953C19.908 370.953 27.736 370.953 27.736 362.129C27.736 353.305 19.908 353.305 19.908 353.305");
    			attr_dev(path8, "stroke", "#4F4F4F");
    			attr_dev(path8, "stroke-linecap", "round");
    			add_location(path8, file$b, 22, 8, 1884);
    			attr_dev(path9, "d", "M27.736 353.305C27.736 353.305 19.908 353.305 19.908 362.129C19.908 370.953 27.736 370.953 27.736 370.953");
    			attr_dev(path9, "stroke", "#4F4F4F");
    			attr_dev(path9, "stroke-linecap", "round");
    			add_location(path9, file$b, 23, 8, 2050);
    			attr_dev(path10, "d", "M19.908 388.601C19.908 388.601 27.736 388.601 27.736 379.777C27.736 370.953 19.908 370.953 19.908 370.953");
    			attr_dev(path10, "stroke", "#4F4F4F");
    			attr_dev(path10, "stroke-linecap", "round");
    			add_location(path10, file$b, 24, 8, 2216);
    			attr_dev(path11, "d", "M27.736 370.953C27.736 370.953 19.908 370.953 19.908 379.777C19.908 388.602 27.736 388.602 27.736 388.602");
    			attr_dev(path11, "stroke", "#4F4F4F");
    			attr_dev(path11, "stroke-linecap", "round");
    			add_location(path11, file$b, 25, 8, 2382);
    			attr_dev(path12, "d", "M19.908 300.026C19.908 300.026 27.736 300.026 27.736 291.202C27.736 282.378 19.908 282.378 19.908 282.378");
    			attr_dev(path12, "stroke", "#4F4F4F");
    			attr_dev(path12, "stroke-linecap", "round");
    			add_location(path12, file$b, 26, 8, 2548);
    			attr_dev(path13, "d", "M27.736 282.378C27.736 282.378 19.908 282.378 19.908 291.202C19.908 300.026 27.736 300.026 27.736 300.026");
    			attr_dev(path13, "stroke", "#4F4F4F");
    			attr_dev(path13, "stroke-linecap", "round");
    			add_location(path13, file$b, 27, 8, 2714);
    			attr_dev(path14, "d", "M19.908 317.664C19.908 317.664 27.736 317.664 27.736 308.84C27.736 300.016 19.908 300.016 19.908 300.016");
    			attr_dev(path14, "stroke", "#4F4F4F");
    			attr_dev(path14, "stroke-linecap", "round");
    			add_location(path14, file$b, 28, 8, 2880);
    			attr_dev(path15, "d", "M27.736 300.016C27.736 300.016 19.908 300.016 19.908 308.84C19.908 317.665 27.736 317.665 27.736 317.665");
    			attr_dev(path15, "stroke", "#4F4F4F");
    			attr_dev(path15, "stroke-linecap", "round");
    			add_location(path15, file$b, 29, 8, 3045);
    			attr_dev(path16, "d", "M19.908 335.313C19.908 335.313 27.736 335.313 27.736 326.489C27.736 317.665 19.908 317.665 19.908 317.665");
    			attr_dev(path16, "stroke", "#4F4F4F");
    			attr_dev(path16, "stroke-linecap", "round");
    			add_location(path16, file$b, 30, 8, 3210);
    			attr_dev(path17, "d", "M27.736 317.665C27.736 317.665 19.908 317.665 19.908 326.489C19.908 335.313 27.736 335.313 27.736 335.313");
    			attr_dev(path17, "stroke", "#4F4F4F");
    			attr_dev(path17, "stroke-linecap", "round");
    			add_location(path17, file$b, 31, 8, 3376);
    			attr_dev(path18, "d", "M19.908 247.093C19.908 247.093 27.736 247.093 27.736 238.269C27.736 229.445 19.908 229.445 19.908 229.445");
    			attr_dev(path18, "stroke", "#4F4F4F");
    			attr_dev(path18, "stroke-linecap", "round");
    			add_location(path18, file$b, 32, 8, 3542);
    			attr_dev(path19, "d", "M27.736 229.445C27.736 229.445 19.908 229.445 19.908 238.269C19.908 247.093 27.736 247.093 27.736 247.093");
    			attr_dev(path19, "stroke", "#4F4F4F");
    			attr_dev(path19, "stroke-linecap", "round");
    			add_location(path19, file$b, 33, 8, 3708);
    			attr_dev(path20, "d", "M19.908 264.73C19.908 264.73 27.736 264.73 27.736 255.906C27.736 247.082 19.908 247.082 19.908 247.082");
    			attr_dev(path20, "stroke", "#4F4F4F");
    			attr_dev(path20, "stroke-linecap", "round");
    			add_location(path20, file$b, 34, 8, 3874);
    			attr_dev(path21, "d", "M27.736 247.083C27.736 247.083 19.908 247.083 19.908 255.907C19.908 264.731 27.736 264.731 27.736 264.731");
    			attr_dev(path21, "stroke", "#4F4F4F");
    			attr_dev(path21, "stroke-linecap", "round");
    			add_location(path21, file$b, 35, 8, 4037);
    			attr_dev(path22, "d", "M19.908 282.379C19.908 282.379 27.736 282.379 27.736 273.555C27.736 264.731 19.908 264.731 19.908 264.731");
    			attr_dev(path22, "stroke", "#4F4F4F");
    			attr_dev(path22, "stroke-linecap", "round");
    			add_location(path22, file$b, 36, 8, 4203);
    			attr_dev(path23, "d", "M27.736 264.731C27.736 264.731 19.908 264.731 19.908 273.555C19.908 282.379 27.736 282.379 27.736 282.379");
    			attr_dev(path23, "stroke", "#4F4F4F");
    			attr_dev(path23, "stroke-linecap", "round");
    			add_location(path23, file$b, 37, 8, 4369);
    			attr_dev(path24, "d", "M19.908 193.804C19.908 193.804 27.736 193.804 27.736 184.98C27.736 176.156 19.908 176.156 19.908 176.156");
    			attr_dev(path24, "stroke", "#4F4F4F");
    			attr_dev(path24, "stroke-linecap", "round");
    			add_location(path24, file$b, 38, 8, 4535);
    			attr_dev(path25, "d", "M27.736 176.156C27.736 176.156 19.908 176.156 19.908 184.98C19.908 193.804 27.736 193.804 27.736 193.804");
    			attr_dev(path25, "stroke", "#4F4F4F");
    			attr_dev(path25, "stroke-linecap", "round");
    			add_location(path25, file$b, 39, 8, 4700);
    			attr_dev(path26, "d", "M19.908 211.441C19.908 211.441 27.736 211.441 27.736 202.617C27.736 193.793 19.908 193.793 19.908 193.793");
    			attr_dev(path26, "stroke", "#4F4F4F");
    			attr_dev(path26, "stroke-linecap", "round");
    			add_location(path26, file$b, 40, 8, 4865);
    			attr_dev(path27, "d", "M27.736 193.793C27.736 193.793 19.908 193.793 19.908 202.617C19.908 211.441 27.736 211.441 27.736 211.441");
    			attr_dev(path27, "stroke", "#4F4F4F");
    			attr_dev(path27, "stroke-linecap", "round");
    			add_location(path27, file$b, 41, 8, 5031);
    			attr_dev(path28, "d", "M19.908 229.09C19.908 229.09 27.736 229.09 27.736 220.265C27.736 211.441 19.908 211.441 19.908 211.441");
    			attr_dev(path28, "stroke", "#4F4F4F");
    			attr_dev(path28, "stroke-linecap", "round");
    			add_location(path28, file$b, 42, 8, 5197);
    			attr_dev(path29, "d", "M27.736 211.442C27.736 211.442 19.908 211.442 19.908 220.266C19.908 229.09 27.736 229.09 27.736 229.09");
    			attr_dev(path29, "stroke", "#4F4F4F");
    			attr_dev(path29, "stroke-linecap", "round");
    			add_location(path29, file$b, 43, 8, 5360);
    			attr_dev(path30, "d", "M19.908 140.87C19.908 140.87 27.736 140.87 27.736 132.046C27.736 123.222 19.908 123.222 19.908 123.222");
    			attr_dev(path30, "stroke", "#4F4F4F");
    			attr_dev(path30, "stroke-linecap", "round");
    			add_location(path30, file$b, 44, 8, 5523);
    			attr_dev(path31, "d", "M27.736 123.222C27.736 123.222 19.908 123.222 19.908 132.047C19.908 140.871 27.736 140.871 27.736 140.871");
    			attr_dev(path31, "stroke", "#4F4F4F");
    			attr_dev(path31, "stroke-linecap", "round");
    			add_location(path31, file$b, 45, 8, 5686);
    			attr_dev(path32, "d", "M19.908 158.508C19.908 158.508 27.7359 158.508 27.7359 149.683C27.7359 140.859 19.908 140.859 19.908 140.859");
    			attr_dev(path32, "stroke", "#4F4F4F");
    			attr_dev(path32, "stroke-linecap", "round");
    			add_location(path32, file$b, 46, 8, 5852);
    			attr_dev(path33, "d", "M27.736 140.86C27.736 140.86 19.908 140.86 19.908 149.684C19.908 158.508 27.736 158.508 27.736 158.508");
    			attr_dev(path33, "stroke", "#4F4F4F");
    			attr_dev(path33, "stroke-linecap", "round");
    			add_location(path33, file$b, 47, 8, 6021);
    			attr_dev(path34, "d", "M19.908 176.155C19.908 176.155 27.736 176.155 27.736 167.331C27.736 158.507 19.908 158.507 19.908 158.507");
    			attr_dev(path34, "stroke", "#4F4F4F");
    			attr_dev(path34, "stroke-linecap", "round");
    			add_location(path34, file$b, 48, 8, 6184);
    			attr_dev(path35, "d", "M27.736 158.507C27.736 158.507 19.908 158.507 19.908 167.331C19.908 176.155 27.736 176.155 27.736 176.155");
    			attr_dev(path35, "stroke", "#4F4F4F");
    			attr_dev(path35, "stroke-linecap", "round");
    			add_location(path35, file$b, 49, 8, 6350);
    			attr_dev(path36, "d", "M19.908 87.5808C19.908 87.5808 27.736 87.5808 27.736 78.7567C27.736 69.9326 19.908 69.9326 19.908 69.9326");
    			attr_dev(path36, "stroke", "#4F4F4F");
    			attr_dev(path36, "stroke-linecap", "round");
    			add_location(path36, file$b, 50, 8, 6516);
    			attr_dev(path37, "d", "M27.736 69.9334C27.736 69.9334 19.908 69.9334 19.908 78.7575C19.908 87.5815 27.736 87.5815 27.736 87.5815");
    			attr_dev(path37, "stroke", "#4F4F4F");
    			attr_dev(path37, "stroke-linecap", "round");
    			add_location(path37, file$b, 51, 8, 6682);
    			attr_dev(path38, "d", "M19.908 105.218C19.908 105.218 27.736 105.218 27.736 96.3944C27.736 87.5703 19.908 87.5703 19.908 87.5703");
    			attr_dev(path38, "stroke", "#4F4F4F");
    			attr_dev(path38, "stroke-linecap", "round");
    			add_location(path38, file$b, 52, 8, 6848);
    			attr_dev(path39, "d", "M27.736 87.5706C27.736 87.5706 19.908 87.5706 19.908 96.3947C19.908 105.219 27.736 105.219 27.736 105.219");
    			attr_dev(path39, "stroke", "#4F4F4F");
    			attr_dev(path39, "stroke-linecap", "round");
    			add_location(path39, file$b, 53, 8, 7014);
    			attr_dev(path40, "d", "M19.908 122.865C19.908 122.865 27.736 122.865 27.736 114.041C27.736 105.217 19.908 105.217 19.908 105.217");
    			attr_dev(path40, "stroke", "#4F4F4F");
    			attr_dev(path40, "stroke-linecap", "round");
    			add_location(path40, file$b, 54, 8, 7180);
    			attr_dev(path41, "d", "M27.736 105.218C27.736 105.218 19.908 105.218 19.908 114.042C19.908 122.866 27.736 122.866 27.736 122.866");
    			attr_dev(path41, "stroke", "#4F4F4F");
    			attr_dev(path41, "stroke-linecap", "round");
    			add_location(path41, file$b, 55, 8, 7346);
    			attr_dev(path42, "d", "M19.908 512.072C19.908 512.072 27.736 512.072 27.736 503.248C27.736 494.424 19.908 494.424 19.908 494.424");
    			attr_dev(path42, "stroke", "#4F4F4F");
    			attr_dev(path42, "stroke-linecap", "round");
    			add_location(path42, file$b, 56, 8, 7512);
    			attr_dev(path43, "d", "M27.736 494.424C27.736 494.424 19.908 494.424 19.908 503.248C19.908 512.072 27.736 512.072 27.736 512.072");
    			attr_dev(path43, "stroke", "#4F4F4F");
    			attr_dev(path43, "stroke-linecap", "round");
    			add_location(path43, file$b, 57, 8, 7678);
    			attr_dev(path44, "d", "M19.908 529.709C19.908 529.709 27.736 529.709 27.736 520.885C27.736 512.061 19.908 512.061 19.908 512.061");
    			attr_dev(path44, "stroke", "#4F4F4F");
    			attr_dev(path44, "stroke-linecap", "round");
    			add_location(path44, file$b, 58, 8, 7844);
    			attr_dev(path45, "d", "M27.736 512.061C27.736 512.061 19.908 512.061 19.908 520.885C19.908 529.709 27.736 529.709 27.736 529.709");
    			attr_dev(path45, "stroke", "#4F4F4F");
    			attr_dev(path45, "stroke-linecap", "round");
    			add_location(path45, file$b, 59, 8, 8010);
    			attr_dev(path46, "d", "M19.908 547.358C19.908 547.358 27.7359 547.358 27.7359 538.534C27.7359 529.71 19.908 529.71 19.908 529.71");
    			attr_dev(path46, "stroke", "#4F4F4F");
    			attr_dev(path46, "stroke-linecap", "round");
    			add_location(path46, file$b, 60, 8, 8176);
    			attr_dev(path47, "d", "M27.736 529.71C27.736 529.71 19.908 529.71 19.908 538.534C19.908 547.358 27.736 547.358 27.736 547.358");
    			attr_dev(path47, "stroke", "#4F4F4F");
    			attr_dev(path47, "stroke-linecap", "round");
    			add_location(path47, file$b, 61, 8, 8342);
    			attr_dev(path48, "d", "M19.908 459.138C19.908 459.138 27.736 459.138 27.736 450.314C27.736 441.49 19.908 441.49 19.908 441.49");
    			attr_dev(path48, "stroke", "#4F4F4F");
    			attr_dev(path48, "stroke-linecap", "round");
    			add_location(path48, file$b, 62, 8, 8505);
    			attr_dev(path49, "d", "M27.736 441.491C27.736 441.491 19.908 441.491 19.908 450.315C19.908 459.139 27.736 459.139 27.736 459.139");
    			attr_dev(path49, "stroke", "#4F4F4F");
    			attr_dev(path49, "stroke-linecap", "round");
    			add_location(path49, file$b, 63, 8, 8668);
    			attr_dev(path50, "d", "M19.908 476.775C19.908 476.775 27.736 476.775 27.736 467.951C27.736 459.127 19.908 459.127 19.908 459.127");
    			attr_dev(path50, "stroke", "#4F4F4F");
    			attr_dev(path50, "stroke-linecap", "round");
    			add_location(path50, file$b, 64, 8, 8834);
    			attr_dev(path51, "d", "M27.736 459.127C27.736 459.127 19.908 459.127 19.908 467.951C19.908 476.775 27.736 476.775 27.736 476.775");
    			attr_dev(path51, "stroke", "#4F4F4F");
    			attr_dev(path51, "stroke-linecap", "round");
    			add_location(path51, file$b, 65, 8, 9000);
    			attr_dev(path52, "d", "M19.908 494.424C19.908 494.424 27.736 494.424 27.736 485.599C27.736 476.775 19.908 476.775 19.908 476.775");
    			attr_dev(path52, "stroke", "#4F4F4F");
    			attr_dev(path52, "stroke-linecap", "round");
    			add_location(path52, file$b, 66, 8, 9166);
    			attr_dev(path53, "d", "M27.736 476.776C27.736 476.776 19.908 476.776 19.908 485.6C19.908 494.424 27.736 494.424 27.736 494.424");
    			attr_dev(path53, "stroke", "#4F4F4F");
    			attr_dev(path53, "stroke-linecap", "round");
    			add_location(path53, file$b, 67, 8, 9332);
    			attr_dev(path54, "d", "M19.908 565.362C19.908 565.362 27.736 565.362 27.736 556.538C27.736 547.714 19.908 547.714 19.908 547.714");
    			attr_dev(path54, "stroke", "#4F4F4F");
    			attr_dev(path54, "stroke-linecap", "round");
    			add_location(path54, file$b, 68, 8, 9496);
    			attr_dev(path55, "d", "M27.736 547.714C27.736 547.714 19.908 547.714 19.908 556.538C19.908 565.362 27.736 565.362 27.736 565.362");
    			attr_dev(path55, "stroke", "#4F4F4F");
    			attr_dev(path55, "stroke-linecap", "round");
    			add_location(path55, file$b, 69, 8, 9662);
    			attr_dev(path56, "d", "M19.908 582.999C19.908 582.999 27.736 582.999 27.736 574.175C27.736 565.351 19.908 565.351 19.908 565.351");
    			attr_dev(path56, "stroke", "#4F4F4F");
    			attr_dev(path56, "stroke-linecap", "round");
    			add_location(path56, file$b, 70, 8, 9828);
    			attr_dev(path57, "d", "M27.736 565.351C27.736 565.351 19.908 565.351 19.908 574.175C19.908 582.999 27.736 582.999 27.736 582.999");
    			attr_dev(path57, "stroke", "#4F4F4F");
    			attr_dev(path57, "stroke-linecap", "round");
    			add_location(path57, file$b, 71, 8, 9994);
    			attr_dev(path58, "d", "M19.908 34.6472C19.908 34.6472 27.736 34.6472 27.736 25.8231C27.736 16.999 19.908 16.999 19.908 16.999");
    			attr_dev(path58, "stroke", "#4F4F4F");
    			attr_dev(path58, "stroke-linecap", "round");
    			add_location(path58, file$b, 72, 8, 10160);
    			attr_dev(path59, "d", "M27.736 16.9993C27.736 16.9993 19.908 16.9993 19.908 25.8234C19.908 34.6475 27.736 34.6475 27.736 34.6475");
    			attr_dev(path59, "stroke", "#4F4F4F");
    			attr_dev(path59, "stroke-linecap", "round");
    			add_location(path59, file$b, 73, 8, 10323);
    			attr_dev(path60, "d", "M19.908 52.2844C19.908 52.2844 27.736 52.2844 27.736 43.4603C27.736 34.6362 19.908 34.6362 19.908 34.6362");
    			attr_dev(path60, "stroke", "#4F4F4F");
    			attr_dev(path60, "stroke-linecap", "round");
    			add_location(path60, file$b, 74, 8, 10489);
    			attr_dev(path61, "d", "M27.736 34.636C27.736 34.636 19.908 34.636 19.908 43.4601C19.908 52.2842 27.736 52.2842 27.736 52.2842");
    			attr_dev(path61, "stroke", "#4F4F4F");
    			attr_dev(path61, "stroke-linecap", "round");
    			add_location(path61, file$b, 75, 8, 10655);
    			attr_dev(path62, "d", "M19.908 69.9323C19.908 69.9323 27.736 69.9323 27.736 61.1083C27.736 52.2842 19.908 52.2842 19.908 52.2842");
    			attr_dev(path62, "stroke", "#4F4F4F");
    			attr_dev(path62, "stroke-linecap", "round");
    			add_location(path62, file$b, 76, 8, 10818);
    			attr_dev(path63, "d", "M27.736 52.2845C27.736 52.2845 19.908 52.2845 19.908 61.1085C19.908 69.9326 27.736 69.9326 27.736 69.9326");
    			attr_dev(path63, "stroke", "#4F4F4F");
    			attr_dev(path63, "stroke-linecap", "round");
    			add_location(path63, file$b, 77, 8, 10984);
    			attr_dev(path64, "d", "M322.264 406.25C322.264 406.25 330.092 406.25 330.092 397.426C330.092 388.602 322.264 388.602 322.264 388.602");
    			attr_dev(path64, "stroke", "#4F4F4F");
    			attr_dev(path64, "stroke-linecap", "round");
    			add_location(path64, file$b, 78, 8, 11150);
    			attr_dev(path65, "d", "M330.092 388.602C330.092 388.602 322.264 388.602 322.264 397.426C322.264 406.25 330.092 406.25 330.092 406.25");
    			attr_dev(path65, "stroke", "#4F4F4F");
    			attr_dev(path65, "stroke-linecap", "round");
    			add_location(path65, file$b, 79, 8, 11320);
    			attr_dev(path66, "d", "M322.264 423.887C322.264 423.887 330.092 423.887 330.092 415.063C330.092 406.239 322.264 406.239 322.264 406.239");
    			attr_dev(path66, "stroke", "#4F4F4F");
    			attr_dev(path66, "stroke-linecap", "round");
    			add_location(path66, file$b, 80, 8, 11490);
    			attr_dev(path67, "d", "M330.092 406.239C330.092 406.239 322.264 406.239 322.264 415.063C322.264 423.887 330.092 423.887 330.092 423.887");
    			attr_dev(path67, "stroke", "#4F4F4F");
    			attr_dev(path67, "stroke-linecap", "round");
    			add_location(path67, file$b, 81, 8, 11663);
    			attr_dev(path68, "d", "M322.264 441.535C322.264 441.535 330.092 441.535 330.092 432.711C330.092 423.887 322.264 423.887 322.264 423.887");
    			attr_dev(path68, "stroke", "#4F4F4F");
    			attr_dev(path68, "stroke-linecap", "round");
    			add_location(path68, file$b, 82, 8, 11836);
    			attr_dev(path69, "d", "M330.092 423.887C330.092 423.887 322.264 423.887 322.264 432.712C322.264 441.536 330.092 441.536 330.092 441.536");
    			attr_dev(path69, "stroke", "#4F4F4F");
    			attr_dev(path69, "stroke-linecap", "round");
    			add_location(path69, file$b, 83, 8, 12009);
    			attr_dev(path70, "d", "M322.264 353.317C322.264 353.317 330.092 353.317 330.092 344.493C330.092 335.669 322.264 335.669 322.264 335.669");
    			attr_dev(path70, "stroke", "#4F4F4F");
    			attr_dev(path70, "stroke-linecap", "round");
    			add_location(path70, file$b, 84, 8, 12182);
    			attr_dev(path71, "d", "M330.092 335.669C330.092 335.669 322.264 335.669 322.264 344.493C322.264 353.317 330.092 353.317 330.092 353.317");
    			attr_dev(path71, "stroke", "#4F4F4F");
    			attr_dev(path71, "stroke-linecap", "round");
    			add_location(path71, file$b, 85, 8, 12355);
    			attr_dev(path72, "d", "M322.264 370.953C322.264 370.953 330.092 370.953 330.092 362.129C330.092 353.305 322.264 353.305 322.264 353.305");
    			attr_dev(path72, "stroke", "#4F4F4F");
    			attr_dev(path72, "stroke-linecap", "round");
    			add_location(path72, file$b, 86, 8, 12528);
    			attr_dev(path73, "d", "M330.092 353.305C330.092 353.305 322.264 353.305 322.264 362.129C322.264 370.953 330.092 370.953 330.092 370.953");
    			attr_dev(path73, "stroke", "#4F4F4F");
    			attr_dev(path73, "stroke-linecap", "round");
    			add_location(path73, file$b, 87, 8, 12701);
    			attr_dev(path74, "d", "M322.264 388.601C322.264 388.601 330.092 388.601 330.092 379.777C330.092 370.953 322.264 370.953 322.264 370.953");
    			attr_dev(path74, "stroke", "#4F4F4F");
    			attr_dev(path74, "stroke-linecap", "round");
    			add_location(path74, file$b, 88, 8, 12874);
    			attr_dev(path75, "d", "M330.092 370.953C330.092 370.953 322.264 370.953 322.264 379.777C322.264 388.602 330.092 388.602 330.092 388.602");
    			attr_dev(path75, "stroke", "#4F4F4F");
    			attr_dev(path75, "stroke-linecap", "round");
    			add_location(path75, file$b, 89, 8, 13047);
    			attr_dev(path76, "d", "M322.264 300.026C322.264 300.026 330.092 300.026 330.092 291.202C330.092 282.378 322.264 282.378 322.264 282.378");
    			attr_dev(path76, "stroke", "#4F4F4F");
    			attr_dev(path76, "stroke-linecap", "round");
    			add_location(path76, file$b, 90, 8, 13220);
    			attr_dev(path77, "d", "M330.092 282.378C330.092 282.378 322.264 282.378 322.264 291.202C322.264 300.026 330.092 300.026 330.092 300.026");
    			attr_dev(path77, "stroke", "#4F4F4F");
    			attr_dev(path77, "stroke-linecap", "round");
    			add_location(path77, file$b, 91, 8, 13393);
    			attr_dev(path78, "d", "M322.264 317.664C322.264 317.664 330.092 317.664 330.092 308.84C330.092 300.016 322.264 300.016 322.264 300.016");
    			attr_dev(path78, "stroke", "#4F4F4F");
    			attr_dev(path78, "stroke-linecap", "round");
    			add_location(path78, file$b, 92, 8, 13566);
    			attr_dev(path79, "d", "M330.092 300.016C330.092 300.016 322.264 300.016 322.264 308.84C322.264 317.665 330.092 317.665 330.092 317.665");
    			attr_dev(path79, "stroke", "#4F4F4F");
    			attr_dev(path79, "stroke-linecap", "round");
    			add_location(path79, file$b, 93, 8, 13738);
    			attr_dev(path80, "d", "M322.264 335.313C322.264 335.313 330.092 335.313 330.092 326.489C330.092 317.665 322.264 317.665 322.264 317.665");
    			attr_dev(path80, "stroke", "#4F4F4F");
    			attr_dev(path80, "stroke-linecap", "round");
    			add_location(path80, file$b, 94, 8, 13910);
    			attr_dev(path81, "d", "M330.092 317.665C330.092 317.665 322.264 317.665 322.264 326.489C322.264 335.313 330.092 335.313 330.092 335.313");
    			attr_dev(path81, "stroke", "#4F4F4F");
    			attr_dev(path81, "stroke-linecap", "round");
    			add_location(path81, file$b, 95, 8, 14083);
    			attr_dev(path82, "d", "M322.264 247.093C322.264 247.093 330.092 247.093 330.092 238.269C330.092 229.445 322.264 229.445 322.264 229.445");
    			attr_dev(path82, "stroke", "#4F4F4F");
    			attr_dev(path82, "stroke-linecap", "round");
    			add_location(path82, file$b, 96, 8, 14256);
    			attr_dev(path83, "d", "M330.092 229.445C330.092 229.445 322.264 229.445 322.264 238.269C322.264 247.093 330.092 247.093 330.092 247.093");
    			attr_dev(path83, "stroke", "#4F4F4F");
    			attr_dev(path83, "stroke-linecap", "round");
    			add_location(path83, file$b, 97, 8, 14429);
    			attr_dev(path84, "d", "M322.264 264.73C322.264 264.73 330.092 264.73 330.092 255.906C330.092 247.082 322.264 247.082 322.264 247.082");
    			attr_dev(path84, "stroke", "#4F4F4F");
    			attr_dev(path84, "stroke-linecap", "round");
    			add_location(path84, file$b, 98, 8, 14602);
    			attr_dev(path85, "d", "M330.092 247.083C330.092 247.083 322.264 247.083 322.264 255.907C322.264 264.731 330.092 264.731 330.092 264.731");
    			attr_dev(path85, "stroke", "#4F4F4F");
    			attr_dev(path85, "stroke-linecap", "round");
    			add_location(path85, file$b, 99, 8, 14772);
    			attr_dev(path86, "d", "M322.264 282.379C322.264 282.379 330.092 282.379 330.092 273.555C330.092 264.731 322.264 264.731 322.264 264.731");
    			attr_dev(path86, "stroke", "#4F4F4F");
    			attr_dev(path86, "stroke-linecap", "round");
    			add_location(path86, file$b, 100, 8, 14945);
    			attr_dev(path87, "d", "M330.092 264.731C330.092 264.731 322.264 264.731 322.264 273.555C322.264 282.379 330.092 282.379 330.092 282.379");
    			attr_dev(path87, "stroke", "#4F4F4F");
    			attr_dev(path87, "stroke-linecap", "round");
    			add_location(path87, file$b, 101, 8, 15118);
    			attr_dev(path88, "d", "M322.264 193.804C322.264 193.804 330.092 193.804 330.092 184.98C330.092 176.156 322.264 176.156 322.264 176.156");
    			attr_dev(path88, "stroke", "#4F4F4F");
    			attr_dev(path88, "stroke-linecap", "round");
    			add_location(path88, file$b, 102, 8, 15291);
    			attr_dev(path89, "d", "M330.092 176.156C330.092 176.156 322.264 176.156 322.264 184.98C322.264 193.804 330.092 193.804 330.092 193.804");
    			attr_dev(path89, "stroke", "#4F4F4F");
    			attr_dev(path89, "stroke-linecap", "round");
    			add_location(path89, file$b, 103, 8, 15463);
    			attr_dev(path90, "d", "M322.264 211.441C322.264 211.441 330.092 211.441 330.092 202.617C330.092 193.793 322.264 193.793 322.264 193.793");
    			attr_dev(path90, "stroke", "#4F4F4F");
    			attr_dev(path90, "stroke-linecap", "round");
    			add_location(path90, file$b, 104, 8, 15635);
    			attr_dev(path91, "d", "M330.092 193.793C330.092 193.793 322.264 193.793 322.264 202.617C322.264 211.441 330.092 211.441 330.092 211.441");
    			attr_dev(path91, "stroke", "#4F4F4F");
    			attr_dev(path91, "stroke-linecap", "round");
    			add_location(path91, file$b, 105, 8, 15808);
    			attr_dev(path92, "d", "M322.264 229.09C322.264 229.09 330.092 229.09 330.092 220.265C330.092 211.441 322.264 211.441 322.264 211.441");
    			attr_dev(path92, "stroke", "#4F4F4F");
    			attr_dev(path92, "stroke-linecap", "round");
    			add_location(path92, file$b, 106, 8, 15981);
    			attr_dev(path93, "d", "M330.092 211.442C330.092 211.442 322.264 211.442 322.264 220.266C322.264 229.09 330.092 229.09 330.092 229.09");
    			attr_dev(path93, "stroke", "#4F4F4F");
    			attr_dev(path93, "stroke-linecap", "round");
    			add_location(path93, file$b, 107, 8, 16151);
    			attr_dev(path94, "d", "M322.264 140.87C322.264 140.87 330.092 140.87 330.092 132.046C330.092 123.222 322.264 123.222 322.264 123.222");
    			attr_dev(path94, "stroke", "#4F4F4F");
    			attr_dev(path94, "stroke-linecap", "round");
    			add_location(path94, file$b, 108, 8, 16321);
    			attr_dev(path95, "d", "M330.092 123.222C330.092 123.222 322.264 123.222 322.264 132.047C322.264 140.871 330.092 140.871 330.092 140.871");
    			attr_dev(path95, "stroke", "#4F4F4F");
    			attr_dev(path95, "stroke-linecap", "round");
    			add_location(path95, file$b, 109, 8, 16491);
    			attr_dev(path96, "d", "M322.264 158.508C322.264 158.508 330.092 158.508 330.092 149.683C330.092 140.859 322.264 140.859 322.264 140.859");
    			attr_dev(path96, "stroke", "#4F4F4F");
    			attr_dev(path96, "stroke-linecap", "round");
    			add_location(path96, file$b, 110, 8, 16664);
    			attr_dev(path97, "d", "M330.092 140.86C330.092 140.86 322.264 140.86 322.264 149.684C322.264 158.508 330.092 158.508 330.092 158.508");
    			attr_dev(path97, "stroke", "#4F4F4F");
    			attr_dev(path97, "stroke-linecap", "round");
    			add_location(path97, file$b, 111, 8, 16837);
    			attr_dev(path98, "d", "M322.264 176.155C322.264 176.155 330.092 176.155 330.092 167.331C330.092 158.507 322.264 158.507 322.264 158.507");
    			attr_dev(path98, "stroke", "#4F4F4F");
    			attr_dev(path98, "stroke-linecap", "round");
    			add_location(path98, file$b, 112, 8, 17007);
    			attr_dev(path99, "d", "M330.092 158.507C330.092 158.507 322.264 158.507 322.264 167.331C322.264 176.155 330.092 176.155 330.092 176.155");
    			attr_dev(path99, "stroke", "#4F4F4F");
    			attr_dev(path99, "stroke-linecap", "round");
    			add_location(path99, file$b, 113, 8, 17180);
    			attr_dev(path100, "d", "M322.264 87.5808C322.264 87.5808 330.092 87.5808 330.092 78.7567C330.092 69.9326 322.264 69.9326 322.264 69.9326");
    			attr_dev(path100, "stroke", "#4F4F4F");
    			attr_dev(path100, "stroke-linecap", "round");
    			add_location(path100, file$b, 114, 8, 17353);
    			attr_dev(path101, "d", "M330.092 69.9334C330.092 69.9334 322.264 69.9334 322.264 78.7575C322.264 87.5815 330.092 87.5815 330.092 87.5815");
    			attr_dev(path101, "stroke", "#4F4F4F");
    			attr_dev(path101, "stroke-linecap", "round");
    			add_location(path101, file$b, 115, 8, 17526);
    			attr_dev(path102, "d", "M322.264 105.218C322.264 105.218 330.092 105.218 330.092 96.3944C330.092 87.5703 322.264 87.5703 322.264 87.5703");
    			attr_dev(path102, "stroke", "#4F4F4F");
    			attr_dev(path102, "stroke-linecap", "round");
    			add_location(path102, file$b, 116, 8, 17699);
    			attr_dev(path103, "d", "M330.092 87.5706C330.092 87.5706 322.264 87.5706 322.264 96.3947C322.264 105.219 330.092 105.219 330.092 105.219");
    			attr_dev(path103, "stroke", "#4F4F4F");
    			attr_dev(path103, "stroke-linecap", "round");
    			add_location(path103, file$b, 117, 8, 17872);
    			attr_dev(path104, "d", "M322.264 122.865C322.264 122.865 330.092 122.865 330.092 114.041C330.092 105.217 322.264 105.217 322.264 105.217");
    			attr_dev(path104, "stroke", "#4F4F4F");
    			attr_dev(path104, "stroke-linecap", "round");
    			add_location(path104, file$b, 118, 8, 18045);
    			attr_dev(path105, "d", "M330.092 105.218C330.092 105.218 322.264 105.218 322.264 114.042C322.264 122.866 330.092 122.866 330.092 122.866");
    			attr_dev(path105, "stroke", "#4F4F4F");
    			attr_dev(path105, "stroke-linecap", "round");
    			add_location(path105, file$b, 119, 8, 18218);
    			attr_dev(path106, "d", "M322.264 512.072C322.264 512.072 330.092 512.072 330.092 503.248C330.092 494.424 322.264 494.424 322.264 494.424");
    			attr_dev(path106, "stroke", "#4F4F4F");
    			attr_dev(path106, "stroke-linecap", "round");
    			add_location(path106, file$b, 120, 8, 18391);
    			attr_dev(path107, "d", "M330.092 494.424C330.092 494.424 322.264 494.424 322.264 503.248C322.264 512.072 330.092 512.072 330.092 512.072");
    			attr_dev(path107, "stroke", "#4F4F4F");
    			attr_dev(path107, "stroke-linecap", "round");
    			add_location(path107, file$b, 121, 8, 18564);
    			attr_dev(path108, "d", "M322.264 529.709C322.264 529.709 330.092 529.709 330.092 520.885C330.092 512.061 322.264 512.061 322.264 512.061");
    			attr_dev(path108, "stroke", "#4F4F4F");
    			attr_dev(path108, "stroke-linecap", "round");
    			add_location(path108, file$b, 122, 8, 18737);
    			attr_dev(path109, "d", "M330.092 512.061C330.092 512.061 322.264 512.061 322.264 520.885C322.264 529.709 330.092 529.709 330.092 529.709");
    			attr_dev(path109, "stroke", "#4F4F4F");
    			attr_dev(path109, "stroke-linecap", "round");
    			add_location(path109, file$b, 123, 8, 18910);
    			attr_dev(path110, "d", "M322.264 547.358C322.264 547.358 330.092 547.358 330.092 538.534C330.092 529.71 322.264 529.71 322.264 529.71");
    			attr_dev(path110, "stroke", "#4F4F4F");
    			attr_dev(path110, "stroke-linecap", "round");
    			add_location(path110, file$b, 124, 8, 19083);
    			attr_dev(path111, "d", "M330.092 529.71C330.092 529.71 322.264 529.71 322.264 538.534C322.264 547.358 330.092 547.358 330.092 547.358");
    			attr_dev(path111, "stroke", "#4F4F4F");
    			attr_dev(path111, "stroke-linecap", "round");
    			add_location(path111, file$b, 125, 8, 19253);
    			attr_dev(path112, "d", "M322.264 459.138C322.264 459.138 330.092 459.138 330.092 450.314C330.092 441.49 322.264 441.49 322.264 441.49");
    			attr_dev(path112, "stroke", "#4F4F4F");
    			attr_dev(path112, "stroke-linecap", "round");
    			add_location(path112, file$b, 126, 8, 19423);
    			attr_dev(path113, "d", "M330.092 441.491C330.092 441.491 322.264 441.491 322.264 450.315C322.264 459.139 330.092 459.139 330.092 459.139");
    			attr_dev(path113, "stroke", "#4F4F4F");
    			attr_dev(path113, "stroke-linecap", "round");
    			add_location(path113, file$b, 127, 8, 19593);
    			attr_dev(path114, "d", "M322.264 476.775C322.264 476.775 330.092 476.775 330.092 467.951C330.092 459.127 322.264 459.127 322.264 459.127");
    			attr_dev(path114, "stroke", "#4F4F4F");
    			attr_dev(path114, "stroke-linecap", "round");
    			add_location(path114, file$b, 128, 8, 19766);
    			attr_dev(path115, "d", "M330.092 459.127C330.092 459.127 322.264 459.127 322.264 467.951C322.264 476.775 330.092 476.775 330.092 476.775");
    			attr_dev(path115, "stroke", "#4F4F4F");
    			attr_dev(path115, "stroke-linecap", "round");
    			add_location(path115, file$b, 129, 8, 19939);
    			attr_dev(path116, "d", "M322.264 494.424C322.264 494.424 330.092 494.424 330.092 485.599C330.092 476.775 322.264 476.775 322.264 476.775");
    			attr_dev(path116, "stroke", "#4F4F4F");
    			attr_dev(path116, "stroke-linecap", "round");
    			add_location(path116, file$b, 130, 8, 20112);
    			attr_dev(path117, "d", "M330.092 476.776C330.092 476.776 322.264 476.776 322.264 485.6C322.264 494.424 330.092 494.424 330.092 494.424");
    			attr_dev(path117, "stroke", "#4F4F4F");
    			attr_dev(path117, "stroke-linecap", "round");
    			add_location(path117, file$b, 131, 8, 20285);
    			attr_dev(path118, "d", "M322.264 565.362C322.264 565.362 330.092 565.362 330.092 556.538C330.092 547.714 322.264 547.714 322.264 547.714");
    			attr_dev(path118, "stroke", "#4F4F4F");
    			attr_dev(path118, "stroke-linecap", "round");
    			add_location(path118, file$b, 132, 8, 20456);
    			attr_dev(path119, "d", "M330.092 547.714C330.092 547.714 322.264 547.714 322.264 556.538C322.264 565.362 330.092 565.362 330.092 565.362");
    			attr_dev(path119, "stroke", "#4F4F4F");
    			attr_dev(path119, "stroke-linecap", "round");
    			add_location(path119, file$b, 133, 8, 20629);
    			attr_dev(path120, "d", "M322.264 582.999C322.264 582.999 330.092 582.999 330.092 574.175C330.092 565.351 322.264 565.351 322.264 565.351");
    			attr_dev(path120, "stroke", "#4F4F4F");
    			attr_dev(path120, "stroke-linecap", "round");
    			add_location(path120, file$b, 134, 8, 20802);
    			attr_dev(path121, "d", "M330.092 565.351C330.092 565.351 322.264 565.351 322.264 574.175C322.264 582.999 330.092 582.999 330.092 582.999");
    			attr_dev(path121, "stroke", "#4F4F4F");
    			attr_dev(path121, "stroke-linecap", "round");
    			add_location(path121, file$b, 135, 8, 20975);
    			attr_dev(path122, "d", "M322.264 34.6472C322.264 34.6472 330.092 34.6472 330.092 25.8231C330.092 16.999 322.264 16.999 322.264 16.999");
    			attr_dev(path122, "stroke", "#4F4F4F");
    			attr_dev(path122, "stroke-linecap", "round");
    			add_location(path122, file$b, 136, 8, 21148);
    			attr_dev(path123, "d", "M330.092 16.9993C330.092 16.9993 322.264 16.9993 322.264 25.8234C322.264 34.6475 330.092 34.6475 330.092 34.6475");
    			attr_dev(path123, "stroke", "#4F4F4F");
    			attr_dev(path123, "stroke-linecap", "round");
    			add_location(path123, file$b, 137, 8, 21318);
    			attr_dev(path124, "d", "M322.264 52.2844C322.264 52.2844 330.092 52.2844 330.092 43.4603C330.092 34.6362 322.264 34.6362 322.264 34.6362");
    			attr_dev(path124, "stroke", "#4F4F4F");
    			attr_dev(path124, "stroke-linecap", "round");
    			add_location(path124, file$b, 138, 8, 21491);
    			attr_dev(path125, "d", "M330.092 34.636C330.092 34.636 322.264 34.636 322.264 43.4601C322.264 52.2842 330.092 52.2842 330.092 52.2842");
    			attr_dev(path125, "stroke", "#4F4F4F");
    			attr_dev(path125, "stroke-linecap", "round");
    			add_location(path125, file$b, 139, 8, 21664);
    			attr_dev(path126, "d", "M322.264 69.9323C322.264 69.9323 330.092 69.9323 330.092 61.1083C330.092 52.2842 322.264 52.2842 322.264 52.2842");
    			attr_dev(path126, "stroke", "#4F4F4F");
    			attr_dev(path126, "stroke-linecap", "round");
    			add_location(path126, file$b, 140, 8, 21834);
    			attr_dev(path127, "d", "M330.092 52.2845C330.092 52.2845 322.264 52.2845 322.264 61.1085C322.264 69.9326 330.092 69.9326 330.092 69.9326");
    			attr_dev(path127, "stroke", "#4F4F4F");
    			attr_dev(path127, "stroke-linecap", "round");
    			add_location(path127, file$b, 141, 8, 22007);
    			attr_dev(path128, "d", "M37.1404 25.0159C37.1404 25.0159 37.1404 16.999 28.5242 16.999C19.908 16.999 19.908 25.0159 19.908 25.0159");
    			attr_dev(path128, "stroke", "#4F4F4F");
    			attr_dev(path128, "stroke-linecap", "round");
    			add_location(path128, file$b, 142, 8, 22180);
    			attr_dev(path129, "d", "M19.908 16.9988C19.908 16.9988 19.908 25.0156 28.5242 25.0156C37.1404 25.0156 37.1404 16.9988 37.1404 16.9988");
    			attr_dev(path129, "stroke", "#4F4F4F");
    			attr_dev(path129, "stroke-linecap", "round");
    			add_location(path129, file$b, 143, 8, 22347);
    			attr_dev(path130, "d", "M54.3729 25.0159C54.3729 25.0159 54.3729 16.999 45.7567 16.999C37.1404 16.999 37.1404 25.0159 37.1404 25.0159");
    			attr_dev(path130, "stroke", "#4F4F4F");
    			attr_dev(path130, "stroke-linecap", "round");
    			add_location(path130, file$b, 144, 8, 22517);
    			attr_dev(path131, "d", "M37.1404 16.9988C37.1404 16.9988 37.1404 25.0156 45.7567 25.0156C54.3729 25.0156 54.3729 16.9988 54.3729 16.9988");
    			attr_dev(path131, "stroke", "#4F4F4F");
    			attr_dev(path131, "stroke-linecap", "round");
    			add_location(path131, file$b, 145, 8, 22687);
    			attr_dev(path132, "d", "M71.6053 25.0159C71.6053 25.0159 71.6053 16.999 62.9891 16.999C54.3729 16.999 54.3729 25.0159 54.3729 25.0159");
    			attr_dev(path132, "stroke", "#4F4F4F");
    			attr_dev(path132, "stroke-linecap", "round");
    			add_location(path132, file$b, 146, 8, 22860);
    			attr_dev(path133, "d", "M54.3729 16.9988C54.3729 16.9988 54.3729 25.0156 62.9891 25.0156C71.6053 25.0156 71.6053 16.9988 71.6053 16.9988");
    			attr_dev(path133, "stroke", "#4F4F4F");
    			attr_dev(path133, "stroke-linecap", "round");
    			add_location(path133, file$b, 147, 8, 23030);
    			attr_dev(path134, "d", "M88.8377 25.0159C88.8377 25.0159 88.8377 16.999 80.2214 16.999C71.6052 16.999 71.6052 25.0159 71.6052 25.0159");
    			attr_dev(path134, "stroke", "#4F4F4F");
    			attr_dev(path134, "stroke-linecap", "round");
    			add_location(path134, file$b, 148, 8, 23203);
    			attr_dev(path135, "d", "M71.6052 16.9988C71.6052 16.9988 71.6052 25.0156 80.2215 25.0156C88.8377 25.0156 88.8377 16.9988 88.8377 16.9988");
    			attr_dev(path135, "stroke", "#4F4F4F");
    			attr_dev(path135, "stroke-linecap", "round");
    			add_location(path135, file$b, 149, 8, 23373);
    			attr_dev(path136, "d", "M106.07 25.0159C106.07 25.0159 106.07 16.999 97.4539 16.999C88.8377 16.999 88.8377 25.0159 88.8377 25.0159");
    			attr_dev(path136, "stroke", "#4F4F4F");
    			attr_dev(path136, "stroke-linecap", "round");
    			add_location(path136, file$b, 150, 8, 23546);
    			attr_dev(path137, "d", "M88.8378 16.9988C88.8378 16.9988 88.8378 25.0156 97.454 25.0156C106.07 25.0156 106.07 16.9988 106.07 16.9988");
    			attr_dev(path137, "stroke", "#4F4F4F");
    			attr_dev(path137, "stroke-linecap", "round");
    			add_location(path137, file$b, 151, 8, 23713);
    			attr_dev(path138, "d", "M123.303 25.0159C123.303 25.0159 123.303 16.999 114.686 16.999C106.07 16.999 106.07 25.0159 106.07 25.0159");
    			attr_dev(path138, "stroke", "#4F4F4F");
    			attr_dev(path138, "stroke-linecap", "round");
    			add_location(path138, file$b, 152, 8, 23882);
    			attr_dev(path139, "d", "M106.07 16.9988C106.07 16.9988 106.07 25.0156 114.686 25.0156C123.303 25.0156 123.303 16.9988 123.303 16.9988");
    			attr_dev(path139, "stroke", "#4F4F4F");
    			attr_dev(path139, "stroke-linecap", "round");
    			add_location(path139, file$b, 153, 8, 24049);
    			attr_dev(path140, "d", "M140.535 25.0159C140.535 25.0159 140.535 16.999 131.919 16.999C123.303 16.999 123.303 25.0159 123.303 25.0159");
    			attr_dev(path140, "stroke", "#4F4F4F");
    			attr_dev(path140, "stroke-linecap", "round");
    			add_location(path140, file$b, 154, 8, 24219);
    			attr_dev(path141, "d", "M123.303 16.9988C123.303 16.9988 123.303 25.0156 131.919 25.0156C140.535 25.0156 140.535 16.9988 140.535 16.9988");
    			attr_dev(path141, "stroke", "#4F4F4F");
    			attr_dev(path141, "stroke-linecap", "round");
    			add_location(path141, file$b, 155, 8, 24389);
    			attr_dev(path142, "d", "M157.767 25.0159C157.767 25.0159 157.767 16.999 149.151 16.999C140.535 16.999 140.535 25.0159 140.535 25.0159");
    			attr_dev(path142, "stroke", "#4F4F4F");
    			attr_dev(path142, "stroke-linecap", "round");
    			add_location(path142, file$b, 156, 8, 24562);
    			attr_dev(path143, "d", "M140.535 16.9988C140.535 16.9988 140.535 25.0156 149.151 25.0156C157.767 25.0156 157.767 16.9988 157.767 16.9988");
    			attr_dev(path143, "stroke", "#4F4F4F");
    			attr_dev(path143, "stroke-linecap", "round");
    			add_location(path143, file$b, 157, 8, 24732);
    			attr_dev(path144, "d", "M175 25.0159C175 25.0159 175 16.999 166.384 16.999C157.767 16.999 157.767 25.0159 157.767 25.0159");
    			attr_dev(path144, "stroke", "#4F4F4F");
    			attr_dev(path144, "stroke-linecap", "round");
    			add_location(path144, file$b, 158, 8, 24905);
    			attr_dev(path145, "d", "M157.768 16.9988C157.768 16.9988 157.768 25.0156 166.384 25.0156C175 25.0156 175 16.9988 175 16.9988");
    			attr_dev(path145, "stroke", "#4F4F4F");
    			attr_dev(path145, "stroke-linecap", "round");
    			add_location(path145, file$b, 159, 8, 25063);
    			attr_dev(path146, "d", "M192.232 25.0159C192.232 25.0159 192.232 16.999 183.616 16.999C175 16.999 175 25.0159 175 25.0159");
    			attr_dev(path146, "stroke", "#4F4F4F");
    			attr_dev(path146, "stroke-linecap", "round");
    			add_location(path146, file$b, 160, 8, 25224);
    			attr_dev(path147, "d", "M175 16.9988C175 16.9988 175 25.0156 183.616 25.0156C192.232 25.0156 192.232 16.9988 192.232 16.9988");
    			attr_dev(path147, "stroke", "#4F4F4F");
    			attr_dev(path147, "stroke-linecap", "round");
    			add_location(path147, file$b, 161, 8, 25382);
    			attr_dev(path148, "d", "M209.465 25.0159C209.465 25.0159 209.465 16.999 200.849 16.999C192.232 16.999 192.232 25.0159 192.232 25.0159");
    			attr_dev(path148, "stroke", "#4F4F4F");
    			attr_dev(path148, "stroke-linecap", "round");
    			add_location(path148, file$b, 162, 8, 25543);
    			attr_dev(path149, "d", "M192.232 16.9988C192.232 16.9988 192.232 25.0156 200.849 25.0156C209.465 25.0156 209.465 16.9988 209.465 16.9988");
    			attr_dev(path149, "stroke", "#4F4F4F");
    			attr_dev(path149, "stroke-linecap", "round");
    			add_location(path149, file$b, 163, 8, 25713);
    			attr_dev(path150, "d", "M226.697 25.0159C226.697 25.0159 226.697 16.999 218.081 16.999C209.465 16.999 209.465 25.0159 209.465 25.0159");
    			attr_dev(path150, "stroke", "#4F4F4F");
    			attr_dev(path150, "stroke-linecap", "round");
    			add_location(path150, file$b, 164, 8, 25886);
    			attr_dev(path151, "d", "M209.465 16.9988C209.465 16.9988 209.465 25.0156 218.081 25.0156C226.697 25.0156 226.697 16.9988 226.697 16.9988");
    			attr_dev(path151, "stroke", "#4F4F4F");
    			attr_dev(path151, "stroke-linecap", "round");
    			add_location(path151, file$b, 165, 8, 26056);
    			attr_dev(path152, "d", "M243.93 25.0159C243.93 25.0159 243.93 16.999 235.314 16.999C226.697 16.999 226.697 25.0159 226.697 25.0159");
    			attr_dev(path152, "stroke", "#4F4F4F");
    			attr_dev(path152, "stroke-linecap", "round");
    			add_location(path152, file$b, 166, 8, 26229);
    			attr_dev(path153, "d", "M226.697 16.9988C226.697 16.9988 226.697 25.0156 235.314 25.0156C243.93 25.0156 243.93 16.9988 243.93 16.9988");
    			attr_dev(path153, "stroke", "#4F4F4F");
    			attr_dev(path153, "stroke-linecap", "round");
    			add_location(path153, file$b, 167, 8, 26396);
    			attr_dev(path154, "d", "M261.162 25.0159C261.162 25.0159 261.162 16.999 252.546 16.999C243.93 16.999 243.93 25.0159 243.93 25.0159");
    			attr_dev(path154, "stroke", "#4F4F4F");
    			attr_dev(path154, "stroke-linecap", "round");
    			add_location(path154, file$b, 168, 8, 26566);
    			attr_dev(path155, "d", "M243.93 16.9988C243.93 16.9988 243.93 25.0156 252.546 25.0156C261.162 25.0156 261.162 16.9988 261.162 16.9988");
    			attr_dev(path155, "stroke", "#4F4F4F");
    			attr_dev(path155, "stroke-linecap", "round");
    			add_location(path155, file$b, 169, 8, 26733);
    			attr_dev(path156, "d", "M278.395 25.0159C278.395 25.0159 278.395 16.999 269.778 16.999C261.162 16.999 261.162 25.0159 261.162 25.0159");
    			attr_dev(path156, "stroke", "#4F4F4F");
    			attr_dev(path156, "stroke-linecap", "round");
    			add_location(path156, file$b, 170, 8, 26903);
    			attr_dev(path157, "d", "M261.162 16.9988C261.162 16.9988 261.162 25.0156 269.778 25.0156C278.395 25.0156 278.395 16.9988 278.395 16.9988");
    			attr_dev(path157, "stroke", "#4F4F4F");
    			attr_dev(path157, "stroke-linecap", "round");
    			add_location(path157, file$b, 171, 8, 27073);
    			attr_dev(path158, "d", "M295.627 25.0159C295.627 25.0159 295.627 16.999 287.011 16.999C278.395 16.999 278.395 25.0159 278.395 25.0159");
    			attr_dev(path158, "stroke", "#4F4F4F");
    			attr_dev(path158, "stroke-linecap", "round");
    			add_location(path158, file$b, 172, 8, 27246);
    			attr_dev(path159, "d", "M278.395 16.9988C278.395 16.9988 278.395 25.0156 287.011 25.0156C295.627 25.0156 295.627 16.9988 295.627 16.9988");
    			attr_dev(path159, "stroke", "#4F4F4F");
    			attr_dev(path159, "stroke-linecap", "round");
    			add_location(path159, file$b, 173, 8, 27416);
    			attr_dev(path160, "d", "M312.86 25.0159C312.86 25.0159 312.86 16.999 304.243 16.999C295.627 16.999 295.627 25.0159 295.627 25.0159");
    			attr_dev(path160, "stroke", "#4F4F4F");
    			attr_dev(path160, "stroke-linecap", "round");
    			add_location(path160, file$b, 174, 8, 27589);
    			attr_dev(path161, "d", "M295.627 16.9988C295.627 16.9988 295.627 25.0156 304.243 25.0156C312.86 25.0156 312.86 16.9988 312.86 16.9988");
    			attr_dev(path161, "stroke", "#4F4F4F");
    			attr_dev(path161, "stroke-linecap", "round");
    			add_location(path161, file$b, 175, 8, 27756);
    			attr_dev(path162, "d", "M330.092 25.0159C330.092 25.0159 330.092 16.999 321.476 16.999C312.86 16.999 312.86 25.0159 312.86 25.0159");
    			attr_dev(path162, "stroke", "#4F4F4F");
    			attr_dev(path162, "stroke-linecap", "round");
    			add_location(path162, file$b, 176, 8, 27926);
    			attr_dev(path163, "d", "M312.86 16.9988C312.86 16.9988 312.86 25.0156 321.476 25.0156C330.092 25.0156 330.092 16.9988 330.092 16.9988");
    			attr_dev(path163, "stroke", "#4F4F4F");
    			attr_dev(path163, "stroke-linecap", "round");
    			add_location(path163, file$b, 177, 8, 28093);
    			attr_dev(path164, "d", "M37.1404 582.987C37.1404 582.987 37.1404 574.97 28.5242 574.97C19.908 574.97 19.908 582.987 19.908 582.987");
    			attr_dev(path164, "stroke", "#4F4F4F");
    			attr_dev(path164, "stroke-linecap", "round");
    			add_location(path164, file$b, 178, 8, 28263);
    			attr_dev(path165, "d", "M19.908 574.97C19.908 574.97 19.908 582.987 28.5242 582.987C37.1404 582.987 37.1404 574.97 37.1404 574.97");
    			attr_dev(path165, "stroke", "#4F4F4F");
    			attr_dev(path165, "stroke-linecap", "round");
    			add_location(path165, file$b, 179, 8, 28430);
    			attr_dev(path166, "d", "M54.3729 582.987C54.3729 582.987 54.3729 574.97 45.7567 574.97C37.1404 574.97 37.1404 582.987 37.1404 582.987");
    			attr_dev(path166, "stroke", "#4F4F4F");
    			attr_dev(path166, "stroke-linecap", "round");
    			add_location(path166, file$b, 180, 8, 28596);
    			attr_dev(path167, "d", "M37.1404 574.97C37.1404 574.97 37.1404 582.987 45.7566 582.987C54.3729 582.987 54.3729 574.97 54.3729 574.97");
    			attr_dev(path167, "stroke", "#4F4F4F");
    			attr_dev(path167, "stroke-linecap", "round");
    			add_location(path167, file$b, 181, 8, 28766);
    			attr_dev(path168, "d", "M71.6053 582.987C71.6053 582.987 71.6053 574.97 62.9891 574.97C54.3729 574.97 54.3729 582.987 54.3729 582.987");
    			attr_dev(path168, "stroke", "#4F4F4F");
    			attr_dev(path168, "stroke-linecap", "round");
    			add_location(path168, file$b, 182, 8, 28935);
    			attr_dev(path169, "d", "M54.3729 574.97C54.3729 574.97 54.3729 582.987 62.9891 582.987C71.6053 582.987 71.6053 574.97 71.6053 574.97");
    			attr_dev(path169, "stroke", "#4F4F4F");
    			attr_dev(path169, "stroke-linecap", "round");
    			add_location(path169, file$b, 183, 8, 29105);
    			attr_dev(path170, "d", "M88.8377 582.987C88.8377 582.987 88.8377 574.97 80.2215 574.97C71.6053 574.97 71.6053 582.987 71.6053 582.987");
    			attr_dev(path170, "stroke", "#4F4F4F");
    			attr_dev(path170, "stroke-linecap", "round");
    			add_location(path170, file$b, 184, 8, 29274);
    			attr_dev(path171, "d", "M71.6053 574.97C71.6053 574.97 71.6053 582.987 80.2215 582.987C88.8377 582.987 88.8377 574.97 88.8377 574.97");
    			attr_dev(path171, "stroke", "#4F4F4F");
    			attr_dev(path171, "stroke-linecap", "round");
    			add_location(path171, file$b, 185, 8, 29444);
    			attr_dev(path172, "d", "M106.07 582.987C106.07 582.987 106.07 574.97 97.454 574.97C88.8378 574.97 88.8378 582.987 88.8378 582.987");
    			attr_dev(path172, "stroke", "#4F4F4F");
    			attr_dev(path172, "stroke-linecap", "round");
    			add_location(path172, file$b, 186, 8, 29613);
    			attr_dev(path173, "d", "M88.8378 574.97C88.8378 574.97 88.8378 582.987 97.4541 582.987C106.07 582.987 106.07 574.97 106.07 574.97");
    			attr_dev(path173, "stroke", "#4F4F4F");
    			attr_dev(path173, "stroke-linecap", "round");
    			add_location(path173, file$b, 187, 8, 29779);
    			attr_dev(path174, "d", "M123.303 582.987C123.303 582.987 123.303 574.97 114.686 574.97C106.07 574.97 106.07 582.987 106.07 582.987");
    			attr_dev(path174, "stroke", "#4F4F4F");
    			attr_dev(path174, "stroke-linecap", "round");
    			add_location(path174, file$b, 188, 8, 29945);
    			attr_dev(path175, "d", "M106.07 574.97C106.07 574.97 106.07 582.987 114.686 582.987C123.303 582.987 123.303 574.97 123.303 574.97");
    			attr_dev(path175, "stroke", "#4F4F4F");
    			attr_dev(path175, "stroke-linecap", "round");
    			add_location(path175, file$b, 189, 8, 30112);
    			attr_dev(path176, "d", "M140.535 582.987C140.535 582.987 140.535 574.97 131.919 574.97C123.303 574.97 123.303 582.987 123.303 582.987");
    			attr_dev(path176, "stroke", "#4F4F4F");
    			attr_dev(path176, "stroke-linecap", "round");
    			add_location(path176, file$b, 190, 8, 30278);
    			attr_dev(path177, "d", "M123.303 574.97C123.303 574.97 123.303 582.987 131.919 582.987C140.535 582.987 140.535 574.97 140.535 574.97");
    			attr_dev(path177, "stroke", "#4F4F4F");
    			attr_dev(path177, "stroke-linecap", "round");
    			add_location(path177, file$b, 191, 8, 30448);
    			attr_dev(path178, "d", "M157.768 582.987C157.768 582.987 157.768 574.97 149.151 574.97C140.535 574.97 140.535 582.987 140.535 582.987");
    			attr_dev(path178, "stroke", "#4F4F4F");
    			attr_dev(path178, "stroke-linecap", "round");
    			add_location(path178, file$b, 192, 8, 30617);
    			attr_dev(path179, "d", "M140.535 574.97C140.535 574.97 140.535 582.987 149.151 582.987C157.768 582.987 157.768 574.97 157.768 574.97");
    			attr_dev(path179, "stroke", "#4F4F4F");
    			attr_dev(path179, "stroke-linecap", "round");
    			add_location(path179, file$b, 193, 8, 30787);
    			attr_dev(path180, "d", "M175 582.987C175 582.987 175 574.97 166.384 574.97C157.767 574.97 157.767 582.987 157.767 582.987");
    			attr_dev(path180, "stroke", "#4F4F4F");
    			attr_dev(path180, "stroke-linecap", "round");
    			add_location(path180, file$b, 194, 8, 30956);
    			attr_dev(path181, "d", "M157.768 574.97C157.768 574.97 157.768 582.987 166.384 582.987C175 582.987 175 574.97 175 574.97");
    			attr_dev(path181, "stroke", "#4F4F4F");
    			attr_dev(path181, "stroke-linecap", "round");
    			add_location(path181, file$b, 195, 8, 31114);
    			attr_dev(path182, "d", "M192.232 582.987C192.232 582.987 192.232 574.97 183.616 574.97C175 574.97 175 582.987 175 582.987");
    			attr_dev(path182, "stroke", "#4F4F4F");
    			attr_dev(path182, "stroke-linecap", "round");
    			add_location(path182, file$b, 196, 8, 31271);
    			attr_dev(path183, "d", "M175 574.97C175 574.97 175 582.987 183.616 582.987C192.232 582.987 192.232 574.97 192.232 574.97");
    			attr_dev(path183, "stroke", "#4F4F4F");
    			attr_dev(path183, "stroke-linecap", "round");
    			add_location(path183, file$b, 197, 8, 31429);
    			attr_dev(path184, "d", "M209.465 582.987C209.465 582.987 209.465 574.97 200.849 574.97C192.232 574.97 192.232 582.987 192.232 582.987");
    			attr_dev(path184, "stroke", "#4F4F4F");
    			attr_dev(path184, "stroke-linecap", "round");
    			add_location(path184, file$b, 198, 8, 31586);
    			attr_dev(path185, "d", "M192.232 574.97C192.232 574.97 192.232 582.987 200.849 582.987C209.465 582.987 209.465 574.97 209.465 574.97");
    			attr_dev(path185, "stroke", "#4F4F4F");
    			attr_dev(path185, "stroke-linecap", "round");
    			add_location(path185, file$b, 199, 8, 31756);
    			attr_dev(path186, "d", "M226.697 582.987C226.697 582.987 226.697 574.97 218.081 574.97C209.465 574.97 209.465 582.987 209.465 582.987");
    			attr_dev(path186, "stroke", "#4F4F4F");
    			attr_dev(path186, "stroke-linecap", "round");
    			add_location(path186, file$b, 200, 8, 31925);
    			attr_dev(path187, "d", "M209.465 574.97C209.465 574.97 209.465 582.987 218.081 582.987C226.697 582.987 226.697 574.97 226.697 574.97");
    			attr_dev(path187, "stroke", "#4F4F4F");
    			attr_dev(path187, "stroke-linecap", "round");
    			add_location(path187, file$b, 201, 8, 32095);
    			attr_dev(path188, "d", "M243.93 582.987C243.93 582.987 243.93 574.97 235.314 574.97C226.697 574.97 226.697 582.987 226.697 582.987");
    			attr_dev(path188, "stroke", "#4F4F4F");
    			attr_dev(path188, "stroke-linecap", "round");
    			add_location(path188, file$b, 202, 8, 32264);
    			attr_dev(path189, "d", "M226.697 574.97C226.697 574.97 226.697 582.987 235.314 582.987C243.93 582.987 243.93 574.97 243.93 574.97");
    			attr_dev(path189, "stroke", "#4F4F4F");
    			attr_dev(path189, "stroke-linecap", "round");
    			add_location(path189, file$b, 203, 8, 32431);
    			attr_dev(path190, "d", "M261.162 582.987C261.162 582.987 261.162 574.97 252.546 574.97C243.93 574.97 243.93 582.987 243.93 582.987");
    			attr_dev(path190, "stroke", "#4F4F4F");
    			attr_dev(path190, "stroke-linecap", "round");
    			add_location(path190, file$b, 204, 8, 32597);
    			attr_dev(path191, "d", "M243.93 574.97C243.93 574.97 243.93 582.987 252.546 582.987C261.162 582.987 261.162 574.97 261.162 574.97");
    			attr_dev(path191, "stroke", "#4F4F4F");
    			attr_dev(path191, "stroke-linecap", "round");
    			add_location(path191, file$b, 205, 8, 32764);
    			attr_dev(path192, "d", "M278.395 582.987C278.395 582.987 278.395 574.97 269.778 574.97C261.162 574.97 261.162 582.987 261.162 582.987");
    			attr_dev(path192, "stroke", "#4F4F4F");
    			attr_dev(path192, "stroke-linecap", "round");
    			add_location(path192, file$b, 206, 8, 32930);
    			attr_dev(path193, "d", "M261.162 574.97C261.162 574.97 261.162 582.987 269.778 582.987C278.395 582.987 278.395 574.97 278.395 574.97");
    			attr_dev(path193, "stroke", "#4F4F4F");
    			attr_dev(path193, "stroke-linecap", "round");
    			add_location(path193, file$b, 207, 8, 33100);
    			attr_dev(path194, "d", "M295.627 582.987C295.627 582.987 295.627 574.97 287.011 574.97C278.395 574.97 278.395 582.987 278.395 582.987");
    			attr_dev(path194, "stroke", "#4F4F4F");
    			attr_dev(path194, "stroke-linecap", "round");
    			add_location(path194, file$b, 208, 8, 33269);
    			attr_dev(path195, "d", "M278.395 574.97C278.395 574.97 278.395 582.987 287.011 582.987C295.627 582.987 295.627 574.97 295.627 574.97");
    			attr_dev(path195, "stroke", "#4F4F4F");
    			attr_dev(path195, "stroke-linecap", "round");
    			add_location(path195, file$b, 209, 8, 33439);
    			attr_dev(path196, "d", "M312.86 582.987C312.86 582.987 312.86 574.97 304.243 574.97C295.627 574.97 295.627 582.987 295.627 582.987");
    			attr_dev(path196, "stroke", "#4F4F4F");
    			attr_dev(path196, "stroke-linecap", "round");
    			add_location(path196, file$b, 210, 8, 33608);
    			attr_dev(path197, "d", "M295.627 574.97C295.627 574.97 295.627 582.987 304.243 582.987C312.86 582.987 312.86 574.97 312.86 574.97");
    			attr_dev(path197, "stroke", "#4F4F4F");
    			attr_dev(path197, "stroke-linecap", "round");
    			add_location(path197, file$b, 211, 8, 33775);
    			attr_dev(path198, "d", "M330.092 582.987C330.092 582.987 330.092 574.97 321.476 574.97C312.86 574.97 312.86 582.987 312.86 582.987");
    			attr_dev(path198, "stroke", "#4F4F4F");
    			attr_dev(path198, "stroke-linecap", "round");
    			add_location(path198, file$b, 212, 8, 33941);
    			attr_dev(path199, "d", "M312.86 574.97C312.86 574.97 312.86 582.987 321.476 582.987C330.092 582.987 330.092 574.97 330.092 574.97");
    			attr_dev(path199, "stroke", "#4F4F4F");
    			attr_dev(path199, "stroke-linecap", "round");
    			add_location(path199, file$b, 213, 8, 34108);
    			attr_dev(g1, "class", "title-svg-border");
    			add_location(g1, file$b, 13, 4, 509);
    			attr_dev(path200, "fill", "#ffffff");
    			attr_dev(path200, "d", "M61.7312 140.736C61.7312 137.006 61.7345 133.389 61.741 129.887C61.7345 126.599 61.7345 123.411 61.741 120.325C61.741 117.407 61.741 114.561 61.741 111.786C61.741 109.134 61.741 106.532 61.741 103.978C63.2186 105.59 64.6995 107.201 66.1837 108.813C67.6613 110.418 69.1422 112.013 70.6264 113.599C70.6199 118.128 70.6199 122.791 70.6264 127.586C70.6199 132.681 70.6199 137.928 70.6264 143.329C70.7625 144.021 71.0152 144.703 71.3652 145.337C71.7346 145.96 72.1429 146.526 72.5901 147.003C72.8137 147.228 73.0956 147.491 73.4164 147.803C73.747 148.076 74.1358 148.378 74.583 148.719C75.0399 149.06 75.3802 149.304 75.6038 149.499C75.8565 149.684 76.0121 149.791 76.0801 149.82C77.1495 150.561 77.6939 151.702 77.7036 153.261C77.7036 154.363 77.2953 155.474 76.4787 156.556C75.6912 157.638 74.6511 158.369 73.3581 158.71C72.4637 158.925 71.6568 159.051 70.8986 159.1C70.1597 159.149 69.4598 159.129 68.8085 159.051C68.1571 158.934 67.6613 158.856 67.2919 158.808C66.9419 158.739 66.7184 158.72 66.6309 158.72C66.0378 158.759 65.4351 158.837 64.7741 158.983C64.1324 159.119 63.4325 159.305 62.6742 159.548C61.1674 159.977 60.098 160.162 59.437 160.055C56.4039 159.344 54.7999 156.702 54.586 152.569C54.7221 150.62 55.1109 149.294 55.7331 148.534C56.3553 147.793 57.2399 147.14 58.3676 146.555C59.505 145.941 60.3508 145.239 60.8952 144.469C61.459 143.689 61.741 142.442 61.7312 140.736ZM52.0001 86.4911C51.9904 83.8495 52.875 81.9585 54.6151 80.7206C56.3747 79.4144 58.8051 78.8491 61.8771 79.0343C64.0741 79.2585 66.0281 79.4242 67.7002 79.5509C69.382 79.6581 70.85 79.7361 72.0943 79.7654C72.6776 79.7751 73.3873 79.7848 74.2525 79.7556C75.1177 79.7459 76.1482 79.7166 77.3633 79.6776C78.5688 79.6289 79.5798 79.5802 80.4061 79.5607C81.2325 79.5412 81.8935 79.5314 82.3796 79.5314C85.3252 79.5802 87.9208 80.009 90.1568 80.7986C92.383 81.5881 94.2495 82.7578 95.7563 84.3077C97.2631 85.8478 98.4005 87.768 99.1783 90.0879C99.9657 92.4078 100.384 95.1176 100.432 98.2563C100.442 101.044 100.092 103.871 99.4116 106.746C98.7214 109.651 97.6812 112.624 96.3007 115.675C95.7271 116.913 95.1925 118.063 94.7258 119.135C94.23 120.217 93.8023 121.212 93.4037 122.128C92.9954 123.025 92.626 123.902 92.2858 124.769C91.9552 125.617 91.6539 126.456 91.3817 127.284C90.847 128.951 90.5553 130.325 90.5553 131.417C90.5651 132.548 90.7984 133.415 91.265 134.01C91.7122 134.585 92.3149 134.77 93.0246 134.575C93.6468 134.419 94.5703 133.942 95.8146 133.142C97.1173 132.314 98.1478 131.797 98.9061 131.583C100.403 131.164 101.648 131.554 102.629 132.753C103.602 133.883 104.078 135.355 104.088 137.178C104.078 139.42 103.903 141.262 103.553 142.714C103.203 144.196 102.61 145.668 101.784 147.13C101.618 147.062 101.521 146.984 101.424 146.925C101.366 146.867 101.298 146.818 101.229 146.799C101.152 146.76 101.074 146.75 100.996 146.73C100.909 146.721 100.792 146.701 100.656 146.701C100.199 146.399 99.7616 146.331 99.3144 146.526C98.5853 146.847 97.5256 147.617 96.1549 148.826C94.7744 150.064 93.5495 150.912 92.4607 151.399C90.5359 152.248 88.8444 151.799 87.3959 150.015C85.9765 148.124 85.2572 144.8 85.2474 140.131C85.2669 138.533 85.3252 137.002 85.4127 135.511C85.4905 134.029 85.6168 132.597 85.7821 131.222C85.9474 129.819 86.1418 128.259 86.3751 126.543C86.6182 124.838 86.9098 122.956 87.2403 120.9C87.5611 118.882 87.8528 117.001 88.0958 115.256C88.3291 113.531 88.5527 111.912 88.7277 110.392C88.9221 108.881 89.0582 107.351 89.1457 105.781C89.2332 104.222 89.3013 102.623 89.311 100.966C89.3207 98.2758 88.8346 95.7902 87.8722 93.4995C86.8904 91.1504 85.5488 89.3471 83.8864 88.041C82.1755 86.6763 80.3478 85.9842 78.3938 85.955C76.6764 85.9225 74.9524 85.8803 73.222 85.8283C71.9582 85.7795 71.1611 85.9452 70.8305 86.3059C70.5 86.6471 70.3542 87.1539 70.3542 87.7973C70.3542 91.8457 70.3542 95.9494 70.3542 100.108C68.87 98.7372 67.3826 97.3693 65.892 96.0046C64.4144 94.6465 62.9335 93.2948 61.4493 91.9497C61.4493 91.0627 61.4396 90.3121 61.4104 89.7078C61.3813 89.0839 61.3521 88.5868 61.3132 88.2262C61.3035 86.725 60.8466 85.916 59.9036 85.8088C59.3398 85.838 58.912 86.0817 58.6009 86.5886C58.3093 87.0954 58.1732 87.7095 58.1635 88.4503C58.1635 89.2691 58.2704 89.9807 58.494 90.5948C58.7176 91.1991 59.0287 91.7352 59.4175 92.2129C59.8064 92.6905 60.3605 93.2363 61.1091 93.8602C61.4688 94.1624 61.7604 94.4158 61.9743 94.6107C62.1979 94.7959 62.3631 94.9227 62.4409 95.0104C63.9575 96.5797 66.0573 98.6364 68.7501 101.19C71.4235 103.764 73.6109 105.85 75.3121 107.458C76.1579 108.267 76.9939 109.066 77.8202 109.875C78.6368 110.675 79.4632 111.513 80.2798 112.361C80.8339 112.946 81.32 113.511 81.7185 114.067C82.1074 114.622 82.4379 115.129 82.6907 115.607C83.1962 116.582 83.4392 117.761 83.4295 119.145C83.4295 120.773 83.167 122.157 82.6615 123.249C81.8158 124.769 80.5714 125.695 78.9479 125.949C77.9661 125.978 77.0328 125.442 76.1287 124.302C75.2246 123.171 74.5441 121.718 74.058 119.993C75.1371 119.847 75.6621 119.252 75.6621 118.239C75.6718 116.66 74.4566 114.535 72.0651 111.805C70.85 110.392 69.4598 108.862 67.8752 107.185C66.2906 105.489 64.4824 103.656 62.4604 101.668C60.4286 99.6989 58.8731 98.1881 57.7746 97.1061C56.6858 96.0534 56.0539 95.41 55.8498 95.2053C53.2736 92.3883 51.9904 89.4933 52.0001 86.4911ZM107.053 131.144C107.062 128.746 107.519 126.436 108.443 124.233C109.366 122.079 110.543 120.149 111.962 118.443C113.401 116.786 114.898 115.314 116.473 114.037C117.26 113.414 118.135 112.78 119.059 112.107C119.992 111.445 121.003 110.743 122.111 110.002C122.724 109.641 123.219 109.359 123.599 109.134C123.978 108.91 124.221 108.764 124.357 108.676C124.619 108.481 124.775 108.218 124.843 107.897C124.853 107.351 124.473 107.117 123.725 107.214C122.879 107.331 121.567 107.702 119.827 108.345C118.971 108.667 118.232 108.92 117.62 109.125C116.998 109.31 116.502 109.427 116.103 109.485C114.266 109.758 112.604 109.446 111.116 108.54C109.629 107.575 108.89 106.035 108.89 103.929C108.89 101.57 109.755 99.7477 111.515 98.461C113.274 97.1938 115.219 96.4628 117.348 96.2873C117.941 96.2386 118.961 96.1996 120.42 96.1606C121.868 96.1216 122.967 96.0729 123.725 96.0046C124.697 95.9267 126.262 95.7707 128.401 95.5173C130.52 95.2736 131.93 95.1274 132.601 95.0786C136.246 94.8252 138.774 95.8584 140.174 98.1783C140.757 99.1336 141.194 100.557 141.486 102.448C141.778 104.319 141.923 106.639 141.923 109.388C141.917 112.416 141.917 115.402 141.923 118.346C141.923 121.192 141.923 123.983 141.923 126.719C143.926 127.625 144.918 128.425 144.927 129.088C144.84 129.916 143.528 130.842 141 131.914C140.397 132.109 139.736 132.294 139.036 132.489C138.327 132.694 137.559 132.889 136.742 133.084C136.382 133.172 135.857 133.279 135.187 133.386C134.516 133.503 133.699 133.64 132.717 133.786C131.755 133.932 130.899 134.088 130.161 134.263C129.422 134.439 128.79 134.614 128.265 134.79C127.74 134.975 127.079 135.228 126.321 135.57C125.543 135.92 124.629 136.359 123.569 136.924C122.529 137.49 121.615 137.967 120.808 138.367C120.031 138.767 119.35 139.079 118.806 139.313C116.755 140.219 114.82 140.599 112.992 140.414C112.069 140.297 111.262 140.024 110.543 139.586C109.833 139.108 109.211 138.484 108.657 137.704C107.597 136.106 107.053 133.913 107.053 131.144ZM132.474 123.395C132.474 120.646 132.471 117.858 132.465 115.032C132.471 112.14 132.474 109.219 132.474 106.269C132.474 103.783 131.765 101.97 130.345 100.8C128.936 99.6112 127.108 99.1238 124.853 99.3285C122.967 99.5137 121.372 99.8939 120.079 100.479C118.407 101.005 117.493 101.951 117.338 103.325C117.348 104.631 118.388 105.158 120.507 104.894C120.935 104.836 121.479 104.738 122.131 104.592C122.782 104.456 123.55 104.261 124.435 104.017C126.214 103.53 127.351 103.266 127.857 103.208C129.956 102.984 130.987 103.705 130.997 105.333C130.997 106.161 130.685 106.951 130.063 107.692C129.743 108.052 129.363 108.413 128.965 108.793C128.556 109.164 128.08 109.544 127.565 109.924C127.03 110.314 126.515 110.704 125.98 111.094C125.465 111.484 124.95 111.864 124.425 112.254C122.335 113.774 120.721 115.344 119.535 116.942C118.359 118.531 117.766 120.442 117.766 122.654C117.775 124.769 118.359 126.173 119.535 126.836C120.711 127.479 122.247 127.518 124.153 126.982C125.348 126.651 126.787 126.007 128.508 125.072C130.219 124.155 131.541 123.59 132.474 123.395ZM146.395 125.637C146.395 123.713 146.395 121.767 146.395 119.798C146.389 117.777 146.389 115.737 146.395 113.677C146.395 111.571 146.395 109.446 146.395 107.302C146.395 105.125 146.392 102.932 146.386 100.722C146.395 100.449 146.356 100.206 146.279 99.9913C146.191 99.7672 146.075 99.5722 145.919 99.3967C145.773 99.2115 145.579 99.0263 145.336 98.8509C145.102 98.6657 144.82 98.4902 144.509 98.2953C144.198 98.1003 143.926 97.9249 143.693 97.7494C143.479 97.574 143.294 97.418 143.168 97.2815C142.896 96.9891 142.76 96.5797 142.75 96.0534C142.75 94.9519 143.664 94.3476 145.472 94.2403C147.338 94.1429 149.205 94.0454 151.071 93.9479C152.938 93.8634 154.808 93.7822 156.681 93.7042C158.304 93.636 159.13 93.9869 159.13 94.7375C159.13 95.2736 158.965 95.7122 158.654 96.0534C158.362 96.3848 157.906 96.7649 157.274 97.1743C156.972 97.3985 156.7 97.5935 156.457 97.7884C156.224 97.9639 156.029 98.1491 155.883 98.3245C155.738 98.4902 155.611 98.6657 155.543 98.8509C155.446 99.0361 155.417 99.2505 155.407 99.4747C155.414 99.7542 155.417 100.027 155.417 100.294C156.972 99.7184 158.654 98.7144 160.482 97.2913C161.396 96.57 162.212 95.9559 162.912 95.449C163.622 94.9519 164.244 94.562 164.769 94.2598C165.799 93.6652 167.335 93.3436 169.348 93.2948C171.525 93.2461 173.236 93.8212 174.471 95.0104C175.715 96.1898 176.347 97.7104 176.347 99.5527C177.144 99.309 177.961 98.9581 178.807 98.5097C179.672 98.0419 180.566 97.4668 181.499 96.7844C182.423 96.0924 183.249 95.5075 183.978 95.0396C184.698 94.562 185.33 94.1916 185.845 93.9089C186.885 93.3533 188.411 93.0706 190.404 93.0706C192.708 93.0804 194.458 93.6945 195.625 94.9032C196.83 96.1119 197.423 97.7007 197.423 99.6892C197.423 101.788 197.423 103.881 197.423 105.967C197.423 108.02 197.423 110.06 197.423 112.088C197.417 114.089 197.417 116.078 197.423 118.053C197.423 119.996 197.423 121.93 197.423 123.853C197.423 124.038 197.462 124.204 197.511 124.341C197.598 124.496 197.725 124.623 197.89 124.76C198.045 124.886 198.25 125.013 198.502 125.14C198.755 125.257 199.047 125.383 199.377 125.539C200.077 125.851 200.592 126.144 200.942 126.426C201.292 126.69 201.467 127.05 201.477 127.479C201.477 127.947 200.835 128.405 199.591 128.863C198.522 129.331 197.462 129.555 196.432 129.516C196.286 129.507 196.072 129.487 195.839 129.458C195.596 129.438 195.294 129.39 194.935 129.341C194.585 129.292 194.244 129.243 193.875 129.214C193.544 129.195 193.204 129.175 192.864 129.166C192.66 129.166 192.436 129.166 192.174 129.175C191.931 129.195 191.629 129.224 191.328 129.263C191.007 129.292 190.706 129.321 190.424 129.331C190.171 129.351 189.928 129.36 189.714 129.36C188.761 129.351 187.624 129.127 186.312 128.727C185.038 128.327 184.387 127.772 184.387 127.06C184.387 126.68 184.581 126.329 184.97 126.017C185.164 125.842 185.398 125.686 185.67 125.51C185.962 125.345 186.282 125.169 186.652 124.994C187.012 124.818 187.303 124.682 187.498 124.584C187.702 124.496 187.809 124.428 187.828 124.418C188.304 124.126 188.528 123.834 188.528 123.512C188.528 121.9 188.528 120.282 188.528 118.658C188.528 117.014 188.528 115.36 188.528 113.696C188.528 112.013 188.528 110.32 188.528 108.618C188.528 106.902 188.528 105.174 188.528 103.432C188.538 102.526 188.217 101.775 187.585 101.19C186.953 100.615 186.127 100.323 185.096 100.323C184.435 100.333 183.803 100.43 183.259 100.615C182.656 100.82 181.849 101.132 180.848 101.541C179.847 101.951 179.011 102.263 178.301 102.477C177.611 102.691 176.96 102.799 176.347 102.808C176.354 104.621 176.354 106.425 176.347 108.218C176.347 109.986 176.35 111.744 176.357 113.492C176.35 115.22 176.347 116.936 176.347 118.638C176.347 120.328 176.347 122.008 176.347 123.678C176.415 124.048 176.59 124.311 176.882 124.467C177.028 124.565 177.222 124.662 177.475 124.789C177.728 124.916 178.029 125.042 178.389 125.179C179.089 125.471 179.604 125.744 179.954 126.007C180.304 126.271 180.469 126.621 180.469 127.06C180.459 127.781 179.857 128.327 178.622 128.737C177.387 129.136 176.289 129.36 175.365 129.37C175.161 129.37 174.938 129.36 174.675 129.351C174.403 129.331 174.101 129.302 173.742 129.273C173.402 129.234 173.071 129.204 172.77 129.195C172.497 129.185 172.245 129.185 172.011 129.185C171.739 129.195 171.477 129.204 171.175 129.234C170.884 129.253 170.592 129.302 170.281 129.351C169.97 129.399 169.688 129.438 169.435 129.468C169.173 129.487 168.93 129.516 168.716 129.526C167.646 129.555 166.509 129.399 165.274 129.068C164.03 128.727 163.398 128.21 163.398 127.508C163.398 127.128 163.563 126.777 163.933 126.485C164.293 126.163 164.798 125.842 165.449 125.51C165.78 125.325 166.042 125.179 166.237 125.081C166.431 124.974 166.548 124.906 166.616 124.857C167.18 124.506 167.471 124.185 167.462 123.921C167.468 122.316 167.468 120.701 167.462 119.077C167.468 117.433 167.471 115.776 167.471 114.106C167.471 112.416 167.468 110.714 167.462 108.998C167.468 107.269 167.468 105.528 167.462 103.773C167.471 102.886 167.102 102.165 166.402 101.59C165.692 101.005 164.915 100.732 164.03 100.771C163.602 100.82 163.165 100.908 162.708 101.034C162.27 101.171 161.794 101.336 161.318 101.541C160.812 101.756 160.326 101.97 159.85 102.204C159.354 102.418 158.858 102.633 158.362 102.867C157.847 103.091 157.332 103.286 156.856 103.432C156.379 103.578 155.903 103.695 155.407 103.764C155.414 105.596 155.417 107.419 155.417 109.232C155.417 111.019 155.414 112.79 155.407 114.544C155.407 116.273 155.41 117.985 155.417 119.681C155.417 121.351 155.417 123.008 155.417 124.652C155.407 124.838 155.446 125.003 155.543 125.159C155.631 125.296 155.757 125.413 155.913 125.539C156.078 125.647 156.301 125.754 156.545 125.861C156.797 125.959 157.079 126.056 157.419 126.163C158.081 126.368 158.567 126.582 158.907 126.797C159.247 127.021 159.412 127.333 159.412 127.723C159.422 128.201 158.732 128.766 157.381 129.438C156.01 129.945 155.009 130.228 154.377 130.286C154.163 130.306 153.91 130.306 153.628 130.316C153.356 130.316 153.025 130.316 152.685 130.316C152.335 130.306 152.005 130.296 151.703 130.316C151.431 130.325 151.169 130.335 150.935 130.364C150.77 130.384 150.576 130.413 150.313 130.452C150.051 130.501 149.72 130.569 149.351 130.657C148.981 130.735 148.641 130.803 148.359 130.862C148.077 130.91 147.834 130.959 147.64 130.979C146.687 131.105 145.55 131.076 144.227 130.901C142.964 130.735 142.322 130.316 142.332 129.624C142.332 129.273 142.633 128.795 143.226 128.22C143.667 127.96 144.104 127.703 144.539 127.45C144.762 127.313 144.995 127.167 145.229 127.021C145.462 126.875 145.666 126.729 145.831 126.573C146.006 126.417 146.133 126.261 146.24 126.115C146.337 125.949 146.395 125.783 146.395 125.637ZM204.345 124.185C204.345 122.092 204.345 119.98 204.345 117.849C204.345 115.685 204.345 113.505 204.345 111.308C204.345 109.079 204.342 106.834 204.335 104.573C204.342 102.285 204.342 99.9848 204.335 97.6714C201.584 96.5407 200.213 95.566 200.213 94.7082C200.213 93.6652 201.351 93.1486 203.635 93.1779C205.281 93.2104 206.931 93.2396 208.583 93.2656C210.223 93.3046 211.869 93.3436 213.522 93.3826C216.088 93.441 217.362 93.9674 217.362 94.9324C217.352 96.2483 215.981 97.2328 213.23 97.9151C213.23 100.261 213.227 102.594 213.221 104.914C213.227 107.214 213.23 109.498 213.23 111.766C213.224 114.008 213.224 116.231 213.23 118.434C213.23 120.604 213.23 122.755 213.23 124.886C213.23 125.267 213.376 125.559 213.668 125.783C213.823 125.89 214.018 126.017 214.261 126.173C214.533 126.329 214.844 126.514 215.204 126.699C215.593 126.894 215.894 127.08 216.156 127.265C216.429 127.421 216.652 127.596 216.837 127.762C217.022 127.928 217.138 128.103 217.226 128.288C217.323 128.473 217.352 128.688 217.362 128.912C217.362 129.643 216.74 130.121 215.515 130.364C214.28 130.608 213.191 130.686 212.258 130.579C212.064 130.559 211.821 130.511 211.578 130.472C211.305 130.423 211.004 130.355 210.664 130.286C210.314 130.208 210.003 130.14 209.682 130.092C209.381 130.043 209.089 130.014 208.826 129.984C208.603 129.965 208.37 129.955 208.107 129.955C207.854 129.945 207.572 129.965 207.281 129.984C206.979 129.994 206.697 130.004 206.406 130.004C206.134 130.004 205.871 129.994 205.609 129.984C204.617 129.916 203.451 129.633 202.138 129.166C200.845 128.698 200.213 128.123 200.204 127.411C200.213 126.914 200.456 126.514 200.942 126.251C201.185 126.115 201.506 125.959 201.885 125.773C202.264 125.578 202.712 125.374 203.237 125.159C203.966 124.867 204.345 124.535 204.345 124.185ZM203.645 84.2394C203.645 81.8318 205.366 80.6231 208.826 80.6524C212.229 80.6816 213.93 81.9195 213.93 84.3467C213.93 86.764 212.18 87.9337 208.671 87.885C205.327 87.846 203.635 86.6276 203.645 84.2394ZM254.119 105.002C254.119 107.172 254.115 109.349 254.109 111.532C254.109 113.729 254.109 115.928 254.109 118.131C254.115 120.341 254.119 122.553 254.119 124.769C254.119 126.992 254.119 129.214 254.119 131.437C254.226 131.944 254.43 132.363 254.712 132.694C255.042 133.035 255.557 133.435 256.228 133.922C256.918 134.41 257.424 134.868 257.755 135.287C258.095 135.687 258.25 136.203 258.26 136.798C258.26 137.782 257.648 138.396 256.413 138.669C255.169 138.932 254.08 138.962 253.137 138.747C252.981 138.708 252.777 138.64 252.495 138.552C252.242 138.474 251.922 138.348 251.562 138.221C251.193 138.075 250.862 137.958 250.541 137.86C250.24 137.773 249.968 137.695 249.715 137.636C249.443 137.578 249.18 137.529 248.898 137.48C248.607 137.441 248.296 137.412 247.975 137.402C247.664 137.373 247.382 137.353 247.139 137.314C246.886 137.285 246.682 137.256 246.497 137.217C245.515 136.983 244.358 136.457 243.027 135.677C241.743 134.897 241.102 134.088 241.102 133.24C241.102 132.753 241.286 132.353 241.646 132.061C242.006 131.768 242.531 131.515 243.221 131.271C243.561 131.154 243.833 131.057 244.028 130.979C244.222 130.901 244.329 130.842 244.397 130.813C244.961 130.481 245.233 130.16 245.233 129.848C245.233 127.957 245.233 126.063 245.233 124.165C245.233 122.268 245.233 120.367 245.233 118.463C245.233 116.559 245.233 114.658 245.233 112.761C245.233 110.857 245.233 108.953 245.233 107.049C245.233 105.752 244.893 104.641 244.232 103.725C243.571 102.779 242.715 102.272 241.666 102.214C240.975 102.214 240.343 102.263 239.789 102.37C239.225 102.477 238.73 102.623 238.302 102.818C237.864 103.003 237.427 103.218 236.97 103.452C236.513 103.686 236.056 103.929 235.58 104.193C234.637 104.699 233.752 104.953 232.916 104.953C232.91 106.876 232.906 108.797 232.906 110.714C232.913 112.618 232.916 114.522 232.916 116.426C232.916 118.31 232.913 120.191 232.906 122.069C232.913 123.934 232.913 125.793 232.906 127.645C232.906 127.859 232.945 128.064 233.033 128.259C233.13 128.444 233.247 128.62 233.402 128.805C233.587 128.98 233.791 129.156 234.034 129.351C234.297 129.536 234.588 129.731 234.919 129.945C235.58 130.374 236.066 130.764 236.406 131.115C236.746 131.466 236.902 131.885 236.912 132.363C236.912 132.928 236.231 133.415 234.88 133.805C233.499 134 232.498 134.02 231.876 133.883C231.652 133.844 231.409 133.766 231.118 133.688C230.846 133.61 230.534 133.503 230.184 133.386C229.825 133.269 229.504 133.162 229.212 133.084C228.921 133.006 228.668 132.938 228.425 132.899C228.279 132.86 228.055 132.831 227.803 132.801C227.54 132.762 227.229 132.743 226.85 132.714C226.461 132.684 226.131 132.655 225.858 132.616C225.577 132.587 225.333 132.558 225.139 132.519C224.186 132.343 223.049 131.924 221.717 131.281C220.463 130.667 219.831 130.004 219.821 129.253C219.831 128.873 220.133 128.464 220.726 128.025C221.166 127.889 221.6 127.752 222.028 127.616C222.271 127.538 222.505 127.45 222.718 127.362C222.961 127.265 223.156 127.177 223.321 127.05C223.496 126.933 223.632 126.807 223.739 126.68C223.846 126.524 223.885 126.368 223.885 126.202C223.891 124.116 223.891 122.021 223.885 119.915C223.891 117.777 223.895 115.626 223.895 113.462C223.895 111.285 223.891 109.095 223.885 106.893C223.885 104.67 223.888 102.441 223.895 100.206C223.895 99.9329 223.856 99.6892 223.778 99.465C223.691 99.231 223.574 99.0166 223.418 98.8314C223.263 98.617 223.078 98.422 222.825 98.2173C222.592 98.0029 222.31 97.7982 222.018 97.574C221.698 97.3498 221.425 97.1451 221.192 96.9404C220.969 96.7454 220.794 96.5797 220.667 96.4238C220.395 96.1119 220.249 95.7025 220.249 95.1761C220.239 94.1039 221.163 93.5873 222.971 93.6457C224.838 93.7042 226.704 93.766 228.571 93.8309C230.444 93.8894 232.313 93.9512 234.18 94.0161C235.813 94.0746 236.62 94.5035 236.62 95.2931C236.61 95.8584 236.465 96.3165 236.153 96.648C235.862 96.9696 235.405 97.3303 234.783 97.7104C234.462 97.9151 234.199 98.1003 233.947 98.2758C233.733 98.4318 233.538 98.617 233.363 98.7827C233.227 98.9386 233.12 99.1141 233.033 99.2993C232.955 99.4942 232.916 99.7087 232.916 99.9426C232.916 100.235 232.916 100.521 232.916 100.8C234.423 100.479 235.881 99.5917 237.291 98.1198C238.739 96.6285 239.809 95.6147 240.538 95.1079C241.316 94.562 242.735 94.3183 244.806 94.3866C247.547 94.4743 249.783 95.4295 251.523 97.2913C253.253 99.1433 254.109 101.717 254.119 105.002ZM261.167 119.272C261.196 116.845 261.361 114.603 261.663 112.546C261.964 110.499 262.401 108.618 262.975 106.912C264.112 103.51 265.794 100.761 268.02 98.6462C269.615 97.1646 271.471 96.0436 273.591 95.2736C275.72 94.4743 278.101 94.0161 280.755 93.8797C281.485 93.8309 282.33 93.8017 283.302 93.7822C284.284 93.7335 285.422 93.714 286.686 93.6847C289.194 93.5775 291.089 93.441 292.382 93.2753C293.199 93.1649 294.016 93.0511 294.832 92.9342C295.328 92.8562 295.824 92.8854 296.261 93.0122C296.757 93.1194 296.99 93.4118 297 93.8894C297 94.8837 296.096 96.2483 294.278 97.9736C294.278 100.034 294.275 102.113 294.268 104.212C294.275 106.356 294.275 108.533 294.268 110.743C294.275 113.037 294.278 115.383 294.278 117.78C294.278 120.315 294.278 122.934 294.278 125.637C294.278 126.651 294.327 127.577 294.434 128.405C294.492 128.815 294.57 129.38 294.677 130.092C294.784 130.823 294.929 131.71 295.085 132.762C295.396 134.926 295.639 136.72 295.804 138.094C295.882 138.777 295.931 139.488 295.97 140.268C296.008 141.009 296.028 141.798 296.028 142.637C296.028 146.886 295.425 150.824 294.259 154.324C293.111 157.706 291.527 160.143 289.534 161.634C287.57 162.989 285.402 163.321 283.059 162.697C282.389 162.512 281.533 162.278 280.512 162.014C279.482 161.732 278.257 161.41 276.847 161.01C275.428 160.611 274.223 160.27 273.182 159.967C272.171 159.656 271.306 159.402 270.616 159.178C267.913 158.32 265.648 157.072 263.83 155.474C262.042 153.944 261.157 151.721 261.157 148.787C261.157 147.9 261.303 147.062 261.575 146.253C261.857 145.512 262.003 145.015 262.003 144.781C262.003 144.05 261.906 143.485 261.731 143.075C262.071 142.919 262.547 142.909 263.121 143.036C264.715 143.514 266.154 144.381 267.457 145.648C267.69 145.892 267.943 146.233 268.244 146.672C268.565 147.12 268.924 147.666 269.352 148.31C269.77 148.953 270.159 149.508 270.519 150.015C270.898 150.542 271.248 150.961 271.588 151.312C272.978 153.037 275.02 154.236 277.752 154.889C280.843 155.562 283.147 155.152 284.693 153.632C286.229 152.014 287.006 149.314 287.006 145.639C287.006 143.494 286.938 141.964 286.851 141.038C286.799 141.038 286.754 141.041 286.715 141.048C285.927 143.056 284.42 144.011 282.233 143.923C281.65 143.884 280.94 143.728 280.094 143.436C279.258 143.163 278.461 142.987 277.752 142.919C277.061 142.841 276.254 142.841 275.331 142.929C274.855 142.978 274.437 142.997 274.087 142.997C273.746 142.997 273.455 142.968 273.212 142.929C271.18 142.607 269.411 141.613 267.884 139.946C266.368 138.279 265.104 136.291 264.112 133.971C263.626 132.801 263.189 131.622 262.819 130.394C262.46 129.185 262.139 127.908 261.896 126.602C261.4 124.097 261.167 121.66 261.167 119.272ZM285.665 120.636C285.665 118.044 285.665 115.493 285.665 112.985C285.665 110.554 285.662 108.156 285.655 105.791C285.665 103.51 285.013 101.765 283.74 100.518C282.447 99.2603 280.843 98.6852 278.957 98.8119C275.72 98.9874 273.377 100.557 271.919 103.608C270.49 106.698 269.78 110.392 269.78 114.749C269.78 119.964 270.402 123.717 271.656 125.939C272.92 128.171 274.437 129.321 276.206 129.36C278.176 129.354 280.137 129.305 282.087 129.214C283.147 129.127 284.002 128.22 284.663 126.504C285.334 124.828 285.655 122.859 285.665 120.636Z");
    			add_location(path200, file$b, 218, 8, 34371);
    			attr_dev(g2, "class", "title-svg-naming-text");
    			add_location(g2, file$b, 217, 4, 34306);
    			attr_dev(path201, "fill", "#ffffff");
    			attr_dev(path201, "d", "M76.7455 387.419C76.7551 387.275 76.7069 387.141 76.5815 387.016C76.4368 386.881 76.2438 386.766 76.0123 386.67C75.7904 386.535 75.5106 386.42 75.2019 386.314C74.9028 386.199 74.5941 386.065 74.3047 385.949C72.5681 385.591 70.8284 385.251 69.0854 384.931C64.8984 384.278 62.7952 385.315 62.8049 387.9C62.8049 388.476 62.9978 389.254 63.3837 390.234C63.7793 391.214 63.9626 392.146 63.9722 393.01C60.9815 393.087 58.7337 392.511 57.2383 391.137C55.7429 389.744 54.9904 387.429 55.0001 384.239C55.0001 380.07 57.3927 377.889 62.2067 378.004C63.3741 378.062 64.7923 378.225 66.4516 378.523C68.1303 378.831 70.108 379.272 72.3752 379.858C73.9381 380.272 75.3755 380.694 76.6972 381.136C78.0189 381.569 79.2442 382.02 80.3343 382.472C84.3959 383.884 86.4991 385.411 86.6245 387.025C86.6245 388.783 84.3187 390.551 79.659 392.53C79.0609 392.809 78.4917 393.068 77.9611 393.327C77.469 393.568 76.9867 393.798 76.5236 394.019C76.0894 394.24 75.6457 394.432 75.2212 394.615C74.816 394.778 74.3915 394.922 73.9574 395.057C73.1856 395.652 72.7225 396.354 72.5392 397.113C72.5295 397.247 72.7321 398.121 73.1373 399.678C74.1985 403.415 75.2598 407.104 76.3403 410.755C77.4401 414.3 78.5881 417.816 79.7941 421.322C80.3826 423.051 80.9518 424.685 81.5017 426.241C82.0709 427.769 82.6401 429.229 83.2189 430.641C83.7881 432.044 84.3766 433.446 84.9651 434.849C85.5729 436.232 86.2193 437.635 86.885 439.047C87.676 440.565 88.4671 441.314 89.2389 441.324C90.1458 441.324 91.1684 440.517 92.3551 438.903C93.3777 437.299 94.3617 435.329 95.3072 433.014C96.2623 430.699 97.1691 428.038 98.0567 425.011C99.0311 421.755 99.7547 418.805 100.247 416.173C100.729 413.55 100.97 411.216 100.97 409.169C100.97 406.316 100.469 403.636 99.4652 401.1C98.4716 398.573 96.8508 397.026 94.6029 396.517C93.9758 396.373 92.6927 396.402 90.7632 396.632C88.8337 396.882 86.2579 397.382 83.0356 398.179C79.0609 399.197 76.6972 399.745 75.9737 399.678C75.1922 399.61 74.787 399.149 74.787 398.275C74.7967 397.612 75.0186 397.074 75.4624 396.68C75.9544 396.738 76.8034 396.44 77.99 395.806C78.3084 395.633 78.5688 395.508 78.7907 395.374C79.0126 395.258 79.2152 395.153 79.3503 395.086C79.5432 394.999 79.6879 394.913 79.8327 394.845C80.8746 394.509 81.82 394.202 82.6883 393.933C83.5469 393.645 84.3477 393.395 85.0326 393.164C85.7369 392.924 86.5376 392.665 87.4349 392.405C88.3417 392.127 89.3643 391.838 90.4931 391.512C91.6026 391.204 92.7313 390.916 93.8408 390.676C94.9599 390.426 96.0886 390.176 97.1981 389.955C101.655 389.331 104.385 389.225 105.418 389.542C107.28 390.109 108.785 391.3 109.942 393.097C111.081 394.855 111.65 396.949 111.65 399.418C111.66 401.08 111.235 403.357 110.377 406.278C109.952 407.757 109.45 409.304 108.891 410.927C108.331 412.58 107.695 414.309 107.01 416.125C106.315 417.941 105.562 419.843 104.762 421.822C103.951 423.81 103.093 425.886 102.167 428.018C101.289 430.199 100.324 432.418 99.2723 434.686C98.2304 436.962 97.1113 439.278 95.9053 441.641C94.6994 444.004 93.4163 446.416 92.056 448.856C90.6861 451.306 89.2486 453.784 87.7243 456.311C86.3447 458.761 85.187 460 84.2705 460C82.9584 460.01 81.8586 458.636 81.0193 455.879C80.2346 453.861 79.4468 451.84 78.6557 449.817C77.8646 447.793 77.0735 445.766 76.2824 443.735C75.4913 441.705 74.7002 439.668 73.9091 437.625C73.118 435.576 72.3269 433.513 71.5358 431.438C70.7447 429.344 69.9537 427.234 69.1626 425.107C68.3715 422.943 67.5804 420.752 66.7893 418.536C65.9982 416.25 65.2071 413.925 64.416 411.562C63.6249 409.096 62.837 406.566 62.0524 403.972C61.8594 403.309 61.6183 402.867 61.2902 402.637C60.9526 402.377 60.4798 402.176 59.8431 401.983C59.2353 401.753 58.7915 401.484 58.5021 401.148C58.2223 400.783 58.0969 400.187 58.0873 399.351C58.0873 397.91 59.4862 396.142 62.2839 394.288C64.6572 393.52 67.6093 392.194 71.1885 390.426C74.8835 389.1 76.7455 388.159 76.7455 387.419ZM108.312 436.213C108.312 433.936 108.486 431.727 108.823 429.565C109.161 427.403 109.663 425.319 110.348 423.292C111.023 421.284 111.891 419.507 112.943 417.96C113.985 416.432 115.22 415.135 116.638 414.069C118.066 413.022 119.638 412.33 121.375 411.975C123.102 411.619 124.992 411.59 127.028 411.869C129.022 412.119 131.022 412.359 133.029 412.589C135.029 412.788 137.032 412.974 139.039 413.147C141.654 413.339 143.969 413.867 145.966 414.751C147.992 415.596 149.015 417.086 149.015 419.218C149.015 419.958 148.918 420.65 148.716 421.303C148.532 421.947 148.272 422.562 147.924 423.128C147.577 423.714 147.182 424.243 146.699 424.723C146.226 425.213 145.715 425.655 145.136 426.058C144.017 426.875 142.802 427.615 141.47 428.287C140.158 428.95 138.73 429.651 137.187 430.401C135.778 431.045 134.534 431.631 133.434 432.188C132.344 432.735 131.389 433.245 130.549 433.706C128.871 434.647 127.327 435.915 125.909 437.481C124.51 439.038 123.613 440.969 123.256 443.274C124.761 444.206 126.362 444.907 128.051 445.397C129.749 445.868 131.533 446.127 133.405 446.156C136.704 446.204 139.3 445.561 141.171 444.225C143.043 442.9 144.181 441.382 144.567 439.662C145.918 440.094 147.095 441.045 148.117 442.506C149.111 443.966 149.613 445.465 149.613 447.021C149.613 449.106 149.101 451.075 148.088 452.939C147.587 453.88 146.998 454.726 146.323 455.465C145.657 456.186 144.914 456.83 144.075 457.377C142.406 458.501 140.621 459.078 138.711 459.068C137.968 459.068 137.206 459.03 136.454 458.991C135.701 458.943 134.891 458.866 134.032 458.751C132.363 458.569 131.128 458.472 130.308 458.463C129.633 458.463 128.494 458.54 126.874 458.722C126.063 458.828 125.301 458.895 124.626 458.934C123.951 458.972 123.314 459.001 122.745 459.001C120.902 458.991 119.088 458.367 117.303 457.127C115.528 455.879 113.956 454.197 112.595 452.074C111.168 449.836 110.097 447.396 109.383 444.754C108.679 442.102 108.312 439.249 108.312 436.213ZM119.3 439.739C120.352 436.655 121.818 434.253 123.7 432.514C125.6 430.804 127.906 429.334 130.627 428.105C133.627 426.635 135.643 425.53 136.637 424.79C137.679 424.051 138.2 422.927 138.19 421.409C138.2 418.613 135.392 417.018 129.797 416.5C127.346 416.25 125.311 416.355 123.68 416.845C122.05 417.345 120.815 418.238 119.995 419.535C119.175 420.851 118.558 422.379 118.152 424.099C117.738 425.838 117.545 427.769 117.535 429.892C117.535 434.253 118.123 437.539 119.3 439.739ZM194.715 421.793C194.715 423.939 194.715 426.113 194.715 428.316C194.715 430.577 194.711 432.863 194.705 435.176C194.711 437.532 194.715 439.909 194.715 442.304C194.708 444.744 194.705 447.2 194.705 449.672C194.83 450.21 195.072 450.633 195.429 450.931C195.824 451.229 196.413 451.555 197.233 451.901C198.062 452.276 198.68 452.651 199.075 453.044C199.461 453.41 199.673 453.919 199.673 454.601C199.673 455.686 198.931 456.561 197.455 457.214C195.969 457.867 194.666 458.203 193.538 458.232C193.354 458.232 193.084 458.232 192.766 458.203C192.447 458.184 192.071 458.146 191.637 458.088C191.203 458.05 190.798 458.011 190.431 457.992C190.045 457.963 189.717 457.963 189.428 457.973C189.1 457.982 188.781 458.002 188.444 458.04C188.096 458.088 187.73 458.136 187.354 458.203C186.968 458.28 186.62 458.328 186.331 458.367C186.032 458.415 185.791 458.424 185.569 458.434C184.373 458.463 182.993 458.203 181.411 457.646C179.867 457.079 179.095 456.292 179.086 455.264C179.095 454.668 179.308 454.13 179.751 453.679C180.166 453.246 180.803 452.785 181.633 452.314C182.038 452.084 182.366 451.901 182.597 451.757C182.829 451.623 182.983 451.517 183.051 451.479C183.717 450.941 184.045 450.499 184.054 450.134C184.048 447.956 184.048 445.794 184.054 443.649C184.048 441.529 184.048 439.428 184.054 437.347C184.048 435.291 184.045 433.257 184.045 431.246C184.051 429.267 184.051 427.311 184.045 425.376C184.045 424.07 183.649 423.013 182.868 422.206C182.057 421.361 181.025 420.986 179.761 421.063C178.951 421.14 178.198 421.265 177.513 421.447C176.848 421.61 176.259 421.822 175.738 422.062C175.217 422.302 174.677 422.571 174.137 422.859C173.596 423.138 173.056 423.436 172.468 423.772C171.348 424.387 170.278 424.733 169.284 424.819C169.277 426.843 169.274 428.886 169.274 430.948C169.274 433.043 169.274 435.153 169.274 437.279C169.274 439.444 169.274 441.625 169.274 443.822C169.274 446.051 169.274 448.292 169.274 450.547C169.284 450.816 169.323 451.065 169.429 451.286C169.535 451.498 169.679 451.68 169.863 451.863C170.075 452.036 170.326 452.209 170.635 452.382C170.934 452.545 171.271 452.727 171.667 452.91C172.468 453.275 173.066 453.621 173.452 453.957C173.876 454.303 174.079 454.774 174.079 455.369C174.069 456.071 173.249 456.858 171.628 457.742C169.988 458.396 168.782 458.722 168.02 458.732C167.76 458.732 167.47 458.722 167.133 458.703C166.795 458.674 166.428 458.626 165.994 458.569C165.579 458.52 165.184 458.482 164.827 458.453C164.489 458.424 164.19 458.415 163.901 458.415C163.717 458.424 163.467 458.434 163.148 458.472C162.83 458.501 162.454 458.549 162.01 458.607C161.556 458.674 161.161 458.722 160.823 458.761C160.476 458.789 160.186 458.809 159.945 458.809C158.807 458.818 157.446 458.549 155.845 457.973C154.34 457.416 153.588 456.628 153.588 455.6C153.578 455.072 153.935 454.457 154.668 453.755C155.189 453.474 155.71 453.198 156.231 452.929C156.501 452.775 156.79 452.622 157.07 452.458C157.34 452.286 157.572 452.122 157.784 451.94C157.987 451.738 158.151 451.546 158.276 451.344C158.392 451.142 158.459 450.921 158.459 450.7C158.459 448.042 158.459 445.404 158.459 442.784C158.459 440.203 158.456 437.644 158.45 435.108C158.456 432.617 158.456 430.148 158.45 427.701C158.456 425.3 158.459 422.92 158.459 420.563C158.459 420.285 158.402 420.025 158.315 419.785C158.218 419.564 158.083 419.343 157.89 419.151C157.697 418.94 157.475 418.738 157.196 418.546C156.906 418.334 156.578 418.133 156.202 417.912C155.826 417.691 155.498 417.479 155.228 417.287C154.967 417.086 154.745 416.913 154.591 416.759C154.263 416.451 154.099 416.029 154.099 415.5C154.099 414.415 155.179 413.886 157.36 413.915C159.598 413.928 161.836 413.931 164.074 413.925C166.313 413.893 168.551 413.851 170.789 413.8C172.747 413.742 173.731 414.088 173.731 414.838C173.722 415.395 173.548 415.846 173.172 416.192C172.815 416.528 172.265 416.913 171.512 417.335C171.136 417.566 170.818 417.768 170.519 417.96C170.258 418.142 170.027 418.334 169.834 418.517C169.66 418.68 169.525 418.863 169.429 419.055C169.332 419.247 169.274 419.478 169.284 419.708C169.277 420.003 169.274 420.294 169.274 420.582C171.078 420.121 172.825 419.093 174.513 417.527C176.259 415.942 177.561 414.866 178.42 414.319C179.337 413.733 181.054 413.368 183.543 413.204C186.833 412.955 189.515 413.521 191.589 414.962C193.673 416.365 194.705 418.623 194.715 421.793ZM207.71 443.86C207.71 441.318 207.713 438.794 207.719 436.29C207.713 433.831 207.71 431.394 207.71 428.979C207.716 426.616 207.719 424.284 207.719 421.985C207.719 419.756 207.719 417.566 207.719 415.414C207.719 414.655 207.498 414.184 207.083 413.992C206.861 413.906 206.562 413.8 206.185 413.685C205.809 413.55 205.346 413.416 204.767 413.272C203.667 412.974 203.021 412.609 202.847 412.196C203.021 411.206 203.938 410.553 205.607 410.178C207.33 409.749 209.051 409.294 210.768 408.814C212.492 408.276 214.212 407.706 215.929 407.104C216.798 406.787 217.454 406.816 217.888 407.219C218.322 407.632 218.544 408.295 218.544 409.208C218.544 411.456 218.541 413.742 218.534 416.067C218.541 418.463 218.544 420.893 218.544 423.359C218.544 425.87 218.544 428.406 218.544 430.968C218.544 433.568 218.544 436.181 218.544 438.807C218.544 442.871 219.904 444.773 222.663 444.513C223.898 444.398 225.664 443.687 227.95 442.39C230.294 441.026 232.089 440.258 233.314 440.113C233.314 437.302 233.311 434.49 233.304 431.679C233.304 428.873 233.308 426.071 233.314 423.272C233.314 420.493 233.314 417.723 233.314 414.962C233.314 412.228 233.311 409.512 233.304 406.816C233.304 405.989 232.928 405.432 232.166 405.163C231.79 405.029 231.404 404.894 231.018 404.779C230.642 404.645 230.246 404.529 229.851 404.414C229.079 404.193 228.703 403.684 228.703 402.896C228.703 401.955 229.658 400.994 231.549 400.014C233.941 398.739 236.334 397.449 238.726 396.142C241.112 394.817 243.499 393.491 245.885 392.165C247.92 391.051 248.933 391.243 248.933 392.751C248.933 393.702 248.711 394.557 248.277 395.297C247.843 396.046 247.206 396.844 246.386 397.727C245.981 398.169 245.624 398.563 245.316 398.9C245.016 399.236 244.775 399.572 244.563 399.908C244.36 400.216 244.206 400.552 244.119 400.888C244.013 401.234 243.975 401.618 243.975 402.031C243.968 405.746 243.968 409.461 243.975 413.176C243.975 416.877 243.971 420.57 243.965 424.252C243.965 427.903 243.965 431.538 243.965 435.156C243.971 438.743 243.971 442.313 243.965 445.868C243.965 447.693 244.891 449.134 246.734 450.249C247.853 451.219 248.422 452.218 248.422 453.227C248.422 454.236 248.181 454.899 247.747 455.254C247.303 455.562 246.628 455.744 245.73 455.782C243.37 455.872 241.006 455.965 238.64 456.061C236.279 456.164 233.915 456.266 231.549 456.369C230.516 456.417 229.851 456.292 229.542 456.032C228.982 455.782 228.703 455.35 228.703 454.726C228.703 453.986 228.886 453.342 229.281 452.804C229.667 452.238 230.217 451.661 230.96 451.056C231.674 450.441 232.234 449.874 232.62 449.403C233.015 448.913 233.247 448.318 233.304 447.607C233.311 447.235 233.314 446.864 233.314 446.493C231.462 447.3 229.561 448.837 227.641 451.113C226.686 452.238 225.837 453.169 225.114 453.919C224.4 454.649 223.792 455.225 223.319 455.629C222.345 456.417 220.647 456.858 218.216 456.964C215.418 457.079 213.238 456.541 211.656 455.369C210.411 454.409 209.446 453.073 208.742 451.344C208.067 449.624 207.71 447.117 207.71 443.86ZM255.04 397.804C255.04 393.789 256.294 390.455 258.851 387.755C261.34 385.046 264.109 383.058 267.119 381.914C269.962 381.043 272.801 380.332 275.638 379.782C278.474 379.66 281.31 379.826 284.147 380.281C289.308 382.683 291.874 389.091 291.874 397.228C291.884 398.631 291.768 399.755 291.566 400.677C291.382 401.561 291.093 402.185 290.736 402.569C290.369 402.954 289.916 403.117 289.385 403.059C288.845 403.002 288.256 402.733 287.591 402.243C285.217 400.715 283.886 398.515 283.587 395.249C283.587 394.077 283.529 393.03 283.423 392.107C283.066 391.185 282.507 390.58 281.735 390.34C278.853 389.84 275.972 389.603 273.091 389.629C269.569 390.109 267.794 392.031 267.804 395.105C267.804 396.834 268.46 398.217 269.772 399.284C270.438 399.851 271.354 400.571 272.521 401.503C273.689 402.464 275.136 403.684 276.853 405.154C278.57 406.729 280.046 408.276 281.301 409.775C282.564 411.312 283.645 412.734 284.494 414.031C286.221 416.692 287.726 419.334 289.019 421.899C290.321 424.416 291.401 426.789 292.26 429.017C294.006 433.245 294.904 437.452 295 441.756C295 444.869 294.489 447.482 293.456 449.672C292.453 451.969 291.035 453.707 289.221 454.918C287.436 456.224 285.449 456.83 283.22 456.657C282.757 456.628 282.121 456.541 281.349 456.417C280.587 456.32 279.651 456.176 278.541 455.984C277.432 455.802 276.429 455.638 275.531 455.504C274.644 455.379 273.824 455.283 273.091 455.235C272.57 455.225 271.894 455.235 271.084 455.302C270.274 455.369 269.28 455.465 268.132 455.6C266.974 455.754 265.99 455.859 265.141 455.946C264.311 456.042 263.598 456.1 263.009 456.1C261.572 456.109 260.24 455.811 258.996 455.216C257.751 454.591 256.68 453.707 255.764 452.564C254.847 451.431 254.124 450.038 253.583 448.404C253.034 446.742 252.734 444.879 252.677 442.765C252.667 441.122 252.841 439.681 253.198 438.423C253.535 437.164 254.018 435.867 254.635 434.551C254.963 433.888 255.233 433.302 255.445 432.793C255.677 432.255 255.87 431.794 256.015 431.381C256.323 430.574 256.468 429.603 256.468 428.451C256.468 427.567 256.275 426.52 255.87 425.29C256.989 424.617 258.224 424.224 259.565 424.099C261.099 423.964 262.478 424.848 263.704 426.741C264.919 428.633 265.517 430.929 265.517 433.581C265.517 436.232 266.26 437.933 267.727 438.73C269.154 439.537 270.987 439.998 273.255 440.142C275.57 440.344 277.644 440.027 279.487 439.153C281.301 438.307 282.227 436.482 282.227 433.562C282.227 430.612 280.857 427.231 278.107 423.436C277.635 422.84 277.152 422.273 276.66 421.707C276.159 421.159 275.657 420.621 275.136 420.093C274.625 419.555 273.92 418.872 273.023 418.037C272.155 417.23 271.084 416.25 269.81 415.145C268.527 414.059 267.36 413.079 266.27 412.205C265.189 411.341 264.157 410.514 263.173 409.765C260.443 407.767 258.388 406.018 257.018 404.385C255.687 402.838 255.04 400.658 255.04 397.804Z");
    			add_location(path201, file$b, 226, 8, 58863);
    			attr_dev(g3, "class", "title-svg-venus-text");
    			add_location(g3, file$b, 225, 4, 58822);
    			attr_dev(circle0, "cx", "175");
    			attr_dev(circle0, "cy", "270");
    			attr_dev(circle0, "r", "110.5");
    			attr_dev(circle0, "stroke", "#9B9B9B");
    			add_location(circle0, file$b, 235, 12, 75416);
    			attr_dev(circle1, "cx", "175.5");
    			attr_dev(circle1, "cy", "270.5");
    			attr_dev(circle1, "r", "102");
    			attr_dev(circle1, "stroke", "#9B9B9B");
    			add_location(circle1, file$b, 236, 12, 75483);
    			attr_dev(g4, "class", "title-svg-inner-outer-circles");
    			add_location(g4, file$b, 234, 8, 75329);
    			attr_dev(circle2, "cx", "65");
    			attr_dev(circle2, "cy", "370");
    			attr_dev(circle2, "r", "2");
    			attr_dev(circle2, "fill", "#9B9B9B");
    			add_location(circle2, file$b, 239, 12, 75630);
    			attr_dev(circle3, "cx", "69");
    			attr_dev(circle3, "cy", "364");
    			attr_dev(circle3, "r", "2");
    			attr_dev(circle3, "fill", "#9B9B9B");
    			add_location(circle3, file$b, 240, 12, 75690);
    			attr_dev(circle4, "cx", "73");
    			attr_dev(circle4, "cy", "370");
    			attr_dev(circle4, "r", "2");
    			attr_dev(circle4, "fill", "#9B9B9B");
    			add_location(circle4, file$b, 241, 12, 75750);
    			attr_dev(g5, "class", "title-svg-ll-dots");
    			add_location(g5, file$b, 238, 8, 75561);
    			attr_dev(circle5, "cx", "73");
    			attr_dev(circle5, "cy", "170");
    			attr_dev(circle5, "r", "2");
    			attr_dev(circle5, "transform", "rotate(-180 73 170)");
    			attr_dev(circle5, "fill", "#9B9B9B");
    			add_location(circle5, file$b, 244, 12, 75888);
    			attr_dev(circle6, "cx", "69");
    			attr_dev(circle6, "cy", "176");
    			attr_dev(circle6, "r", "2");
    			attr_dev(circle6, "transform", "rotate(-180 69 176)");
    			attr_dev(circle6, "fill", "#9B9B9B");
    			add_location(circle6, file$b, 245, 12, 75980);
    			attr_dev(circle7, "cx", "65");
    			attr_dev(circle7, "cy", "170");
    			attr_dev(circle7, "r", "2");
    			attr_dev(circle7, "transform", "rotate(-180 65 170)");
    			attr_dev(circle7, "fill", "#9B9B9B");
    			add_location(circle7, file$b, 246, 12, 76072);
    			attr_dev(g6, "class", "title-svg-ul-dots");
    			add_location(g6, file$b, 243, 8, 75819);
    			attr_dev(circle8, "cx", "274");
    			attr_dev(circle8, "cy", "370");
    			attr_dev(circle8, "r", "2");
    			attr_dev(circle8, "fill", "#9B9B9B");
    			add_location(circle8, file$b, 249, 12, 76243);
    			attr_dev(circle9, "cx", "278");
    			attr_dev(circle9, "cy", "364");
    			attr_dev(circle9, "r", "2");
    			attr_dev(circle9, "fill", "#9B9B9B");
    			add_location(circle9, file$b, 250, 12, 76304);
    			attr_dev(circle10, "cx", "282");
    			attr_dev(circle10, "cy", "370");
    			attr_dev(circle10, "r", "2");
    			attr_dev(circle10, "fill", "#9B9B9B");
    			add_location(circle10, file$b, 251, 12, 76365);
    			attr_dev(g7, "class", "title-svg-lr-dots");
    			add_location(g7, file$b, 248, 8, 76173);
    			attr_dev(circle11, "cx", "288");
    			attr_dev(circle11, "cy", "170");
    			attr_dev(circle11, "r", "2");
    			attr_dev(circle11, "transform", "rotate(-180 288 170)");
    			attr_dev(circle11, "fill", "#9B9B9B");
    			add_location(circle11, file$b, 254, 12, 76505);
    			attr_dev(circle12, "cx", "284");
    			attr_dev(circle12, "cy", "176");
    			attr_dev(circle12, "r", "2");
    			attr_dev(circle12, "transform", "rotate(-180 284 176)");
    			attr_dev(circle12, "fill", "#9B9B9B");
    			add_location(circle12, file$b, 255, 12, 76599);
    			attr_dev(circle13, "cx", "280");
    			attr_dev(circle13, "cy", "170");
    			attr_dev(circle13, "r", "2");
    			attr_dev(circle13, "transform", "rotate(-180 280 170)");
    			attr_dev(circle13, "fill", "#9B9B9B");
    			add_location(circle13, file$b, 256, 12, 76693);
    			attr_dev(g8, "class", "title-svg-ur-dots");
    			add_location(g8, file$b, 253, 8, 76435);
    			attr_dev(path202, "d", "M55.83 536.888L52.5582 550.512L66.1827 547.24L52.7477 551.219L62.3934 561.382L52.2301 551.737L48.2512 565.172L51.523 551.547L37.8985 554.819L51.3335 550.84L41.6878 540.677L51.8511 550.323L55.83 536.888Z");
    			attr_dev(path202, "fill", "#4F4F4F");
    			add_location(path202, file$b, 261, 12, 76895);
    			attr_dev(path203, "d", "M48.2122 536.832L52.191 550.267L62.3543 540.621L52.7086 550.784L66.1437 554.763L52.5192 551.491L55.7909 565.116L51.8121 551.681L41.6488 561.327L51.2944 551.163L37.8594 547.184L51.4839 550.456L48.2122 536.832Z");
    			attr_dev(path203, "fill", "#4F4F4F");
    			add_location(path203, file$b, 262, 12, 77137);
    			attr_dev(path204, "d", "M44.6795 538.321L52 548.804L59.3205 538.321L53.9019 549.902L66.641 551L53.9019 552.098L59.3205 563.68L52 553.196L44.6795 563.68L50.0981 552.098L37.359 551L50.0981 549.902L44.6795 538.321Z");
    			attr_dev(path204, "fill", "#4F4F4F");
    			add_location(path204, file$b, 263, 12, 77385);
    			attr_dev(path205, "d", "M51.9583 536.335L53.0564 549.075L64.6378 543.656L54.1545 550.976L64.6378 558.297L53.0564 552.878L51.9583 565.617L50.8602 552.878L39.2788 558.297L49.7622 550.976L39.2788 543.656L50.8602 549.075L51.9583 536.335Z");
    			attr_dev(path205, "fill", "#4F4F4F");
    			add_location(path205, file$b, 264, 12, 77612);
    			attr_dev(g9, "class", "title-svg-ll-star");
    			add_location(g9, file$b, 260, 8, 76828);
    			attr_dev(path206, "d", "M301.83 34.8875L298.558 48.512L312.183 45.2403L298.748 49.2191L308.393 59.3824L298.23 49.7368L294.251 63.1718L297.523 49.5473L283.898 52.819L297.333 48.8402L287.688 38.6769L297.851 48.3225L301.83 34.8875Z");
    			attr_dev(path206, "fill", "#4F4F4F");
    			add_location(path206, file$b, 267, 12, 77938);
    			attr_dev(path207, "d", "M294.212 34.8317L298.191 48.2667L308.354 38.6211L298.709 48.7844L312.144 52.7632L298.519 49.4915L301.791 63.116L297.812 49.681L287.649 59.3266L297.294 49.1633L283.859 45.1845L297.484 48.4562L294.212 34.8317Z");
    			attr_dev(path207, "fill", "#4F4F4F");
    			add_location(path207, file$b, 268, 12, 78182);
    			attr_dev(path208, "d", "M290.679 36.3206L298 46.8039L305.321 36.3206L299.902 47.902L312.641 49.0001L299.902 50.0982L305.321 61.6796L298 51.1962L290.679 61.6796L296.098 50.0982L283.359 49.0001L296.098 47.902L290.679 36.3206Z");
    			attr_dev(path208, "fill", "#4F4F4F");
    			add_location(path208, file$b, 269, 12, 78429);
    			attr_dev(path209, "d", "M297.958 34.3354L299.056 47.0745L310.638 41.656L300.154 48.9765L310.638 56.297L299.056 50.8784L297.958 63.6175L296.86 50.8784L285.279 56.297L295.762 48.9765L285.279 41.656L296.86 47.0745L297.958 34.3354Z");
    			attr_dev(path209, "fill", "#4F4F4F");
    			add_location(path209, file$b, 270, 12, 78668);
    			attr_dev(g10, "class", "title-svg-ur-star");
    			add_location(g10, file$b, 266, 8, 77870);
    			attr_dev(path210, "d", "M55.83 34.8875L52.5582 48.512L66.1827 45.2403L52.7477 49.2191L62.3934 59.3824L52.2301 49.7368L48.2512 63.1718L51.523 49.5473L37.8985 52.819L51.3335 48.8402L41.6878 38.6769L51.8511 48.3225L55.83 34.8875Z");
    			attr_dev(path210, "fill", "#4F4F4F");
    			add_location(path210, file$b, 273, 12, 78987);
    			attr_dev(path211, "d", "M48.2122 34.8317L52.191 48.2667L62.3543 38.6211L52.7086 48.7844L66.1437 52.7632L52.5192 49.4915L55.7909 63.116L51.8121 49.681L41.6488 59.3266L51.2944 49.1633L37.8594 45.1845L51.4839 48.4562L48.2122 34.8317Z");
    			attr_dev(path211, "fill", "#4F4F4F");
    			add_location(path211, file$b, 274, 12, 79229);
    			attr_dev(path212, "d", "M44.6795 36.3206L52 46.8039L59.3205 36.3206L53.9019 47.902L66.641 49.0001L53.9019 50.0982L59.3205 61.6796L52 51.1962L44.6795 61.6796L50.0981 50.0982L37.359 49.0001L50.0981 47.902L44.6795 36.3206Z");
    			attr_dev(path212, "fill", "#4F4F4F");
    			add_location(path212, file$b, 275, 12, 79475);
    			attr_dev(path213, "d", "M51.9583 34.3354L53.0564 47.0745L64.6378 41.656L54.1545 48.9765L64.6378 56.297L53.0564 50.8784L51.9583 63.6175L50.8602 50.8784L39.2788 56.297L49.7622 48.9765L39.2788 41.656L50.8602 47.0745L51.9583 34.3354Z");
    			attr_dev(path213, "fill", "#4F4F4F");
    			add_location(path213, file$b, 276, 12, 79710);
    			attr_dev(g11, "class", "title-svg-ul-star");
    			add_location(g11, file$b, 272, 8, 78920);
    			attr_dev(path214, "d", "M301.83 536.888L298.558 550.512L312.183 547.24L298.748 551.219L308.393 561.382L298.23 551.737L294.251 565.172L297.523 551.547L283.898 554.819L297.333 550.84L287.688 540.677L297.851 550.323L301.83 536.888Z");
    			attr_dev(path214, "fill", "#4F4F4F");
    			add_location(path214, file$b, 279, 12, 80032);
    			attr_dev(path215, "d", "M294.212 536.832L298.191 550.267L308.354 540.621L298.709 550.784L312.144 554.763L298.519 551.491L301.791 565.116L297.812 551.681L287.649 561.327L297.294 551.163L283.859 547.184L297.484 550.456L294.212 536.832Z");
    			attr_dev(path215, "fill", "#4F4F4F");
    			add_location(path215, file$b, 280, 12, 80276);
    			attr_dev(path216, "d", "M290.679 538.321L298 548.804L305.321 538.321L299.902 549.902L312.641 551L299.902 552.098L305.321 563.68L298 553.196L290.679 563.68L296.098 552.098L283.359 551L296.098 549.902L290.679 538.321Z");
    			attr_dev(path216, "fill", "#4F4F4F");
    			add_location(path216, file$b, 281, 12, 80525);
    			attr_dev(path217, "d", "M297.958 536.335L299.056 549.075L310.638 543.656L300.154 550.976L310.638 558.297L299.056 552.878L297.958 565.617L296.86 552.878L285.279 558.297L295.762 550.976L285.279 543.656L296.86 549.075L297.958 536.335Z");
    			attr_dev(path217, "fill", "#4F4F4F");
    			add_location(path217, file$b, 282, 12, 80756);
    			attr_dev(g12, "class", "title-svg-lr-star");
    			add_location(g12, file$b, 278, 8, 79964);
    			add_location(g13, file$b, 232, 4, 75285);
    			attr_dev(svg, "class", "title-card-svg svelte-1xbwznz");
    			attr_dev(svg, "width", /*width*/ ctx[0]);
    			attr_dev(svg, "height", /*height*/ ctx[1]);
    			attr_dev(svg, "viewBox", svg_viewBox_value = "0 0 " + /*width*/ ctx[0] + " " + /*height*/ ctx[1]);
    			attr_dev(svg, "fill", "none");
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			add_location(svg, file$b, 6, 0, 77);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, g0);
    			append_dev(g0, rect0);
    			append_dev(g0, rect1);
    			append_dev(g0, rect2);
    			append_dev(svg, g1);
    			append_dev(g1, path0);
    			append_dev(g1, path1);
    			append_dev(g1, path2);
    			append_dev(g1, path3);
    			append_dev(g1, path4);
    			append_dev(g1, path5);
    			append_dev(g1, path6);
    			append_dev(g1, path7);
    			append_dev(g1, path8);
    			append_dev(g1, path9);
    			append_dev(g1, path10);
    			append_dev(g1, path11);
    			append_dev(g1, path12);
    			append_dev(g1, path13);
    			append_dev(g1, path14);
    			append_dev(g1, path15);
    			append_dev(g1, path16);
    			append_dev(g1, path17);
    			append_dev(g1, path18);
    			append_dev(g1, path19);
    			append_dev(g1, path20);
    			append_dev(g1, path21);
    			append_dev(g1, path22);
    			append_dev(g1, path23);
    			append_dev(g1, path24);
    			append_dev(g1, path25);
    			append_dev(g1, path26);
    			append_dev(g1, path27);
    			append_dev(g1, path28);
    			append_dev(g1, path29);
    			append_dev(g1, path30);
    			append_dev(g1, path31);
    			append_dev(g1, path32);
    			append_dev(g1, path33);
    			append_dev(g1, path34);
    			append_dev(g1, path35);
    			append_dev(g1, path36);
    			append_dev(g1, path37);
    			append_dev(g1, path38);
    			append_dev(g1, path39);
    			append_dev(g1, path40);
    			append_dev(g1, path41);
    			append_dev(g1, path42);
    			append_dev(g1, path43);
    			append_dev(g1, path44);
    			append_dev(g1, path45);
    			append_dev(g1, path46);
    			append_dev(g1, path47);
    			append_dev(g1, path48);
    			append_dev(g1, path49);
    			append_dev(g1, path50);
    			append_dev(g1, path51);
    			append_dev(g1, path52);
    			append_dev(g1, path53);
    			append_dev(g1, path54);
    			append_dev(g1, path55);
    			append_dev(g1, path56);
    			append_dev(g1, path57);
    			append_dev(g1, path58);
    			append_dev(g1, path59);
    			append_dev(g1, path60);
    			append_dev(g1, path61);
    			append_dev(g1, path62);
    			append_dev(g1, path63);
    			append_dev(g1, path64);
    			append_dev(g1, path65);
    			append_dev(g1, path66);
    			append_dev(g1, path67);
    			append_dev(g1, path68);
    			append_dev(g1, path69);
    			append_dev(g1, path70);
    			append_dev(g1, path71);
    			append_dev(g1, path72);
    			append_dev(g1, path73);
    			append_dev(g1, path74);
    			append_dev(g1, path75);
    			append_dev(g1, path76);
    			append_dev(g1, path77);
    			append_dev(g1, path78);
    			append_dev(g1, path79);
    			append_dev(g1, path80);
    			append_dev(g1, path81);
    			append_dev(g1, path82);
    			append_dev(g1, path83);
    			append_dev(g1, path84);
    			append_dev(g1, path85);
    			append_dev(g1, path86);
    			append_dev(g1, path87);
    			append_dev(g1, path88);
    			append_dev(g1, path89);
    			append_dev(g1, path90);
    			append_dev(g1, path91);
    			append_dev(g1, path92);
    			append_dev(g1, path93);
    			append_dev(g1, path94);
    			append_dev(g1, path95);
    			append_dev(g1, path96);
    			append_dev(g1, path97);
    			append_dev(g1, path98);
    			append_dev(g1, path99);
    			append_dev(g1, path100);
    			append_dev(g1, path101);
    			append_dev(g1, path102);
    			append_dev(g1, path103);
    			append_dev(g1, path104);
    			append_dev(g1, path105);
    			append_dev(g1, path106);
    			append_dev(g1, path107);
    			append_dev(g1, path108);
    			append_dev(g1, path109);
    			append_dev(g1, path110);
    			append_dev(g1, path111);
    			append_dev(g1, path112);
    			append_dev(g1, path113);
    			append_dev(g1, path114);
    			append_dev(g1, path115);
    			append_dev(g1, path116);
    			append_dev(g1, path117);
    			append_dev(g1, path118);
    			append_dev(g1, path119);
    			append_dev(g1, path120);
    			append_dev(g1, path121);
    			append_dev(g1, path122);
    			append_dev(g1, path123);
    			append_dev(g1, path124);
    			append_dev(g1, path125);
    			append_dev(g1, path126);
    			append_dev(g1, path127);
    			append_dev(g1, path128);
    			append_dev(g1, path129);
    			append_dev(g1, path130);
    			append_dev(g1, path131);
    			append_dev(g1, path132);
    			append_dev(g1, path133);
    			append_dev(g1, path134);
    			append_dev(g1, path135);
    			append_dev(g1, path136);
    			append_dev(g1, path137);
    			append_dev(g1, path138);
    			append_dev(g1, path139);
    			append_dev(g1, path140);
    			append_dev(g1, path141);
    			append_dev(g1, path142);
    			append_dev(g1, path143);
    			append_dev(g1, path144);
    			append_dev(g1, path145);
    			append_dev(g1, path146);
    			append_dev(g1, path147);
    			append_dev(g1, path148);
    			append_dev(g1, path149);
    			append_dev(g1, path150);
    			append_dev(g1, path151);
    			append_dev(g1, path152);
    			append_dev(g1, path153);
    			append_dev(g1, path154);
    			append_dev(g1, path155);
    			append_dev(g1, path156);
    			append_dev(g1, path157);
    			append_dev(g1, path158);
    			append_dev(g1, path159);
    			append_dev(g1, path160);
    			append_dev(g1, path161);
    			append_dev(g1, path162);
    			append_dev(g1, path163);
    			append_dev(g1, path164);
    			append_dev(g1, path165);
    			append_dev(g1, path166);
    			append_dev(g1, path167);
    			append_dev(g1, path168);
    			append_dev(g1, path169);
    			append_dev(g1, path170);
    			append_dev(g1, path171);
    			append_dev(g1, path172);
    			append_dev(g1, path173);
    			append_dev(g1, path174);
    			append_dev(g1, path175);
    			append_dev(g1, path176);
    			append_dev(g1, path177);
    			append_dev(g1, path178);
    			append_dev(g1, path179);
    			append_dev(g1, path180);
    			append_dev(g1, path181);
    			append_dev(g1, path182);
    			append_dev(g1, path183);
    			append_dev(g1, path184);
    			append_dev(g1, path185);
    			append_dev(g1, path186);
    			append_dev(g1, path187);
    			append_dev(g1, path188);
    			append_dev(g1, path189);
    			append_dev(g1, path190);
    			append_dev(g1, path191);
    			append_dev(g1, path192);
    			append_dev(g1, path193);
    			append_dev(g1, path194);
    			append_dev(g1, path195);
    			append_dev(g1, path196);
    			append_dev(g1, path197);
    			append_dev(g1, path198);
    			append_dev(g1, path199);
    			append_dev(svg, g2);
    			append_dev(g2, path200);
    			append_dev(svg, g3);
    			append_dev(g3, path201);
    			append_dev(svg, g13);
    			append_dev(g13, g4);
    			append_dev(g4, circle0);
    			append_dev(g4, circle1);
    			append_dev(g13, g5);
    			append_dev(g5, circle2);
    			append_dev(g5, circle3);
    			append_dev(g5, circle4);
    			append_dev(g13, g6);
    			append_dev(g6, circle5);
    			append_dev(g6, circle6);
    			append_dev(g6, circle7);
    			append_dev(g13, g7);
    			append_dev(g7, circle8);
    			append_dev(g7, circle9);
    			append_dev(g7, circle10);
    			append_dev(g13, g8);
    			append_dev(g8, circle11);
    			append_dev(g8, circle12);
    			append_dev(g8, circle13);
    			append_dev(g13, g9);
    			append_dev(g9, path202);
    			append_dev(g9, path203);
    			append_dev(g9, path204);
    			append_dev(g9, path205);
    			append_dev(g13, g10);
    			append_dev(g10, path206);
    			append_dev(g10, path207);
    			append_dev(g10, path208);
    			append_dev(g10, path209);
    			append_dev(g13, g11);
    			append_dev(g11, path210);
    			append_dev(g11, path211);
    			append_dev(g11, path212);
    			append_dev(g11, path213);
    			append_dev(g13, g12);
    			append_dev(g12, path214);
    			append_dev(g12, path215);
    			append_dev(g12, path216);
    			append_dev(g12, path217);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*width*/ 1) {
    				attr_dev(svg, "width", /*width*/ ctx[0]);
    			}

    			if (dirty & /*height*/ 2) {
    				attr_dev(svg, "height", /*height*/ ctx[1]);
    			}

    			if (dirty & /*width, height*/ 3 && svg_viewBox_value !== (svg_viewBox_value = "0 0 " + /*width*/ ctx[0] + " " + /*height*/ ctx[1])) {
    				attr_dev(svg, "viewBox", svg_viewBox_value);
    			}
    		},
    		i: noop$2,
    		o: noop$2,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$b.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$b($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('TitleCard', slots, []);
    	let { width } = $$props;
    	let { height } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (width === undefined && !('width' in $$props || $$self.$$.bound[$$self.$$.props['width']])) {
    			console.warn("<TitleCard> was created without expected prop 'width'");
    		}

    		if (height === undefined && !('height' in $$props || $$self.$$.bound[$$self.$$.props['height']])) {
    			console.warn("<TitleCard> was created without expected prop 'height'");
    		}
    	});

    	const writable_props = ['width', 'height'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<TitleCard> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('width' in $$props) $$invalidate(0, width = $$props.width);
    		if ('height' in $$props) $$invalidate(1, height = $$props.height);
    	};

    	$$self.$capture_state = () => ({ width, height });

    	$$self.$inject_state = $$props => {
    		if ('width' in $$props) $$invalidate(0, width = $$props.width);
    		if ('height' in $$props) $$invalidate(1, height = $$props.height);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [width, height];
    }

    class TitleCard extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$b, create_fragment$b, safe_not_equal, { width: 0, height: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "TitleCard",
    			options,
    			id: create_fragment$b.name
    		});
    	}

    	get width() {
    		throw new Error("<TitleCard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set width(value) {
    		throw new Error("<TitleCard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get height() {
    		throw new Error("<TitleCard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set height(value) {
    		throw new Error("<TitleCard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    function fade(node, { delay = 0, duration = 400, easing = identity$3 } = {}) {
        const o = +getComputedStyle(node).opacity;
        return {
            delay,
            duration,
            easing,
            css: t => `opacity: ${t * o}`
        };
    }

    /* src/lib/elements/SectionIntro.svelte generated by Svelte v3.53.1 */
    const file$a = "src/lib/elements/SectionIntro.svelte";

    // (24:12) <SplideSlide>
    function create_default_slot_9(ctx) {
    	let div1;
    	let div0;
    	let globe_1;
    	let div0_intro;
    	let t;
    	let titlecard;
    	let current;

    	globe_1 = new Globe_1({
    			props: { targetNode: "intro-globe" },
    			$$inline: true
    		});

    	titlecard = new TitleCard({
    			props: { width: 350, height: 600 },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			create_component(globe_1.$$.fragment);
    			t = space();
    			create_component(titlecard.$$.fragment);
    			attr_dev(div0, "class", "globe-wrapper svelte-vlxpl7");
    			set_style(div0, "margin", /*globeMargin*/ ctx[1]);
    			attr_dev(div0, "aria-hidden", "true");
    			attr_dev(div0, "focusable", "false");
    			add_location(div0, file$a, 25, 20, 915);
    			attr_dev(div1, "class", "intro-card svelte-vlxpl7");
    			attr_dev(div1, "id", "card-1");
    			add_location(div1, file$a, 24, 16, 858);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			mount_component(globe_1, div0, null);
    			append_dev(div1, t);
    			mount_component(titlecard, div1, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (!current || dirty & /*globeMargin*/ 2) {
    				set_style(div0, "margin", /*globeMargin*/ ctx[1]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(globe_1.$$.fragment, local);

    			if (!div0_intro) {
    				add_render_callback(() => {
    					div0_intro = create_in_transition(div0, fade, { duration: 500, delay: 2000 });
    					div0_intro.start();
    				});
    			}

    			transition_in(titlecard.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(globe_1.$$.fragment, local);
    			transition_out(titlecard.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			destroy_component(globe_1);
    			destroy_component(titlecard);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_9.name,
    		type: "slot",
    		source: "(24:12) <SplideSlide>",
    		ctx
    	});

    	return block;
    }

    // (35:20) <IntroTextCard cardNumber={2}>
    function create_default_slot_8(ctx) {
    	let p0;
    	let t1;
    	let p1;
    	let t3;
    	let p2;
    	let t5;
    	let p3;

    	const block = {
    		c: function create() {
    			p0 = element("p");
    			p0.textContent = "Venus — Earth's twin, the Morning Star, the brightest planet — has captured our collective imagination for more than 5,000 years.";
    			t1 = space();
    			p1 = element("p");
    			p1.textContent = "But for a remarkably long time, its surface was a mystery. Normal telescopes can't see through the dense sulfuric acid clouds that envelop the whole planet.";
    			t3 = space();
    			p2 = element("p");
    			p2.textContent = "It was only in the last 50 years, and the invention of radar imaging, that astronomers could peer through the clouds and see craters, valleys, and mountains on Venus for the first time.";
    			t5 = space();
    			p3 = element("p");
    			p3.textContent = "There was an explosion of discovery — and what we saw, we named.";
    			attr_dev(p0, "class", "intro-paragraph svelte-vlxpl7");
    			add_location(p0, file$a, 35, 24, 1394);
    			attr_dev(p1, "class", "intro-paragraph svelte-vlxpl7");
    			add_location(p1, file$a, 37, 24, 1580);
    			attr_dev(p2, "class", "intro-paragraph svelte-vlxpl7");
    			add_location(p2, file$a, 39, 24, 1809);
    			attr_dev(p3, "class", "intro-paragraph svelte-vlxpl7");
    			add_location(p3, file$a, 41, 24, 2051);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p0, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, p1, anchor);
    			insert_dev(target, t3, anchor);
    			insert_dev(target, p2, anchor);
    			insert_dev(target, t5, anchor);
    			insert_dev(target, p3, anchor);
    		},
    		p: noop$2,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(p1);
    			if (detaching) detach_dev(t3);
    			if (detaching) detach_dev(p2);
    			if (detaching) detach_dev(t5);
    			if (detaching) detach_dev(p3);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_8.name,
    		type: "slot",
    		source: "(35:20) <IntroTextCard cardNumber={2}>",
    		ctx
    	});

    	return block;
    }

    // (33:12) <SplideSlide>
    function create_default_slot_7(ctx) {
    	let div;
    	let introtextcard;
    	let current;

    	introtextcard = new IntroTextCard({
    			props: {
    				cardNumber: 2,
    				$$slots: { default: [create_default_slot_8] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(introtextcard.$$.fragment);
    			attr_dev(div, "class", "intro-card svelte-vlxpl7");
    			add_location(div, file$a, 33, 16, 1294);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(introtextcard, div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const introtextcard_changes = {};

    			if (dirty & /*$$scope*/ 64) {
    				introtextcard_changes.$$scope = { dirty, ctx };
    			}

    			introtextcard.$set(introtextcard_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(introtextcard.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(introtextcard.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(introtextcard);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_7.name,
    		type: "slot",
    		source: "(33:12) <SplideSlide>",
    		ctx
    	});

    	return block;
    }

    // (49:20) <IntroTextCard cardNumber={3}>
    function create_default_slot_6(ctx) {
    	let p0;
    	let t1;
    	let p1;
    	let t2;
    	let em;
    	let t4;
    	let t5;
    	let p2;
    	let t7;
    	let p3;

    	const block = {
    		c: function create() {
    			p0 = element("p");
    			p0.textContent = "Why do we name features on other worlds?";
    			t1 = space();
    			p1 = element("p");
    			t2 = text("It's more than just convenience: naming is an expression of culture and ownership. An alien landscape feels more human, more ");
    			em = element("em");
    			em.textContent = "ours";
    			t4 = text(", when we call it names from home.");
    			t5 = space();
    			p2 = element("p");
    			p2.textContent = "On Venus, nearly every one of its 1,976 recorded features honor women: famous women, heroines, goddesses, and female names.";
    			t7 = space();
    			p3 = element("p");
    			p3.textContent = "But 40% of those names are European in origin, reflecting the bias of those early astronomers who discovered so many features so quickly.";
    			attr_dev(p0, "class", "intro-paragraph svelte-vlxpl7");
    			add_location(p0, file$a, 49, 24, 2381);
    			add_location(em, file$a, 51, 176, 2630);
    			attr_dev(p1, "class", "intro-paragraph svelte-vlxpl7");
    			add_location(p1, file$a, 51, 24, 2478);
    			attr_dev(p2, "class", "intro-paragraph svelte-vlxpl7");
    			add_location(p2, file$a, 53, 24, 2707);
    			attr_dev(p3, "class", "intro-paragraph svelte-vlxpl7");
    			add_location(p3, file$a, 55, 24, 2887);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p0, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, p1, anchor);
    			append_dev(p1, t2);
    			append_dev(p1, em);
    			append_dev(p1, t4);
    			insert_dev(target, t5, anchor);
    			insert_dev(target, p2, anchor);
    			insert_dev(target, t7, anchor);
    			insert_dev(target, p3, anchor);
    		},
    		p: noop$2,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(p1);
    			if (detaching) detach_dev(t5);
    			if (detaching) detach_dev(p2);
    			if (detaching) detach_dev(t7);
    			if (detaching) detach_dev(p3);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_6.name,
    		type: "slot",
    		source: "(49:20) <IntroTextCard cardNumber={3}>",
    		ctx
    	});

    	return block;
    }

    // (47:12) <SplideSlide>
    function create_default_slot_5(ctx) {
    	let div;
    	let introtextcard;
    	let current;

    	introtextcard = new IntroTextCard({
    			props: {
    				cardNumber: 3,
    				$$slots: { default: [create_default_slot_6] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(introtextcard.$$.fragment);
    			attr_dev(div, "class", "intro-card svelte-vlxpl7");
    			add_location(div, file$a, 47, 16, 2281);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(introtextcard, div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const introtextcard_changes = {};

    			if (dirty & /*$$scope*/ 64) {
    				introtextcard_changes.$$scope = { dirty, ctx };
    			}

    			introtextcard.$set(introtextcard_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(introtextcard.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(introtextcard.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(introtextcard);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5.name,
    		type: "slot",
    		source: "(47:12) <SplideSlide>",
    		ctx
    	});

    	return block;
    }

    // (64:20) <IntroTextCard cardNumber={3}>
    function create_default_slot_4(ctx) {
    	let p0;
    	let t1;
    	let p1;
    	let t3;
    	let p2;
    	let t5;
    	let p3;
    	let t7;
    	let div;
    	let button;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			p0 = element("p");
    			p0.textContent = "Every feature on Venus tells a story, and this project is my attempt to more easily find and explore those stories.";
    			t1 = space();
    			p1 = element("p");
    			p1.textContent = "Explore 1,976 names of Venus, and especially look for the 769 goddesses, heroines, and famous women with extra color and detail.";
    			t3 = space();
    			p2 = element("p");
    			p2.textContent = "The names we give our surroundings reveal more about ourselves — and our values — than they do the landscape we observe.";
    			t5 = space();
    			p3 = element("p");
    			p3.textContent = "See what stories you can find:";
    			t7 = space();
    			div = element("div");
    			button = element("button");
    			button.textContent = "Explore the names";
    			attr_dev(p0, "class", "intro-paragraph svelte-vlxpl7");
    			add_location(p0, file$a, 64, 24, 3287);
    			attr_dev(p1, "class", "intro-paragraph svelte-vlxpl7");
    			add_location(p1, file$a, 66, 24, 3459);
    			attr_dev(p2, "class", "intro-paragraph svelte-vlxpl7");
    			add_location(p2, file$a, 68, 24, 3644);
    			attr_dev(p3, "class", "intro-paragraph svelte-vlxpl7");
    			add_location(p3, file$a, 70, 24, 3821);
    			attr_dev(button, "id", "intro-button");
    			attr_dev(button, "class", "svelte-vlxpl7");
    			add_location(button, file$a, 73, 28, 3971);
    			attr_dev(div, "class", "intro-button-wrapper svelte-vlxpl7");
    			add_location(div, file$a, 72, 24, 3908);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p0, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, p1, anchor);
    			insert_dev(target, t3, anchor);
    			insert_dev(target, p2, anchor);
    			insert_dev(target, t5, anchor);
    			insert_dev(target, p3, anchor);
    			insert_dev(target, t7, anchor);
    			insert_dev(target, div, anchor);
    			append_dev(div, button);

    			if (!mounted) {
    				dispose = [
    					listen_dev(button, "click", /*click_handler*/ ctx[4], false, false, false),
    					listen_dev(button, "keypress", /*keypress_handler*/ ctx[5], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: noop$2,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(p1);
    			if (detaching) detach_dev(t3);
    			if (detaching) detach_dev(p2);
    			if (detaching) detach_dev(t5);
    			if (detaching) detach_dev(p3);
    			if (detaching) detach_dev(t7);
    			if (detaching) detach_dev(div);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4.name,
    		type: "slot",
    		source: "(64:20) <IntroTextCard cardNumber={3}>",
    		ctx
    	});

    	return block;
    }

    // (62:12) <SplideSlide>
    function create_default_slot_3(ctx) {
    	let div;
    	let introtextcard;
    	let current;

    	introtextcard = new IntroTextCard({
    			props: {
    				cardNumber: 3,
    				$$slots: { default: [create_default_slot_4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(introtextcard.$$.fragment);
    			attr_dev(div, "class", "intro-card svelte-vlxpl7");
    			add_location(div, file$a, 62, 16, 3187);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(introtextcard, div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const introtextcard_changes = {};

    			if (dirty & /*$$scope, $activePage, $globe*/ 69) {
    				introtextcard_changes.$$scope = { dirty, ctx };
    			}

    			introtextcard.$set(introtextcard_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(introtextcard.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(introtextcard.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(introtextcard);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3.name,
    		type: "slot",
    		source: "(62:12) <SplideSlide>",
    		ctx
    	});

    	return block;
    }

    // (82:20) <IntroTextCard cardNumber={4}>
    function create_default_slot_2(ctx) {
    	let p0;
    	let t0;
    	let a0;
    	let t2;
    	let t3;
    	let p1;
    	let t4;
    	let a1;
    	let t6;
    	let t7;
    	let p2;
    	let t8;
    	let a2;
    	let t10;
    	let a3;
    	let t12;
    	let a4;
    	let t14;
    	let a5;
    	let t16;
    	let t17;
    	let p3;
    	let t18;
    	let a6;
    	let t20;
    	let a7;
    	let t22;
    	let a8;
    	let t24;
    	let a9;
    	let t26;
    	let a10;
    	let t28;
    	let t29;
    	let p4;
    	let t31;
    	let p5;
    	let t32;
    	let a11;
    	let t34;
    	let a12;
    	let t36;
    	let a13;

    	const block = {
    		c: function create() {
    			p0 = element("p");
    			t0 = text("This project's data source is the International Astronomical Union’s ");
    			a0 = element("a");
    			a0.textContent = "Gazetteer of Planetary Nomenclature";
    			t2 = text(". Note that some of the terms used by the IAU are out of date.");
    			t3 = space();
    			p1 = element("p");
    			t4 = text("Extended descriptions for 769 features were collected using the Python ");
    			a1 = element("a");
    			a1.textContent = "wikipedia";
    			t6 = text(" package and individually edited for clarity.");
    			t7 = space();
    			p2 = element("p");
    			t8 = text("The site is made in ");
    			a2 = element("a");
    			a2.textContent = "Svelte";
    			t10 = text(". The globe uses Vasco Asturiano’s ");
    			a3 = element("a");
    			a3.textContent = "Globe.GL";
    			t12 = text(" package, a convenience wrapper for ThreeJS. The globe's contour map is derived from a 1993 ");
    			a4 = element("a");
    			a4.textContent = "topographic elevation map";
    			t14 = text(" captured by NASA's Magellan team. The map was taken into ");
    			a5 = element("a");
    			a5.textContent = "QGIS";
    			t16 = text(" to generate contours, exported as an SVG file, and styled using Adobe Illustrator.");
    			t17 = space();
    			p3 = element("p");
    			t18 = text("This project is a capstone for the CUNY Graduate Center’s ");
    			a6 = element("a");
    			a6.textContent = "M.S. in Data Analysis & Visualization";
    			t20 = text(" program for fall 2022.  It was inspired by the works of ");
    			a7 = element("a");
    			a7.textContent = "Eleanor Lutz";
    			t22 = text(", ");
    			a8 = element("a");
    			a8.textContent = "Patricia Monaghan";
    			t24 = text(", ");
    			a9 = element("a");
    			a9.textContent = "Inkleby";
    			t26 = text(", and ");
    			a10 = element("a");
    			a10.textContent = "Henrik Hargitai";
    			t28 = text(".");
    			t29 = space();
    			p4 = element("p");
    			p4.textContent = "Special thanks to Aucher Serr, Matthew Gold, Jason Nieslen, and my colleagues at Axios Visuals for their support. And to Leighton, who made me so many cups of tea.";
    			t31 = space();
    			p5 = element("p");
    			t32 = text("By Kavya Beheraj    ");
    			a11 = element("a");
    			a11.textContent = "Twitter";
    			t34 = text("   |   ");
    			a12 = element("a");
    			a12.textContent = "LinkedIn";
    			t36 = text("   |   ");
    			a13 = element("a");
    			a13.textContent = "Email";
    			attr_dev(a0, "href", "https://planetarynames.wr.usgs.gov/SearchResults?Target=15_Venus");
    			attr_dev(a0, "target", "_blank");
    			attr_dev(a0, "class", "svelte-vlxpl7");
    			add_location(a0, file$a, 82, 125, 4497);
    			attr_dev(p0, "class", "about-data-paragraph svelte-vlxpl7");
    			add_location(p0, file$a, 82, 24, 4396);
    			attr_dev(a1, "href", "https://pypi.org/project/wikipedia/");
    			attr_dev(a1, "target", "_blank");
    			attr_dev(a1, "class", "svelte-vlxpl7");
    			add_location(a1, file$a, 84, 127, 4822);
    			attr_dev(p1, "class", "about-data-paragraph svelte-vlxpl7");
    			add_location(p1, file$a, 84, 24, 4719);
    			attr_dev(a2, "href", "https://svelte.dev/");
    			attr_dev(a2, "target", "_blank");
    			attr_dev(a2, "class", "svelte-vlxpl7");
    			add_location(a2, file$a, 86, 76, 5024);
    			attr_dev(a3, "href", "https://globe.gl/");
    			attr_dev(a3, "target", "_blank");
    			attr_dev(a3, "class", "svelte-vlxpl7");
    			add_location(a3, file$a, 86, 167, 5115);
    			attr_dev(a4, "href", "https://astrogeology.usgs.gov/search/map/Venus/Magellan/RadarProperties/Venus_Magellan_Topography_Global_4641m_v02");
    			attr_dev(a4, "target", "_blank");
    			attr_dev(a4, "class", "svelte-vlxpl7");
    			add_location(a4, file$a, 86, 315, 5263);
    			attr_dev(a5, "href", "https://www.qgis.org/en/site/");
    			attr_dev(a5, "target", "_blank");
    			attr_dev(a5, "class", "svelte-vlxpl7");
    			add_location(a5, file$a, 86, 543, 5491);
    			attr_dev(p2, "class", "about-data-paragraph svelte-vlxpl7");
    			add_location(p2, file$a, 86, 24, 4972);
    			attr_dev(a6, "href", "https://www.gc.cuny.edu/data-analysis-and-visualization/curriculum-and-degree-information");
    			attr_dev(a6, "target", "_blank");
    			attr_dev(a6, "class", "svelte-vlxpl7");
    			add_location(a6, file$a, 88, 114, 5758);
    			attr_dev(a7, "href", "https://tabletopwhale.com/2017/03/06/goddesses-of-venus.html");
    			attr_dev(a7, "target", "_blank");
    			attr_dev(a7, "class", "svelte-vlxpl7");
    			add_location(a7, file$a, 88, 328, 5972);
    			attr_dev(a8, "href", "https://bookshop.org/p/books/encyclopedia-of-goddesses-heroines-revised-patricia-monaghan/107143");
    			attr_dev(a8, "target", "_blank");
    			attr_dev(a8, "class", "svelte-vlxpl7");
    			add_location(a8, file$a, 88, 433, 6077);
    			attr_dev(a9, "href", "https://wenamethestars.inkleby.com/world/venus");
    			attr_dev(a9, "target", "_blank");
    			attr_dev(a9, "class", "svelte-vlxpl7");
    			add_location(a9, file$a, 88, 579, 6223);
    			attr_dev(a10, "href", "https://hargitaihenrik.wordpress.com/");
    			attr_dev(a10, "target", "_blank");
    			attr_dev(a10, "class", "svelte-vlxpl7");
    			add_location(a10, file$a, 88, 669, 6313);
    			attr_dev(p3, "class", "about-data-paragraph svelte-vlxpl7");
    			add_location(p3, file$a, 88, 24, 5668);
    			attr_dev(p4, "class", "about-data-paragraph svelte-vlxpl7");
    			add_location(p4, file$a, 90, 24, 6427);
    			attr_dev(a11, "href", "https://twitter.com/KavyaBeheraj");
    			attr_dev(a11, "target", "_blank");
    			attr_dev(a11, "class", "svelte-vlxpl7");
    			add_location(a11, file$a, 92, 86, 6714);
    			attr_dev(a12, "href", "https://www.linkedin.com/in/kavyabeheraj/");
    			attr_dev(a12, "target", "_blank");
    			attr_dev(a12, "class", "svelte-vlxpl7");
    			add_location(a12, file$a, 92, 173, 6801);
    			attr_dev(a13, "href", "mailto:kavya.beheraj@gmail.com");
    			attr_dev(a13, "target", "_blank");
    			attr_dev(a13, "class", "svelte-vlxpl7");
    			add_location(a13, file$a, 92, 270, 6898);
    			attr_dev(p5, "class", "about-data-paragraph svelte-vlxpl7");
    			add_location(p5, file$a, 92, 24, 6652);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p0, anchor);
    			append_dev(p0, t0);
    			append_dev(p0, a0);
    			append_dev(p0, t2);
    			insert_dev(target, t3, anchor);
    			insert_dev(target, p1, anchor);
    			append_dev(p1, t4);
    			append_dev(p1, a1);
    			append_dev(p1, t6);
    			insert_dev(target, t7, anchor);
    			insert_dev(target, p2, anchor);
    			append_dev(p2, t8);
    			append_dev(p2, a2);
    			append_dev(p2, t10);
    			append_dev(p2, a3);
    			append_dev(p2, t12);
    			append_dev(p2, a4);
    			append_dev(p2, t14);
    			append_dev(p2, a5);
    			append_dev(p2, t16);
    			insert_dev(target, t17, anchor);
    			insert_dev(target, p3, anchor);
    			append_dev(p3, t18);
    			append_dev(p3, a6);
    			append_dev(p3, t20);
    			append_dev(p3, a7);
    			append_dev(p3, t22);
    			append_dev(p3, a8);
    			append_dev(p3, t24);
    			append_dev(p3, a9);
    			append_dev(p3, t26);
    			append_dev(p3, a10);
    			append_dev(p3, t28);
    			insert_dev(target, t29, anchor);
    			insert_dev(target, p4, anchor);
    			insert_dev(target, t31, anchor);
    			insert_dev(target, p5, anchor);
    			append_dev(p5, t32);
    			append_dev(p5, a11);
    			append_dev(p5, t34);
    			append_dev(p5, a12);
    			append_dev(p5, t36);
    			append_dev(p5, a13);
    		},
    		p: noop$2,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p0);
    			if (detaching) detach_dev(t3);
    			if (detaching) detach_dev(p1);
    			if (detaching) detach_dev(t7);
    			if (detaching) detach_dev(p2);
    			if (detaching) detach_dev(t17);
    			if (detaching) detach_dev(p3);
    			if (detaching) detach_dev(t29);
    			if (detaching) detach_dev(p4);
    			if (detaching) detach_dev(t31);
    			if (detaching) detach_dev(p5);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2.name,
    		type: "slot",
    		source: "(82:20) <IntroTextCard cardNumber={4}>",
    		ctx
    	});

    	return block;
    }

    // (80:12) <SplideSlide>
    function create_default_slot_1(ctx) {
    	let div;
    	let introtextcard;
    	let current;

    	introtextcard = new IntroTextCard({
    			props: {
    				cardNumber: 4,
    				$$slots: { default: [create_default_slot_2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(introtextcard.$$.fragment);
    			attr_dev(div, "class", "intro-card svelte-vlxpl7");
    			add_location(div, file$a, 80, 16, 4296);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(introtextcard, div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const introtextcard_changes = {};

    			if (dirty & /*$$scope*/ 64) {
    				introtextcard_changes.$$scope = { dirty, ctx };
    			}

    			introtextcard.$set(introtextcard_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(introtextcard.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(introtextcard.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(introtextcard);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1.name,
    		type: "slot",
    		source: "(80:12) <SplideSlide>",
    		ctx
    	});

    	return block;
    }

    // (23:8) <Splide {options} aria-label="Introduction" style='padding: 0rem 0.5rem 1.3rem 0.5rem;'>
    function create_default_slot(ctx) {
    	let splideslide0;
    	let t0;
    	let splideslide1;
    	let t1;
    	let splideslide2;
    	let t2;
    	let splideslide3;
    	let t3;
    	let splideslide4;
    	let current;

    	splideslide0 = new SplideSlide({
    			props: {
    				$$slots: { default: [create_default_slot_9] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	splideslide1 = new SplideSlide({
    			props: {
    				$$slots: { default: [create_default_slot_7] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	splideslide2 = new SplideSlide({
    			props: {
    				$$slots: { default: [create_default_slot_5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	splideslide3 = new SplideSlide({
    			props: {
    				$$slots: { default: [create_default_slot_3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	splideslide4 = new SplideSlide({
    			props: {
    				$$slots: { default: [create_default_slot_1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(splideslide0.$$.fragment);
    			t0 = space();
    			create_component(splideslide1.$$.fragment);
    			t1 = space();
    			create_component(splideslide2.$$.fragment);
    			t2 = space();
    			create_component(splideslide3.$$.fragment);
    			t3 = space();
    			create_component(splideslide4.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(splideslide0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(splideslide1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(splideslide2, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(splideslide3, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(splideslide4, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const splideslide0_changes = {};

    			if (dirty & /*$$scope, globeMargin*/ 66) {
    				splideslide0_changes.$$scope = { dirty, ctx };
    			}

    			splideslide0.$set(splideslide0_changes);
    			const splideslide1_changes = {};

    			if (dirty & /*$$scope*/ 64) {
    				splideslide1_changes.$$scope = { dirty, ctx };
    			}

    			splideslide1.$set(splideslide1_changes);
    			const splideslide2_changes = {};

    			if (dirty & /*$$scope*/ 64) {
    				splideslide2_changes.$$scope = { dirty, ctx };
    			}

    			splideslide2.$set(splideslide2_changes);
    			const splideslide3_changes = {};

    			if (dirty & /*$$scope, $activePage, $globe*/ 69) {
    				splideslide3_changes.$$scope = { dirty, ctx };
    			}

    			splideslide3.$set(splideslide3_changes);
    			const splideslide4_changes = {};

    			if (dirty & /*$$scope*/ 64) {
    				splideslide4_changes.$$scope = { dirty, ctx };
    			}

    			splideslide4.$set(splideslide4_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(splideslide0.$$.fragment, local);
    			transition_in(splideslide1.$$.fragment, local);
    			transition_in(splideslide2.$$.fragment, local);
    			transition_in(splideslide3.$$.fragment, local);
    			transition_in(splideslide4.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(splideslide0.$$.fragment, local);
    			transition_out(splideslide1.$$.fragment, local);
    			transition_out(splideslide2.$$.fragment, local);
    			transition_out(splideslide3.$$.fragment, local);
    			transition_out(splideslide4.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(splideslide0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(splideslide1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(splideslide2, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(splideslide3, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(splideslide4, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot.name,
    		type: "slot",
    		source: "(23:8) <Splide {options} aria-label=\\\"Introduction\\\" style='padding: 0rem 0.5rem 1.3rem 0.5rem;'>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$a(ctx) {
    	let div;
    	let h2;
    	let t1;
    	let section;
    	let splide;
    	let current;

    	splide = new Splide_1({
    			props: {
    				options: /*options*/ ctx[3],
    				"aria-label": "Introduction",
    				style: "padding: 0rem 0.5rem 1.3rem 0.5rem;",
    				$$slots: { default: [create_default_slot] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			h2 = element("h2");
    			h2.textContent = "Introduction";
    			t1 = space();
    			section = element("section");
    			create_component(splide.$$.fragment);
    			attr_dev(h2, "class", "sr-only svelte-vlxpl7");
    			add_location(h2, file$a, 19, 4, 649);
    			attr_dev(section, "class", "carousel");
    			add_location(section, file$a, 21, 4, 692);
    			attr_dev(div, "class", "intro svelte-vlxpl7");
    			add_location(div, file$a, 18, 0, 625);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, h2);
    			append_dev(div, t1);
    			append_dev(div, section);
    			mount_component(splide, section, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const splide_changes = {};

    			if (dirty & /*$$scope, $activePage, $globe, globeMargin*/ 71) {
    				splide_changes.$$scope = { dirty, ctx };
    			}

    			splide.$set(splide_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(splide.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(splide.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(splide);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$a.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$a($$self, $$props, $$invalidate) {
    	let globeMargin;
    	let $activePage;
    	let $globe;
    	validate_store(activePage, 'activePage');
    	component_subscribe($$self, activePage, $$value => $$invalidate(0, $activePage = $$value));
    	validate_store(globe$1, 'globe');
    	component_subscribe($$self, globe$1, $$value => $$invalidate(2, $globe = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('SectionIntro', slots, []);
    	const options = { focus: 'center', autoWidth: true };
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<SectionIntro> was created with unknown prop '${key}'`);
    	});

    	const click_handler = e => handlePageChange($activePage);
    	const keypress_handler = e => handlePageChange($activePage);

    	$$self.$capture_state = () => ({
    		Splide: Splide_1,
    		SplideSlide,
    		SplideTrack,
    		activePage,
    		globe: globe$1,
    		handlePageChange,
    		IntroTextCard,
    		Globe: Globe_1,
    		TitleCard,
    		fade,
    		options,
    		globeMargin,
    		$activePage,
    		$globe
    	});

    	$$self.$inject_state = $$props => {
    		if ('globeMargin' in $$props) $$invalidate(1, globeMargin = $$props.globeMargin);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$activePage*/ 1) {
    			$$invalidate(1, globeMargin = $activePage == "intro" ? "134px 40px" : "0% 0%");
    		}
    	};

    	return [$activePage, globeMargin, $globe, options, click_handler, keypress_handler];
    }

    class SectionIntro extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$a, create_fragment$a, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "SectionIntro",
    			options,
    			id: create_fragment$a.name
    		});
    	}
    }

    /* src/lib/elements/Header.svelte generated by Svelte v3.53.1 */
    const file$9 = "src/lib/elements/Header.svelte";

    function create_fragment$9(ctx) {
    	let div1;
    	let div0;
    	let h1;
    	let t1;
    	let button;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			h1 = element("h1");
    			h1.textContent = "Naming Venus: a data visualization project by Kavya Beheraj";
    			t1 = space();
    			button = element("button");
    			button.textContent = "Naming Venus";
    			attr_dev(h1, "class", "sr-only svelte-3tcg3o");
    			add_location(h1, file$9, 10, 8, 278);
    			attr_dev(button, "aria-expanded", "false");
    			attr_dev(button, "id", "title-button");
    			attr_dev(button, "class", "svelte-3tcg3o");
    			add_location(button, file$9, 11, 8, 371);
    			set_style(div0, "--theme-color", getThemeColor(pageTheme));
    			add_location(div0, file$9, 9, 4, 214);
    			attr_dev(div1, "class", "header");
    			add_location(div1, file$9, 7, 0, 164);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			append_dev(div0, h1);
    			append_dev(div0, t1);
    			append_dev(div0, button);

    			if (!mounted) {
    				dispose = [
    					listen_dev(button, "click", /*click_handler*/ ctx[2], false, false, false),
    					listen_dev(button, "keypress", /*keypress_handler*/ ctx[3], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: noop$2,
    		i: noop$2,
    		o: noop$2,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$9.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$9($$self, $$props, $$invalidate) {
    	let $activePage;
    	let $globe;
    	validate_store(activePage, 'activePage');
    	component_subscribe($$self, activePage, $$value => $$invalidate(0, $activePage = $$value));
    	validate_store(globe$1, 'globe');
    	component_subscribe($$self, globe$1, $$value => $$invalidate(1, $globe = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Header', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Header> was created with unknown prop '${key}'`);
    	});

    	const click_handler = e => handlePageChange($activePage);
    	const keypress_handler = e => handlePageChange($activePage);

    	$$self.$capture_state = () => ({
    		activePage,
    		globe: globe$1,
    		pageTheme,
    		handlePageChange,
    		getThemeColor,
    		$activePage,
    		$globe
    	});

    	return [$activePage, $globe, click_handler, keypress_handler];
    }

    class Header extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$9, create_fragment$9, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Header",
    			options,
    			id: create_fragment$9.name
    		});
    	}
    }

    /* src/lib/elements/HoverText.svelte generated by Svelte v3.53.1 */
    const file$8 = "src/lib/elements/HoverText.svelte";

    // (20:0) {:else}
    function create_else_block$2(ctx) {
    	let span;
    	let p;
    	let t;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			span = element("span");
    			p = element("p");
    			t = text(/*text*/ ctx[0]);
    			attr_dev(p, "class", "hover-button svelte-c5vyum");
    			attr_dev(p, "title", /*text*/ ctx[0]);
    			add_location(p, file$8, 21, 8, 600);
    			attr_dev(span, "class", "hover-text");
    			set_style(span, "--theme-color", /*color*/ ctx[2]);
    			set_style(span, "display", "flex");
    			set_style(span, "justify-content", /*align*/ ctx[3]);
    			add_location(span, file$8, 20, 4, 494);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, p);
    			append_dev(p, t);

    			if (!mounted) {
    				dispose = action_destroyer(tippy.call(null, p, /*props*/ ctx[4]));
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*text*/ 1) set_data_dev(t, /*text*/ ctx[0]);

    			if (dirty & /*text*/ 1) {
    				attr_dev(p, "title", /*text*/ ctx[0]);
    			}

    			if (dirty & /*color*/ 4) {
    				set_style(span, "--theme-color", /*color*/ ctx[2]);
    			}

    			if (dirty & /*align*/ 8) {
    				set_style(span, "justify-content", /*align*/ ctx[3]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$2.name,
    		type: "else",
    		source: "(20:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (16:0) {#if tooltip == null}
    function create_if_block$4(ctx) {
    	let span;
    	let p;
    	let t;

    	const block = {
    		c: function create() {
    			span = element("span");
    			p = element("p");
    			t = text(/*text*/ ctx[0]);
    			attr_dev(p, "class", "hover-button svelte-c5vyum");
    			add_location(p, file$8, 17, 8, 435);
    			attr_dev(span, "class", "hover-text");
    			set_style(span, "--theme-color", /*color*/ ctx[2]);
    			set_style(span, "display", "flex");
    			set_style(span, "justify-content", /*align*/ ctx[3]);
    			add_location(span, file$8, 16, 4, 329);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, p);
    			append_dev(p, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*text*/ 1) set_data_dev(t, /*text*/ ctx[0]);

    			if (dirty & /*color*/ 4) {
    				set_style(span, "--theme-color", /*color*/ ctx[2]);
    			}

    			if (dirty & /*align*/ 8) {
    				set_style(span, "justify-content", /*align*/ ctx[3]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$4.name,
    		type: "if",
    		source: "(16:0) {#if tooltip == null}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$8(ctx) {
    	let if_block_anchor;

    	function select_block_type(ctx, dirty) {
    		if (/*tooltip*/ ctx[1] == null) return create_if_block$4;
    		return create_else_block$2;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty$1();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, [dirty]) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		i: noop$2,
    		o: noop$2,
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$8.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$8($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('HoverText', slots, []);
    	let { text } = $$props;
    	let { tooltip = null } = $$props;
    	let { color = "white" } = $$props;
    	let { align = "center" } = $$props;
    	let { link = null } = $$props;

    	const props = {
    		content: tooltip,
    		allowHTML: true,
    		arrow: true
    	};

    	$$self.$$.on_mount.push(function () {
    		if (text === undefined && !('text' in $$props || $$self.$$.bound[$$self.$$.props['text']])) {
    			console.warn("<HoverText> was created without expected prop 'text'");
    		}
    	});

    	const writable_props = ['text', 'tooltip', 'color', 'align', 'link'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<HoverText> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('text' in $$props) $$invalidate(0, text = $$props.text);
    		if ('tooltip' in $$props) $$invalidate(1, tooltip = $$props.tooltip);
    		if ('color' in $$props) $$invalidate(2, color = $$props.color);
    		if ('align' in $$props) $$invalidate(3, align = $$props.align);
    		if ('link' in $$props) $$invalidate(5, link = $$props.link);
    	};

    	$$self.$capture_state = () => ({
    		text,
    		tooltip,
    		color,
    		align,
    		link,
    		tippy,
    		props
    	});

    	$$self.$inject_state = $$props => {
    		if ('text' in $$props) $$invalidate(0, text = $$props.text);
    		if ('tooltip' in $$props) $$invalidate(1, tooltip = $$props.tooltip);
    		if ('color' in $$props) $$invalidate(2, color = $$props.color);
    		if ('align' in $$props) $$invalidate(3, align = $$props.align);
    		if ('link' in $$props) $$invalidate(5, link = $$props.link);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [text, tooltip, color, align, props, link];
    }

    class HoverText extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$8, create_fragment$8, safe_not_equal, {
    			text: 0,
    			tooltip: 1,
    			color: 2,
    			align: 3,
    			link: 5
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "HoverText",
    			options,
    			id: create_fragment$8.name
    		});
    	}

    	get text() {
    		throw new Error("<HoverText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set text(value) {
    		throw new Error("<HoverText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get tooltip() {
    		throw new Error("<HoverText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tooltip(value) {
    		throw new Error("<HoverText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get color() {
    		throw new Error("<HoverText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set color(value) {
    		throw new Error("<HoverText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get align() {
    		throw new Error("<HoverText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set align(value) {
    		throw new Error("<HoverText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get link() {
    		throw new Error("<HoverText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set link(value) {
    		throw new Error("<HoverText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/lib/card/CardHeader.svelte generated by Svelte v3.53.1 */
    const file$7 = "src/lib/card/CardHeader.svelte";

    // (32:8) {#if modalStyle}
    function create_if_block$3(ctx) {
    	let button;
    	let venusicon;
    	let current;

    	venusicon = new VenusIcon({
    			props: {
    				themeFill: /*hovering*/ ctx[7] == false
    				? getThemeColor(/*type*/ ctx[4])
    				: getThemeColor(/*type*/ ctx[4], 100, true)
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			button = element("button");
    			create_component(venusicon.$$.fragment);
    			attr_dev(button, "class", "card-icon svelte-154iy8j");
    			attr_dev(button, "aria-expanded", "false");
    			attr_dev(button, "title", "Click to view more information");
    			add_location(button, file$7, 32, 12, 1026);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			mount_component(venusicon, button, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const venusicon_changes = {};

    			if (dirty & /*hovering, type*/ 144) venusicon_changes.themeFill = /*hovering*/ ctx[7] == false
    			? getThemeColor(/*type*/ ctx[4])
    			: getThemeColor(/*type*/ ctx[4], 100, true);

    			venusicon.$set(venusicon_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(venusicon.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(venusicon.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			destroy_component(venusicon);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$3.name,
    		type: "if",
    		source: "(32:8) {#if modalStyle}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$7(ctx) {
    	let div3;
    	let div0;
    	let t0;
    	let h3;
    	let t1;
    	let t2;
    	let div2;
    	let div1;
    	let hovertext0;
    	let t3;
    	let p0;
    	let hovertext1;
    	let t4;
    	let p1;
    	let hovertext2;
    	let current;
    	let if_block = /*modalStyle*/ ctx[6] && create_if_block$3(ctx);

    	hovertext0 = new HoverText({
    			props: {
    				text: /*feature*/ ctx[1],
    				tooltip: /*featDefinition*/ ctx[5],
    				color: getThemeColor(/*type*/ ctx[4]),
    				align: "left"
    			},
    			$$inline: true
    		});

    	hovertext1 = new HoverText({
    			props: {
    				text: /*year*/ ctx[3],
    				tooltip: "Year discovered",
    				color: getThemeColor(/*type*/ ctx[4]),
    				align: "center"
    			},
    			$$inline: true
    		});

    	hovertext2 = new HoverText({
    			props: {
    				text: /*origin*/ ctx[2],
    				tooltip: "Culture or country of origin",
    				color: getThemeColor(/*type*/ ctx[4]),
    				align: "right"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div3 = element("div");
    			div0 = element("div");
    			if (if_block) if_block.c();
    			t0 = space();
    			h3 = element("h3");
    			t1 = text(/*name*/ ctx[0]);
    			t2 = space();
    			div2 = element("div");
    			div1 = element("div");
    			create_component(hovertext0.$$.fragment);
    			t3 = space();
    			p0 = element("p");
    			create_component(hovertext1.$$.fragment);
    			t4 = space();
    			p1 = element("p");
    			create_component(hovertext2.$$.fragment);
    			attr_dev(h3, "class", "name svelte-154iy8j");
    			add_location(h3, file$7, 36, 8, 1275);
    			attr_dev(div0, "class", "name-header");
    			add_location(div0, file$7, 30, 4, 963);
    			attr_dev(div1, "class", "category feature svelte-154iy8j");
    			add_location(div1, file$7, 39, 8, 1355);
    			attr_dev(p0, "class", "category year svelte-154iy8j");
    			add_location(p0, file$7, 42, 8, 1516);
    			attr_dev(p1, "class", "category origin svelte-154iy8j");
    			add_location(p1, file$7, 45, 8, 1670);
    			attr_dev(div2, "class", "category-grid svelte-154iy8j");
    			add_location(div2, file$7, 38, 4, 1319);
    			attr_dev(div3, "class", "card-header svelte-154iy8j");
    			set_style(div3, "--theme-color", getThemeColor(/*type*/ ctx[4]));
    			set_style(div3, "--light-theme", getThemeColor(/*type*/ ctx[4], 100, true));
    			add_location(div3, file$7, 29, 0, 841);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div3, anchor);
    			append_dev(div3, div0);
    			if (if_block) if_block.m(div0, null);
    			append_dev(div0, t0);
    			append_dev(div0, h3);
    			append_dev(h3, t1);
    			append_dev(div3, t2);
    			append_dev(div3, div2);
    			append_dev(div2, div1);
    			mount_component(hovertext0, div1, null);
    			append_dev(div2, t3);
    			append_dev(div2, p0);
    			mount_component(hovertext1, p0, null);
    			append_dev(div2, t4);
    			append_dev(div2, p1);
    			mount_component(hovertext2, p1, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*modalStyle*/ ctx[6]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*modalStyle*/ 64) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$3(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(div0, t0);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}

    			if (!current || dirty & /*name*/ 1) set_data_dev(t1, /*name*/ ctx[0]);
    			const hovertext0_changes = {};
    			if (dirty & /*feature*/ 2) hovertext0_changes.text = /*feature*/ ctx[1];
    			if (dirty & /*featDefinition*/ 32) hovertext0_changes.tooltip = /*featDefinition*/ ctx[5];
    			if (dirty & /*type*/ 16) hovertext0_changes.color = getThemeColor(/*type*/ ctx[4]);
    			hovertext0.$set(hovertext0_changes);
    			const hovertext1_changes = {};
    			if (dirty & /*year*/ 8) hovertext1_changes.text = /*year*/ ctx[3];
    			if (dirty & /*type*/ 16) hovertext1_changes.color = getThemeColor(/*type*/ ctx[4]);
    			hovertext1.$set(hovertext1_changes);
    			const hovertext2_changes = {};
    			if (dirty & /*origin*/ 4) hovertext2_changes.text = /*origin*/ ctx[2];
    			if (dirty & /*type*/ 16) hovertext2_changes.color = getThemeColor(/*type*/ ctx[4]);
    			hovertext2.$set(hovertext2_changes);

    			if (!current || dirty & /*type*/ 16) {
    				set_style(div3, "--theme-color", getThemeColor(/*type*/ ctx[4]));
    			}

    			if (!current || dirty & /*type*/ 16) {
    				set_style(div3, "--light-theme", getThemeColor(/*type*/ ctx[4], 100, true));
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			transition_in(hovertext0.$$.fragment, local);
    			transition_in(hovertext1.$$.fragment, local);
    			transition_in(hovertext2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			transition_out(hovertext0.$$.fragment, local);
    			transition_out(hovertext1.$$.fragment, local);
    			transition_out(hovertext2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div3);
    			if (if_block) if_block.d();
    			destroy_component(hovertext0);
    			destroy_component(hovertext1);
    			destroy_component(hovertext2);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$7.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$7($$self, $$props, $$invalidate) {
    	let hovering;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('CardHeader', slots, []);
    	let { id } = $$props;
    	let { name } = $$props;
    	let { feature } = $$props;
    	let { origin } = $$props;
    	let { year } = $$props;
    	let { type } = $$props;
    	let { featDefinition = getDefinition(feature) } = $$props;
    	let { modalStyle } = $$props;

    	function getDefinition(feature) {
    		const found = featureData.find(element => element.feature == feature.toLowerCase());

    		if (feature == undefined || found == undefined) {
    			return null;
    		} else {
    			return found.definition;
    		}
    	}

    	$$self.$$.on_mount.push(function () {
    		if (id === undefined && !('id' in $$props || $$self.$$.bound[$$self.$$.props['id']])) {
    			console.warn("<CardHeader> was created without expected prop 'id'");
    		}

    		if (name === undefined && !('name' in $$props || $$self.$$.bound[$$self.$$.props['name']])) {
    			console.warn("<CardHeader> was created without expected prop 'name'");
    		}

    		if (feature === undefined && !('feature' in $$props || $$self.$$.bound[$$self.$$.props['feature']])) {
    			console.warn("<CardHeader> was created without expected prop 'feature'");
    		}

    		if (origin === undefined && !('origin' in $$props || $$self.$$.bound[$$self.$$.props['origin']])) {
    			console.warn("<CardHeader> was created without expected prop 'origin'");
    		}

    		if (year === undefined && !('year' in $$props || $$self.$$.bound[$$self.$$.props['year']])) {
    			console.warn("<CardHeader> was created without expected prop 'year'");
    		}

    		if (type === undefined && !('type' in $$props || $$self.$$.bound[$$self.$$.props['type']])) {
    			console.warn("<CardHeader> was created without expected prop 'type'");
    		}

    		if (modalStyle === undefined && !('modalStyle' in $$props || $$self.$$.bound[$$self.$$.props['modalStyle']])) {
    			console.warn("<CardHeader> was created without expected prop 'modalStyle'");
    		}
    	});

    	const writable_props = [
    		'id',
    		'name',
    		'feature',
    		'origin',
    		'year',
    		'type',
    		'featDefinition',
    		'modalStyle'
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<CardHeader> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('id' in $$props) $$invalidate(8, id = $$props.id);
    		if ('name' in $$props) $$invalidate(0, name = $$props.name);
    		if ('feature' in $$props) $$invalidate(1, feature = $$props.feature);
    		if ('origin' in $$props) $$invalidate(2, origin = $$props.origin);
    		if ('year' in $$props) $$invalidate(3, year = $$props.year);
    		if ('type' in $$props) $$invalidate(4, type = $$props.type);
    		if ('featDefinition' in $$props) $$invalidate(5, featDefinition = $$props.featDefinition);
    		if ('modalStyle' in $$props) $$invalidate(6, modalStyle = $$props.modalStyle);
    	};

    	$$self.$capture_state = () => ({
    		getThemeColor,
    		moveGlobeToPoint,
    		featureData,
    		HoverText,
    		VenusIcon,
    		data,
    		globe: globe$1,
    		id,
    		name,
    		feature,
    		origin,
    		year,
    		type,
    		featDefinition,
    		modalStyle,
    		getDefinition,
    		hovering
    	});

    	$$self.$inject_state = $$props => {
    		if ('id' in $$props) $$invalidate(8, id = $$props.id);
    		if ('name' in $$props) $$invalidate(0, name = $$props.name);
    		if ('feature' in $$props) $$invalidate(1, feature = $$props.feature);
    		if ('origin' in $$props) $$invalidate(2, origin = $$props.origin);
    		if ('year' in $$props) $$invalidate(3, year = $$props.year);
    		if ('type' in $$props) $$invalidate(4, type = $$props.type);
    		if ('featDefinition' in $$props) $$invalidate(5, featDefinition = $$props.featDefinition);
    		if ('modalStyle' in $$props) $$invalidate(6, modalStyle = $$props.modalStyle);
    		if ('hovering' in $$props) $$invalidate(7, hovering = $$props.hovering);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$invalidate(7, hovering = false);
    	return [name, feature, origin, year, type, featDefinition, modalStyle, hovering, id];
    }

    class CardHeader extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$7, create_fragment$7, safe_not_equal, {
    			id: 8,
    			name: 0,
    			feature: 1,
    			origin: 2,
    			year: 3,
    			type: 4,
    			featDefinition: 5,
    			modalStyle: 6
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "CardHeader",
    			options,
    			id: create_fragment$7.name
    		});
    	}

    	get id() {
    		throw new Error("<CardHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set id(value) {
    		throw new Error("<CardHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get name() {
    		throw new Error("<CardHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set name(value) {
    		throw new Error("<CardHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get feature() {
    		throw new Error("<CardHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set feature(value) {
    		throw new Error("<CardHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get origin() {
    		throw new Error("<CardHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set origin(value) {
    		throw new Error("<CardHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get year() {
    		throw new Error("<CardHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set year(value) {
    		throw new Error("<CardHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get type() {
    		throw new Error("<CardHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set type(value) {
    		throw new Error("<CardHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get featDefinition() {
    		throw new Error("<CardHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set featDefinition(value) {
    		throw new Error("<CardHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get modalStyle() {
    		throw new Error("<CardHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set modalStyle(value) {
    		throw new Error("<CardHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/lib/card/CardBody.svelte generated by Svelte v3.53.1 */
    const file$6 = "src/lib/card/CardBody.svelte";

    // (27:0) {:else}
    function create_else_block$1(ctx) {
    	let div1;
    	let div0;
    	let p;
    	let t;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			p = element("p");
    			t = text(/*description*/ ctx[2]);
    			attr_dev(p, "class", "svelte-pdgo34");
    			add_location(p, file$6, 29, 12, 1048);
    			attr_dev(div0, "class", "card-description svelte-pdgo34");
    			add_location(div0, file$6, 28, 8, 971);
    			attr_dev(div1, "class", "card-body svelte-pdgo34");
    			set_style(div1, "--theme-color", /*themeColor*/ ctx[1]);
    			set_style(div1, "--theme-opacity", /*themeColor*/ ctx[1] + "26");
    			add_location(div1, file$6, 27, 4, 871);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			append_dev(div0, p);
    			append_dev(p, t);

    			if (!mounted) {
    				dispose = action_destroyer(tippy.call(null, div0, /*descriptionTippyProps*/ ctx[5]));
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*description*/ 4) set_data_dev(t, /*description*/ ctx[2]);

    			if (dirty & /*themeColor*/ 2) {
    				set_style(div1, "--theme-color", /*themeColor*/ ctx[1]);
    			}

    			if (dirty & /*themeColor*/ 2) {
    				set_style(div1, "--theme-opacity", /*themeColor*/ ctx[1] + "26");
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$1.name,
    		type: "else",
    		source: "(27:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (12:0) {#if modalStyle}
    function create_if_block$2(ctx) {
    	let div2;
    	let div0;
    	let p0;
    	let t0;
    	let t1;
    	let div1;
    	let p1;
    	let t3;
    	let p2;
    	let t4;
    	let t5;
    	let mounted;
    	let dispose;
    	let if_block = /*searchTerm*/ ctx[4] != "" && create_if_block_1$1(ctx);

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div0 = element("div");
    			p0 = element("p");
    			t0 = text(/*description*/ ctx[2]);
    			t1 = space();
    			div1 = element("div");
    			p1 = element("p");
    			p1.textContent = "FROM WIKIPEDIA:";
    			t3 = space();
    			p2 = element("p");
    			t4 = text(/*bio*/ ctx[3]);
    			t5 = space();
    			if (if_block) if_block.c();
    			attr_dev(p0, "class", "svelte-pdgo34");
    			add_location(p0, file$6, 14, 8, 528);
    			attr_dev(div0, "class", "card-description svelte-pdgo34");
    			add_location(div0, file$6, 13, 4, 455);
    			attr_dev(p1, "class", "bio-subtitle svelte-pdgo34");
    			add_location(p1, file$6, 17, 8, 594);
    			attr_dev(p2, "class", "svelte-pdgo34");
    			add_location(p2, file$6, 18, 8, 646);
    			attr_dev(div1, "class", "card-bio svelte-pdgo34");
    			add_location(div1, file$6, 16, 3, 563);
    			attr_dev(div2, "class", "card-body svelte-pdgo34");
    			set_style(div2, "--theme-color", /*themeColor*/ ctx[1]);
    			set_style(div2, "--theme-opacity", /*themeColor*/ ctx[1] + "26");
    			add_location(div2, file$6, 12, 0, 359);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div0);
    			append_dev(div0, p0);
    			append_dev(p0, t0);
    			append_dev(div2, t1);
    			append_dev(div2, div1);
    			append_dev(div1, p1);
    			append_dev(div1, t3);
    			append_dev(div1, p2);
    			append_dev(p2, t4);
    			append_dev(div2, t5);
    			if (if_block) if_block.m(div2, null);

    			if (!mounted) {
    				dispose = action_destroyer(tippy.call(null, div0, /*descriptionTippyProps*/ ctx[5]));
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*description*/ 4) set_data_dev(t0, /*description*/ ctx[2]);
    			if (dirty & /*bio*/ 8) set_data_dev(t4, /*bio*/ ctx[3]);

    			if (/*searchTerm*/ ctx[4] != "") {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_1$1(ctx);
    					if_block.c();
    					if_block.m(div2, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if (dirty & /*themeColor*/ 2) {
    				set_style(div2, "--theme-color", /*themeColor*/ ctx[1]);
    			}

    			if (dirty & /*themeColor*/ 2) {
    				set_style(div2, "--theme-opacity", /*themeColor*/ ctx[1] + "26");
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			if (if_block) if_block.d();
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$2.name,
    		type: "if",
    		source: "(12:0) {#if modalStyle}",
    		ctx
    	});

    	return block;
    }

    // (21:3) {#if searchTerm != ""}
    function create_if_block_1$1(ctx) {
    	let div;
    	let a;
    	let t;
    	let a_href_value;

    	const block = {
    		c: function create() {
    			div = element("div");
    			a = element("a");
    			t = text("LEARN MORE");
    			attr_dev(a, "href", a_href_value = "https://en.wikipedia.org/wiki/" + /*searchTerm*/ ctx[4]);
    			attr_dev(a, "target", "_blank");
    			attr_dev(a, "class", "svelte-pdgo34");
    			add_location(a, file$6, 22, 16, 744);
    			attr_dev(div, "class", "learn-more svelte-pdgo34");
    			add_location(div, file$6, 21, 8, 703);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, a);
    			append_dev(a, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*searchTerm*/ 16 && a_href_value !== (a_href_value = "https://en.wikipedia.org/wiki/" + /*searchTerm*/ ctx[4])) {
    				attr_dev(a, "href", a_href_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$1.name,
    		type: "if",
    		source: "(21:3) {#if searchTerm != \\\"\\\"}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$6(ctx) {
    	let if_block_anchor;

    	function select_block_type(ctx, dirty) {
    		if (/*modalStyle*/ ctx[0]) return create_if_block$2;
    		return create_else_block$1;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty$1();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, [dirty]) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		i: noop$2,
    		o: noop$2,
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$6.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$6($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('CardBody', slots, []);
    	let { modalStyle, themeColor, name, description, bio, searchTerm } = $$props;

    	const descriptionTippyProps = {
    		content: "This is the official description from the International Astronomical Union. It may be out of date.",
    		allowHTML: true,
    		arrow: true
    	};

    	$$self.$$.on_mount.push(function () {
    		if (modalStyle === undefined && !('modalStyle' in $$props || $$self.$$.bound[$$self.$$.props['modalStyle']])) {
    			console.warn("<CardBody> was created without expected prop 'modalStyle'");
    		}

    		if (themeColor === undefined && !('themeColor' in $$props || $$self.$$.bound[$$self.$$.props['themeColor']])) {
    			console.warn("<CardBody> was created without expected prop 'themeColor'");
    		}

    		if (name === undefined && !('name' in $$props || $$self.$$.bound[$$self.$$.props['name']])) {
    			console.warn("<CardBody> was created without expected prop 'name'");
    		}

    		if (description === undefined && !('description' in $$props || $$self.$$.bound[$$self.$$.props['description']])) {
    			console.warn("<CardBody> was created without expected prop 'description'");
    		}

    		if (bio === undefined && !('bio' in $$props || $$self.$$.bound[$$self.$$.props['bio']])) {
    			console.warn("<CardBody> was created without expected prop 'bio'");
    		}

    		if (searchTerm === undefined && !('searchTerm' in $$props || $$self.$$.bound[$$self.$$.props['searchTerm']])) {
    			console.warn("<CardBody> was created without expected prop 'searchTerm'");
    		}
    	});

    	const writable_props = ['modalStyle', 'themeColor', 'name', 'description', 'bio', 'searchTerm'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<CardBody> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('modalStyle' in $$props) $$invalidate(0, modalStyle = $$props.modalStyle);
    		if ('themeColor' in $$props) $$invalidate(1, themeColor = $$props.themeColor);
    		if ('name' in $$props) $$invalidate(6, name = $$props.name);
    		if ('description' in $$props) $$invalidate(2, description = $$props.description);
    		if ('bio' in $$props) $$invalidate(3, bio = $$props.bio);
    		if ('searchTerm' in $$props) $$invalidate(4, searchTerm = $$props.searchTerm);
    	};

    	$$self.$capture_state = () => ({
    		modalStyle,
    		themeColor,
    		name,
    		description,
    		bio,
    		searchTerm,
    		tippy,
    		descriptionTippyProps
    	});

    	$$self.$inject_state = $$props => {
    		if ('modalStyle' in $$props) $$invalidate(0, modalStyle = $$props.modalStyle);
    		if ('themeColor' in $$props) $$invalidate(1, themeColor = $$props.themeColor);
    		if ('name' in $$props) $$invalidate(6, name = $$props.name);
    		if ('description' in $$props) $$invalidate(2, description = $$props.description);
    		if ('bio' in $$props) $$invalidate(3, bio = $$props.bio);
    		if ('searchTerm' in $$props) $$invalidate(4, searchTerm = $$props.searchTerm);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		modalStyle,
    		themeColor,
    		description,
    		bio,
    		searchTerm,
    		descriptionTippyProps,
    		name
    	];
    }

    class CardBody extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$6, create_fragment$6, safe_not_equal, {
    			modalStyle: 0,
    			themeColor: 1,
    			name: 6,
    			description: 2,
    			bio: 3,
    			searchTerm: 4
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "CardBody",
    			options,
    			id: create_fragment$6.name
    		});
    	}

    	get modalStyle() {
    		throw new Error("<CardBody>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set modalStyle(value) {
    		throw new Error("<CardBody>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get themeColor() {
    		throw new Error("<CardBody>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set themeColor(value) {
    		throw new Error("<CardBody>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get name() {
    		throw new Error("<CardBody>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set name(value) {
    		throw new Error("<CardBody>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get description() {
    		throw new Error("<CardBody>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set description(value) {
    		throw new Error("<CardBody>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get bio() {
    		throw new Error("<CardBody>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set bio(value) {
    		throw new Error("<CardBody>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get searchTerm() {
    		throw new Error("<CardBody>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set searchTerm(value) {
    		throw new Error("<CardBody>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/lib/svg/Star.svelte generated by Svelte v3.53.1 */

    const file$5 = "src/lib/svg/Star.svelte";

    function create_fragment$5(ctx) {
    	let svg;
    	let path0;
    	let path1;
    	let path2;
    	let path3;

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			path2 = svg_element("path");
    			path3 = svg_element("path");
    			attr_dev(path0, "d", "M250.969 62.0052L216.512 205.494L360.001 171.037L218.508 212.941L320.092 319.977L213.056 218.392L171.152 359.885L205.609 216.397L62.1205 250.854L203.614 208.95L102.029 101.914L209.065 203.498L250.969 62.0052Z");
    			attr_dev(path0, "fill", /*fill*/ ctx[0]);
    			add_location(path0, file$5, 7, 4, 212);
    			attr_dev(path1, "d", "M170.741 61.4203L212.645 202.913L319.681 101.329L218.096 208.365L359.589 250.269L216.101 215.812L250.557 359.3L208.654 217.807L101.617 319.392L203.202 212.356L61.7091 170.452L205.198 204.909L170.741 61.4203Z");
    			attr_dev(path1, "fill", /*fill*/ ctx[0]);
    			add_location(path1, file$5, 8, 4, 444);
    			attr_dev(path2, "d", "M133.536 77.097L210.633 187.504L287.73 77.097L230.663 199.068L364.827 210.633L230.663 222.198L287.73 344.169L210.633 233.762L133.536 344.169L190.603 222.198L56.439 210.633L190.603 199.068L133.536 77.097Z");
    			attr_dev(path2, "fill", /*fill*/ ctx[0]);
    			add_location(path2, file$5, 9, 4, 675);
    			attr_dev(path3, "d", "M210.194 56.1941L221.759 190.358L343.73 133.291L233.323 210.388L343.73 287.485L221.759 230.419L210.194 364.582L198.63 230.419L76.6581 287.485L187.065 210.388L76.6581 133.291L198.63 190.358L210.194 56.1941Z");
    			attr_dev(path3, "fill", /*fill*/ ctx[0]);
    			add_location(path3, file$5, 10, 4, 902);
    			attr_dev(svg, "class", "star-svg svelte-vhyy91");
    			attr_dev(svg, "width", /*width*/ ctx[1]);
    			attr_dev(svg, "height", /*height*/ ctx[2]);
    			attr_dev(svg, "viewBox", "0 0 422 422");
    			attr_dev(svg, "fill", /*fill*/ ctx[0]);
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			add_location(svg, file$5, 6, 0, 104);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path0);
    			append_dev(svg, path1);
    			append_dev(svg, path2);
    			append_dev(svg, path3);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*fill*/ 1) {
    				attr_dev(path0, "fill", /*fill*/ ctx[0]);
    			}

    			if (dirty & /*fill*/ 1) {
    				attr_dev(path1, "fill", /*fill*/ ctx[0]);
    			}

    			if (dirty & /*fill*/ 1) {
    				attr_dev(path2, "fill", /*fill*/ ctx[0]);
    			}

    			if (dirty & /*fill*/ 1) {
    				attr_dev(path3, "fill", /*fill*/ ctx[0]);
    			}

    			if (dirty & /*width*/ 2) {
    				attr_dev(svg, "width", /*width*/ ctx[1]);
    			}

    			if (dirty & /*height*/ 4) {
    				attr_dev(svg, "height", /*height*/ ctx[2]);
    			}

    			if (dirty & /*fill*/ 1) {
    				attr_dev(svg, "fill", /*fill*/ ctx[0]);
    			}
    		},
    		i: noop$2,
    		o: noop$2,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$5.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$5($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Star', slots, []);
    	let { fill } = $$props;
    	let { width = "25px" } = $$props;
    	let { height = "25px" } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (fill === undefined && !('fill' in $$props || $$self.$$.bound[$$self.$$.props['fill']])) {
    			console.warn("<Star> was created without expected prop 'fill'");
    		}
    	});

    	const writable_props = ['fill', 'width', 'height'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Star> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('fill' in $$props) $$invalidate(0, fill = $$props.fill);
    		if ('width' in $$props) $$invalidate(1, width = $$props.width);
    		if ('height' in $$props) $$invalidate(2, height = $$props.height);
    	};

    	$$self.$capture_state = () => ({ fill, width, height });

    	$$self.$inject_state = $$props => {
    		if ('fill' in $$props) $$invalidate(0, fill = $$props.fill);
    		if ('width' in $$props) $$invalidate(1, width = $$props.width);
    		if ('height' in $$props) $$invalidate(2, height = $$props.height);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [fill, width, height];
    }

    class Star extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$5, create_fragment$5, safe_not_equal, { fill: 0, width: 1, height: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Star",
    			options,
    			id: create_fragment$5.name
    		});
    	}

    	get fill() {
    		throw new Error("<Star>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set fill(value) {
    		throw new Error("<Star>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get width() {
    		throw new Error("<Star>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set width(value) {
    		throw new Error("<Star>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get height() {
    		throw new Error("<Star>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set height(value) {
    		throw new Error("<Star>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/lib/card/CardFooter.svelte generated by Svelte v3.53.1 */
    const file$4 = "src/lib/card/CardFooter.svelte";

    function create_fragment$4(ctx) {
    	let div2;
    	let div1;
    	let div0;
    	let star;
    	let current;

    	star = new Star({
    			props: { fill: /*themeColor*/ ctx[0] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div1 = element("div");
    			div0 = element("div");
    			create_component(star.$$.fragment);
    			attr_dev(div0, "class", "star");
    			add_location(div0, file$4, 7, 8, 179);
    			attr_dev(div1, "class", "circle svelte-d4vab7");
    			add_location(div1, file$4, 6, 4, 150);
    			attr_dev(div2, "class", "footer svelte-d4vab7");
    			set_style(div2, "--theme-color", /*themeColor*/ ctx[0]);
    			add_location(div2, file$4, 5, 0, 90);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div1);
    			append_dev(div1, div0);
    			mount_component(star, div0, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const star_changes = {};
    			if (dirty & /*themeColor*/ 1) star_changes.fill = /*themeColor*/ ctx[0];
    			star.$set(star_changes);

    			if (!current || dirty & /*themeColor*/ 1) {
    				set_style(div2, "--theme-color", /*themeColor*/ ctx[0]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(star.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(star.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			destroy_component(star);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$4.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$4($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('CardFooter', slots, []);
    	let { themeColor } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (themeColor === undefined && !('themeColor' in $$props || $$self.$$.bound[$$self.$$.props['themeColor']])) {
    			console.warn("<CardFooter> was created without expected prop 'themeColor'");
    		}
    	});

    	const writable_props = ['themeColor'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<CardFooter> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('themeColor' in $$props) $$invalidate(0, themeColor = $$props.themeColor);
    	};

    	$$self.$capture_state = () => ({ Star, themeColor });

    	$$self.$inject_state = $$props => {
    		if ('themeColor' in $$props) $$invalidate(0, themeColor = $$props.themeColor);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [themeColor];
    }

    class CardFooter extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$4, create_fragment$4, safe_not_equal, { themeColor: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "CardFooter",
    			options,
    			id: create_fragment$4.name
    		});
    	}

    	get themeColor() {
    		throw new Error("<CardFooter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set themeColor(value) {
    		throw new Error("<CardFooter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/lib/card/CardModal.svelte generated by Svelte v3.53.1 */
    const file$3 = "src/lib/card/CardModal.svelte";
    const get_card_slot_changes = dirty => ({});
    const get_card_slot_context = ctx => ({ class: "card-slot" });

    function create_fragment$3(ctx) {
    	let div0;
    	let t0;
    	let div2;
    	let div1;
    	let button;
    	let t2;
    	let current;
    	let mounted;
    	let dispose;
    	const card_slot_template = /*#slots*/ ctx[7].card;
    	const card_slot = create_slot(card_slot_template, ctx, /*$$scope*/ ctx[6], get_card_slot_context);

    	const block = {
    		c: function create() {
    			div0 = element("div");
    			t0 = space();
    			div2 = element("div");
    			div1 = element("div");
    			button = element("button");
    			button.textContent = "close";
    			t2 = space();
    			if (card_slot) card_slot.c();
    			attr_dev(div0, "class", "modal-background svelte-1szwvb1");
    			add_location(div0, file$3, 50, 0, 1199);
    			attr_dev(button, "class", "modal-close-button svelte-1szwvb1");
    			button.autofocus = true;
    			add_location(button, file$3, 55, 8, 1437);
    			attr_dev(div1, "class", "modal-button-wrapper svelte-1szwvb1");
    			add_location(div1, file$3, 54, 4, 1394);
    			attr_dev(div2, "class", "modal svelte-1szwvb1");
    			attr_dev(div2, "role", "dialog");
    			attr_dev(div2, "aria-modal", "true");
    			set_style(div2, "top", /*topValue*/ ctx[1]);
    			add_location(div2, file$3, 52, 0, 1254);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div0, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div1);
    			append_dev(div1, button);
    			append_dev(div2, t2);

    			if (card_slot) {
    				card_slot.m(div2, null);
    			}

    			/*div2_binding*/ ctx[8](div2);
    			current = true;
    			button.focus();

    			if (!mounted) {
    				dispose = [
    					listen_dev(window, "keydown", /*handle_keydown*/ ctx[3], false, false, false),
    					listen_dev(div0, "click", /*close*/ ctx[2], false, false, false),
    					listen_dev(button, "click", /*close*/ ctx[2], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (card_slot) {
    				if (card_slot.p && (!current || dirty & /*$$scope*/ 64)) {
    					update_slot_base(
    						card_slot,
    						card_slot_template,
    						ctx,
    						/*$$scope*/ ctx[6],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[6])
    						: get_slot_changes(card_slot_template, /*$$scope*/ ctx[6], dirty, get_card_slot_changes),
    						get_card_slot_context
    					);
    				}
    			}

    			if (!current || dirty & /*topValue*/ 2) {
    				set_style(div2, "top", /*topValue*/ ctx[1]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(card_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(card_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div0);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(div2);
    			if (card_slot) card_slot.d(detaching);
    			/*div2_binding*/ ctx[8](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$3.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$3($$self, $$props, $$invalidate) {
    	let topValue;
    	let $modalLocation;
    	let $isMobile;
    	validate_store(modalLocation, 'modalLocation');
    	component_subscribe($$self, modalLocation, $$value => $$invalidate(4, $modalLocation = $$value));
    	validate_store(isMobile, 'isMobile');
    	component_subscribe($$self, isMobile, $$value => $$invalidate(5, $isMobile = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('CardModal', slots, ['card']);
    	const dispatch = createEventDispatcher();
    	const close = () => dispatch('close');
    	let modal;

    	const handle_keydown = e => {
    		if (e.key === 'Escape') {
    			close();
    			return;
    		}

    		if (e.key === 'Tab') {
    			// trap focus
    			const nodes = modal.querySelectorAll('*');

    			const tabbable = Array.from(nodes).filter(n => n.tabIndex >= 0);
    			let index = tabbable.indexOf(document.activeElement);
    			if (index === -1 && e.shiftKey) index = 0;
    			index += tabbable.length + (e.shiftKey ? -1 : 1);
    			index %= tabbable.length;
    			tabbable[index].focus();
    			e.preventDefault();
    		}
    	};

    	const previously_focused = typeof document !== 'undefined' && document.activeElement;

    	if (previously_focused) {
    		onDestroy(() => {
    			previously_focused.focus();
    		});
    	}

    	onDestroy(() => {
    		const allModals = document.querySelectorAll('.modal');
    		allModals.innerHTML = "";
    		close();
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<CardModal> was created with unknown prop '${key}'`);
    	});

    	function div2_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			modal = $$value;
    			$$invalidate(0, modal);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ('$$scope' in $$props) $$invalidate(6, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		onDestroy,
    		isMobile,
    		modalLocation,
    		dispatch,
    		close,
    		modal,
    		handle_keydown,
    		previously_focused,
    		topValue,
    		$modalLocation,
    		$isMobile
    	});

    	$$self.$inject_state = $$props => {
    		if ('modal' in $$props) $$invalidate(0, modal = $$props.modal);
    		if ('topValue' in $$props) $$invalidate(1, topValue = $$props.topValue);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$isMobile, $modalLocation*/ 48) {
    			$$invalidate(1, topValue = $isMobile == true ? `${$modalLocation}` : "50%");
    		}
    	};

    	return [
    		modal,
    		topValue,
    		close,
    		handle_keydown,
    		$modalLocation,
    		$isMobile,
    		$$scope,
    		slots,
    		div2_binding
    	];
    }

    class CardModal extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$3, create_fragment$3, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "CardModal",
    			options,
    			id: create_fragment$3.name
    		});
    	}
    }

    /* src/lib/card/Card.svelte generated by Svelte v3.53.1 */
    const file$2 = "src/lib/card/Card.svelte";

    // (77:0) {#if openModal==true && showModal==true}
    function create_if_block$1(ctx) {
    	let cardmodal;
    	let current;

    	cardmodal = new CardModal({
    			props: {
    				$$slots: { card: [create_card_slot] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	cardmodal.$on("close", /*close_handler*/ ctx[19]);

    	const block = {
    		c: function create() {
    			create_component(cardmodal.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(cardmodal, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const cardmodal_changes = {};

    			if (dirty & /*$$scope*/ 16777216) {
    				cardmodal_changes.$$scope = { dirty, ctx };
    			}

    			cardmodal.$set(cardmodal_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(cardmodal.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(cardmodal.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(cardmodal, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$1.name,
    		type: "if",
    		source: "(77:0) {#if openModal==true && showModal==true}",
    		ctx
    	});

    	return block;
    }

    // (80:8) 
    function create_card_slot(ctx) {
    	let div3;
    	let div2;
    	let div1;
    	let div0;
    	let cardheader;
    	let t0;
    	let cardbody;
    	let t1;
    	let cardfooter;
    	let current;

    	cardheader = new CardHeader({
    			props: {
    				modalStyle: false,
    				id: /*id*/ ctx[3],
    				type: /*type*/ ctx[6],
    				name: /*name*/ ctx[7],
    				feature: /*feature*/ ctx[10],
    				origin: /*origin*/ ctx[9],
    				year: /*year*/ ctx[8]
    			},
    			$$inline: true
    		});

    	cardbody = new CardBody({
    			props: {
    				modalStyle: true,
    				themeColor: /*themeColor*/ ctx[4],
    				name: /*name*/ ctx[7],
    				description: /*description*/ ctx[11],
    				bio: /*bio*/ ctx[12],
    				searchTerm: /*searchTerm*/ ctx[13]
    			},
    			$$inline: true
    		});

    	cardfooter = new CardFooter({
    			props: { themeColor: /*themeColor*/ ctx[4] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div3 = element("div");
    			div2 = element("div");
    			div1 = element("div");
    			div0 = element("div");
    			create_component(cardheader.$$.fragment);
    			t0 = space();
    			create_component(cardbody.$$.fragment);
    			t1 = space();
    			create_component(cardfooter.$$.fragment);
    			attr_dev(div0, "class", "content svelte-1f92r4a");
    			add_location(div0, file$2, 82, 20, 3366);
    			attr_dev(div1, "class", "inner-border svelte-1f92r4a");
    			add_location(div1, file$2, 81, 16, 3319);
    			attr_dev(div2, "class", "outer-border svelte-1f92r4a");
    			add_location(div2, file$2, 80, 12, 3276);
    			attr_dev(div3, "slot", "card");
    			attr_dev(div3, "class", "modal-card svelte-1f92r4a");
    			set_style(div3, "--theme-color", /*themeColor*/ ctx[4]);
    			set_style(div3, "--theme-light", /*themeColorLight*/ ctx[5]);
    			add_location(div3, file$2, 79, 8, 3159);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div3, anchor);
    			append_dev(div3, div2);
    			append_dev(div2, div1);
    			append_dev(div1, div0);
    			mount_component(cardheader, div0, null);
    			append_dev(div0, t0);
    			mount_component(cardbody, div0, null);
    			append_dev(div0, t1);
    			mount_component(cardfooter, div0, null);
    			current = true;
    		},
    		p: noop$2,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(cardheader.$$.fragment, local);
    			transition_in(cardbody.$$.fragment, local);
    			transition_in(cardfooter.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(cardheader.$$.fragment, local);
    			transition_out(cardbody.$$.fragment, local);
    			transition_out(cardfooter.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div3);
    			destroy_component(cardheader);
    			destroy_component(cardbody);
    			destroy_component(cardfooter);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_card_slot.name,
    		type: "slot",
    		source: "(80:8) ",
    		ctx
    	});

    	return block;
    }

    function create_fragment$2(ctx) {
    	let div3;
    	let div2;
    	let div1;
    	let div0;
    	let cardheader;
    	let t0;
    	let cardbody;
    	let t1;
    	let cardfooter;
    	let t2;
    	let if_block_anchor;
    	let current;
    	let mounted;
    	let dispose;

    	cardheader = new CardHeader({
    			props: {
    				modalStyle: /*showModal*/ ctx[14],
    				id: /*id*/ ctx[3],
    				type: /*type*/ ctx[6],
    				name: /*name*/ ctx[7],
    				feature: /*feature*/ ctx[10],
    				origin: /*origin*/ ctx[9],
    				year: /*year*/ ctx[8]
    			},
    			$$inline: true
    		});

    	cardbody = new CardBody({
    			props: {
    				modalStyle: false,
    				themeColor: /*themeColor*/ ctx[4],
    				name: /*name*/ ctx[7],
    				description: /*description*/ ctx[11],
    				bio: /*bio*/ ctx[12],
    				searchTerm: /*searchTerm*/ ctx[13]
    			},
    			$$inline: true
    		});

    	cardfooter = new CardFooter({
    			props: { themeColor: /*themeColor*/ ctx[4] },
    			$$inline: true
    		});

    	let if_block = /*openModal*/ ctx[2] == true && /*showModal*/ ctx[14] == true && create_if_block$1(ctx);

    	const block = {
    		c: function create() {
    			div3 = element("div");
    			div2 = element("div");
    			div1 = element("div");
    			div0 = element("div");
    			create_component(cardheader.$$.fragment);
    			t0 = space();
    			create_component(cardbody.$$.fragment);
    			t1 = space();
    			create_component(cardfooter.$$.fragment);
    			t2 = space();
    			if (if_block) if_block.c();
    			if_block_anchor = empty$1();
    			attr_dev(div0, "class", "content svelte-1f92r4a");
    			add_location(div0, file$2, 67, 12, 2692);
    			attr_dev(div1, "class", "inner-border svelte-1f92r4a");
    			add_location(div1, file$2, 66, 8, 2653);
    			attr_dev(div2, "class", "outer-border svelte-1f92r4a");
    			add_location(div2, file$2, 65, 4, 2618);
    			attr_dev(div3, "class", "card svelte-1f92r4a");
    			attr_dev(div3, "id", "card-" + /*id*/ ctx[3]);
    			set_style(div3, "--theme-color", /*themeColor*/ ctx[4]);
    			set_style(div3, "--theme-light", /*themeColorLight*/ ctx[5]);
    			attr_dev(div3, "tabindex", /*cardIndex*/ ctx[0]);
    			add_location(div3, file$2, 64, 0, 2381);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div3, anchor);
    			append_dev(div3, div2);
    			append_dev(div2, div1);
    			append_dev(div1, div0);
    			mount_component(cardheader, div0, null);
    			append_dev(div0, t0);
    			mount_component(cardbody, div0, null);
    			append_dev(div0, t1);
    			mount_component(cardfooter, div0, null);
    			/*div3_binding*/ ctx[18](div3);
    			insert_dev(target, t2, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(div3, "mouseover", /*handleCardHover*/ ctx[15], false, false, false),
    					listen_dev(div3, "focus", /*handleCardHover*/ ctx[15], false, false, false),
    					listen_dev(div3, "click", /*handleCardClick*/ ctx[16], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (!current || dirty & /*cardIndex*/ 1) {
    				attr_dev(div3, "tabindex", /*cardIndex*/ ctx[0]);
    			}

    			if (/*openModal*/ ctx[2] == true && /*showModal*/ ctx[14] == true) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*openModal*/ 4) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$1(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(cardheader.$$.fragment, local);
    			transition_in(cardbody.$$.fragment, local);
    			transition_in(cardfooter.$$.fragment, local);
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(cardheader.$$.fragment, local);
    			transition_out(cardbody.$$.fragment, local);
    			transition_out(cardfooter.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div3);
    			destroy_component(cardheader);
    			destroy_component(cardbody);
    			destroy_component(cardfooter);
    			/*div3_binding*/ ctx[18](null);
    			if (detaching) detach_dev(t2);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$2($$self, $$props, $$invalidate) {
    	let $globe;
    	let $data;
    	let $isMobile;
    	validate_store(globe$1, 'globe');
    	component_subscribe($$self, globe$1, $$value => $$invalidate(21, $globe = $$value));
    	validate_store(data, 'data');
    	component_subscribe($$self, data, $$value => $$invalidate(22, $data = $$value));
    	validate_store(isMobile, 'isMobile');
    	component_subscribe($$self, isMobile, $$value => $$invalidate(23, $isMobile = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Card', slots, []);
    	let loaded = false;
    	let thisCard;
    	let { cardData } = $$props;
    	let { cardIndex } = $$props;

    	// data
    	const id = cardData.feature_id;

    	const themeColor = cardData.type == undefined
    	? getThemeColor("default")
    	: getThemeColor(cardData.type);

    	const themeColorLight = cardData.type == undefined
    	? getThemeColor("default", 15)
    	: getThemeColor(cardData.type, 15);

    	const type = cardData.type == undefined ? "Other" : cardData.type;
    	const name = cardData.name == undefined ? "N/A" : cardData.name;
    	const year = cardData.year == undefined ? 2022 : cardData.year;
    	const origin = cardData.origin == undefined ? "N/A" : cardData.origin;
    	const feature = cardData.feature == undefined ? "N/A" : cardData.feature;

    	const description = cardData.description == ""
    	? "N/A"
    	: cardData.description;

    	const bio = cardData.bio == "" ? "" : cardData.bio;
    	const searchTerm = cardData.search_term;

    	// state
    	/* If the card has image data, then show the modal */
    	const showModal = cardData.bio == "" ? false : true;

    	let openModal = false;

    	// card hover
    	function handleCardHover(e) {
    		pageTheme.set(type);

    		if ($isMobile == false) {
    			moveGlobeToPoint(id, $data, $globe);
    		}
    	} //showGlobePoints([id], $globe);

    	function handleCardClick(e) {
    		const allModals = document.querySelectorAll('.modal');
    		allModals.innerHTML = "";
    		$$invalidate(2, openModal = true);
    		const bodyRect = document.body.getBoundingClientRect();
    		const currentCard = document.querySelector(`#card-${id}`);
    		const cardRect = currentCard.getBoundingClientRect();
    		const offset = cardRect.top - bodyRect.top;
    		setModalLocation(offset);
    	}

    	onMount(() => {
    		$$invalidate(
    			1,
    			thisCard.onload = () => {
    				loaded = true;
    			},
    			thisCard
    		);
    	});

    	$$self.$$.on_mount.push(function () {
    		if (cardData === undefined && !('cardData' in $$props || $$self.$$.bound[$$self.$$.props['cardData']])) {
    			console.warn("<Card> was created without expected prop 'cardData'");
    		}

    		if (cardIndex === undefined && !('cardIndex' in $$props || $$self.$$.bound[$$self.$$.props['cardIndex']])) {
    			console.warn("<Card> was created without expected prop 'cardIndex'");
    		}
    	});

    	const writable_props = ['cardData', 'cardIndex'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Card> was created with unknown prop '${key}'`);
    	});

    	function div3_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			thisCard = $$value;
    			$$invalidate(1, thisCard);
    		});
    	}

    	const close_handler = () => $$invalidate(2, openModal = false);

    	$$self.$$set = $$props => {
    		if ('cardData' in $$props) $$invalidate(17, cardData = $$props.cardData);
    		if ('cardIndex' in $$props) $$invalidate(0, cardIndex = $$props.cardIndex);
    	};

    	$$self.$capture_state = () => ({
    		getThemeColor,
    		moveGlobeToPoint,
    		pageTheme,
    		data,
    		globe: globe$1,
    		isMobile,
    		setModalLocation,
    		onMount,
    		loaded,
    		thisCard,
    		cardData,
    		cardIndex,
    		CardHeader,
    		CardBody,
    		CardFooter,
    		CardModal,
    		id,
    		themeColor,
    		themeColorLight,
    		type,
    		name,
    		year,
    		origin,
    		feature,
    		description,
    		bio,
    		searchTerm,
    		showModal,
    		openModal,
    		handleCardHover,
    		handleCardClick,
    		$globe,
    		$data,
    		$isMobile
    	});

    	$$self.$inject_state = $$props => {
    		if ('loaded' in $$props) loaded = $$props.loaded;
    		if ('thisCard' in $$props) $$invalidate(1, thisCard = $$props.thisCard);
    		if ('cardData' in $$props) $$invalidate(17, cardData = $$props.cardData);
    		if ('cardIndex' in $$props) $$invalidate(0, cardIndex = $$props.cardIndex);
    		if ('openModal' in $$props) $$invalidate(2, openModal = $$props.openModal);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		cardIndex,
    		thisCard,
    		openModal,
    		id,
    		themeColor,
    		themeColorLight,
    		type,
    		name,
    		year,
    		origin,
    		feature,
    		description,
    		bio,
    		searchTerm,
    		showModal,
    		handleCardHover,
    		handleCardClick,
    		cardData,
    		div3_binding,
    		close_handler
    	];
    }

    class Card extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2, create_fragment$2, safe_not_equal, { cardData: 17, cardIndex: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Card",
    			options,
    			id: create_fragment$2.name
    		});
    	}

    	get cardData() {
    		throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set cardData(value) {
    		throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get cardIndex() {
    		throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set cardIndex(value) {
    		throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/lib/elements/SectionCards.svelte generated by Svelte v3.53.1 */
    const file$1 = "src/lib/elements/SectionCards.svelte";

    function get_each_context$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[7] = list[i];
    	child_ctx[9] = i;
    	return child_ctx;
    }

    // (31:12) {#each $visibleData as feature, index}
    function create_each_block$1(ctx) {
    	let div;
    	let card;
    	let t;
    	let div_intro;
    	let current;

    	card = new Card({
    			props: {
    				cardData: /*feature*/ ctx[7],
    				cardIndex: /*index*/ ctx[9]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(card.$$.fragment);
    			t = space();
    			add_location(div, file$1, 31, 16, 1056);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(card, div, null);
    			append_dev(div, t);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const card_changes = {};
    			if (dirty & /*$visibleData*/ 4) card_changes.cardData = /*feature*/ ctx[7];
    			card.$set(card_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(card.$$.fragment, local);

    			if (!div_intro) {
    				add_render_callback(() => {
    					div_intro = create_in_transition(div, fade, { delay: 50 });
    					div_intro.start();
    				});
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(card.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(card);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$1.name,
    		type: "each",
    		source: "(31:12) {#each $visibleData as feature, index}",
    		ctx
    	});

    	return block;
    }

    // (30:8) {#key $page}
    function create_key_block_1(ctx) {
    	let each_1_anchor;
    	let current;
    	let each_value = /*$visibleData*/ ctx[2];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty$1();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$visibleData*/ 4) {
    				each_value = /*$visibleData*/ ctx[2];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$1(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$1(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_key_block_1.name,
    		type: "key",
    		source: "(30:8) {#key $page}",
    		ctx
    	});

    	return block;
    }

    // (29:4) {#key $data}
    function create_key_block(ctx) {
    	let previous_key = /*$page*/ ctx[1];
    	let key_block_anchor;
    	let current;
    	let key_block = create_key_block_1(ctx);

    	const block = {
    		c: function create() {
    			key_block.c();
    			key_block_anchor = empty$1();
    		},
    		m: function mount(target, anchor) {
    			key_block.m(target, anchor);
    			insert_dev(target, key_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$page*/ 2 && safe_not_equal(previous_key, previous_key = /*$page*/ ctx[1])) {
    				group_outros();
    				transition_out(key_block, 1, 1, noop$2);
    				check_outros();
    				key_block = create_key_block_1(ctx);
    				key_block.c();
    				transition_in(key_block, 1);
    				key_block.m(key_block_anchor.parentNode, key_block_anchor);
    			} else {
    				key_block.p(ctx, dirty);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(key_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(key_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(key_block_anchor);
    			key_block.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_key_block.name,
    		type: "key",
    		source: "(29:4) {#key $data}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1(ctx) {
    	let div;
    	let previous_key = /*$data*/ ctx[0];
    	let current;
    	let key_block = create_key_block(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			key_block.c();
    			attr_dev(div, "class", "cards svelte-1ft0do7");
    			add_location(div, file$1, 27, 0, 931);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			key_block.m(div, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*$data*/ 1 && safe_not_equal(previous_key, previous_key = /*$data*/ ctx[0])) {
    				group_outros();
    				transition_out(key_block, 1, 1, noop$2);
    				check_outros();
    				key_block = create_key_block(ctx);
    				key_block.c();
    				transition_in(key_block, 1);
    				key_block.m(div, null);
    			} else {
    				key_block.p(ctx, dirty);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(key_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(key_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			key_block.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1($$self, $$props, $$invalidate) {
    	let $visibleData;
    	let $globe;
    	let $activePage;
    	let $data;
    	let $cardsPerPage;
    	let $page;
    	validate_store(visibleData, 'visibleData');
    	component_subscribe($$self, visibleData, $$value => $$invalidate(2, $visibleData = $$value));
    	validate_store(globe$1, 'globe');
    	component_subscribe($$self, globe$1, $$value => $$invalidate(4, $globe = $$value));
    	validate_store(activePage, 'activePage');
    	component_subscribe($$self, activePage, $$value => $$invalidate(5, $activePage = $$value));
    	validate_store(data, 'data');
    	component_subscribe($$self, data, $$value => $$invalidate(0, $data = $$value));
    	validate_store(cardsPerPage, 'cardsPerPage');
    	component_subscribe($$self, cardsPerPage, $$value => $$invalidate(6, $cardsPerPage = $$value));
    	validate_store(page, 'page');
    	component_subscribe($$self, page, $$value => $$invalidate(1, $page = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('SectionCards', slots, []);
    	let idArray;
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<SectionCards> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		activePage,
    		data,
    		page,
    		globe: globe$1,
    		cardsPerPage,
    		visibleData,
    		showGlobePoints,
    		fade,
    		Card,
    		idArray,
    		$visibleData,
    		$globe,
    		$activePage,
    		$data,
    		$cardsPerPage,
    		$page
    	});

    	$$self.$inject_state = $$props => {
    		if ('idArray' in $$props) $$invalidate(3, idArray = $$props.idArray);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$page, $cardsPerPage, $data, $activePage, $globe, idArray*/ 123) {
    			// Only show active cards
    			{
    				// Get the indices of the first and last cards to show
    				const minIndex = $page * $cardsPerPage + 0;

    				const maxIndex = $page * $cardsPerPage + ($cardsPerPage - 1);

    				const filtered = $data.filter((value, index) => {
    					if (index >= minIndex && index <= maxIndex) {
    						return value;
    					}
    				});

    				// Get IDs of visible cards, to show them on the globe too
    				$$invalidate(3, idArray = $activePage == "intro"
    				? null
    				: filtered.map(v => v.feature_id));

    				$globe == undefined
    				? null
    				: showGlobePoints(idArray, $globe);

    				// Update the cards visible on the page
    				set_store_value(visibleData, $visibleData = filtered, $visibleData);
    			}
    		}
    	};

    	return [$data, $page, $visibleData, idArray, $globe, $activePage, $cardsPerPage];
    }

    class SectionCards extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1, create_fragment$1, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "SectionCards",
    			options,
    			id: create_fragment$1.name
    		});
    	}
    }

    /* src/App.svelte generated by Svelte v3.53.1 */

    const { Object: Object_1 } = globals;
    const file = "src/App.svelte";

    function get_each_context(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[16] = list[i];
    	return child_ctx;
    }

    // (38:0) {#if ready == true}
    function create_if_block(ctx) {
    	let div0;
    	let sectionintro;
    	let div0_class_value;
    	let t0;
    	let div9;
    	let div1;
    	let header;
    	let t1;
    	let pagenavigation;
    	let div1_class_value;
    	let t2;
    	let div8;
    	let div6;
    	let t3;
    	let div5;
    	let t4;
    	let div3;
    	let div2;
    	let p0;
    	let t5_value = /*formatValue*/ ctx[9](/*$data*/ ctx[6].length) + "";
    	let t5;
    	let t6;
    	let t7_value = (/*$data*/ ctx[6].length == 1 ? "feature" : "features") + "";
    	let t7;
    	let t8;
    	let p1;
    	let t9_value = /*$visibleData*/ ctx[7].length + "";
    	let t9;
    	let t10;
    	let t11;
    	let t12;
    	let div4;
    	let t13;
    	let div7;
    	let sectioncards;
    	let div7_class_value;
    	let div9_class_value;
    	let current;
    	sectionintro = new SectionIntro({ $$inline: true });
    	header = new Header({ $$inline: true });
    	pagenavigation = new PageNavigation({ $$inline: true });
    	let if_block0 = /*$isMobile*/ ctx[4] == false && create_if_block_3(ctx);
    	let if_block1 = /*$isMobile*/ ctx[4] == false && create_if_block_2(ctx);

    	function select_block_type(ctx, dirty) {
    		if (/*$data*/ ctx[6].length == dataSource.length) return create_if_block_1;
    		return create_else_block;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block2 = current_block_type(ctx);
    	let each_value = Object.keys(/*$filterObj*/ ctx[8]);
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	sectioncards = new SectionCards({ $$inline: true });

    	const block = {
    		c: function create() {
    			div0 = element("div");
    			create_component(sectionintro.$$.fragment);
    			t0 = space();
    			div9 = element("div");
    			div1 = element("div");
    			create_component(header.$$.fragment);
    			t1 = space();
    			create_component(pagenavigation.$$.fragment);
    			t2 = space();
    			div8 = element("div");
    			div6 = element("div");
    			if (if_block0) if_block0.c();
    			t3 = space();
    			div5 = element("div");
    			if (if_block1) if_block1.c();
    			t4 = space();
    			div3 = element("div");
    			div2 = element("div");
    			p0 = element("p");
    			t5 = text(t5_value);
    			t6 = space();
    			t7 = text(t7_value);
    			t8 = space();
    			p1 = element("p");
    			t9 = text(t9_value);
    			t10 = text(" visible on globe");
    			t11 = space();
    			if_block2.c();
    			t12 = space();
    			div4 = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t13 = space();
    			div7 = element("div");
    			create_component(sectioncards.$$.fragment);
    			attr_dev(div0, "class", div0_class_value = "intro-mode " + /*showIntroPage*/ ctx[3] + " svelte-1sffoyp");
    			add_location(div0, file, 39, 1, 1223);
    			attr_dev(div1, "class", div1_class_value = "header-wrapper " + /*showMainPage*/ ctx[2] + " svelte-1sffoyp");
    			add_location(div1, file, 45, 2, 1370);
    			attr_dev(p0, "class", "feature-number svelte-1sffoyp");
    			add_location(p0, file, 69, 6, 2157);
    			attr_dev(p1, "class", "visible-number svelte-1sffoyp");
    			add_location(p1, file, 70, 6, 2266);
    			attr_dev(div2, "class", "filter-numbers");
    			add_location(div2, file, 68, 5, 2122);
    			attr_dev(div3, "class", "filter-header svelte-1sffoyp");
    			add_location(div3, file, 67, 4, 2089);
    			attr_dev(div4, "class", "filter-wrapper");
    			add_location(div4, file, 84, 4, 2843);
    			attr_dev(div5, "class", "filter-section svelte-1sffoyp");
    			add_location(div5, file, 61, 3, 1947);
    			attr_dev(div6, "class", "sidebar");
    			add_location(div6, file, 52, 2, 1528);
    			attr_dev(div7, "class", div7_class_value = "nav-cards " + /*showMainPage*/ ctx[2] + " svelte-1sffoyp");
    			add_location(div7, file, 93, 2, 3019);
    			attr_dev(div8, "class", "content-grid svelte-1sffoyp");
    			add_location(div8, file, 50, 2, 1462);
    			attr_dev(div9, "class", div9_class_value = "main-mode " + /*showMainPage*/ ctx[2] + " svelte-1sffoyp");
    			add_location(div9, file, 44, 1, 1314);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div0, anchor);
    			mount_component(sectionintro, div0, null);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, div9, anchor);
    			append_dev(div9, div1);
    			mount_component(header, div1, null);
    			append_dev(div1, t1);
    			mount_component(pagenavigation, div1, null);
    			append_dev(div9, t2);
    			append_dev(div9, div8);
    			append_dev(div8, div6);
    			if (if_block0) if_block0.m(div6, null);
    			append_dev(div6, t3);
    			append_dev(div6, div5);
    			if (if_block1) if_block1.m(div5, null);
    			append_dev(div5, t4);
    			append_dev(div5, div3);
    			append_dev(div3, div2);
    			append_dev(div2, p0);
    			append_dev(p0, t5);
    			append_dev(p0, t6);
    			append_dev(p0, t7);
    			append_dev(div2, t8);
    			append_dev(div2, p1);
    			append_dev(p1, t9);
    			append_dev(p1, t10);
    			append_dev(div3, t11);
    			if_block2.m(div3, null);
    			append_dev(div5, t12);
    			append_dev(div5, div4);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div4, null);
    			}

    			append_dev(div8, t13);
    			append_dev(div8, div7);
    			mount_component(sectioncards, div7, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (!current || dirty & /*showIntroPage*/ 8 && div0_class_value !== (div0_class_value = "intro-mode " + /*showIntroPage*/ ctx[3] + " svelte-1sffoyp")) {
    				attr_dev(div0, "class", div0_class_value);
    			}

    			if (!current || dirty & /*showMainPage*/ 4 && div1_class_value !== (div1_class_value = "header-wrapper " + /*showMainPage*/ ctx[2] + " svelte-1sffoyp")) {
    				attr_dev(div1, "class", div1_class_value);
    			}

    			if (/*$isMobile*/ ctx[4] == false) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty & /*$isMobile*/ 16) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_3(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(div6, t3);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (/*$isMobile*/ ctx[4] == false) {
    				if (if_block1) ; else {
    					if_block1 = create_if_block_2(ctx);
    					if_block1.c();
    					if_block1.m(div5, t4);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if ((!current || dirty & /*$data*/ 64) && t5_value !== (t5_value = /*formatValue*/ ctx[9](/*$data*/ ctx[6].length) + "")) set_data_dev(t5, t5_value);
    			if ((!current || dirty & /*$data*/ 64) && t7_value !== (t7_value = (/*$data*/ ctx[6].length == 1 ? "feature" : "features") + "")) set_data_dev(t7, t7_value);
    			if ((!current || dirty & /*$visibleData*/ 128) && t9_value !== (t9_value = /*$visibleData*/ ctx[7].length + "")) set_data_dev(t9, t9_value);

    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block2) {
    				if_block2.p(ctx, dirty);
    			} else {
    				if_block2.d(1);
    				if_block2 = current_block_type(ctx);

    				if (if_block2) {
    					if_block2.c();
    					if_block2.m(div3, null);
    				}
    			}

    			if (dirty & /*Object, $filterObj*/ 256) {
    				each_value = Object.keys(/*$filterObj*/ ctx[8]);
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(div4, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}

    			if (!current || dirty & /*showMainPage*/ 4 && div7_class_value !== (div7_class_value = "nav-cards " + /*showMainPage*/ ctx[2] + " svelte-1sffoyp")) {
    				attr_dev(div7, "class", div7_class_value);
    			}

    			if (!current || dirty & /*showMainPage*/ 4 && div9_class_value !== (div9_class_value = "main-mode " + /*showMainPage*/ ctx[2] + " svelte-1sffoyp")) {
    				attr_dev(div9, "class", div9_class_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(sectionintro.$$.fragment, local);
    			transition_in(header.$$.fragment, local);
    			transition_in(pagenavigation.$$.fragment, local);
    			transition_in(if_block0);

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			transition_in(sectioncards.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(sectionintro.$$.fragment, local);
    			transition_out(header.$$.fragment, local);
    			transition_out(pagenavigation.$$.fragment, local);
    			transition_out(if_block0);
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			transition_out(sectioncards.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div0);
    			destroy_component(sectionintro);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(div9);
    			destroy_component(header);
    			destroy_component(pagenavigation);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if_block2.d();
    			destroy_each(each_blocks, detaching);
    			destroy_component(sectioncards);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block.name,
    		type: "if",
    		source: "(38:0) {#if ready == true}",
    		ctx
    	});

    	return block;
    }

    // (55:3) {#if $isMobile == false}
    function create_if_block_3(ctx) {
    	let button;
    	let t1;
    	let div;
    	let globe_1;
    	let current;
    	let mounted;
    	let dispose;

    	globe_1 = new Globe_1({
    			props: { targetNode: "cards-globe" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			button = element("button");
    			button.textContent = "Reset globe";
    			t1 = space();
    			div = element("div");
    			create_component(globe_1.$$.fragment);
    			attr_dev(button, "class", "globe-reset svelte-1sffoyp");
    			attr_dev(button, "title", "Reset the globe's latitude and longitude");
    			attr_dev(button, "aria-hidden", "true");
    			add_location(button, file, 55, 4, 1610);
    			attr_dev(div, "class", "globe-wrapper svelte-1sffoyp");
    			set_style(div, "margin", /*globeMargin*/ ctx[1]);
    			attr_dev(div, "aria-hidden", "true");
    			attr_dev(div, "focusable", "false");
    			add_location(div, file, 56, 4, 1767);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div, anchor);
    			mount_component(globe_1, div, null);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*click_handler*/ ctx[11], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (!current || dirty & /*globeMargin*/ 2) {
    				set_style(div, "margin", /*globeMargin*/ ctx[1]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(globe_1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(globe_1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div);
    			destroy_component(globe_1);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3.name,
    		type: "if",
    		source: "(55:3) {#if $isMobile == false}",
    		ctx
    	});

    	return block;
    }

    // (63:4) {#if $isMobile == false}
    function create_if_block_2(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			attr_dev(div, "class", "globe-spacer svelte-1sffoyp");
    			add_location(div, file, 63, 5, 2010);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2.name,
    		type: "if",
    		source: "(63:4) {#if $isMobile == false}",
    		ctx
    	});

    	return block;
    }

    // (78:5) {:else}
    function create_else_block(ctx) {
    	let div;
    	let button;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div = element("div");
    			button = element("button");
    			button.textContent = "Show all";
    			attr_dev(button, "class", "reset-button svelte-1sffoyp");
    			add_location(button, file, 79, 7, 2677);
    			add_location(div, file, 78, 6, 2664);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, button);

    			if (!mounted) {
    				dispose = [
    					listen_dev(button, "click", /*click_handler_2*/ ctx[14], false, false, false),
    					listen_dev(button, "keypress", /*keypress_handler_1*/ ctx[15], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: noop$2,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block.name,
    		type: "else",
    		source: "(78:5) {:else}",
    		ctx
    	});

    	return block;
    }

    // (74:5) {#if $data.length == dataSource.length}
    function create_if_block_1(ctx) {
    	let div;
    	let button;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div = element("div");
    			button = element("button");
    			button.textContent = "Hide all";
    			attr_dev(button, "class", "reset-button svelte-1sffoyp");
    			add_location(button, file, 75, 7, 2412);
    			add_location(div, file, 74, 6, 2399);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, button);

    			if (!mounted) {
    				dispose = [
    					listen_dev(button, "click", /*click_handler_1*/ ctx[12], false, false, false),
    					listen_dev(button, "keypress", /*keypress_handler*/ ctx[13], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: noop$2,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1.name,
    		type: "if",
    		source: "(74:5) {#if $data.length == dataSource.length}",
    		ctx
    	});

    	return block;
    }

    // (86:5) {#each Object.keys($filterObj) as variable}
    function create_each_block(ctx) {
    	let filter;
    	let current;

    	filter = new Filter({
    			props: { variable: /*variable*/ ctx[16] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(filter.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(filter, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const filter_changes = {};
    			if (dirty & /*$filterObj*/ 256) filter_changes.variable = /*variable*/ ctx[16];
    			filter.$set(filter_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(filter.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(filter.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(filter, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block.name,
    		type: "each",
    		source: "(86:5) {#each Object.keys($filterObj) as variable}",
    		ctx
    	});

    	return block;
    }

    function create_fragment(ctx) {
    	let main;
    	let current;
    	let if_block = /*ready*/ ctx[0] == true && create_if_block(ctx);

    	const block = {
    		c: function create() {
    			main = element("main");
    			if (if_block) if_block.c();
    			attr_dev(main, "class", "svelte-1sffoyp");
    			add_location(main, file, 36, 0, 1174);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, main, anchor);
    			if (if_block) if_block.m(main, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*ready*/ ctx[0] == true) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*ready*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(main, null);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(main);
    			if (if_block) if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance($$self, $$props, $$invalidate) {
    	let showIntroPage;
    	let showMainPage;
    	let globeMargin;
    	let $activePage;
    	let $isMobile;
    	let $globe;
    	let $data;
    	let $visibleData;
    	let $filterObj;
    	validate_store(activePage, 'activePage');
    	component_subscribe($$self, activePage, $$value => $$invalidate(10, $activePage = $$value));
    	validate_store(isMobile, 'isMobile');
    	component_subscribe($$self, isMobile, $$value => $$invalidate(4, $isMobile = $$value));
    	validate_store(globe$1, 'globe');
    	component_subscribe($$self, globe$1, $$value => $$invalidate(5, $globe = $$value));
    	validate_store(data, 'data');
    	component_subscribe($$self, data, $$value => $$invalidate(6, $data = $$value));
    	validate_store(visibleData, 'visibleData');
    	component_subscribe($$self, visibleData, $$value => $$invalidate(7, $visibleData = $$value));
    	validate_store(filterObj, 'filterObj');
    	component_subscribe($$self, filterObj, $$value => $$invalidate(8, $filterObj = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('App', slots, []);
    	const formatValue = format$1(",");

    	// Waits for page load to add svelte transitions
    	let ready = false;

    	onMount(async () => {
    		resetData();
    		$$invalidate(0, ready = true);
    	});

    	const writable_props = [];

    	Object_1.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<App> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => resetGlobe($globe);
    	const click_handler_1 = e => filterData($filterObj, defaultFilters["type"], "type", $data, false);
    	const keypress_handler = e => filterData($filterObj, defaultFilters["type"], "type", $data, false);
    	const click_handler_2 = e => resetData();
    	const keypress_handler_1 = e => resetData();

    	$$self.$capture_state = () => ({
    		data,
    		activePage,
    		resetData,
    		filterObj,
    		visibleData,
    		globe: globe$1,
    		isMobile,
    		setPercentages,
    		defaultFilters,
    		getPercentages,
    		Globe: Globe_1,
    		Filter,
    		PageNavigation,
    		SectionIntro,
    		Header,
    		SectionCards,
    		onMount,
    		format: format$1,
    		filterData,
    		resetGlobe,
    		dataSource,
    		formatValue,
    		ready,
    		globeMargin,
    		showMainPage,
    		showIntroPage,
    		$activePage,
    		$isMobile,
    		$globe,
    		$data,
    		$visibleData,
    		$filterObj
    	});

    	$$self.$inject_state = $$props => {
    		if ('ready' in $$props) $$invalidate(0, ready = $$props.ready);
    		if ('globeMargin' in $$props) $$invalidate(1, globeMargin = $$props.globeMargin);
    		if ('showMainPage' in $$props) $$invalidate(2, showMainPage = $$props.showMainPage);
    		if ('showIntroPage' in $$props) $$invalidate(3, showIntroPage = $$props.showIntroPage);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$activePage*/ 1024) {
    			// Add "hide" class to page that is not active
    			$$invalidate(3, showIntroPage = $activePage == "intro" ? "" : "hide");
    		}

    		if ($$self.$$.dirty & /*$activePage*/ 1024) {
    			$$invalidate(2, showMainPage = $activePage == "main" ? "" : "hide");
    		}

    		if ($$self.$$.dirty & /*$activePage*/ 1024) {
    			$$invalidate(1, globeMargin = $activePage == "intro" ? "148px 55px" : "-20px 35px");
    		}
    	};

    	return [
    		ready,
    		globeMargin,
    		showMainPage,
    		showIntroPage,
    		$isMobile,
    		$globe,
    		$data,
    		$visibleData,
    		$filterObj,
    		formatValue,
    		$activePage,
    		click_handler,
    		click_handler_1,
    		keypress_handler,
    		click_handler_2,
    		keypress_handler_1
    	];
    }

    class App extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance, create_fragment, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "App",
    			options,
    			id: create_fragment.name
    		});
    	}
    }

    const app = new App({
    	target: document.body,
    });

    return app;

})();
//# sourceMappingURL=bundle.js.map
